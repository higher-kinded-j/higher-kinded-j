<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Chainable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect.capability</a> &gt; <span class="el_source">Chainable.java</span></div><h1>Chainable.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect.capability;

import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.effect.FreePath;
import org.higherkindedj.hkt.effect.GenericPath;
import org.higherkindedj.hkt.effect.IdPath;
import org.higherkindedj.hkt.effect.LazyPath;
import org.higherkindedj.hkt.effect.ListPath;
import org.higherkindedj.hkt.effect.NonDetPath;
import org.higherkindedj.hkt.effect.OptionalPath;
import org.higherkindedj.hkt.effect.ReaderPath;
import org.higherkindedj.hkt.effect.StreamPath;
import org.higherkindedj.hkt.effect.TrampolinePath;
import org.higherkindedj.hkt.effect.ValidationPath;
import org.higherkindedj.hkt.effect.WithStatePath;
import org.higherkindedj.hkt.effect.WriterPath;

/**
 * A capability interface representing types that support sequencing dependent computations.
 *
 * &lt;p&gt;This capability extends {@link Combinable} and corresponds to the Monad typeclass. Types
 * implementing this interface can chain computations where subsequent operations depend on previous
 * results.
 *
 * &lt;h2&gt;Operations&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #via(Function)} - Chain a dependent computation (the core operation)
 *   &lt;li&gt;{@link #flatMap(Function)} - Alias for via (matches traditional monad terminology)
 *   &lt;li&gt;{@link #then(Supplier)} - Sequence an independent computation, discarding this result
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;The {@code via} Pattern&lt;/h2&gt;
 *
 * &lt;p&gt;The {@code via} method is the central operation for Effect Path composition, deliberately
 * named to match the Focus DSL's vocabulary. Where FocusPath's {@code via} navigates through data
 * structures, EffectPath's {@code via} navigates through effect types.
 *
 * &lt;h2&gt;Laws&lt;/h2&gt;
 *
 * &lt;p&gt;Implementations must satisfy the Monad laws:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Left identity:&lt;/b&gt; {@code pure(a).via(f)} equals {@code f.apply(a)}
 *   &lt;li&gt;&lt;b&gt;Right identity:&lt;/b&gt; {@code path.via(x -&gt; pure(x))} equals {@code path}
 *   &lt;li&gt;&lt;b&gt;Associativity:&lt;/b&gt; {@code path.via(f).via(g)} equals {@code path.via(x -&gt;
 *       f.apply(x).via(g))}
 * &lt;/ul&gt;
 *
 * @param &lt;A&gt; the type of the contained value
 */
public sealed interface Chainable&lt;A&gt; extends Combinable&lt;A&gt;
    permits Recoverable,
        Effectful,
        ValidationPath,
        IdPath,
        OptionalPath,
        GenericPath,
        ReaderPath,
        WithStatePath,
        WriterPath,
        LazyPath,
        ListPath,
        NonDetPath,
        StreamPath,
        TrampolinePath,
        FreePath {

  /**
   * Chains a dependent computation that returns a path.
   *
   * &lt;p&gt;This is the core monadic bind operation, named {@code via} to match the Focus DSL's
   * vocabulary. The function is applied to the contained value, and the resulting path becomes the
   * new path.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * MaybePath&lt;User&gt; user = Path.maybe(userId)
   *     .via(id -&gt; userRepo.findById(id))      // Returns MaybePath&lt;User&gt;
   *     .via(user -&gt; validateUser(user));      // Returns MaybePath&lt;User&gt;
   * }&lt;/pre&gt;
   *
   * @param mapper the function to apply, returning a new path; must not be null
   * @param &lt;B&gt; the type of the value in the returned path
   * @return the path returned by the function, or an error/empty path if this is an error/empty
   * @throws NullPointerException if mapper is null or returns null
   */
  &lt;B&gt; Chainable&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper);

  /**
   * Chains a dependent computation that returns a path.
   *
   * &lt;p&gt;This is an alias for {@link #via(Function)} that matches traditional monad terminology.
   *
   * @param mapper the function to apply, returning a new path; must not be null
   * @param &lt;B&gt; the type of the value in the returned path
   * @return the path returned by the function, or an error/empty path if this is an error/empty
   * @throws NullPointerException if mapper is null or returns null
   */
  default &lt;B&gt; Chainable&lt;B&gt; flatMap(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L105">    return via(mapper);</span>
  }

  /**
   * Sequences an independent computation, discarding this path's result.
   *
   * &lt;p&gt;This operation is useful when you need to perform an effect but don't care about its result,
   * only about sequencing it after this computation.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Path.maybe(userId)
   *     .via(id -&gt; userRepo.findById(id))
   *     .then(() -&gt; Path.maybe(logService.recordAccess()));  // Log access, discard result
   * }&lt;/pre&gt;
   *
   * @param supplier provides the next path to sequence; must not be null
   * @param &lt;B&gt; the type of the value in the returned path
   * @return the path from the supplier
   * @throws NullPointerException if supplier is null or returns null
   */
  &lt;B&gt; Chainable&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>