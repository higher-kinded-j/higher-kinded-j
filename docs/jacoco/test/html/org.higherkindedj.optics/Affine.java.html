<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Affine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Affine.java</span></div><h1>Affine.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;

/**
 * An &lt;b&gt;Affine&lt;/b&gt; is an optic that focuses on &lt;b&gt;zero or one&lt;/b&gt; element within a structure. It
 * combines the partial access of a {@link Prism} with the update capability of a {@link Lens}.
 *
 * &lt;p&gt;An Affine is the right tool when you have a field that might not exist, but when it does (or
 * when you set it), you want full lens-like access. Common use cases include:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Accessing {@code Optional&lt;T&gt;} fields in records
 *   &lt;li&gt;Working with nullable fields in legacy code
 *   &lt;li&gt;Navigating through optional intermediate structures
 *   &lt;li&gt;The result of composing a {@link Lens} with a {@link Prism}
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Relationship to Other Optics&lt;/h2&gt;
 *
 * &lt;p&gt;In the optic hierarchy, Affine sits between Lens and Traversal:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A {@link Lens} focuses on &lt;b&gt;exactly one&lt;/b&gt; element (always present)
 *   &lt;li&gt;An &lt;b&gt;Affine&lt;/b&gt; focuses on &lt;b&gt;zero or one&lt;/b&gt; element (may be absent)
 *   &lt;li&gt;A {@link Traversal} focuses on &lt;b&gt;zero or more&lt;/b&gt; elements
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The key distinction from {@link Prism}: a Prism's {@code build} creates a new structure from
 * scratch, whilst an Affine's {@code set} updates an existing structure. This makes Affine ideal
 * for optional fields within product types, whereas Prism is ideal for sum type variants.
 *
 * &lt;h2&gt;Laws&lt;/h2&gt;
 *
 * &lt;p&gt;A well-behaved Affine must satisfy these laws:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Get-Set:&lt;/b&gt; {@code getOptional(set(a, s))} = {@code Optional.of(a)} &amp;mdash; Setting a
 *       value then getting it returns what was set
 *   &lt;li&gt;&lt;b&gt;Set-Set:&lt;/b&gt; {@code set(b, set(a, s))} = {@code set(b, s)} &amp;mdash; Second set wins
 *   &lt;li&gt;&lt;b&gt;GetOptional-Set:&lt;/b&gt; If {@code getOptional(s)} = {@code Optional.of(a)}, then {@code
 *       set(a, s)} = {@code s} &amp;mdash; Setting the current value changes nothing
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // A record with an optional email field
 * record UserProfile(String name, Optional&lt;String&gt; email) {}
 *
 * // An Affine focusing on the email value (not the Optional wrapper)
 * Affine&lt;UserProfile, String&gt; emailAffine = Affine.of(
 *     UserProfile::email,
 *     (profile, newEmail) -&gt; new UserProfile(profile.name(), Optional.of(newEmail))
 * );
 *
 * UserProfile alice = new UserProfile(&quot;Alice&quot;, Optional.of(&quot;alice@example.com&quot;));
 * UserProfile bob = new UserProfile(&quot;Bob&quot;, Optional.empty());
 *
 * // Get: returns Optional
 * emailAffine.getOptional(alice);  // Optional.of(&quot;alice@example.com&quot;)
 * emailAffine.getOptional(bob);    // Optional.empty()
 *
 * // Set: always succeeds
 * emailAffine.set(&quot;new@example.com&quot;, alice);  // UserProfile[name=Alice, email=Optional[new@example.com]]
 * emailAffine.set(&quot;bob@example.com&quot;, bob);    // UserProfile[name=Bob, email=Optional[bob@example.com]]
 *
 * // Modify: only applies if present
 * emailAffine.modify(String::toUpperCase, alice);  // Email uppercased
 * emailAffine.modify(String::toUpperCase, bob);    // Unchanged (no email to modify)
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;It extends the generic {@link Optic}, specialising it for {@code S = T} and {@code A = B}.
 *
 * @param &lt;S&gt; The source type of the whole structure (e.g., {@code UserProfile}).
 * @param &lt;A&gt; The target type of the focused part (e.g., {@code String} for the email value).
 */
public interface Affine&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * Attempts to get the focused part {@code A} from the whole structure {@code S}.
   *
   * &lt;p&gt;This is the primary &quot;getter&quot; for an Affine. Unlike a {@link Lens}, it may return empty if
   * the focused element is absent.
   *
   * @param source The whole structure.
   * @return An {@link Optional} containing the focused part if present, otherwise empty.
   */
  Optional&lt;A&gt; getOptional(S source);

  /**
   * Sets a new value for the focused part {@code A}, returning a new, updated structure {@code S}.
   *
   * &lt;p&gt;Unlike a {@link Prism}, this operation always succeeds. If the focused element was
   * previously absent, it becomes present with the new value. This operation must be immutable; the
   * original {@code source} object is not changed.
   *
   * @param newValue The new value for the focused part.
   * @param source The original structure.
   * @return A new structure with the focused part set to the new value.
   */
  S set(A newValue, S source);

  /**
   * Modifies the focused part {@code A} using a pure function, if present.
   *
   * &lt;p&gt;If the focused element is absent, the original structure is returned unchanged. This differs
   * from {@link #set}, which always updates the structure.
   *
   * @param modifier The function to apply to the focused part.
   * @param source The whole structure.
   * @return A new structure with the modified part, or the original if the focus is absent.
   */
  default S modify(Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L123">    return getOptional(source).map(a -&gt; set(modifier.apply(a), source)).orElse(source);</span>
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;The implementation for an {@code Affine} will only apply the function {@code f} if the
   * affine successfully focuses on a value. If no value is present, it returns the original
   * structure {@code s} wrapped in the {@link Applicative} context, effectively performing a no-op.
   */
  @Override
  default &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L135">    return getOptional(s).map(a -&gt; app.map(newA -&gt; set(newA, s), f.apply(a))).orElse(app.of(s));</span>
  }

  /**
   * Views this {@code Affine} as a {@link Traversal}.
   *
   * &lt;p&gt;This is always possible because an {@code Affine} is fundamentally a {@code Traversal} that
   * focuses on zero or one element.
   *
   * @return A {@link Traversal} that represents this {@code Affine}.
   */
  default Traversal&lt;S, A&gt; asTraversal() {
<span class="fc" id="L147">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L148">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; app) {
<span class="fc" id="L151">        return self.modifyF(f, source, app);</span>
      }
    };
  }

  /**
   * Views this {@code Affine} as a {@link Fold}.
   *
   * &lt;p&gt;This is always possible because an {@code Affine} can be used as a read-only query that
   * focuses on zero or one element.
   *
   * @return A {@link Fold} that represents this {@code Affine}.
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L165">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L166">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
<span class="fc" id="L169">        Optional&lt;A&gt; opt = self.getOptional(source);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (opt.isPresent()) {</span>
<span class="fc" id="L171">          return f.apply(opt.get());</span>
        }
<span class="fc" id="L173">        return monoid.empty();</span>
      }
    };
  }

  // ===== Composition Methods =====

  /**
   * Composes this {@code Affine&lt;S, A&gt;} with another {@code Affine&lt;A, B&gt;} to create a new {@code
   * Affine&lt;S, B&gt;}.
   *
   * &lt;p&gt;The resulting Affine focuses on zero or one element: it finds a value only if both this
   * Affine and the other Affine successfully focus.
   *
   * @param other The {@link Affine} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(Affine&lt;A, B&gt; other) {
<span class="fc" id="L192">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L193">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L196">        return self.getOptional(source).flatMap(other::getOptional);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L201">        return self.getOptional(source)</span>
<span class="fc" id="L202">            .map(a -&gt; self.set(other.set(newValue, a), source))</span>
<span class="fc" id="L203">            .orElse(source);</span>
      }
    };
  }

  /**
   * Composes this {@code Affine&lt;S, A&gt;} with a {@code Lens&lt;A, B&gt;} to create a new {@code Affine&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;The resulting Affine focuses on zero or one element: it finds a value only if this Affine
   * successfully focuses, and then the Lens always succeeds on that value.
   *
   * @param lens The {@link Lens} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L220">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L221">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L224">        return self.getOptional(source).map(lens::get);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L229">        return self.getOptional(source)</span>
<span class="fc" id="L230">            .map(a -&gt; self.set(lens.set(newValue, a), source))</span>
<span class="fc" id="L231">            .orElse(source);</span>
      }
    };
  }

  /**
   * Composes this {@code Affine&lt;S, A&gt;} with a {@code Prism&lt;A, B&gt;} to create a new {@code Affine&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;The resulting Affine focuses on zero or one element: it finds a value only if both this
   * Affine successfully focuses and the Prism matches.
   *
   * @param prism The {@link Prism} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(Prism&lt;A, B&gt; prism) {
<span class="fc" id="L248">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L249">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L252">        return self.getOptional(source).flatMap(prism::getOptional);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L257">        return self.getOptional(source)</span>
<span class="fc" id="L258">            .map(a -&gt; self.set(prism.build(newValue), source))</span>
<span class="fc" id="L259">            .orElse(source);</span>
      }
    };
  }

  /**
   * Composes this {@code Affine&lt;S, A&gt;} with an {@code Iso&lt;A, B&gt;} to create a new {@code Affine&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;This is possible because composing a partial focus with a lossless, two-way conversion
   * results in a new partial focus.
   *
   * @param iso The {@link Iso} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(Iso&lt;A, B&gt; iso) {
<span class="fc" id="L276">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L277">    return Affine.of(</span>
<span class="fc" id="L278">        s -&gt; self.getOptional(s).map(iso::get), (s, b) -&gt; self.set(iso.reverseGet(b), s));</span>
  }

  /**
   * Composes this {@code Affine&lt;S, A&gt;} with a {@code Traversal&lt;A, B&gt;} to create a new {@code
   * Traversal&lt;S, B&gt;}.
   *
   * &lt;p&gt;The result is a Traversal because the inner Traversal may focus on zero or more elements.
   *
   * @param traversal The {@link Traversal} to compose with.
   * @param &lt;B&gt; The type of the final focused parts.
   * @return A new {@link Traversal} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Traversal&lt;S, B&gt; andThen(Traversal&lt;A, B&gt; traversal) {
<span class="fc" id="L292">    Affine&lt;S, A&gt; self = this;</span>
<span class="fc" id="L293">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;B, Kind&lt;F, B&gt;&gt; f, S source, Applicative&lt;F&gt; app) {
<span class="fc" id="L296">        return self.getOptional(source)</span>
<span class="fc" id="L297">            .map(a -&gt; app.map(newA -&gt; self.set(newA, source), traversal.modifyF(f, a, app)))</span>
<span class="fc" id="L298">            .orElse(app.of(source));</span>
      }
    };
  }

  // ===== Convenience Methods =====

  /**
   * Checks if this affine focuses on a value in the given structure.
   *
   * &lt;p&gt;This is a convenient alternative to {@code getOptional(source).isPresent()}.
   *
   * @param source The source structure to test.
   * @return {@code true} if a value is present, {@code false} otherwise.
   */
  default boolean matches(S source) {
<span class="fc" id="L314">    return getOptional(source).isPresent();</span>
  }

  /**
   * Checks if this affine does NOT focus on a value in the given structure.
   *
   * &lt;p&gt;This is the logical negation of {@link #matches(Object)}.
   *
   * @param source The source structure to test.
   * @return {@code true} if no value is present, {@code false} if a value exists.
   */
  default boolean doesNotMatch(S source) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">    return !matches(source);</span>
  }

  /**
   * Returns the focused value or a default if absent.
   *
   * &lt;p&gt;This is a convenient shortcut for {@code getOptional(source).orElse(defaultValue)}.
   *
   * @param defaultValue The default value to use if no focus is present.
   * @param source The source structure.
   * @return The focused value or the default value.
   */
  default A getOrElse(A defaultValue, S source) {
<span class="fc" id="L339">    return getOptional(source).orElse(defaultValue);</span>
  }

  /**
   * Applies a function to the focused value and returns the result wrapped in an {@link Optional}.
   *
   * &lt;p&gt;This is useful for transforming focused values without modifying the source structure. It is
   * equivalent to {@code getOptional(source).map(f)}.
   *
   * @param f The function to apply to the focused value.
   * @param source The source structure.
   * @param &lt;B&gt; The result type of the function.
   * @return An {@link Optional} containing the result if a value is present, or empty otherwise.
   */
  default &lt;B&gt; Optional&lt;B&gt; mapOptional(Function&lt;? super A, ? extends B&gt; f, S source) {
<span class="fc" id="L354">    return getOptional(source).map(f);</span>
  }

  /**
   * Modifies the focused part only when it is present and meets a specified condition.
   *
   * &lt;p&gt;This combines presence checking and conditional modification: the affine must focus on a
   * value, and that value must satisfy the predicate for modification to occur.
   *
   * @param condition The predicate that the focused value must satisfy.
   * @param modifier The function to apply if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally modified part, or the original if absent or
   *     condition not met.
   */
  default S modifyWhen(Predicate&lt;? super A&gt; condition, Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L370">    return getOptional(source)</span>
<span class="fc" id="L371">        .filter(condition)</span>
<span class="fc" id="L372">        .map(a -&gt; set(modifier.apply(a), source))</span>
<span class="fc" id="L373">        .orElse(source);</span>
  }

  /**
   * Sets a new value only when the current value is present and meets a specified condition.
   *
   * &lt;p&gt;This is useful for conditional updates based on the current state.
   *
   * @param condition The predicate that the current value must satisfy.
   * @param newValue The new value to set if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally set value, or the original if absent or
   *     condition not met.
   */
  default S setWhen(Predicate&lt;? super A&gt; condition, A newValue, S source) {
<span class="fc" id="L388">    return getOptional(source).filter(condition).map(a -&gt; set(newValue, source)).orElse(source);</span>
  }

  /**
   * Removes the focused value, setting it to empty/absent.
   *
   * &lt;p&gt;This operation requires a way to represent &quot;absence&quot; in the structure. Implementations
   * should return a structure where {@code getOptional} returns empty.
   *
   * &lt;p&gt;Note: This default implementation throws {@link UnsupportedOperationException}. Affines
   * created via {@link #of(Function, BiFunction)} do not support removal. Use {@link #of(Function,
   * BiFunction, Function)} to create an Affine with removal support.
   *
   * @param source The source structure.
   * @return A new structure with the focused value removed.
   * @throws UnsupportedOperationException if removal is not supported by this Affine.
   */
  default S remove(S source) {
<span class="fc" id="L406">    throw new UnsupportedOperationException(</span>
        &quot;This Affine does not support removal. Use Affine.of(getter, setter, remover) to create &quot;
            + &quot;an Affine with removal support.&quot;);
  }

  // ===== Factory Methods =====

  /**
   * Creates an {@code Affine} from its two fundamental operations: a failable getter and a setter.
   *
   * &lt;p&gt;The resulting Affine does not support the {@link #remove} operation.
   *
   * @param getter A function that attempts to extract part {@code A} from structure {@code S}.
   * @param setter A function that sets the part {@code A} within the structure {@code S}.
   * @param &lt;S&gt; The type of the whole structure.
   * @param &lt;A&gt; The type of the focused part.
   * @return A new {@code Affine} instance.
   */
  static &lt;S, A&gt; Affine&lt;S, A&gt; of(Function&lt;S, Optional&lt;A&gt;&gt; getter, BiFunction&lt;S, A, S&gt; setter) {
<span class="fc" id="L425">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;A&gt; getOptional(S source) {
<span class="fc" id="L428">        return getter.apply(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L433">        return setter.apply(source, newValue);</span>
      }
    };
  }

  /**
   * Creates an {@code Affine} with full support for getting, setting, and removing values.
   *
   * &lt;p&gt;This factory method creates an Affine that supports the {@link #remove} operation, which is
   * useful for optional fields that can be cleared.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Affine&lt;UserProfile, String&gt; emailAffine = Affine.of(
   *     UserProfile::email,
   *     (profile, email) -&gt; new UserProfile(profile.name(), Optional.of(email)),
   *     profile -&gt; new UserProfile(profile.name(), Optional.empty())
   * );
   *
   * // Now remove() works
   * UserProfile withoutEmail = emailAffine.remove(profileWithEmail);
   * }&lt;/pre&gt;
   *
   * @param getter A function that attempts to extract part {@code A} from structure {@code S}.
   * @param setter A function that sets the part {@code A} within the structure {@code S}.
   * @param remover A function that removes the part, returning a structure where the focus is
   *     absent.
   * @param &lt;S&gt; The type of the whole structure.
   * @param &lt;A&gt; The type of the focused part.
   * @return A new {@code Affine} instance with removal support.
   */
  static &lt;S, A&gt; Affine&lt;S, A&gt; of(
      Function&lt;S, Optional&lt;A&gt;&gt; getter, BiFunction&lt;S, A, S&gt; setter, Function&lt;S, S&gt; remover) {
<span class="fc" id="L467">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;A&gt; getOptional(S source) {
<span class="fc" id="L470">        return getter.apply(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L475">        return setter.apply(source, newValue);</span>
      }

      @Override
      public S remove(S source) {
<span class="fc" id="L480">        return remover.apply(source);</span>
      }
    };
  }

  /**
   * Creates an Affine from a Lens and a Prism, which is a common pattern.
   *
   * &lt;p&gt;This is equivalent to {@code lens.andThen(prism)} but provided here for discoverability.
   *
   * @param lens The lens to apply first.
   * @param prism The prism to apply second.
   * @param &lt;S&gt; The source type.
   * @param &lt;A&gt; The intermediate type.
   * @param &lt;B&gt; The target type.
   * @return An Affine from S to B.
   */
  static &lt;S, A, B&gt; Affine&lt;S, B&gt; fromLensAndPrism(Lens&lt;S, A&gt; lens, Prism&lt;A, B&gt; prism) {
<span class="fc" id="L498">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L501">        return prism.getOptional(lens.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L506">        return lens.set(prism.build(newValue), source);</span>
      }
    };
  }

  /**
   * Creates an Affine from a Prism and a Lens, which is a common pattern.
   *
   * &lt;p&gt;This is equivalent to {@code prism.andThen(lens)} but provided here for discoverability.
   *
   * @param prism The prism to apply first.
   * @param lens The lens to apply second.
   * @param &lt;S&gt; The source type.
   * @param &lt;A&gt; The intermediate type.
   * @param &lt;B&gt; The target type.
   * @return An Affine from S to B.
   */
  static &lt;S, A, B&gt; Affine&lt;S, B&gt; fromPrismAndLens(Prism&lt;S, A&gt; prism, Lens&lt;A, B&gt; lens) {
<span class="fc" id="L524">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L527">        return prism.getOptional(source).map(lens::get);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L532">        return prism</span>
<span class="fc" id="L533">            .getOptional(source)</span>
<span class="fc" id="L534">            .map(a -&gt; prism.build(lens.set(newValue, a)))</span>
<span class="fc" id="L535">            .orElse(source);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>