<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lens.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Lens.java</span></div><h1>Lens.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Selective;

/**
 * A **Lens** is an optic that provides a focused view into a part of a data structure. Think of it
 * as a functional, composable &quot;magnifying glass&quot; ðŸ”Ž for a field that is guaranteed to exist.
 *
 * &lt;p&gt;A Lens is the right tool for &quot;has-a&quot; relationships, such as a field within a record or a
 * property of a class (e.g., a {@code User} has an {@code Address}). It is defined by two core,
 * well-behaved operations: getting the part, and setting the part in an immutable way.
 *
 * &lt;p&gt;It extends the generic {@link Optic}, specializing it for {@code S = T} and {@code A = B}.
 *
 * @param &lt;S&gt; The source type of the whole structure (e.g., {@code User}).
 * @param &lt;A&gt; The target type of the focused part (e.g., {@code Address}).
 */
public interface Lens&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * Gets the focused part {@code A} from the whole structure {@code S}.
   *
   * @param source The whole structure.
   * @return The focused part.
   */
  A get(S source);

  /**
   * Sets a new value for the focused part {@code A}, returning a new, updated structure {@code S}.
   *
   * &lt;p&gt;This operation must be immutable; the original {@code source} object is not changed.
   *
   * @param newValue The new value for the focused part.
   * @param source The original structure.
   * @return A new structure with the focused part updated.
   */
  S set(A newValue, S source);

  /**
   * Modifies the focused part {@code A} using a pure function.
   *
   * &lt;p&gt;This is a convenient shortcut for {@code set(modifier.apply(get(source)), source)}.
   *
   * @param modifier The function to apply to the focused part.
   * @param source The whole structure.
   * @return A new structure with the modified part.
   */
  default S modify(Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L59">    return set(modifier.apply(get(source)), source);</span>
  }

  /**
   * Modifies the focused part {@code A} with a function that returns a new value within an
   * effectful context {@code F} (a {@link Functor}).
   *
   * &lt;p&gt;This is the core effectful operation, allowing for updates that might be asynchronous (e.g.,
   * {@code CompletableFuture}) or failable (e.g., {@code Optional}).
   *
   * @param &lt;F&gt; The witness type for the {@link Functor} context.
   * @param f The function to apply, returning the new part in a context.
   * @param source The whole structure.
   * @param functor The {@link Functor} instance for the context {@code F}.
   * @return The updated structure {@code S}, itself wrapped in the context {@code F}.
   */
  &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor);

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This default implementation satisfies the {@link Optic} interface by delegating to the
   * {@link Functor}-based {@code modifyF} method, as every {@link Applicative} is also a {@link
   * Functor}.
   */
  @Override
  default &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L86">    return this.modifyF(f, s, (Functor&lt;F&gt;) app);</span>
  }

  /**
   * Views this {@code Lens} as a {@link Traversal}.
   *
   * &lt;p&gt;This is always possible because a {@code Lens} is fundamentally a {@code Traversal} that
   * focuses on exactly one element.
   *
   * @return A {@link Traversal} that represents this {@code Lens}.
   */
  default Traversal&lt;S, A&gt; asTraversal() {
<span class="fc" id="L98">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L101">        return Lens.this.modifyF(f, s, app);</span>
      }
    };
  }

  /**
   * Views this {@code Lens} as a {@link Fold}.
   *
   * &lt;p&gt;This is always possible because a {@code Lens} is a read-only query that focuses on exactly
   * one element.
   *
   * @return A {@link Fold} that represents this {@code Lens}.
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L115">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L116">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
<span class="fc" id="L119">        return f.apply(self.get(source));</span>
      }
    };
  }

  /**
   * Composes this {@code Lens&lt;S, A&gt;} with another {@code Lens&lt;A, B&gt;} to create a new {@code Lens&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;This specialized version is kept for efficiency and to ensure the result is correctly and
   * conveniently typed as a {@code Lens}.
   *
   * @param other The {@link Lens} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Lens} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Lens&lt;S, B&gt; andThen(Lens&lt;A, B&gt; other) {
<span class="fc" id="L136">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L137">    return new Lens&lt;&gt;() {</span>
      @Override
      public B get(S source) {
<span class="fc" id="L140">        return other.get(self.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L145">        return self.set(other.set(newValue, self.get(source)), source);</span>
      }

      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;B, Kind&lt;F, B&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="fc" id="L150">        return self.modifyF(a -&gt; other.modifyF(f, a, functor), source, functor);</span>
      }
    };
  }

  /**
   * Composes this {@code Lens&lt;S, A&gt;} with an {@code Iso&lt;A, B&gt;} to produce a new {@code Lens&lt;S, B&gt;}.
   *
   * &lt;p&gt;This is possible because composing a one-way focus with a lossless, two-way conversion
   * results in a new one-way focus. This specialized overload ensures the result is correctly and
   * conveniently typed as a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model
   * record User(String name, EmailAddress email) {}
   * record EmailAddress(String value) {}
   *
   * // Lens from User to EmailAddress
   * Lens&lt;User, EmailAddress&gt; emailLens = Lens.of(
   *     User::email,
   *     (user, email) -&gt; new User(user.name(), email)
   * );
   *
   * // Iso from EmailAddress to String
   * Iso&lt;EmailAddress, String&gt; emailIso = Iso.of(
   *     EmailAddress::value,
   *     EmailAddress::new
   * );
   *
   * // Compose: Lens + Iso = Lens
   * Lens&lt;User, String&gt; userEmailStringLens = emailLens.andThen(emailIso);
   * }&lt;/pre&gt;
   *
   * @param iso The {@link Iso} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Lens} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Lens&lt;S, B&gt; andThen(final Iso&lt;A, B&gt; iso) {
<span class="fc" id="L190">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L191">    return Lens.of(s -&gt; iso.get(self.get(s)), (s, b) -&gt; self.set(iso.reverseGet(b), s));</span>
  }

  /**
   * Composes this {@code Lens&lt;S, A&gt;} with a {@code Prism&lt;A, B&gt;} to create an {@code Affine&lt;S, B&gt;}.
   *
   * &lt;p&gt;The composition follows the standard optic composition rule: Lens &gt;&gt;&gt; Prism = Affine. The
   * result is an Affine because the Prism may not match (resulting in zero-or-one focus), but the
   * Lens guarantees we can always set a value.
   *
   * &lt;p&gt;This composition is useful when navigating into optional parts of a structure:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;A record field that contains a sum type (sealed interface)
   *   &lt;li&gt;A nullable field wrapped in Optional
   *   &lt;li&gt;Any &quot;has-a&quot; followed by &quot;is-a&quot; relationship
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model
   * record Config(Optional&lt;DatabaseConfig&gt; database) {}
   * record DatabaseConfig(String url, int port) {}
   *
   * // Optics
   * Lens&lt;Config, Optional&lt;DatabaseConfig&gt;&gt; databaseLens = Lens.of(
   *     Config::database,
   *     (config, db) -&gt; new Config(db)
   * );
   * Prism&lt;Optional&lt;DatabaseConfig&gt;, DatabaseConfig&gt; somePrism = Prisms.some();
   * Lens&lt;DatabaseConfig, String&gt; urlLens = Lens.of(
   *     DatabaseConfig::url,
   *     (db, url) -&gt; new DatabaseConfig(url, db.port())
   * );
   *
   * // Compose: Lens &gt;&gt;&gt; Prism = Affine
   * Affine&lt;Config, DatabaseConfig&gt; dbAffine = databaseLens.andThen(somePrism);
   *
   * // Use the affine
   * Config config = new Config(Optional.of(new DatabaseConfig(&quot;localhost&quot;, 5432)));
   * Optional&lt;DatabaseConfig&gt; db = dbAffine.getOptional(config);
   * // Returns Optional[DatabaseConfig[url=localhost, port=5432]]
   *
   * Config emptyConfig = new Config(Optional.empty());
   * Optional&lt;DatabaseConfig&gt; empty = dbAffine.getOptional(emptyConfig);
   * // Returns Optional.empty()
   *
   * // Can chain further with another lens
   * Affine&lt;Config, String&gt; urlAffine = dbAffine.andThen(urlLens);
   * }&lt;/pre&gt;
   *
   * @param prism The {@link Prism} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(final Prism&lt;A, B&gt; prism) {
<span class="fc" id="L248">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L249">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L252">        return prism.getOptional(self.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L257">        return self.set(prism.build(newValue), source);</span>
      }
    };
  }

  /**
   * Composes this {@code Lens&lt;S, A&gt;} with an {@code Affine&lt;A, B&gt;} to create an {@code Affine&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;The result is an Affine because the inner Affine may not find a value (zero-or-one focus).
   *
   * @param affine The {@link Affine} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(final Affine&lt;A, B&gt; affine) {
<span class="fc" id="L273">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L274">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L277">        return affine.getOptional(self.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L282">        A a = self.get(source);</span>
<span class="fc" id="L283">        return self.set(affine.set(newValue, a), source);</span>
      }
    };
  }

  /**
   * Composes this {@code Lens&lt;S, A&gt;} with a {@code Traversal&lt;A, B&gt;} to create a {@code Traversal&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;The composition follows the standard optic composition rule: Lens &gt;&gt;&gt; Traversal = Traversal.
   * The result is a Traversal because the inner Traversal may focus on zero or more elements.
   *
   * &lt;p&gt;This composition is useful when navigating into collections or multiple targets:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;A record field that contains a list
   *   &lt;li&gt;A field containing multiple optional values
   *   &lt;li&gt;Any &quot;has-a&quot; followed by &quot;has-many&quot; relationship
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model
   * record Team(String name, List&lt;Player&gt; players) {}
   * record Player(String name, int score) {}
   *
   * // Optics
   * Lens&lt;Team, List&lt;Player&gt;&gt; playersLens = Lens.of(
   *     Team::players,
   *     (team, players) -&gt; new Team(team.name(), players)
   * );
   * Traversal&lt;List&lt;Player&gt;, Player&gt; allPlayers = Traversals.forList();
   *
   * // Compose: Lens &gt;&gt;&gt; Traversal = Traversal
   * Traversal&lt;Team, Player&gt; teamPlayersTraversal = playersLens.andThen(allPlayers);
   *
   * // Use the traversal
   * Team team = new Team(&quot;Red&quot;, List.of(new Player(&quot;Alice&quot;, 100), new Player(&quot;Bob&quot;, 85)));
   * List&lt;Player&gt; players = Traversals.getAll(teamPlayersTraversal, team);  // [Alice, Bob]
   * }&lt;/pre&gt;
   *
   * @param traversal The {@link Traversal} to compose with.
   * @param &lt;B&gt; The type of the final focused parts.
   * @return A new {@link Traversal} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Traversal&lt;S, B&gt; andThen(final Traversal&lt;A, B&gt; traversal) {
<span class="fc" id="L330">    Lens&lt;S, A&gt; self = this;</span>
<span class="fc" id="L331">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;B, Kind&lt;F, B&gt;&gt; f, S source, Applicative&lt;F&gt; app) {
<span class="fc" id="L334">        A a = self.get(source);</span>
<span class="fc" id="L335">        Kind&lt;F, A&gt; modifiedA = traversal.modifyF(f, a, app);</span>
<span class="fc" id="L336">        return app.map(newA -&gt; self.set(newA, source), modifiedA);</span>
      }
    };
  }

  /**
   * Creates a {@code Lens} from its two fundamental operations: a getter and a setter.
   *
   * @param getter A function to extract the part {@code A} from the structure {@code S}.
   * @param setter A function to immutably update the part {@code A} within the structure {@code S}.
   * @param &lt;S&gt; The type of the whole structure.
   * @param &lt;A&gt; The type of the focused part.
   * @return A new {@code Lens} instance.
   */
  static &lt;S, A&gt; Lens&lt;S, A&gt; of(Function&lt;S, A&gt; getter, BiFunction&lt;S, A, S&gt; setter) {
<span class="fc" id="L351">    return new Lens&lt;&gt;() {</span>
      @Override
      public A get(S source) {
<span class="fc" id="L354">        return getter.apply(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L359">        return setter.apply(source, newValue);</span>
      }

      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="fc" id="L364">        Kind&lt;F, A&gt; fa = f.apply(this.get(source));</span>
<span class="fc" id="L365">        return functor.map(a -&gt; this.set(a, source), fa);</span>
      }
    };
  }

  /**
   * Conditionally set a new value based on a predicate. Returns the original structure if the
   * predicate is false.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Only update email if it's valid
   * Kind&lt;F, User&gt; result = emailLens.setIf(
   *   email -&gt; email.contains(&quot;@&quot;),
   *   &quot;newemail@example.com&quot;,
   *   user,
   *   selective
   * );
   * }&lt;/pre&gt;
   */
  default &lt;F&gt; Kind&lt;F, S&gt; setIf(
      Predicate&lt;? super A&gt; predicate, A newValue, S source, Selective&lt;F&gt; selective) {
<span class="fc" id="L388">    return selective.ifS(</span>
<span class="fc" id="L389">        selective.of(predicate.test(newValue)),</span>
<span class="fc" id="L390">        selective.of(set(newValue, source)),</span>
<span class="fc" id="L391">        selective.of(source));</span>
  }

  /**
   * Modify the value only when the current value meets a condition. Useful for conditional field
   * updates based on current state.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Only increment counter if below threshold
   * Kind&lt;F, Stats&gt; result = counterLens.modifyWhen(
   *   count -&gt; count &lt; 100,
   *   count -&gt; count + 1,
   *   stats,
   *   selective
   * );
   * }&lt;/pre&gt;
   */
  default &lt;F&gt; Kind&lt;F, S&gt; modifyWhen(
      Predicate&lt;? super A&gt; shouldModify,
      Function&lt;A, A&gt; modifier,
      S source,
      Selective&lt;F&gt; selective) {
<span class="fc" id="L415">    A current = get(source);</span>
<span class="fc" id="L416">    return selective.ifS(</span>
<span class="fc" id="L417">        selective.of(shouldModify.test(current)),</span>
<span class="fc" id="L418">        selective.of(set(modifier.apply(current), source)),</span>
<span class="fc" id="L419">        selective.of(source));</span>
  }

  /**
   * Branch between two modification strategies based on current value.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Different processing for positive/negative values
   * Kind&lt;F, Account&gt; result = balanceLens.modifyBranch(
   *   balance -&gt; balance &gt; 0,
   *   balance -&gt; applyInterest(balance),
   *   balance -&gt; applyOverdraftFee(balance),
   *   account,
   *   selective
   * );
   * }&lt;/pre&gt;
   */
  default &lt;F&gt; Kind&lt;F, S&gt; modifyBranch(
      Predicate&lt;? super A&gt; predicate,
      Function&lt;A, A&gt; thenModifier,
      Function&lt;A, A&gt; elseModifier,
      S source,
      Selective&lt;F&gt; selective) {
<span class="fc" id="L444">    A current = get(source);</span>
<span class="fc" id="L445">    return selective.ifS(</span>
<span class="fc" id="L446">        selective.of(predicate.test(current)),</span>
<span class="fc" id="L447">        selective.of(set(thenModifier.apply(current), source)),</span>
<span class="fc" id="L448">        selective.of(set(elseModifier.apply(current), source)));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>