<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Setter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Setter.java</span></div><h1>Setter.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;

/**
 * A **Setter** is a write-only optic that can modify focused elements without necessarily reading
 * them. Think of it as a functional &quot;modifier&quot; that provides a composable way to update values
 * within structures.
 *
 * &lt;p&gt;A Setter is the right tool for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Modifying elements when you only need to transform them, not read them
 *   &lt;li&gt;Updating potentially multiple elements in a structure (like a {@link Traversal})
 *   &lt;li&gt;Creating write-only access to parts of a data structure
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A Setter is more general than a {@link Lens} in the sense that it can modify multiple elements
 * (like a Traversal) but doesn't need to provide read access. However, it's also more restricted
 * because it can't extract values.
 *
 * &lt;p&gt;Every {@link Lens} and {@link Traversal} can be viewed as a Setter, but not every Setter can
 * be a Lens or Traversal.
 *
 * &lt;p&gt;&lt;b&gt;Example usage:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * record Person(String name, int age) {}
 *
 * // Create a setter for the name field
 * Setter&lt;Person, String&gt; nameSetter = Setter.of(
 *   f -&gt; person -&gt; new Person(f.apply(person.name()), person.age())
 * );
 *
 * Person person = new Person(&quot;John&quot;, 30);
 * Person updated = nameSetter.modify(String::toUpperCase, person);
 * // updated = Person(&quot;JOHN&quot;, 30)
 *
 * Person set = nameSetter.set(&quot;Jane&quot;, person);
 * // set = Person(&quot;Jane&quot;, 30)
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; The source type (the structure being modified).
 * @param &lt;A&gt; The focus type (the values being modified).
 */
public interface Setter&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * Modifies the focused elements using a pure function.
   *
   * &lt;p&gt;This is the core operation of a Setter. It applies the modifier function to all focused
   * elements and returns the updated structure.
   *
   * @param f The function to apply to each focused element.
   * @param source The source structure.
   * @return The modified structure.
   */
  S modify(Function&lt;A, A&gt; f, S source);

  /**
   * Sets all focused elements to a specific value.
   *
   * &lt;p&gt;This is equivalent to {@code modify(a -&gt; value, source)}.
   *
   * @param value The value to set.
   * @param source The source structure.
   * @return The modified structure with all focused elements set to the given value.
   */
  default S set(A value, S source) {
<span class="fc" id="L78">    return modify(a -&gt; value, source);</span>
  }

  /**
   * Composes this {@code Setter&lt;S, A&gt;} with another {@code Setter&lt;A, B&gt;} to create a new {@code
   * Setter&lt;S, B&gt;}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Setter&lt;Person, Address&gt; addressSetter = ...;
   * Setter&lt;Address, String&gt; citySetter = ...;
   * Setter&lt;Person, String&gt; personCitySetter = addressSetter.andThen(citySetter);
   * }&lt;/pre&gt;
   *
   * @param other The Setter to compose with.
   * @param &lt;B&gt; The type of the final focused values.
   * @return A new composed Setter.
   */
  default &lt;B&gt; Setter&lt;S, B&gt; andThen(Setter&lt;A, B&gt; other) {
<span class="fc" id="L98">    Setter&lt;S, A&gt; self = this;</span>
<span class="fc" id="L99">    return new Setter&lt;&gt;() {</span>
      @Override
      public S modify(Function&lt;B, B&gt; f, S source) {
<span class="fc" id="L102">        return self.modify(a -&gt; other.modify(f, a), source);</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;B, Kind&lt;F, B&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L108">        return self.modifyF(a -&gt; other.modifyF(f, a, app), s, app);</span>
      }
    };
  }

  /**
   * Converts this Setter to a {@link Traversal}.
   *
   * &lt;p&gt;This is always valid since a Setter satisfies the requirements of a Traversal (it can
   * traverse and modify elements with effects).
   *
   * @return A Traversal view of this Setter.
   */
  default Traversal&lt;S, A&gt; asTraversal() {
<span class="fc" id="L122">    Setter&lt;S, A&gt; self = this;</span>
<span class="fc" id="L123">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L127">        return self.modifyF(f, s, app);</span>
      }
    };
  }

  /**
   * Creates a Setter from a modification function.
   *
   * &lt;p&gt;The modification function takes a pure transformation {@code A -&gt; A} and returns a structure
   * transformation {@code S -&gt; S}. This is the canonical way to define a Setter.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Setter for all elements in a list
   * Setter&lt;List&lt;String&gt;, String&gt; listSetter = Setter.of(
   *   f -&gt; list -&gt; list.stream().map(f).toList()
   * );
   *
   * // Setter for a record field
   * Setter&lt;Person, String&gt; nameSetter = Setter.of(
   *   f -&gt; person -&gt; new Person(f.apply(person.name()), person.age())
   * );
   * }&lt;/pre&gt;
   *
   * @param over The function that lifts element transformations to structure transformations.
   * @param &lt;S&gt; The source type.
   * @param &lt;A&gt; The focus type.
   * @return A new Setter.
   */
  static &lt;S, A&gt; Setter&lt;S, A&gt; of(Function&lt;Function&lt;A, A&gt;, Function&lt;S, S&gt;&gt; over) {
<span class="fc" id="L158">    return new Setter&lt;&gt;() {</span>
      @Override
      public S modify(Function&lt;A, A&gt; f, S source) {
<span class="fc" id="L161">        return over.apply(f).apply(source);</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
        // Cannot implement modifyF without access to the focused element.
        // Use Setter.fromGetSet() for effectful modifications.
<span class="fc" id="L169">        throw new UnsupportedOperationException(</span>
            &quot;modifyF is not supported for Setters created via of(). Use Setter.fromGetSet() to&quot;
                + &quot; create a Setter that supports effectful modifications.&quot;);
      }
    };
  }

  /**
   * Creates a Setter from a getter and setter pair.
   *
   * &lt;p&gt;This is useful when you have both get and set operations but want to create a write-only
   * view. The resulting Setter will focus on exactly one element.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Setter&lt;Person, String&gt; nameSetter = Setter.fromGetSet(
   *   Person::name,
   *   (person, name) -&gt; new Person(name, person.age())
   * );
   * }&lt;/pre&gt;
   *
   * @param getter The function to extract the current value.
   * @param setter The function to create an updated structure.
   * @param &lt;S&gt; The source type.
   * @param &lt;A&gt; The focus type.
   * @return A new Setter.
   */
  static &lt;S, A&gt; Setter&lt;S, A&gt; fromGetSet(Function&lt;S, A&gt; getter, BiFunction&lt;S, A, S&gt; setter) {
<span class="fc" id="L198">    return new Setter&lt;&gt;() {</span>
      @Override
      public S modify(Function&lt;A, A&gt; f, S source) {
<span class="fc" id="L201">        return setter.apply(source, f.apply(getter.apply(source)));</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L207">        Kind&lt;F, A&gt; fa = f.apply(getter.apply(s));</span>
<span class="fc" id="L208">        return app.map(a -&gt; setter.apply(s, a), fa);</span>
      }
    };
  }

  /**
   * Creates a Setter that modifies all elements in a list.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Setter&lt;List&lt;Integer&gt;, Integer&gt; listElements = Setter.forList();
   * List&lt;Integer&gt; doubled = listElements.modify(x -&gt; x * 2, List.of(1, 2, 3));
   * // doubled = [2, 4, 6]
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The element type.
   * @return A Setter for list elements.
   */
  static &lt;A&gt; Setter&lt;List&lt;A&gt;, A&gt; forList() {
<span class="fc" id="L228">    return new Setter&lt;&gt;() {</span>
      @Override
      public List&lt;A&gt; modify(Function&lt;A, A&gt; f, List&lt;A&gt; source) {
<span class="fc" id="L231">        return source.stream().map(f).toList();</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, List&lt;A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, List&lt;A&gt; s, Applicative&lt;F&gt; app) {
        // Collect all effectful results first
<span class="fc" id="L238">        List&lt;Kind&lt;F, A&gt;&gt; effects = new ArrayList&lt;&gt;(s.size());</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (A a : s) {</span>
<span class="fc" id="L240">          effects.add(f.apply(a));</span>
<span class="fc" id="L241">        }</span>

        // Sequence effects using right-to-left fold with LinkedList for O(1) prepending
<span class="fc" id="L244">        Kind&lt;F, LinkedList&lt;A&gt;&gt; acc = app.of(new LinkedList&lt;&gt;());</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int i = effects.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L246">          Kind&lt;F, A&gt; fa = effects.get(i);</span>
<span class="fc" id="L247">          acc =</span>
<span class="fc" id="L248">              app.map2(</span>
                  fa,
                  acc,
                  (elem, list) -&gt; {
<span class="fc" id="L252">                    list.addFirst(elem); // O(1) prepend</span>
<span class="fc" id="L253">                    return list;</span>
                  });
        }

        // Convert LinkedList to immutable List at the end (O(n) total)
<span class="fc" id="L258">        return app.map(List::copyOf, acc);</span>
      }
    };
  }

  /**
   * Creates a Setter that modifies all values in a map.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Setter&lt;Map&lt;String, Integer&gt;, Integer&gt; mapValues = Setter.forMapValues();
   * Map&lt;String, Integer&gt; doubled = mapValues.modify(x -&gt; x * 2,
   *   Map.of(&quot;a&quot;, 1, &quot;b&quot;, 2));
   * // doubled = {a=2, b=4}
   * }&lt;/pre&gt;
   *
   * @param &lt;K&gt; The key type.
   * @param &lt;V&gt; The value type.
   * @return A Setter for map values.
   */
  static &lt;K, V&gt; Setter&lt;Map&lt;K, V&gt;, V&gt; forMapValues() {
<span class="fc" id="L280">    return new Setter&lt;&gt;() {</span>
      @Override
      public Map&lt;K, V&gt; modify(Function&lt;V, V&gt; f, Map&lt;K, V&gt; source) {
<span class="fc" id="L283">        Map&lt;K, V&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        for (Map.Entry&lt;K, V&gt; entry : source.entrySet()) {</span>
<span class="fc" id="L285">          result.put(entry.getKey(), f.apply(entry.getValue()));</span>
<span class="fc" id="L286">        }</span>
<span class="fc" id="L287">        return result;</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, Map&lt;K, V&gt;&gt; modifyF(
          Function&lt;V, Kind&lt;F, V&gt;&gt; f, Map&lt;K, V&gt; s, Applicative&lt;F&gt; app) {
        // Collect all keys and effectful values
<span class="fc" id="L294">        List&lt;K&gt; keys = new ArrayList&lt;&gt;(s.size());</span>
<span class="fc" id="L295">        List&lt;Kind&lt;F, V&gt;&gt; effects = new ArrayList&lt;&gt;(s.size());</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for (Map.Entry&lt;K, V&gt; entry : s.entrySet()) {</span>
<span class="fc" id="L297">          keys.add(entry.getKey());</span>
<span class="fc" id="L298">          effects.add(f.apply(entry.getValue()));</span>
<span class="fc" id="L299">        }</span>

        // Sequence effects to get Kind&lt;F, List&lt;V&gt;&gt;
<span class="fc" id="L302">        Kind&lt;F, LinkedList&lt;V&gt;&gt; acc = app.of(new LinkedList&lt;&gt;());</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int i = effects.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L304">          Kind&lt;F, V&gt; fv = effects.get(i);</span>
<span class="fc" id="L305">          acc =</span>
<span class="fc" id="L306">              app.map2(</span>
                  fv,
                  acc,
                  (v, list) -&gt; {
<span class="fc" id="L310">                    list.addFirst(v); // O(1) prepend</span>
<span class="fc" id="L311">                    return list;</span>
                  });
        }

        // Convert to Map at the end (O(n) total)
<span class="fc" id="L316">        return app.map(</span>
            values -&gt; {
<span class="fc" id="L318">              Map&lt;K, V&gt; resultMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L319">              Iterator&lt;V&gt; valIter = values.iterator();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">              for (K key : keys) {</span>
<span class="fc" id="L321">                resultMap.put(key, valIter.next());</span>
<span class="fc" id="L322">              }</span>
<span class="fc" id="L323">              return resultMap;</span>
            },
            acc);
      }
    };
  }

  /**
   * Creates a Setter that does nothing (identity setter).
   *
   * &lt;p&gt;This setter passes through modifications without applying them. Useful as a base case for
   * composition.
   *
   * @param &lt;S&gt; The source type.
   * @return An identity Setter.
   */
  static &lt;S&gt; Setter&lt;S, S&gt; identity() {
<span class="fc" id="L340">    return new Setter&lt;&gt;() {</span>
      @Override
      public S modify(Function&lt;S, S&gt; f, S source) {
<span class="fc" id="L343">        return f.apply(source);</span>
      }

      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;S, Kind&lt;F, S&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L349">        return f.apply(s);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>