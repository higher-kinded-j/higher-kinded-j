<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Prism.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Prism.java</span></div><h1>Prism.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;

/**
 * A **Prism** is an optic that provides a focused view into a part of a sum type (e.g., a {@code
 * sealed interface} or {@code enum}). Think of it as a safe-cracker's tool ðŸ”¬; it attempts to focus
 * on a single, specific case 'A' within a larger structure 'S' and only succeeds if the structure
 * is of that case.
 *
 * &lt;p&gt;A Prism is the right tool for &quot;is-a&quot; relationships. It provides a functional, type-safe
 * alternative to {@code instanceof} checks and casting. It is defined by two core operations: a
 * failable getter (`getOptional`) and a constructor (`build`).
 *
 * &lt;p&gt;It extends the generic {@link Optic}, specializing it for {@code S = T} and {@code A = B}.
 *
 * @param &lt;S&gt; The source type of the whole structure (e.g., a sealed interface like {@code
 *     JsonValue}).
 * @param &lt;A&gt; The target type of the focused case (e.g., a specific implementation like {@code
 *     JsonString}).
 */
public interface Prism&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * Attempts to get the focused part {@code A} from the whole structure {@code S}.
   *
   * &lt;p&gt;This is the primary &quot;getter&quot; for a Prism, providing a safe way to access the value of a
   * specific case of a sum type.
   *
   * @param source The whole structure.
   * @return An {@link Optional} containing the focused part if the prism matches, otherwise an
   *     empty {@code Optional}.
   */
  Optional&lt;A&gt; getOptional(S source);

  /**
   * Builds the whole structure {@code S} from a part {@code A}.
   *
   * &lt;p&gt;This is the &quot;constructor&quot; or reverse operation for a Prism.
   *
   * @param value The part to build the structure from.
   * @return A new instance of the whole structure {@code S}.
   */
  S build(A value);

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;The implementation for a {@code Prism} will only apply the function {@code f} if the prism
   * successfully matches the source {@code s}. If it does not match, it returns the original
   * structure {@code s} wrapped in the {@link Applicative} context, effectively performing a no-op.
   */
  @Override
  default &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
      Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L65">    return getOptional(s).map(a -&gt; app.map(this::build, f.apply(a))).orElse(app.of(s));</span>
  }

  /**
   * Views this {@code Prism} as a {@link Traversal}.
   *
   * &lt;p&gt;This is always possible because a {@code Prism} is fundamentally a {@code Traversal} that
   * focuses on zero or one element.
   *
   * @return A {@link Traversal} that represents this {@code Prism}.
   */
  default Traversal&lt;S, A&gt; asTraversal() {
<span class="fc" id="L77">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L78">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L82">        return self.modifyF(f, source, applicative);</span>
      }
    };
  }

  /**
   * Views this {@code Prism} as a {@link Fold}.
   *
   * &lt;p&gt;This is always possible because a {@code Prism} can be used as a read-only query that
   * focuses on zero or one element.
   *
   * @return A {@link Fold} that represents this {@code Prism}.
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L96">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L97">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
<span class="fc" id="L100">        Optional&lt;A&gt; opt = self.getOptional(source);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (opt.isPresent()) {</span>
<span class="fc" id="L102">          return f.apply(opt.get());</span>
        } else {
<span class="fc" id="L104">          return monoid.empty();</span>
        }
      }
    };
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with another {@code Prism&lt;A, B&gt;} to create a new {@code
   * Prism&lt;S, B&gt;}.
   *
   * &lt;p&gt;This specialized version is kept for efficiency and to ensure the result is correctly and
   * conveniently typed as a {@code Prism}.
   *
   * @param other The {@link Prism} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Prism} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Prism&lt;S, B&gt; andThen(final Prism&lt;A, B&gt; other) {
<span class="fc" id="L122">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L123">    return new Prism&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L126">        return self.getOptional(source).flatMap(other::getOptional);</span>
      }

      @Override
      public S build(B value) {
<span class="fc" id="L131">        return self.build(other.build(value));</span>
      }
    };
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with an {@code Iso&lt;A, B&gt;} to produce a new {@code Prism&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;This is possible because composing a partial focus with a lossless, two-way conversion
   * results in a new partial focus. This specialized overload ensures the result is correctly and
   * conveniently typed as a {@link Prism}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model
   * sealed interface JsonValue permits JsonString, JsonNumber {}
   * record JsonString(String value) implements JsonValue {}
   * record JsonNumber(double value) implements JsonValue {}
   *
   * // Prism from JsonValue to JsonString
   * Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = Prism.of(
   *     jv -&gt; jv instanceof JsonString js ? Optional.of(js) : Optional.empty(),
   *     js -&gt; js
   * );
   *
   * // Iso from JsonString to String
   * Iso&lt;JsonString, String&gt; jsonStringIso = Iso.of(
   *     JsonString::value,
   *     JsonString::new
   * );
   *
   * // Compose: Prism + Iso = Prism
   * Prism&lt;JsonValue, String&gt; stringValuePrism = jsonStringPrism.andThen(jsonStringIso);
   * }&lt;/pre&gt;
   *
   * @param iso The {@link Iso} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Prism} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Prism&lt;S, B&gt; andThen(final Iso&lt;A, B&gt; iso) {
<span class="fc" id="L173">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L174">    return Prism.of(s -&gt; self.getOptional(s).map(iso::get), b -&gt; self.build(iso.reverseGet(b)));</span>
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with a {@code Lens&lt;A, B&gt;} to create an {@code Affine&lt;S, B&gt;}.
   *
   * &lt;p&gt;The composition follows the standard optic composition rule: Prism &gt;&gt;&gt; Lens = Affine. The
   * result is an Affine because the Prism may not match (resulting in zero-or-one focus), but once
   * matched, the Lens guarantees access to the field.
   *
   * &lt;p&gt;This composition is useful when navigating from sum types into their components:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;A sealed interface case that contains a record field
   *   &lt;li&gt;An Either that contains a structured value
   *   &lt;li&gt;Any &quot;is-a&quot; followed by &quot;has-a&quot; relationship
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model using sealed interfaces
   * sealed interface ApiResponse permits Success, Failure {}
   * record Success(ResponseData data, String timestamp) implements ApiResponse {}
   * record Failure(String error, int code) implements ApiResponse {}
   * record ResponseData(String message, int count) {}
   *
   * // Optics
   * Prism&lt;ApiResponse, Success&gt; successPrism = Prism.of(
   *     resp -&gt; resp instanceof Success s ? Optional.of(s) : Optional.empty(),
   *     s -&gt; s
   * );
   * Lens&lt;Success, ResponseData&gt; dataLens = Lens.of(
   *     Success::data,
   *     (success, data) -&gt; new Success(data, success.timestamp())
   * );
   * Lens&lt;ResponseData, String&gt; messageLens = Lens.of(
   *     ResponseData::message,
   *     (data, msg) -&gt; new ResponseData(msg, data.count())
   * );
   *
   * // Compose: Prism &gt;&gt;&gt; Lens = Affine
   * Affine&lt;ApiResponse, ResponseData&gt; dataAffine = successPrism.andThen(dataLens);
   *
   * // Use the affine
   * ApiResponse success = new Success(new ResponseData(&quot;OK&quot;, 1), &quot;2024-01-01&quot;);
   * Optional&lt;ResponseData&gt; data = dataAffine.getOptional(success);
   * // Returns Optional[ResponseData[message=OK, count=1]]
   *
   * ApiResponse failure = new Failure(&quot;Not Found&quot;, 404);
   * Optional&lt;ResponseData&gt; empty = dataAffine.getOptional(failure);
   * // Returns Optional.empty()
   *
   * // Chain further to reach the message
   * Affine&lt;ApiResponse, String&gt; messageAffine = dataAffine.andThen(messageLens);
   * }&lt;/pre&gt;
   *
   * @param lens The {@link Lens} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(final Lens&lt;A, B&gt; lens) {
<span class="fc" id="L236">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L237">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L240">        return self.getOptional(source).map(lens::get);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L245">        return self.getOptional(source).map(a -&gt; self.build(lens.set(newValue, a))).orElse(source);</span>
      }
    };
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with an {@code Affine&lt;A, B&gt;} to create an {@code Affine&lt;S,
   * B&gt;}.
   *
   * &lt;p&gt;The result is an Affine because both the Prism may not match and the Affine may not find a
   * value, resulting in zero-or-one focus.
   *
   * @param affine The {@link Affine} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Affine} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Affine&lt;S, B&gt; andThen(final Affine&lt;A, B&gt; affine) {
<span class="fc" id="L262">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L263">    return new Affine&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L266">        return self.getOptional(source).flatMap(affine::getOptional);</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L271">        return self.getOptional(source)</span>
<span class="fc" id="L272">            .map(a -&gt; self.build(affine.set(newValue, a)))</span>
<span class="fc" id="L273">            .orElse(source);</span>
      }
    };
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with a {@code Traversal&lt;A, B&gt;} to create a {@code
   * Traversal&lt;S, B&gt;}.
   *
   * &lt;p&gt;The composition follows the standard optic composition rule: Prism &gt;&gt;&gt; Traversal =
   * Traversal. The result is a Traversal because both the Prism may not match and the Traversal may
   * focus on zero or more elements.
   *
   * &lt;p&gt;This composition is useful when navigating into collections within sum type variants:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;A sum type variant that contains a list
   *   &lt;li&gt;An optional case with multiple nested values
   *   &lt;li&gt;Any &quot;is-a&quot; followed by &quot;has-many&quot; relationship
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Domain model
   * sealed interface Container permits Full, Empty {}
   * record Full(List&lt;Item&gt; items) implements Container {}
   * record Empty() implements Container {}
   * record Item(String name) {}
   *
   * // Optics
   * Prism&lt;Container, Full&gt; fullPrism = Prism.of(
   *     c -&gt; c instanceof Full f ? Optional.of(f) : Optional.empty(),
   *     f -&gt; f
   * );
   * Traversal&lt;List&lt;Item&gt;, Item&gt; allItems = Traversals.forList();
   * Lens&lt;Full, List&lt;Item&gt;&gt; itemsLens = Lens.of(Full::items, (f, items) -&gt; new Full(items));
   *
   * // Compose: Prism &gt;&gt;&gt; Lens &gt;&gt;&gt; Traversal chain
   * Traversal&lt;Container, Item&gt; containerItems =
   *     fullPrism.andThen(itemsLens).andThen(allItems);
   *
   * // Direct: Prism &gt;&gt;&gt; Traversal
   * Traversal&lt;Full, Item&gt; fullToItems = itemsLens.andThen(allItems);
   * Traversal&lt;Container, Item&gt; allContainerItems = fullPrism.andThen(fullToItems);
   * }&lt;/pre&gt;
   *
   * @param traversal The {@link Traversal} to compose with.
   * @param &lt;B&gt; The type of the final focused parts.
   * @return A new {@link Traversal} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Traversal&lt;S, B&gt; andThen(final Traversal&lt;A, B&gt; traversal) {
<span class="fc" id="L325">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L326">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;B, Kind&lt;F, B&gt;&gt; f, S source, Applicative&lt;F&gt; app) {
<span class="fc" id="L330">        return self.getOptional(source)</span>
<span class="fc" id="L331">            .map(a -&gt; app.map(self::build, traversal.modifyF(f, a, app)))</span>
<span class="fc" id="L332">            .orElse(app.of(source));</span>
      }
    };
  }

  /**
   * Checks if this prism matches the given structure.
   *
   * &lt;p&gt;This is useful for type checking without extraction, providing a cleaner alternative to
   * {@code getOptional(source).isPresent()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * if (stringPrism.matches(value)) {
   *   // Process as a string
   * }
   * }&lt;/pre&gt;
   *
   * @param source The source structure to test.
   * @return {@code true} if the prism matches, {@code false} otherwise.
   */
  default boolean matches(S source) {
<span class="fc" id="L358">    return getOptional(source).isPresent();</span>
  }

  /**
   * Checks if this prism does NOT match the given structure.
   *
   * &lt;p&gt;This is the logical negation of {@link #matches(Object)}, provided for readability when
   * checking for non-matches.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonNumber(42);
   *
   * if (stringPrism.doesNotMatch(value)) {
   *   // Handle non-string case
   *   log.warn(&quot;Expected string but got: {}&quot;, value.getClass().getSimpleName());
   * }
   *
   * // Useful in stream filtering
   * List&lt;JsonValue&gt; nonStrings = values.stream()
   *     .filter(stringPrism::doesNotMatch)
   *     .toList();
   * }&lt;/pre&gt;
   *
   * @param source The source structure to test.
   * @return {@code true} if the prism does NOT match, {@code false} if it matches.
   */
  default boolean doesNotMatch(S source) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">    return !matches(source);</span>
  }

  /**
   * Provides a default value if the prism doesn't match.
   *
   * &lt;p&gt;This is a convenient shortcut for {@code getOptional(source).orElse(defaultValue)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonNumber(42);
   *
   * String result = stringPrism.getOrElse(new JsonString(&quot;default&quot;), value);
   * // Returns &quot;default&quot; since the value is a number, not a string
   * }&lt;/pre&gt;
   *
   * @param defaultValue The default value to use if the prism doesn't match.
   * @param source The source structure.
   * @return The matched value or the default value.
   */
  default A getOrElse(A defaultValue, S source) {
<span class="fc" id="L411">    return getOptional(source).orElse(defaultValue);</span>
  }

  /**
   * Applies a function to the matched value and returns the result wrapped in an {@link Optional}.
   *
   * &lt;p&gt;This is useful for transforming matched values without building them back into the source
   * structure. It's equivalent to {@code getOptional(source).map(f)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * Optional&lt;Integer&gt; length = stringPrism.mapOptional(String::length, value);
   * // Returns Optional.of(5)
   * }&lt;/pre&gt;
   *
   * @param f The function to apply to the matched value.
   * @param source The source structure.
   * @param &lt;B&gt; The result type of the function.
   * @return An {@link Optional} containing the result if the prism matches, or empty otherwise.
   */
  default &lt;B&gt; Optional&lt;B&gt; mapOptional(Function&lt;? super A, ? extends B&gt; f, S source) {
<span class="fc" id="L436">    return getOptional(source).map(f);</span>
  }

  /**
   * Modifies the focused part {@code A} using a pure function, if the prism matches.
   *
   * &lt;p&gt;This is a convenient shortcut similar to {@link Lens#modify}, but for prisms. If the prism
   * matches, the focused value is extracted, modified, and built back into the structure. If the
   * prism doesn't match, the original structure is returned unchanged.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * JsonValue result = stringPrism.modify(
   *     s -&gt; new JsonString(s.value().toUpperCase()),
   *     value
   * );
   * // Returns new JsonString(&quot;HELLO&quot;)
   *
   * JsonValue number = new JsonNumber(42);
   * JsonValue unchanged = stringPrism.modify(
   *     s -&gt; new JsonString(s.value().toUpperCase()),
   *     number
   * );
   * // Returns the original JsonNumber(42) unchanged
   * }&lt;/pre&gt;
   *
   * @param modifier The function to apply to the focused part.
   * @param source The source structure.
   * @return A new structure with the modified part, or the original structure if the prism doesn't
   *     match.
   */
  default S modify(Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L472">    return getOptional(source).map(a -&gt; build(modifier.apply(a))).orElse(source);</span>
  }

  /**
   * Modifies the focused part only when it meets a specified condition.
   *
   * &lt;p&gt;This combines matching and conditional modification: the prism must match, and the extracted
   * value must satisfy the predicate for modification to occur.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * // Only uppercase strings longer than 3 characters
   * JsonValue result = stringPrism.modifyWhen(
   *   s -&gt; s.length() &gt; 3,
   *   String::toUpperCase,
   *   value
   * );
   * // Returns new JsonString(&quot;HELLO&quot;)
   *
   * JsonValue shortValue = new JsonString(&quot;hi&quot;);
   * JsonValue unchanged = stringPrism.modifyWhen(
   *   s -&gt; s.length() &gt; 3,
   *   String::toUpperCase,
   *   shortValue
   * );
   * // Returns original JsonString(&quot;hi&quot;) since condition not met
   * }&lt;/pre&gt;
   *
   * @param condition The predicate that the focused value must satisfy.
   * @param modifier The function to apply if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally modified part, or the original structure if the
   *     prism doesn't match or the condition is not met.
   */
  default S modifyWhen(Predicate&lt;? super A&gt; condition, Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L511">    return getOptional(source).filter(condition).map(a -&gt; build(modifier.apply(a))).orElse(source);</span>
  }

  /**
   * Sets a new value only when the current value meets a specified condition.
   *
   * &lt;p&gt;This is useful for conditional updates based on the current state. The prism must match, and
   * the extracted value must satisfy the predicate for the set operation to occur.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;old&quot;);
   *
   * // Only replace non-empty strings
   * JsonValue result = stringPrism.setWhen(
   *   s -&gt; !s.isEmpty(),
   *   &quot;new&quot;,
   *   value
   * );
   * // Returns new JsonString(&quot;new&quot;)
   *
   * JsonValue emptyValue = new JsonString(&quot;&quot;);
   * JsonValue unchanged = stringPrism.setWhen(
   *   s -&gt; !s.isEmpty(),
   *   &quot;new&quot;,
   *   emptyValue
   * );
   * // Returns original JsonString(&quot;&quot;) since condition not met
   * }&lt;/pre&gt;
   *
   * @param condition The predicate that the current value must satisfy.
   * @param newValue The new value to set if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally set value, or the original structure if the
   *     prism doesn't match or the condition is not met.
   */
  default S setWhen(Predicate&lt;? super A&gt; condition, A newValue, S source) {
<span class="fc" id="L550">    return getOptional(source).filter(condition).map(a -&gt; build(newValue)).orElse(source);</span>
  }

  /**
   * Chains multiple prisms, returning the first match.
   *
   * &lt;p&gt;This creates a new prism that tries this prism first, and if it doesn't match, tries the
   * other prism. The resulting prism uses the first prism's {@code build} function for
   * construction.
   *
   * &lt;p&gt;This is useful for providing fallback matching strategies or handling multiple alternative
   * cases.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, Number&gt; intPrism = JsonValuePrisms.jsonInt();
   * Prism&lt;JsonValue, Number&gt; doublePrism = JsonValuePrisms.jsonDouble();
   *
   * Prism&lt;JsonValue, Number&gt; numberPrism = intPrism.orElse(doublePrism);
   *
   * // Matches either int or double
   * JsonValue intValue = new JsonInt(42);
   * Optional&lt;Number&gt; result1 = numberPrism.getOptional(intValue);  // Optional.of(42)
   *
   * JsonValue doubleValue = new JsonDouble(3.14);
   * Optional&lt;Number&gt; result2 = numberPrism.getOptional(doubleValue);  // Optional.of(3.14)
   *
   * // Building uses the first prism's builder
   * JsonValue built = numberPrism.build(100);  // Uses intPrism.build
   * }&lt;/pre&gt;
   *
   * @param other Another prism to try if this one doesn't match.
   * @return A prism that tries this one first, then the other.
   */
  default Prism&lt;S, A&gt; orElse(Prism&lt;S, A&gt; other) {
<span class="fc" id="L586">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L587">    return Prism.of(</span>
<span class="fc" id="L588">        source -&gt; self.getOptional(source).or(() -&gt; other.getOptional(source)),</span>
<span class="fc" id="L589">        self::build // Always use the first prism's builder</span>
        );
  }

  /**
   * Creates a {@code Prism} from its two fundamental operations: a failable getter and a builder
   * function.
   *
   * @param getter A function that attempts to extract part {@code A} from structure {@code S}.
   * @param builder A function that constructs the structure {@code S} from a part {@code A}.
   * @param &lt;S&gt; The type of the whole structure.
   * @param &lt;A&gt; The type of the focused part.
   * @return A new {@code Prism} instance.
   */
  static &lt;S, A&gt; Prism&lt;S, A&gt; of(Function&lt;S, Optional&lt;A&gt;&gt; getter, Function&lt;A, S&gt; builder) {
<span class="fc" id="L604">    return new Prism&lt;&gt;() {</span>
      @Override
      public Optional&lt;A&gt; getOptional(S source) {
<span class="fc" id="L607">        return getter.apply(source);</span>
      }

      @Override
      public S build(A value) {
<span class="fc" id="L612">        return builder.apply(value);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>