<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Optic.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Optic.java</span></div><h1>Optic.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.jspecify.annotations.NullMarked;

/**
 * An abstract representation of an optic using the Profunctor representation. This is the core,
 * shared interface that all other optics (Lens, Prism, etc.) implement.
 *
 * &lt;p&gt;An optic can be thought of as a way to &quot;focus&quot; on a part 'A' within a whole 'S' and
 * potentially change its type to 'B', which in turn changes the whole structure's type to 'T'.
 *
 * &lt;p&gt;With profunctor support, optics can be manipulated using profunctor-style operations like
 * {@code contramap}, {@code map}, and {@code dimap} for powerful type transformations.
 *
 * @param &lt;S&gt; The type of the original whole structure.
 * @param &lt;T&gt; The type of the resulting whole structure.
 * @param &lt;A&gt; The type of the original focused part.
 * @param &lt;B&gt; The type of the resulting focused part.
 */
@NullMarked
public interface Optic&lt;S, T, A, B&gt; {

  /**
   * The fundamental operation of any optic. It applies a function to the focused part 'A' to
   * produce a new part 'B' wrapped in an Applicative context 'F', and returns the updated structure
   * 'T' also wrapped in 'F'.
   *
   * @param f The function to apply to the focused part.
   * @param s The source structure.
   * @param app The Applicative instance for the context 'F'.
   * @param &lt;F&gt; The witness type for the Applicative context.
   * @return The updated structure 'T' wrapped in the context 'F'.
   */
  &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, T&gt; modifyF(
      Function&lt;A, Kind&lt;F, B&gt;&gt; f, S s, Applicative&lt;F&gt; app);

  /**
   * Composes this optic with another optic. This is the universal composition method that works for
   * any combination of optics.
   *
   * @param other The optic to compose with.
   * @param &lt;C&gt; The type of the new focused part.
   * @param &lt;D&gt; The type of the new resulting part.
   * @return A new, composed Optic.
   */
  default &lt;C, D&gt; Optic&lt;S, T, C, D&gt; andThen(Optic&lt;A, B, C, D&gt; other) {
<span class="fc" id="L54">    Optic&lt;S, T, A, B&gt; self = this;</span>
<span class="fc" id="L55">    return new Optic&lt;&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, T&gt; modifyF(
          Function&lt;C, Kind&lt;F, D&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L59">        return self.modifyF(a -&gt; other.modifyF(f, a, app), s, app);</span>
      }
    };
  }

  /**
   * Pre-compose with a function on the source type (contravariant operation). This is equivalent to
   * the profunctor {@code lmap} operation.
   *
   * @param f Function to apply before this optic
   * @param &lt;C&gt; New source type
   * @return A new optic that first applies {@code f}
   */
  default &lt;C&gt; Optic&lt;C, T, A, B&gt; contramap(Function&lt;? super C, ? extends S&gt; f) {
<span class="fc" id="L73">    Optic&lt;S, T, A, B&gt; self = this;</span>
<span class="fc" id="L74">    return new Optic&lt;C, T, A, B&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, T&gt; modifyF(
          Function&lt;A, Kind&lt;F, B&gt;&gt; g, C c, Applicative&lt;F&gt; app) {
<span class="fc" id="L78">        return self.modifyF(g, f.apply(c), app);</span>
      }
    };
  }

  /**
   * Post-compose with a function on the target type (covariant operation). This is equivalent to
   * the profunctor {@code rmap} operation.
   *
   * @param g Function to apply after this optic
   * @param &lt;U&gt; New target type
   * @return A new optic that applies {@code g} to the result
   */
  default &lt;U&gt; Optic&lt;S, U, A, B&gt; map(Function&lt;? super T, ? extends U&gt; g) {
<span class="fc" id="L92">    Optic&lt;S, T, A, B&gt; self = this;</span>
<span class="fc" id="L93">    return new Optic&lt;S, U, A, B&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, U&gt; modifyF(
          Function&lt;A, Kind&lt;F, B&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L97">        return app.map(g, self.modifyF(f, s, app));</span>
      }
    };
  }

  /**
   * Apply both contravariant and covariant transformations simultaneously. This is equivalent to
   * the profunctor {@code dimap} operation.
   *
   * @param f Function to apply before this optic (contravariant)
   * @param g Function to apply after this optic (covariant)
   * @param &lt;C&gt; New source type
   * @param &lt;U&gt; New target type
   * @return A new transformed optic
   */
  default &lt;C, U&gt; Optic&lt;C, U, A, B&gt; dimap(
      Function&lt;? super C, ? extends S&gt; f, Function&lt;? super T, ? extends U&gt; g) {
    // Implement dimap directly to avoid type inference issues with chaining
<span class="fc" id="L115">    Optic&lt;S, T, A, B&gt; self = this;</span>
<span class="fc" id="L116">    return new Optic&lt;C, U, A, B&gt;() {</span>
      @Override
      public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, U&gt; modifyF(
          Function&lt;A, Kind&lt;F, B&gt;&gt; h, C c, Applicative&lt;F&gt; app) {
<span class="fc" id="L120">        S s = f.apply(c);</span>
<span class="fc" id="L121">        Kind&lt;F, T&gt; result = self.modifyF(h, s, app);</span>
<span class="fc" id="L122">        return app.map(g, result);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>