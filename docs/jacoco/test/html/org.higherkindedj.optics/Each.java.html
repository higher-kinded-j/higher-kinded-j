<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Each.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Each.java</span></div><h1>Each.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import org.higherkindedj.optics.indexed.IndexedTraversal;

/**
 * A type class for structures that have a canonical element-wise traversal.
 *
 * &lt;p&gt;{@code Each} provides a {@link Traversal} that focuses on all elements within a container
 * type. This enables uniform traversal operations across different container types like {@link
 * java.util.List}, {@link java.util.Map}, {@link java.util.Optional}, arrays, and custom
 * collections.
 *
 * &lt;p&gt;Unlike {@link org.higherkindedj.hkt.Traverse} which works on higher-kinded types {@code
 * Kind&lt;F, A&gt;}, Each works directly on concrete types, making it more convenient for everyday use
 * with standard Java collections.
 *
 * &lt;h3&gt;Relationship to Other Type Classes:&lt;/h3&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link org.higherkindedj.hkt.Traverse} - HKT version for {@code Kind&lt;F, A&gt;}; Each wraps
 *       this for concrete types
 *   &lt;li&gt;{@link At} - Focuses on a single element by index with insert/delete capability
 *   &lt;li&gt;{@link Ixed} - Focuses on a single element by index (read/update only)
 *   &lt;li&gt;{@code Each} - Focuses on ALL elements at once
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example Usage:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Get an Each instance for List
 * Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
 *
 * // Use the traversal to modify all elements
 * Traversal&lt;List&lt;String&gt;, String&gt; traversal = listEach.each();
 * List&lt;String&gt; result = Traversals.modify(traversal, String::toUpperCase, list);
 *
 * // Get all elements
 * List&lt;String&gt; elements = Traversals.getAll(traversal, list);
 *
 * // Use with FocusDSL
 * TraversalPath&lt;User, Order&gt; allOrders = userOrdersPath.each(listEach);
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Indexed Traversal:&lt;/h3&gt;
 *
 * &lt;p&gt;Some containers support indexed access, where each element has an associated index (e.g.,
 * position in a List, key in a Map). Use {@link #eachWithIndex()} to get an {@link
 * IndexedTraversal} that provides access to both index and value:
 *
 * &lt;pre&gt;{@code
 * Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
 *
 * // Get indexed traversal (index type is Integer for List)
 * Optional&lt;IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt;&gt; indexed =
 *     listEach.eachWithIndex();
 *
 * // Use to modify with position awareness
 * indexed.ifPresent(iTraversal -&gt; {
 *     List&lt;String&gt; numbered = IndexedTraversals.imodify(
 *         iTraversal,
 *         (index, value) -&gt; value + &quot; #&quot; + index,
 *         list
 *     );
 * });
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Creating Custom Each Instances:&lt;/h3&gt;
 *
 * &lt;p&gt;To create an Each instance for a custom type, implement the {@link #each()} method:
 *
 * &lt;pre&gt;{@code
 * public static &lt;A&gt; Each&lt;Tree&lt;A&gt;, A&gt; treeEach() {
 *     return new Each&lt;&gt;() {
 *         @Override
 *         public Traversal&lt;Tree&lt;A&gt;, A&gt; each() {
 *             return new Traversal&lt;&gt;() {
 *                 @Override
 *                 public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, Tree&lt;A&gt;&gt; modifyF(
 *                         Function&lt;A, Kind&lt;F, A&gt;&gt; f,
 *                         Tree&lt;A&gt; source,
 *                         Applicative&lt;F&gt; app) {
 *                     // Implement tree traversal logic
 *                 }
 *             };
 *         }
 *     };
 * }
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; The container type (e.g., {@code List&lt;A&gt;}, {@code Map&lt;K, V&gt;}, {@code Optional&lt;A&gt;})
 * @param &lt;A&gt; The element type within the container
 * @see Traversal
 * @see At
 * @see Ixed
 * @see org.higherkindedj.hkt.Traverse
 */
@FunctionalInterface
public interface Each&lt;S, A&gt; {

  /**
   * Returns the canonical traversal for all elements in this container.
   *
   * &lt;p&gt;The returned traversal focuses on every element of type {@code A} within {@code S}, enabling
   * bulk read and modification operations. The traversal order depends on the container type:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;List: Elements are traversed in order (index 0, 1, 2, ...)
   *   &lt;li&gt;Set: Traversal order depends on the Set implementation
   *   &lt;li&gt;Map: Values are traversed; order depends on the Map implementation
   *   &lt;li&gt;Optional/Maybe: The single element (if present) is traversed
   * &lt;/ul&gt;
   *
   * &lt;p&gt;The traversal is lawful and satisfies the standard traversal laws:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Identity: {@code modifyF(of, s, app) == app.of(s)}
   *   &lt;li&gt;Composition: Traversals compose associatively
   * &lt;/ul&gt;
   *
   * @return A {@link Traversal} focusing on all elements; never null
   */
  Traversal&lt;S, A&gt; each();

  /**
   * Returns an indexed traversal if the container supports indexed access.
   *
   * &lt;p&gt;The index type depends on the container:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code List&lt;A&gt;}: Index type is {@code Integer} (position)
   *   &lt;li&gt;{@code Map&lt;K, V&gt;}: Index type is {@code K} (key type)
   *   &lt;li&gt;{@code A[]}: Index type is {@code Integer} (position)
   *   &lt;li&gt;{@code String}: Index type is {@code Integer} (character position)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Containers that don't naturally support indexing (like {@code Set} or {@code Optional})
   * return {@link Optional#empty()}.
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
   *
   * // Get the indexed traversal
   * Optional&lt;IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt;&gt; maybeIndexed =
   *     listEach.eachWithIndex();
   *
   * maybeIndexed.ifPresent(indexed -&gt; {
   *     // Number each element by position
   *     List&lt;String&gt; numbered = IndexedTraversals.imodify(
   *         indexed,
   *         (i, s) -&gt; (i + 1) + &quot;. &quot; + s,
   *         List.of(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;)
   *     );
   *     // Result: [&quot;1. first&quot;, &quot;2. second&quot;, &quot;3. third&quot;]
   * });
   * }&lt;/pre&gt;
   *
   * @param &lt;I&gt; The index type (inferred from the container)
   * @return An {@link Optional} containing the {@link IndexedTraversal} if indexed access is
   *     supported; {@link Optional#empty()} otherwise
   */
  default &lt;I&gt; Optional&lt;IndexedTraversal&lt;I, S, A&gt;&gt; eachWithIndex() {
<span class="fc" id="L167">    return Optional.empty();</span>
  }

  /**
   * Checks if this Each instance supports indexed traversal.
   *
   * &lt;p&gt;This is a convenience method equivalent to {@code eachWithIndex().isPresent()}.
   *
   * @return {@code true} if {@link #eachWithIndex()} returns a value; {@code false} otherwise
   */
  default boolean supportsIndexed() {
<span class="fc" id="L178">    return eachWithIndex().isPresent();</span>
  }

  /**
   * Creates an Each instance from an existing Traversal.
   *
   * &lt;p&gt;This factory method allows wrapping any Traversal as an Each instance, which is useful for
   * integrating existing traversals with APIs that expect Each.
   *
   * &lt;pre&gt;{@code
   * Traversal&lt;MyContainer&lt;String&gt;, String&gt; myTraversal = ...;
   * Each&lt;MyContainer&lt;String&gt;, String&gt; myEach = Each.fromTraversal(myTraversal);
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal to wrap; must not be null
   * @param &lt;S&gt; The container type
   * @param &lt;A&gt; The element type
   * @return An Each instance that delegates to the given traversal
   */
  static &lt;S, A&gt; Each&lt;S, A&gt; fromTraversal(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L198">    return () -&gt; traversal;</span>
  }

  /**
   * Creates an Each instance from an existing IndexedTraversal.
   *
   * &lt;p&gt;The resulting Each instance supports both regular and indexed traversal.
   *
   * &lt;pre&gt;{@code
   * IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();
   * Each&lt;List&lt;String&gt;, String&gt; each = Each.fromIndexedTraversal(indexed);
   *
   * // Both methods work
   * Traversal&lt;List&lt;String&gt;, String&gt; trav = each.each();
   * Optional&lt;IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt;&gt; iTrav = each.eachWithIndex();
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Type Safety Warning:&lt;/strong&gt; The {@link #eachWithIndex()} method on the returned
   * {@code Each} instance uses an unchecked cast internally. The method signature {@code &lt;J&gt;
   * Optional&lt;IndexedTraversal&lt;J, S, A&gt;&gt;} allows callers to request any index type {@code J}, but
   * the underlying traversal has a fixed index type {@code I}. If the caller specifies an
   * incompatible index type, a {@link ClassCastException} will occur at runtime when the index is
   * accessed.
   *
   * &lt;p&gt;&lt;strong&gt;Correct usage:&lt;/strong&gt; Always use the same index type that was used when creating
   * the original {@link IndexedTraversal}:
   *
   * &lt;pre&gt;{@code
   * // listTraversal has index type Integer
   * IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; listTraversal = IndexedTraversals.forList();
   * Each&lt;List&lt;String&gt;, String&gt; each = Each.fromIndexedTraversal(listTraversal);
   *
   * // Correct: request Integer index (matches the original)
   * Optional&lt;IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt;&gt; goodPath = each.eachWithIndex();
   *
   * // WRONG: requesting String index will compile but fail at runtime
   * // Optional&lt;IndexedTraversal&lt;String, List&lt;String&gt;, String&gt;&gt; badPath = each.eachWithIndex();
   * }&lt;/pre&gt;
   *
   * @param indexedTraversal The indexed traversal to wrap; must not be null
   * @param &lt;I&gt; The index type of the traversal; callers of {@link #eachWithIndex()} must use this
   *     same type
   * @param &lt;S&gt; The container type
   * @param &lt;A&gt; The element type
   * @return An Each instance that provides both regular and indexed traversal
   */
  static &lt;I, S, A&gt; Each&lt;S, A&gt; fromIndexedTraversal(IndexedTraversal&lt;I, S, A&gt; indexedTraversal) {
<span class="fc" id="L245">    return new Each&lt;&gt;() {</span>
      @Override
      public Traversal&lt;S, A&gt; each() {
<span class="fc" id="L248">        return indexedTraversal.asTraversal();</span>
      }

      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public &lt;J&gt; Optional&lt;IndexedTraversal&lt;J, S, A&gt;&gt; eachWithIndex() {
<span class="fc" id="L254">        return Optional.of((IndexedTraversal&lt;J, S, A&gt;) indexedTraversal);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>