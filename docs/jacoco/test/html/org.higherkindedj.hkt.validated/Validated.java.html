<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validated.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.validated</a> &gt; <span class="el_source">Validated.java</span></div><h1>Validated.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.validated;

import static java.util.Objects.requireNonNull;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.NoSuchElementException;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Represents a value that is either Valid (correct) or Invalid (erroneous). This is a sealed
 * interface with two implementations: {@link Valid} and {@link Invalid}.
 *
 * &lt;p&gt;By convention, {@link Invalid} holds an error value of type {@code E}, and {@link Valid} holds
 * a success value of type {@code A}. Operations like {@link #map(Function)} and {@link
 * #flatMap(Function)} are right-biased, operating on the {@link Valid} value and passing {@link
 * Invalid} values through unchanged.
 *
 * @param &lt;E&gt; The type of the error in case of an Invalid value.
 * @param &lt;A&gt; The type of the value in case of a Valid value.
 */
public sealed interface Validated&lt;E, A&gt; permits Valid, Invalid {

<span class="fc" id="L31">  Class&lt;Validated&gt; VALIDATED_CLASS = Validated.class;</span>

  /**
   * Checks if this is a {@code Valid} instance.
   *
   * @return true if this is {@code Valid}, false otherwise.
   */
  boolean isValid();

  /**
   * Checks if this is an {@code Invalid} instance.
   *
   * @return true if this is {@code Invalid}, false otherwise.
   */
  boolean isInvalid();

  /**
   * Gets the value if this is a {@code Valid} instance.
   *
   * @return The encapsulated value.
   * @throws NoSuchElementException if this is an {@code Invalid} instance.
   */
  A get() throws NoSuchElementException;

  /**
   * Gets the error if this is an {@code Invalid} instance.
   *
   * @return The encapsulated error.
   * @throws NoSuchElementException if this is a {@code Valid} instance.
   */
  E getError() throws NoSuchElementException;

  /**
   * Returns the value if {@code Valid}, otherwise returns {@code other}.
   *
   * @param other The value to return if this is {@code Invalid}.
   * @return The value if {@code Valid}, or {@code other}.
   */
  A orElse(A other);

  /**
   * Returns the value if {@code Valid}, otherwise returns the result of {@code
   * otherSupplier.get()}.
   *
   * @param otherSupplier Supplier for the value to return if this is {@code Invalid}. Must not be
   *     null and must produce a non-null value.
   * @return The value if {@code Valid}, or the result of the supplier.
   */
  A orElseGet(Supplier&lt;? extends A&gt; otherSupplier);

  /**
   * Returns the value if {@code Valid}, otherwise throws the exception supplied by {@code
   * exceptionSupplier}.
   *
   * @param exceptionSupplier Supplier for the exception to throw. Must not be null.
   * @param &lt;X&gt; Type of the exception.
   * @return The value if {@code Valid}.
   * @throws X if this is {@code Invalid}.
   */
  &lt;X extends Throwable&gt; A orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X;

  /**
   * Performs the given action with the value if it is {@code Valid}.
   *
   * @param consumer The action to perform. Must not be null.
   */
  void ifValid(Consumer&lt;? super A&gt; consumer);

  /**
   * Performs the given action with the error if it is {@code Invalid}.
   *
   * @param consumer The action to perform. Must not be null.
   */
  void ifInvalid(Consumer&lt;? super E&gt; consumer);

  /**
   * Maps the value {@code A} to {@code B} if this is {@code Valid}, otherwise returns the {@code
   * Invalid} instance.
   *
   * @param fn The mapping function. Must not be null.
   * @param &lt;B&gt; The new value type.
   * @return A {@code Validated&lt;E, B&gt;} instance.
   */
  &lt;B&gt; Validated&lt;E, B&gt; map(Function&lt;? super A, ? extends B&gt; fn);

  /**
   * Transforms both the error and value of this {@code Validated} using the provided mapping
   * functions, producing a new {@code Validated} with potentially different types for both
   * parameters.
   *
   * &lt;p&gt;This is the fundamental bifunctor operation for {@code Validated}, allowing simultaneous
   * transformation of both the error channel (invalid) and success channel (valid). Exactly one of
   * the two functions will be applied, depending on whether this is {@link Invalid} or {@link
   * Valid}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Validated&lt;String, Integer&gt; success = Validated.valid(42);
   * Validated&lt;Exception, String&gt; result1 = success.bimap(
   *     Exception::new,           // Transform error - not applied
   *     n -&gt; &quot;Value: &quot; + n        // Transform value - applied
   * );
   * // result1 = Valid(&quot;Value: 42&quot;)
   *
   * Validated&lt;String, Integer&gt; failure = Validated.invalid(&quot;not found&quot;);
   * Validated&lt;Exception, String&gt; result2 = failure.bimap(
   *     Exception::new,           // Transform error - applied
   *     n -&gt; &quot;Value: &quot; + n        // Transform value - not applied
   * );
   * // result2 = Invalid(new Exception(&quot;not found&quot;))
   * }&lt;/pre&gt;
   *
   * @param errorMapper The non-null function to apply to the error if this is {@link Invalid}.
   * @param valueMapper The non-null function to apply to the value if this is {@link Valid}.
   * @param &lt;E2&gt; The type of the error in the resulting {@code Validated}.
   * @param &lt;B&gt; The type of the value in the resulting {@code Validated}.
   * @return A new {@code Validated&lt;E2, B&gt;} with one value transformed according to the appropriate
   *     mapper. The returned {@code Validated} will be non-null.
   * @throws NullPointerException if either {@code errorMapper} or {@code valueMapper} is null.
   */
  default &lt;E2, B&gt; Validated&lt;E2, B&gt; bimap(
      Function&lt;? super E, ? extends E2&gt; errorMapper, Function&lt;? super A, ? extends B&gt; valueMapper) {
<span class="fc" id="L154">    Validation.function().requireMapper(errorMapper, &quot;errorMapper&quot;, VALIDATED_CLASS, BIMAP);</span>
<span class="fc" id="L155">    Validation.function().requireMapper(valueMapper, &quot;valueMapper&quot;, VALIDATED_CLASS, BIMAP);</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L158">      case Invalid&lt;E, A&gt;(var error) -&gt; Validated.invalid(errorMapper.apply(error));</span>
<span class="fc" id="L159">      case Valid&lt;E, A&gt;(var value) -&gt; Validated.valid(valueMapper.apply(value));</span>
    };
  }

  /**
   * Transforms only the error of this {@code Validated}, leaving the value unchanged if present.
   *
   * &lt;p&gt;This operation allows you to transform the error channel whilst preserving the success
   * channel. It is useful for converting error types, enriching error messages, or mapping between
   * different error representations.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Validated&lt;String, Integer&gt; failure = Validated.invalid(&quot;invalid input&quot;);
   * Validated&lt;Exception, Integer&gt; result1 = failure.mapError(Exception::new);
   * // result1 = Invalid(new Exception(&quot;invalid input&quot;))
   *
   * Validated&lt;String, Integer&gt; success = Validated.valid(42);
   * Validated&lt;Exception, Integer&gt; result2 = success.mapError(Exception::new);
   * // result2 = Valid(42) - value unchanged
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is equivalent to calling {@code bimap(errorMapper, Function.identity())}.
   *
   * @param errorMapper The non-null function to apply to the error if this is {@link Invalid}.
   * @param &lt;E2&gt; The type of the error in the resulting {@code Validated}.
   * @return A new {@code Validated&lt;E2, A&gt;} with the error transformed if this was {@link Invalid},
   *     or the original value unchanged. The returned {@code Validated} will be non-null.
   * @throws NullPointerException if {@code errorMapper} is null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E2&gt; Validated&lt;E2, A&gt; mapError(Function&lt;? super E, ? extends E2&gt; errorMapper) {
<span class="fc" id="L192">    Validation.function().requireMapper(errorMapper, &quot;errorMapper&quot;, VALIDATED_CLASS, MAP_ERROR);</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L195">      case Invalid&lt;E, A&gt;(var error) -&gt; Validated.invalid(errorMapper.apply(error));</span>
<span class="fc" id="L196">      case Valid&lt;E, A&gt; v -&gt; (Validated&lt;E2, A&gt;) v; // Valid remains unchanged, cast is safe</span>
    };
  }

  /**
   * Applies the function {@code fn} if this is {@code Valid}, otherwise returns the {@code Invalid}
   * instance. This is the monadic bind operation.
   *
   * @param fn The function to apply, which returns a {@code Validated&lt;E, B&gt;}. Must not be null and
   *     must not return a null Validated.
   * @param &lt;B&gt; The new value type of the resulting {@code Validated}.
   * @return A {@code Validated&lt;E, B&gt;} instance.
   */
  &lt;B&gt; Validated&lt;E, B&gt; flatMap(Function&lt;? super A, ? extends Validated&lt;E, ? extends B&gt;&gt; fn);

  /**
   * Applies a function contained within a {@code Validated} to this {@code Validated}'s value.
   *
   * &lt;p&gt;If this instance is {@code Valid} and {@code fnValidated} is {@code Valid}, the result is
   * {@code Valid(f.apply(a))}.
   *
   * &lt;p&gt;If either this instance or {@code fnValidated} is {@code Invalid}, an {@code Invalid} is
   * returned. If both are {@code Invalid}, the errors are combined using the provided {@link
   * Semigroup}.
   *
   * @param fnValidated A {@code Validated} containing a function from {@code A} to {@code B}. Must
   *     not be null.
   * @param semigroup A {@link Semigroup} to combine errors if both this and {@code fnValidated} are
   *     {@code Invalid}.
   * @param &lt;B&gt; The new value type.
   * @return A {@code Validated&lt;E, B&gt;} instance.
   */
  &lt;B&gt; Validated&lt;E, B&gt; ap(
      Validated&lt;E, Function&lt;? super A, ? extends B&gt;&gt; fnValidated, Semigroup&lt;E&gt; semigroup);

  /**
   * Applies one of two functions depending on whether this instance is {@link Invalid} or {@link
   * Valid}, using modern switch expression pattern matching.
   *
   * @param invalidMapper The non-null function to apply if this is an {@link Invalid}.
   * @param validMapper The non-null function to apply if this is a {@link Valid}.
   * @param &lt;T&gt; The target type to which both paths will be mapped.
   * @return The result of applying the appropriate mapping function.
   * @throws NullPointerException if either {@code invalidMapper} or {@code validMapper} is null.
   */
  default &lt;T&gt; T fold(
      Function&lt;? super E, ? extends T&gt; invalidMapper,
      Function&lt;? super A, ? extends T&gt; validMapper) {
<span class="fc" id="L244">    Validation.function().requireFunction(invalidMapper, &quot;invalidMapper&quot;, VALIDATED_CLASS, FOLD);</span>
<span class="fc" id="L245">    Validation.function().requireFunction(validMapper, &quot;validMapper&quot;, VALIDATED_CLASS, FOLD);</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L248">      case Invalid&lt;E, A&gt;(var error) -&gt; invalidMapper.apply(error);</span>
<span class="fc" id="L249">      case Valid&lt;E, A&gt;(var value) -&gt; validMapper.apply(value);</span>
    };
  }

  /**
   * Converts this {@code Validated} to an {@link Either}.
   *
   * &lt;p&gt;A {@link Valid} instance becomes an {@link Either.Right}, and an {@link Invalid} instance
   * becomes an {@link Either.Left}.
   *
   * @return An {@code Either&lt;E, A&gt;} representing the state of this {@code Validated}.
   */
  default Either&lt;E, A&gt; toEither() {
<span class="fc" id="L262">    return fold(Either::left, Either::right);</span>
  }

  /**
   * Validates a condition, returning Valid(Unit) if true, Invalid(error) if false.
   *
   * &lt;p&gt;This is useful for validation logic that doesn't produce a value, only checks a condition.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Validated&lt;String, Unit&gt; ageCheck =
   *     Validated.validateThat(age &gt;= 18, &quot;Must be 18 or older&quot;);
   *
   * Validated&lt;String, Unit&gt; nameCheck =
   *     Validated.validateThat(!name.isEmpty(), &quot;Name required&quot;);
   *
   * // Combine both checks
   * ValidatedApplicative&lt;String&gt; app = ValidatedApplicative.instance(Semigroups.string(&quot;, &quot;));
   * Kind&lt;ValidatedKind.Witness&lt;String&gt;, Unit&gt; allValid =
   *     app.map2(
   *         VALIDATED.widen(ageCheck),
   *         VALIDATED.widen(nameCheck),
   *         (u1, u2) -&gt; Unit.INSTANCE
   *     );
   * }&lt;/pre&gt;
   *
   * @param condition The condition to check
   * @param error The error to return if condition is false, must not be null
   * @param &lt;E&gt; The error type
   * @return Valid(Unit.INSTANCE) if condition is true, Invalid(error) otherwise
   * @throws NullPointerException if error is null
   */
  static &lt;E&gt; Validated&lt;E, Unit&gt; validateThat(boolean condition, E error) {
<span class="fc" id="L296">    requireNonNull(error, &quot;error cannot be null&quot;);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">    return condition ? Validated.valid(Unit.INSTANCE) : Validated.invalid(error);</span>
  }

  /**
   * Validates a condition with a lazy error supplier. Only evaluates the error if the condition
   * fails.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Validated&lt;String, Unit&gt; check = Validated.validateThat(
   *     expensiveCondition(),
   *     () -&gt; expensiveErrorMessage()
   * );
   * }&lt;/pre&gt;
   *
   * @param condition The condition to check
   * @param errorSupplier Supplies the error if needed, must not be null
   * @param &lt;E&gt; The error type
   * @return Valid(Unit.INSTANCE) if true, Invalid(errorSupplier.get()) if false
   * @throws NullPointerException if errorSupplier is null
   */
  static &lt;E&gt; Validated&lt;E, Unit&gt; validateThat(boolean condition, Supplier&lt;E&gt; errorSupplier) {

<span class="fc" id="L321">    requireNonNull(errorSupplier, &quot;errorSupplier cannot be null&quot;);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">    return condition ? Validated.valid(Unit.INSTANCE) : Validated.invalid(errorSupplier.get());</span>
  }

  /**
   * Discards the value of a Valid, replacing it with Unit. If Invalid, returns the same Invalid.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Validated&lt;Error, User&gt; userValidation = validateUser(data);
   * Validated&lt;Error, Unit&gt; justCheckValidity = userValidation.asUnit();
   * }&lt;/pre&gt;
   *
   * @return A {@code Validated&lt;E, Unit&gt;} with the same validity but Unit as value
   */
  default Validated&lt;E, Unit&gt; asUnit() {
<span class="fc" id="L338">    return map(a -&gt; Unit.INSTANCE);</span>
  }

  /**
   * Creates a {@code Valid} instance containing the given value.
   *
   * @param value The value, must not be null.
   * @param &lt;E&gt; The error type (unused for Valid).
   * @param &lt;A&gt; The value type.
   * @return A {@code Valid&lt;E, A&gt;} instance.
   * @throws NullPointerException if value is null.
   */
  static &lt;E, A&gt; Validated&lt;E, A&gt; valid(A value) {
<span class="fc" id="L351">    Validation.coreType().requireValue(value, VALIDATED_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L352">    return new Valid&lt;&gt;(value);</span>
  }

  /**
   * Creates an {@code Invalid} instance containing the given error.
   *
   * @param error The error, must not be null.
   * @param &lt;E&gt; The error type.
   * @param &lt;A&gt; The value type (unused for Invalid).
   * @return An {@code Invalid&lt;E, A&gt;} instance.
   * @throws NullPointerException if error is null.
   */
  static &lt;E, A&gt; Validated&lt;E, A&gt; invalid(E error) {
<span class="fc" id="L365">    Validation.coreType().requireError(error, VALIDATED_CLASS, INVALID);</span>
<span class="fc" id="L366">    return new Invalid&lt;&gt;(error);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>