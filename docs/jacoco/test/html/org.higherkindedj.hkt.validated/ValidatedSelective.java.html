<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValidatedSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.validated</a> &gt; <span class="el_source">ValidatedSelective.java</span></div><h1>ValidatedSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.validated;

import static org.higherkindedj.hkt.util.validation.Operation.*;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import org.higherkindedj.hkt.*;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link Validated}, with a fixed error type {@code
 * E}. This provides selective applicative operations with error accumulation.
 *
 * &lt;p&gt;Unlike {@link org.higherkindedj.hkt.either.EitherSelective} which fails fast on the first
 * error, {@code ValidatedSelective} accumulates all errors using the provided {@link Semigroup}.
 * This is the key advantage of Validated over Either for validation scenarios.
 *
 * &lt;p&gt;The Selective interface sits between {@link org.higherkindedj.hkt.Applicative} and {@link
 * org.higherkindedj.hkt.Monad} in terms of power. For Validated with error accumulation:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Valid} values: Operations are applied
 *   &lt;li&gt;{@link Invalid} values: Errors are accumulated using the semigroup
 *   &lt;li&gt;Multiple invalids: All errors are combined, not just the first
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies an effectful function, accumulating
 *       errors.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with error
 *       accumulation.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes an effect, accumulating errors.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional with error accumulation.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This class requires a {@link Semigroup} for combining errors. Use the {@link
 * #instance(Semigroup)} factory method to create instances.
 *
 * @param &lt;E&gt; The fixed type for the error value.
 * @see Validated
 * @see ValidatedMonad
 * @see Selective
 * @see Semigroup
 */
public final class ValidatedSelective&lt;E&gt; extends ValidatedMonad&lt;E&gt;
    implements Selective&lt;ValidatedKind.Witness&lt;E&gt;&gt; {

<span class="fc" id="L54">  private static final Class&lt;ValidatedSelective&gt; VALIDATED_SELECTIVE_CLASS =</span>
      ValidatedSelective.class;

  private final Semigroup&lt;E&gt; semigroup;

  /**
   * Constructs a {@code ValidatedSelective} with the specified semigroup for error accumulation.
   *
   * @param semigroup The semigroup for combining errors. Must not be null.
   */
  private ValidatedSelective(Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L65">    super(semigroup);</span>
<span class="fc" id="L66">    this.semigroup = semigroup;</span>
<span class="fc" id="L67">  }</span>

  /**
   * Provides an instance of {@code ValidatedSelective} for a given error type {@code E}, which
   * requires a {@link Semigroup} for error accumulation.
   *
   * @param semigroup The semigroup for combining errors. Must not be null.
   * @param &lt;E&gt; The error type.
   * @return A new instance of {@code ValidatedSelective}.
   * @throws NullPointerException if {@code semigroup} is null.
   */
  public static &lt;E&gt; ValidatedSelective&lt;E&gt; instance(Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L79">    return new ValidatedSelective&lt;&gt;(semigroup);</span>
  }

  /**
   * The core selective operation for Validated with error accumulation. Given an effectful choice
   * {@code fab} and an effectful function {@code ff}, applies the function only if the choice is a
   * {@code Left}, accumulating any errors encountered.
   *
   * &lt;p&gt;Behavior with error accumulation:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If {@code fab} is {@code Valid(Choice.Right(b))}: Returns {@code Valid(b)}, {@code ff} is
   *       not evaluated.
   *   &lt;li&gt;If {@code fab} is {@code Valid(Choice.Left(a))} and {@code ff} is {@code
   *       Valid(function)}: Returns {@code Valid(function.apply(a))}.
   *   &lt;li&gt;If {@code fab} is {@code Invalid(e1)} and {@code ff} is {@code Invalid(e2)}: Returns
   *       {@code Invalid(semigroup.combine(e1, e2))}.
   *   &lt;li&gt;If only one is {@code Invalid}: Returns that {@code Invalid}.
   * &lt;/ul&gt;
   *
   * @param fab A {@link Kind} representing {@code Validated&lt;E, Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param ff A {@link Kind} representing {@code Validated&lt;E, Function&lt;A, B&gt;&gt;}. Must not be null.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left} of the Choice).
   * @param &lt;B&gt; The output type and the type inside {@code Right} of the Choice.
   * @return A {@link Kind} representing {@code Validated&lt;E, B&gt;}. Never null.
   * @throws NullPointerException if {@code fab} or {@code ff} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; select(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L113">    Validation.kind().requireNonNull(fab, VALIDATED_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L114">    Validation.kind().requireNonNull(ff, VALIDATED_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L116">    Validated&lt;E, Choice&lt;A, B&gt;&gt; validatedChoice = VALIDATED.narrow(fab);</span>
<span class="fc" id="L117">    Validated&lt;E, Function&lt;A, B&gt;&gt; validatedFunction = VALIDATED.narrow(ff);</span>

    // Collect errors for accumulation
<span class="fc" id="L120">    List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>

    // Check if choice has an error
<span class="fc bfc" id="L123" title="All 2 branches covered.">    if (validatedChoice.isInvalid()) {</span>
<span class="fc" id="L124">      errors.add(validatedChoice.getError());</span>
    }

    // If choice is valid and right, return the value without checking function
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (validatedChoice.isValid()) {</span>
<span class="fc" id="L129">      Choice&lt;A, B&gt; choice = validatedChoice.get();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (choice.isRight()) {</span>
<span class="fc" id="L131">        return VALIDATED.widen(Validated.valid(choice.getRight()));</span>
      }

      // Choice is left, so we need the function
<span class="fc bfc" id="L135" title="All 2 branches covered.">      if (validatedFunction.isInvalid()) {</span>
<span class="fc" id="L136">        errors.add(validatedFunction.getError());</span>
      }
<span class="fc" id="L138">    } else {</span>
      // Choice is invalid, still check function to accumulate errors
<span class="fc bfc" id="L140" title="All 2 branches covered.">      if (validatedFunction.isInvalid()) {</span>
<span class="fc" id="L141">        errors.add(validatedFunction.getError());</span>
      }
    }

    // If we have errors, combine and return
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (!errors.isEmpty()) {</span>
<span class="fc" id="L147">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L148">      return VALIDATED.widen(Validated.invalid(combinedError));</span>
    }

    // Both are valid, apply the function
<span class="fc" id="L152">    Choice&lt;A, B&gt; choice = validatedChoice.get();</span>
<span class="fc" id="L153">    Function&lt;A, B&gt; function = validatedFunction.get();</span>
<span class="fc" id="L154">    B result = function.apply(choice.getLeft());</span>

<span class="fc" id="L156">    return VALIDATED.widen(Validated.valid(result));</span>
  }

  /**
   * Optimised implementation of {@code branch} for Validated with error accumulation. Provides a
   * two-way conditional choice, applying the appropriate handler and accumulating all errors.
   *
   * @param fab A {@link Kind} representing {@code Validated&lt;E, Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code Validated&lt;E, Function&lt;A, C&gt;&gt;} for the Left case.
   *     Must not be null.
   * @param fr A {@link Kind} representing {@code Validated&lt;E, Function&lt;B, C&gt;&gt;} for the Right case.
   *     Must not be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code Validated&lt;E, C&gt;}. Never null.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, C&gt; branch(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L179">    Validation.kind().requireNonNull(fab, VALIDATED_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L180">    Validation.kind().requireNonNull(fl, VALIDATED_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L181">    Validation.kind().requireNonNull(fr, VALIDATED_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L183">    Validated&lt;E, Choice&lt;A, B&gt;&gt; validatedChoice = VALIDATED.narrow(fab);</span>
<span class="fc" id="L184">    Validated&lt;E, Function&lt;A, C&gt;&gt; leftFunction = VALIDATED.narrow(fl);</span>
<span class="fc" id="L185">    Validated&lt;E, Function&lt;B, C&gt;&gt; rightFunction = VALIDATED.narrow(fr);</span>

    // Collect errors for accumulation
<span class="fc" id="L188">    List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">    if (validatedChoice.isInvalid()) {</span>
<span class="fc" id="L191">      errors.add(validatedChoice.getError());</span>
    }

    // Determine which function we need and check for its errors
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (validatedChoice.isValid()) {</span>
<span class="fc" id="L196">      Choice&lt;A, B&gt; choice = validatedChoice.get();</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (choice.isLeft()) {</span>
        // Need left function
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (leftFunction.isInvalid()) {</span>
<span class="fc" id="L201">          errors.add(leftFunction.getError());</span>
        }

<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc" id="L205">          E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L206">          return VALIDATED.widen(Validated.invalid(combinedError));</span>
        }

<span class="fc" id="L209">        C result = leftFunction.get().apply(choice.getLeft());</span>
<span class="fc" id="L210">        return VALIDATED.widen(Validated.valid(result));</span>
      } else {
        // Need right function
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (rightFunction.isInvalid()) {</span>
<span class="fc" id="L214">          errors.add(rightFunction.getError());</span>
        }

<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc" id="L218">          E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L219">          return VALIDATED.widen(Validated.invalid(combinedError));</span>
        }

<span class="fc" id="L222">        C result = rightFunction.get().apply(choice.getRight());</span>
<span class="fc" id="L223">        return VALIDATED.widen(Validated.valid(result));</span>
      }
    } else {
      // Choice is invalid, check both functions to accumulate all errors
<span class="fc bfc" id="L227" title="All 2 branches covered.">      if (leftFunction.isInvalid()) {</span>
<span class="fc" id="L228">        errors.add(leftFunction.getError());</span>
      }
<span class="fc bfc" id="L230" title="All 2 branches covered.">      if (rightFunction.isInvalid()) {</span>
<span class="fc" id="L231">        errors.add(rightFunction.getError());</span>
      }

<span class="fc" id="L234">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L235">      return VALIDATED.widen(Validated.invalid(combinedError));</span>
    }
  }

  /**
   * Conditionally executes a Unit-returning effect based on a boolean condition, with error
   * accumulation.
   *
   * &lt;p&gt;Key improvement: Returns Valid(Unit.INSTANCE) instead of Valid(null), making the &quot;skipped
   * effect&quot; case explicit and type-safe.
   *
   * @param fcond The effectful condition
   * @param fa The Unit-returning effect to execute if condition is true
   * @return Validated with Unit result
   */
  @Override
  public Kind&lt;ValidatedKind.Witness&lt;E&gt;, Unit&gt; whenS(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Boolean&gt; fcond, Kind&lt;ValidatedKind.Witness&lt;E&gt;, Unit&gt; fa) {

<span class="fc" id="L254">    Validation.kind().requireNonNull(fcond, VALIDATED_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L255">    Validation.kind().requireNonNull(fa, VALIDATED_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L257">    Validated&lt;E, Boolean&gt; condValidated = VALIDATED.narrow(fcond);</span>
<span class="fc" id="L258">    Validated&lt;E, Unit&gt; effectValidated = VALIDATED.narrow(fa);</span>

    // Collect errors for accumulation
<span class="fc" id="L261">    List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (condValidated.isInvalid()) {</span>
<span class="fc" id="L264">      errors.add(condValidated.getError());</span>
    }

    // If condition is valid and false, we don't need the effect
    // If condition is valid and true, we need to check the effect
<span class="fc bfc" id="L269" title="All 2 branches covered.">    if (condValidated.isValid()) {</span>
<span class="fc" id="L270">      boolean condition = condValidated.get();</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">      if (!condition) {</span>
        // Condition is false, return Valid(Unit.INSTANCE) (not Valid(null)!)
<span class="fc" id="L274">        return VALIDATED.widen(Validated.valid(Unit.INSTANCE));</span>
      }

      // Condition is true, check effect
<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (effectValidated.isInvalid()) {</span>
<span class="fc" id="L279">        errors.add(effectValidated.getError());</span>
      }
<span class="fc" id="L281">    } else {</span>
      // Condition is invalid, still check effect to accumulate errors
<span class="fc bfc" id="L283" title="All 2 branches covered.">      if (effectValidated.isInvalid()) {</span>
<span class="fc" id="L284">        errors.add(effectValidated.getError());</span>
      }
    }

    // If we have errors, combine and return
<span class="fc bfc" id="L289" title="All 2 branches covered.">    if (!errors.isEmpty()) {</span>
<span class="fc" id="L290">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L291">      return VALIDATED.widen(Validated.invalid(combinedError));</span>
    }

    // Condition is true and effect is valid, return the effect
<span class="fc" id="L295">    return VALIDATED.widen(effectValidated);</span>
  }

  /**
   * Optimised implementation of {@code ifS} for Validated with error accumulation. A ternary
   * conditional operator that accumulates errors from all branches.
   *
   * @param fcond A {@link Kind} representing {@code Validated&lt;E, Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code Validated&lt;E, A&gt;} for the true branch. Must not
   *     be null.
   * @param felse A {@link Kind} representing {@code Validated&lt;E, A&gt;} for the false branch. Must not
   *     be null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code Validated&lt;E, A&gt;}. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; ifS(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, Boolean&gt; fcond,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fthen,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; felse) {

<span class="fc" id="L316">    Validation.kind().requireNonNull(fcond, VALIDATED_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L317">    Validation.kind().requireNonNull(fthen, VALIDATED_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L318">    Validation.kind().requireNonNull(felse, VALIDATED_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L320">    Validated&lt;E, Boolean&gt; condValidated = VALIDATED.narrow(fcond);</span>
<span class="fc" id="L321">    Validated&lt;E, A&gt; thenValidated = VALIDATED.narrow(fthen);</span>
<span class="fc" id="L322">    Validated&lt;E, A&gt; elseValidated = VALIDATED.narrow(felse);</span>

    // Collect errors
<span class="fc" id="L325">    List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (condValidated.isInvalid()) {</span>
<span class="fc" id="L328">      errors.add(condValidated.getError());</span>
    }

    // Determine which branch we need based on the condition
<span class="fc bfc" id="L332" title="All 2 branches covered.">    if (condValidated.isValid()) {</span>
<span class="fc" id="L333">      boolean condition = condValidated.get();</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">      if (condition) {</span>
        // Need then branch
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (thenValidated.isInvalid()) {</span>
<span class="fc" id="L338">          errors.add(thenValidated.getError());</span>
        }

<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc" id="L342">          E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L343">          return VALIDATED.widen(Validated.invalid(combinedError));</span>
        }

<span class="fc" id="L346">        return VALIDATED.widen(thenValidated);</span>
      } else {
        // Need else branch
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (elseValidated.isInvalid()) {</span>
<span class="fc" id="L350">          errors.add(elseValidated.getError());</span>
        }

<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc" id="L354">          E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L355">          return VALIDATED.widen(Validated.invalid(combinedError));</span>
        }

<span class="fc" id="L358">        return VALIDATED.widen(elseValidated);</span>
      }
    } else {
      // Condition is invalid, accumulate errors from both branches
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (thenValidated.isInvalid()) {</span>
<span class="fc" id="L363">        errors.add(thenValidated.getError());</span>
      }
<span class="fc bfc" id="L365" title="All 2 branches covered.">      if (elseValidated.isInvalid()) {</span>
<span class="fc" id="L366">        errors.add(elseValidated.getError());</span>
      }

<span class="fc" id="L369">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L370">      return VALIDATED.widen(Validated.invalid(combinedError));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>