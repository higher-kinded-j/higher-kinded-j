<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValidatedMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.validated</a> &gt; <span class="el_source">ValidatedMonad.java</span></div><h1>ValidatedMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.validated;

import static org.higherkindedj.hkt.util.validation.Operation.*;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.function.Function5;
import org.higherkindedj.hkt.util.validation.*;

/**
 * Monad instance for {@link Validated}. The error type {@code E} is fixed for this Monad instance.
 * Implements {@link MonadError} which transitively includes {@link org.higherkindedj.hkt.Monad
 * Monad} and {@link org.higherkindedj.hkt.Applicative Applicative}.
 *
 * &lt;p&gt;&lt;b&gt;Important Note on Monad Laws:&lt;/b&gt; With this implementation, the {@link #ap(Kind, Kind) ap}
 * method (from the {@code Applicative} superclass) accumulates errors, while {@link
 * #flatMap(Function, Kind) flatMap} will still fail fast on the first {@code Invalid} result. This
 * means that the monad law stating that {@code ap} should be equivalent to a {@code flatMap}
 * implementation (i.e., {@code ap(fab, fa)} should equal {@code fab.flatMap(f -&gt; fa.map(f))}) will
 * not hold. This is a common and accepted trade-off when using {@code Validated} to accumulate
 * errors.
 *
 * @param &lt;E&gt; The type of the error value. For ValidatedMonad, this error type E is expected to be
 *     non-null.
 */
public class ValidatedMonad&lt;E&gt; implements MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt; {

<span class="fc" id="L38">  private Class&lt;ValidatedMonad&gt; VALIDATED_MONAD_CLASS = ValidatedMonad.class;</span>

  private final Semigroup&lt;E&gt; semigroup;

<span class="fc" id="L42">  protected ValidatedMonad(Semigroup&lt;E&gt; semigroup) {</span>
<span class="fc" id="L43">    this.semigroup =</span>
<span class="fc" id="L44">        Validation.coreType().requireValue(semigroup, VALIDATED_MONAD_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L45">  }</span>

  /**
   * Provides an instance of {@code ValidatedMonad} for a given error type {@code E}, which requires
   * a {@link Semigroup} for error accumulation in {@code ap}.
   *
   * @param semigroup The semigroup for combining errors. Must not be null.
   * @param &lt;E&gt; The error type.
   * @return A new instance of {@code ValidatedMonad}.
   * @throws NullPointerException if {@code semigroup} is null.
   */
  public static &lt;E&gt; ValidatedMonad&lt;E&gt; instance(Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L57">    return new ValidatedMonad&lt;&gt;(semigroup);</span>
  }

  @Override
  public &lt;A, B&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; map(
      Function&lt;? super A, ? extends B&gt; f, Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa) {

<span class="fc" id="L64">    Validation.function().requireMapper(f, &quot;f&quot;, VALIDATED_MONAD_CLASS, MAP);</span>
<span class="fc" id="L65">    Validation.kind().requireNonNull(fa, VALIDATED_MONAD_CLASS, MAP);</span>

<span class="fc" id="L67">    Validated&lt;E, A&gt; validated = VALIDATED.narrow(fa);</span>
<span class="fc" id="L68">    Validated&lt;E, B&gt; result = validated.map(f);</span>
<span class="fc" id="L69">    return VALIDATED.widen(result);</span>
  }

  /**
   * Lifts a pure value {@code A} into the {@code Validated} context, creating a {@code
   * Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;} that represents a {@code Valid(value)}. This method is part
   * of the {@link org.higherkindedj.hkt.Applicative Applicative} interface.
   *
   * @param value The value to lift. Must not be null.
   * @param &lt;A&gt; The type of the value.
   * @return A {@code Kind} instance representing {@code Validated.valid(value)}.
   * @throws NullPointerException if value is null.
   */
  @Override
  public &lt;A&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; of(A value) {
    // Valid requires non-null value, so validate here
<span class="fc" id="L85">    Validation.coreType().requireValue(value, VALIDATED_MONAD_CLASS, OF);</span>

<span class="fc" id="L87">    Validated&lt;E, A&gt; validInstance = Validated.valid(value);</span>
<span class="fc" id="L88">    return VALIDATED.widen(validInstance);</span>
  }

  @Override
  public &lt;A, B&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; ap(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, ? extends Function&lt;A, B&gt;&gt; ff,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa) {

<span class="fc" id="L96">    Validation.kind().validateAp(ff, fa, VALIDATED_MONAD_CLASS);</span>

<span class="fc" id="L98">    Validated&lt;E, ? extends Function&lt;A, B&gt;&gt; fnValidated = VALIDATED.narrow(ff);</span>
<span class="fc" id="L99">    Validated&lt;E, A&gt; valueValidated = VALIDATED.narrow(fa);</span>

    // Ensure the function type matches what Validated.ap expects
<span class="fc" id="L102">    Validated&lt;E, Function&lt;? super A, ? extends B&gt;&gt; fnValidatedWithWildcards =</span>
<span class="fc" id="L103">        fnValidated.map(f -&gt; (Function&lt;? super A, ? extends B&gt;) f);</span>

<span class="fc" id="L105">    Validated&lt;E, B&gt; result = valueValidated.ap(fnValidatedWithWildcards, semigroup);</span>
<span class="fc" id="L106">    return VALIDATED.widen(result);</span>
  }

  /**
   * Applies a function that returns a {@code Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt;} to the value
   * contained in a {@code Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;}, effectively chaining operations.
   *
   * @param f The function to apply. Must not be null and must not return a null {@code Kind}.
   * @param ma The {@code Kind} instance containing the value to transform. Must not be null.
   * @param &lt;A&gt; The type of the value in the input {@code Kind}.
   * @param &lt;B&gt; The type of the value in the output {@code Kind}.
   * @return A {@code Kind} instance representing the result of the flatMap operation.
   * @throws NullPointerException if {@code f} is null, {@code ma} is null, or {@code f} returns a
   *     null {@code Kind}.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} cannot be unwrapped
   *     to a valid {@code Validated} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; flatMap(
      Function&lt;? super A, ? extends Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt;&gt; f,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; ma) {

<span class="fc" id="L128">    Validation.function().validateFlatMap(f, ma, VALIDATED_MONAD_CLASS);</span>

<span class="fc" id="L130">    Validated&lt;E, A&gt; validatedValue = VALIDATED.narrow(ma);</span>
<span class="fc" id="L131">    Validated&lt;E, B&gt; result =</span>
<span class="fc" id="L132">        validatedValue.flatMap(</span>
            a -&gt; {
<span class="fc" id="L134">              Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; kindResult = f.apply(a);</span>
<span class="fc" id="L135">              Validation.function()</span>
<span class="fc" id="L136">                  .requireNonNullResult(</span>
                      kindResult, &quot;f&quot;, VALIDATED_MONAD_CLASS, FLAT_MAP, Validated.class);
<span class="fc" id="L138">              return VALIDATED.narrow(kindResult);</span>
            });
<span class="fc" id="L140">    return VALIDATED.widen(result);</span>
  }

  // --- MonadError Implementation ---

  /**
   * Lifts an error value {@code error} into the Validated context, creating an {@code
   * Invalid(error)}. For {@code Validated}, the error {@code E} must be non-null.
   *
   * @param error The non-null error value to lift.
   * @param &lt;A&gt; The phantom type parameter of the value (since this represents an error state).
   * @return The error wrapped as {@code Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;}.
   * @throws NullPointerException if error is null.
   */
  @Override
  public &lt;A&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; raiseError(E error) {
    // Validated.invalid already validates non-null, but be explicit
<span class="fc" id="L157">    Validation.coreType().requireError(error, VALIDATED_MONAD_CLASS, RAISE_ERROR);</span>
<span class="fc" id="L158">    return VALIDATED.invalid(error);</span>
  }

  /**
   * Handles an error within the Validated context. If {@code ma} represents a {@code Valid} value,
   * it's returned unchanged. If {@code ma} represents an {@code Invalid(e)}, the {@code handler}
   * function is applied to {@code e} to potentially recover with a new monadic value.
   *
   * @param ma The monadic value ({@code Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;}) potentially containing
   *     an error. Must not be null.
   * @param handler A function that takes an error {@code e} of type {@code E} and returns a new
   *     monadic value ({@code Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;}). Must not be null, and must not
   *     return null.
   * @param &lt;A&gt; The type of the value within the monad.
   * @return The original monadic value if it was {@code Valid}, or the result of the {@code
   *     handler} if it was {@code Invalid}. Guaranteed non-null.
   * @throws NullPointerException if ma, handler, or the result of the handler is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} cannot be unwrapped
   *     to a valid {@code Validated} representation.
   */
  @Override
  public &lt;A&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; handleErrorWith(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; ma,
      Function&lt;? super E, ? extends Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;&gt; handler) {

<span class="fc" id="L183">    Validation.function().validateHandleErrorWith(ma, handler, VALIDATED_MONAD_CLASS);</span>

<span class="fc" id="L185">    Validated&lt;E, A&gt; validated = VALIDATED.narrow(ma);</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (validated.isInvalid()) {</span>
<span class="fc" id="L188">      E errorValue = validated.getError();</span>
<span class="fc" id="L189">      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; resultFromHandler = handler.apply(errorValue);</span>
<span class="fc" id="L190">      Validation.function()</span>
<span class="fc" id="L191">          .requireNonNullResult(</span>
              resultFromHandler, &quot;handler&quot;, VALIDATED_MONAD_CLASS, HANDLE_ERROR_WITH, Kind.class);
<span class="fc" id="L193">      return resultFromHandler;</span>
    } else {
<span class="fc" id="L195">      return ma;</span>
    }
  }

  @Override
  public &lt;A, B, C&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, C&gt; map2(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; fb,
      BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {

<span class="fc" id="L205">    Validation.kind().requireNonNull(fa, ValidatedMonad.class, MAP_2, &quot;first&quot;);</span>
<span class="fc" id="L206">    Validation.kind().requireNonNull(fb, ValidatedMonad.class, MAP_2, &quot;second&quot;);</span>
<span class="fc" id="L207">    Validation.function().requireFunction(f, &quot;combining function&quot;, ValidatedMonad.class, MAP_2);</span>

<span class="fc" id="L209">    Validated&lt;E, A&gt; va = VALIDATED.narrow(fa);</span>
<span class="fc" id="L210">    Validated&lt;E, B&gt; vb = VALIDATED.narrow(fb);</span>

    // Collect all errors if any exist
<span class="fc bfc" id="L213" title="All 4 branches covered.">    if (va.isInvalid() || vb.isInvalid()) {</span>
<span class="fc" id="L214">      List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">      if (va.isInvalid()) errors.add(va.getError());</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (vb.isInvalid()) errors.add(vb.getError());</span>

      // Combine all errors using the semigroup
<span class="fc" id="L219">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L220">      return VALIDATED.invalid(combinedError);</span>
    }

    // Both valid - apply the function
<span class="fc" id="L224">    C result = f.apply(va.get(), vb.get());</span>
<span class="fc" id="L225">    Validation.function()</span>
<span class="fc" id="L226">        .requireNonNullResult(result, &quot;combining function&quot;, ValidatedMonad.class, MAP_2);</span>
<span class="fc" id="L227">    return VALIDATED.valid(result);</span>
  }

  @Override
  public &lt;A, B, C, D&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, D&gt; map3(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; fb,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, C&gt; fc,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; f) {

<span class="fc" id="L237">    Validation.kind().requireNonNull(fa, ValidatedMonad.class, MAP_3, &quot;first&quot;);</span>
<span class="fc" id="L238">    Validation.kind().requireNonNull(fb, ValidatedMonad.class, MAP_3, &quot;second&quot;);</span>
<span class="fc" id="L239">    Validation.kind().requireNonNull(fc, ValidatedMonad.class, MAP_3, &quot;third&quot;);</span>
<span class="fc" id="L240">    Validation.function().requireFunction(f, &quot;f&quot;, ValidatedMonad.class, MAP_3);</span>

<span class="fc" id="L242">    Validated&lt;E, A&gt; va = VALIDATED.narrow(fa);</span>
<span class="fc" id="L243">    Validated&lt;E, B&gt; vb = VALIDATED.narrow(fb);</span>
<span class="fc" id="L244">    Validated&lt;E, C&gt; vc = VALIDATED.narrow(fc);</span>

    // Collect all errors if any exist
<span class="fc bfc" id="L247" title="All 6 branches covered.">    if (va.isInvalid() || vb.isInvalid() || vc.isInvalid()) {</span>
<span class="fc" id="L248">      List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">      if (va.isInvalid()) errors.add(va.getError());</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">      if (vb.isInvalid()) errors.add(vb.getError());</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">      if (vc.isInvalid()) errors.add(vc.getError());</span>

      // Combine all errors using the semigroup
<span class="fc" id="L254">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L255">      return VALIDATED.invalid(combinedError);</span>
    }

    // All valid - apply the function
<span class="fc" id="L259">    D result = f.apply(va.get(), vb.get(), vc.get());</span>
<span class="fc" id="L260">    Validation.function().requireNonNullResult(result, &quot;f&quot;, ValidatedMonad.class, MAP_3);</span>
<span class="fc" id="L261">    return VALIDATED.valid(result);</span>
  }

  @Override
  public &lt;A, B, C, D, R&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, R&gt; map4(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; fb,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, C&gt; fc,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, D&gt; fd,
      Function4&lt;? super A, ? super B, ? super C, ? super D, ? extends R&gt; f) {

<span class="fc" id="L272">    Validation.kind().requireNonNull(fa, ValidatedMonad.class, MAP_4, &quot;first&quot;);</span>
<span class="fc" id="L273">    Validation.kind().requireNonNull(fb, ValidatedMonad.class, MAP_4, &quot;second&quot;);</span>
<span class="fc" id="L274">    Validation.kind().requireNonNull(fc, ValidatedMonad.class, MAP_4, &quot;third&quot;);</span>
<span class="fc" id="L275">    Validation.kind().requireNonNull(fd, ValidatedMonad.class, MAP_4, &quot;fourth&quot;);</span>
<span class="fc" id="L276">    Validation.function().requireFunction(f, &quot;f&quot;, ValidatedMonad.class, MAP_4);</span>

<span class="fc" id="L278">    Validated&lt;E, A&gt; va = VALIDATED.narrow(fa);</span>
<span class="fc" id="L279">    Validated&lt;E, B&gt; vb = VALIDATED.narrow(fb);</span>
<span class="fc" id="L280">    Validated&lt;E, C&gt; vc = VALIDATED.narrow(fc);</span>
<span class="fc" id="L281">    Validated&lt;E, D&gt; vd = VALIDATED.narrow(fd);</span>

    // Collect all errors if any exist
<span class="fc bfc" id="L284" title="All 8 branches covered.">    if (va.isInvalid() || vb.isInvalid() || vc.isInvalid() || vd.isInvalid()) {</span>
<span class="fc" id="L285">      List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">      if (va.isInvalid()) errors.add(va.getError());</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">      if (vb.isInvalid()) errors.add(vb.getError());</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">      if (vc.isInvalid()) errors.add(vc.getError());</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">      if (vd.isInvalid()) errors.add(vd.getError());</span>

      // Combine all errors using the semigroup
<span class="fc" id="L292">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L293">      return VALIDATED.invalid(combinedError);</span>
    }

    // All valid - apply the function
<span class="fc" id="L297">    R result = f.apply(va.get(), vb.get(), vc.get(), vd.get());</span>
<span class="fc" id="L298">    Validation.function().requireNonNullResult(result, &quot;f&quot;, ValidatedMonad.class, MAP_4);</span>
<span class="fc" id="L299">    return VALIDATED.valid(result);</span>
  }

  @Override
  public &lt;A, B, C, D, E1, R&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, R&gt; map5(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fa,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt; fb,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, C&gt; fc,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, D&gt; fd,
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, E1&gt; fe,
      Function5&lt;? super A, ? super B, ? super C, ? super D, ? super E1, ? extends R&gt; f) {

<span class="fc" id="L311">    Validation.kind().requireNonNull(fa, ValidatedMonad.class, MAP_5, &quot;first&quot;);</span>
<span class="fc" id="L312">    Validation.kind().requireNonNull(fb, ValidatedMonad.class, MAP_5, &quot;second&quot;);</span>
<span class="fc" id="L313">    Validation.kind().requireNonNull(fc, ValidatedMonad.class, MAP_5, &quot;third&quot;);</span>
<span class="fc" id="L314">    Validation.kind().requireNonNull(fd, ValidatedMonad.class, MAP_5, &quot;fourth&quot;);</span>
<span class="fc" id="L315">    Validation.kind().requireNonNull(fe, ValidatedMonad.class, MAP_5, &quot;fifth&quot;);</span>
<span class="fc" id="L316">    Validation.function().requireFunction(f, &quot;f&quot;, ValidatedMonad.class, MAP_5);</span>

<span class="fc" id="L318">    Validated&lt;E, A&gt; va = VALIDATED.narrow(fa);</span>
<span class="fc" id="L319">    Validated&lt;E, B&gt; vb = VALIDATED.narrow(fb);</span>
<span class="fc" id="L320">    Validated&lt;E, C&gt; vc = VALIDATED.narrow(fc);</span>
<span class="fc" id="L321">    Validated&lt;E, D&gt; vd = VALIDATED.narrow(fd);</span>
<span class="fc" id="L322">    Validated&lt;E, E1&gt; ve = VALIDATED.narrow(fe);</span>

    // Collect all errors if any exist
<span class="fc bfc" id="L325" title="All 10 branches covered.">    if (va.isInvalid() || vb.isInvalid() || vc.isInvalid() || vd.isInvalid() || ve.isInvalid()) {</span>
<span class="fc" id="L326">      List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (va.isInvalid()) errors.add(va.getError());</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">      if (vb.isInvalid()) errors.add(vb.getError());</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      if (vc.isInvalid()) errors.add(vc.getError());</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">      if (vd.isInvalid()) errors.add(vd.getError());</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">      if (ve.isInvalid()) errors.add(ve.getError());</span>

      // Combine all errors using the semigroup
<span class="fc" id="L334">      E combinedError = errors.stream().reduce(semigroup::combine).orElseThrow();</span>
<span class="fc" id="L335">      return VALIDATED.invalid(combinedError);</span>
    }

    // All valid - apply the function
<span class="fc" id="L339">    R result = f.apply(va.get(), vb.get(), vc.get(), vd.get(), ve.get());</span>
<span class="fc" id="L340">    Validation.function().requireNonNullResult(result, &quot;f&quot;, ValidatedMonad.class, MAP_5);</span>
<span class="fc" id="L341">    return VALIDATED.valid(result);</span>
  }

  @Override
  public &lt;A&gt; Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; recoverWith(
      Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; ma, Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt; fallback) {

<span class="fc" id="L348">    Validation.kind().requireNonNull(ma, ValidatedMonad.class, RECOVER_WITH, &quot;source&quot;);</span>
<span class="fc" id="L349">    Validation.kind().requireNonNull(fallback, ValidatedMonad.class, RECOVER_WITH, &quot;fallback&quot;);</span>

<span class="fc" id="L351">    return handleErrorWith(ma, e -&gt; fallback);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>