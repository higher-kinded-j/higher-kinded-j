<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FreeAp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.free_ap</a> &gt; <span class="el_source">FreeAp.java</span></div><h1>FreeAp.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.free_ap;

import static java.util.Objects.requireNonNull;

import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Natural;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;

/**
 * Free Applicative functor for independent/parallel composition.
 *
 * &lt;p&gt;FreeAp is the &quot;free applicative&quot; - it captures applicative structure (independent
 * computations) without requiring the underlying type F to have any instances. Unlike the Free
 * monad which captures sequential, dependent computations, FreeAp captures computations that are
 * independent and can potentially be executed in parallel.
 *
 * &lt;h2&gt;Core Concept&lt;/h2&gt;
 *
 * &lt;p&gt;FreeAp has three constructors:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Pure(a)} - A completed computation with value a
 *   &lt;li&gt;{@code Lift(fa)} - A suspended single operation in F
 *   &lt;li&gt;{@code Ap(ff, fa)} - Application of a wrapped function to a wrapped value (independent
 *       computations)
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The key insight is that in {@code Ap(ff, fa)}, both {@code ff} and {@code fa} are
 * &lt;em&gt;independent&lt;/em&gt; - neither depends on the other's result. This is in contrast to Free monad's
 * FlatMapped where the continuation depends on the previous result.
 *
 * &lt;h2&gt;Key Benefits&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Parallel execution:&lt;/b&gt; Interpreters can safely parallelize independent computations
 *   &lt;li&gt;&lt;b&gt;Static analysis:&lt;/b&gt; The structure can be analyzed before interpretation
 *   &lt;li&gt;&lt;b&gt;Batching:&lt;/b&gt; Similar operations can be batched (e.g., multiple DB queries)
 *   &lt;li&gt;&lt;b&gt;Optimization:&lt;/b&gt; Independent computations can be reordered for efficiency
 *   &lt;li&gt;&lt;b&gt;Validation:&lt;/b&gt; Collect all errors rather than failing on first (with Validated)
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Free Monad vs Free Applicative&lt;/h2&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;tr&gt;&lt;th&gt;Free Monad&lt;/th&gt;&lt;th&gt;FreeAp&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Sequential/dependent&lt;/td&gt;&lt;td&gt;Independent/parallel&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;flatMap: A → Free[F, B]&lt;/td&gt;&lt;td&gt;ap: FreeAp[F, A→B] × FreeAp[F, A]&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Next step depends on previous result&lt;/td&gt;&lt;td&gt;Steps are independent&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Cannot analyze structure ahead of time&lt;/td&gt;&lt;td&gt;Full structure visible before interpretation&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Define independent operations
 * sealed interface UserOp&lt;A&gt; { ... }
 * record GetUser(int id) implements UserOp&lt;User&gt; {}
 * record GetPosts(int userId) implements UserOp&lt;List&lt;Post&gt;&gt; {}
 *
 * // Build a FreeAp program with independent fetches
 * FreeAp&lt;UserOp.Witness, User&gt; userFetch = FreeAp.lift(getUser(1));
 * FreeAp&lt;UserOp.Witness, List&lt;Post&gt;&gt; postsFetch = FreeAp.lift(getPosts(1));
 *
 * // Combine them - these are INDEPENDENT and can be parallelized
 * FreeAp&lt;UserOp.Witness, UserProfile&gt; profile = userFetch.map2(
 *     postsFetch,
 *     (user, posts) -&gt; new UserProfile(user, posts)
 * );
 *
 * // Interpret - smart interpreter can execute both fetches in parallel
 * UserProfile result = profile.foldMap(interpreter, ioApplicative);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Applicative Laws&lt;/h2&gt;
 *
 * &lt;p&gt;FreeAp satisfies the Applicative laws by construction:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Identity:&lt;/b&gt; {@code pure(id).ap(fa) ≡ fa}
 *   &lt;li&gt;&lt;b&gt;Homomorphism:&lt;/b&gt; {@code pure(f).ap(pure(x)) ≡ pure(f(x))}
 *   &lt;li&gt;&lt;b&gt;Interchange:&lt;/b&gt; {@code ff.ap(pure(x)) ≡ pure(f -&gt; f(x)).ap(ff)}
 *   &lt;li&gt;&lt;b&gt;Composition:&lt;/b&gt; {@code pure(.).ap(ff).ap(fg).ap(fa) ≡ ff.ap(fg.ap(fa))}
 * &lt;/ul&gt;
 *
 * @param &lt;F&gt; The type constructor representing the instruction set (witness type)
 * @param &lt;A&gt; The result type
 * @see FreeApApplicative
 * @see org.higherkindedj.hkt.Applicative
 * @see org.higherkindedj.hkt.free.Free
 */
public sealed interface FreeAp&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
    permits FreeAp.Pure, FreeAp.Lift, FreeAp.Ap {

  /**
   * Terminal case representing a pure value.
   *
   * &lt;p&gt;A computation that immediately produces a value without any effects.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   */
<span class="fc" id="L108">  record Pure&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;(A value) implements FreeAp&lt;F, A&gt; {}</span>

  /**
   * Suspended computation lifting a single instruction in F.
   *
   * &lt;p&gt;Represents a single operation in the instruction set F that will produce a value of type A.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   */
  record Lift&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;(Kind&lt;F, A&gt; fa) implements FreeAp&lt;F, A&gt; {
<span class="fc" id="L119">    public Lift {</span>
<span class="fc" id="L120">      requireNonNull(fa, &quot;Lifted Kind cannot be null&quot;);</span>
<span class="fc" id="L121">    }</span>
  }

  /**
   * Application of a wrapped function to a wrapped value.
   *
   * &lt;p&gt;This represents two &lt;em&gt;independent&lt;/em&gt; computations: one producing a function, one
   * producing a value. Neither depends on the other's result, enabling parallel execution.
   *
   * &lt;p&gt;Note: The type parameter X is existentially quantified (hidden from external users).
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;X&gt; The intermediate type (existential)
   * @param &lt;A&gt; The final result type
   */
  record Ap&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, X, A&gt;(
      FreeAp&lt;F, Function&lt;X, A&gt;&gt; ff, FreeAp&lt;F, X&gt; fa) implements FreeAp&lt;F, A&gt; {
<span class="fc" id="L138">    public Ap {</span>
<span class="fc" id="L139">      requireNonNull(ff, &quot;Function FreeAp cannot be null&quot;);</span>
<span class="fc" id="L140">      requireNonNull(fa, &quot;Value FreeAp cannot be null&quot;);</span>
<span class="fc" id="L141">    }</span>
  }

  /**
   * Creates a FreeAp from a pure value.
   *
   * @param value The value to lift
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   * @return A FreeAp containing the pure value
   */
  static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FreeAp&lt;F, A&gt; pure(A value) {
<span class="fc" id="L153">    return new Pure&lt;&gt;(value);</span>
  }

  /**
   * Lifts a single instruction in F into FreeAp.
   *
   * @param fa The instruction to lift. Must not be null.
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   * @return A FreeAp containing the lifted instruction
   * @throws NullPointerException if fa is null
   */
  static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FreeAp&lt;F, A&gt; lift(Kind&lt;F, A&gt; fa) {
<span class="fc" id="L166">    requireNonNull(fa, &quot;Kind to lift cannot be null&quot;);</span>
<span class="fc" id="L167">    return new Lift&lt;&gt;(fa);</span>
  }

  /**
   * Maps a function over the result of this FreeAp.
   *
   * @param f The function to apply. Must not be null.
   * @param &lt;B&gt; The result type
   * @return A new FreeAp with the function applied
   * @throws NullPointerException if f is null
   */
  default &lt;B&gt; FreeAp&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L179">    requireNonNull(f, &quot;Map function cannot be null&quot;);</span>
<span class="fc" id="L180">    return ap(pure(f));</span>
  }

  /**
   * Applies a FreeAp containing a function to this FreeAp.
   *
   * &lt;p&gt;This is the core applicative operation. The function and this value are &lt;em&gt;independent&lt;/em&gt;
   * computations - neither depends on the other's result.
   *
   * @param ff The FreeAp containing the function. Must not be null.
   * @param &lt;B&gt; The result type
   * @return A new FreeAp representing the application
   * @throws NullPointerException if ff is null
   */
  default &lt;B&gt; FreeAp&lt;F, B&gt; ap(FreeAp&lt;F, ? extends Function&lt;? super A, ? extends B&gt;&gt; ff) {
<span class="fc" id="L195">    requireNonNull(ff, &quot;Function FreeAp cannot be null&quot;);</span>
    // Need to handle the variance carefully
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L198">    FreeAp&lt;F, Function&lt;A, B&gt;&gt; safeFF = (FreeAp&lt;F, Function&lt;A, B&gt;&gt;) (FreeAp&lt;F, ?&gt;) ff;</span>
<span class="fc" id="L199">    return new Ap&lt;&gt;(safeFF, this);</span>
  }

  /**
   * Combines this FreeAp with another using a combining function.
   *
   * &lt;p&gt;Both computations are independent and can be executed in parallel.
   *
   * @param fb The other FreeAp. Must not be null.
   * @param combine The function to combine results. Must not be null.
   * @param &lt;B&gt; The type of the other value
   * @param &lt;C&gt; The result type
   * @return A new FreeAp combining both values
   * @throws NullPointerException if fb or combine is null
   */
  default &lt;B, C&gt; FreeAp&lt;F, C&gt; map2(
      FreeAp&lt;F, B&gt; fb, BiFunction&lt;? super A, ? super B, ? extends C&gt; combine) {
<span class="fc" id="L216">    requireNonNull(fb, &quot;Second FreeAp cannot be null&quot;);</span>
<span class="fc" id="L217">    requireNonNull(combine, &quot;Combine function cannot be null&quot;);</span>
<span class="fc" id="L218">    return fb.ap(this.map(a -&gt; b -&gt; combine.apply(a, b)));</span>
  }

  /**
   * Interprets this FreeAp into a target applicative G using a natural transformation.
   *
   * &lt;p&gt;The natural transformation converts each instruction in F to the target applicative G. The
   * Applicative instance for G is used to combine the results.
   *
   * &lt;h2&gt;Parallel Execution&lt;/h2&gt;
   *
   * &lt;p&gt;If the target Applicative supports parallel execution (like a parallel IO or
   * CompletableFuture), the independent computations in FreeAp can be executed in parallel.
   *
   * &lt;h2&gt;Example&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Define interpreter
   * Natural&lt;MyOp.Witness, IO.Witness&gt; interpreter = ...;
   *
   * // Interpret the FreeAp program
   * FreeAp&lt;MyOp.Witness, Result&gt; program = ...;
   * Kind&lt;IO.Witness, Result&gt; ioResult = program.foldMap(interpreter, ioApplicative);
   * }&lt;/pre&gt;
   *
   * @param transform The natural transformation from F to G. Must not be null.
   * @param applicative The Applicative instance for G. Must not be null.
   * @param &lt;G&gt; The target applicative type
   * @return The interpreted result in G
   * @throws NullPointerException if transform or applicative is null
   */
  default &lt;G extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;G, A&gt; foldMap(
      Natural&lt;F, G&gt; transform, Applicative&lt;G&gt; applicative) {
<span class="fc" id="L251">    requireNonNull(transform, &quot;Natural transformation cannot be null&quot;);</span>
<span class="fc" id="L252">    requireNonNull(applicative, &quot;Applicative cannot be null&quot;);</span>
<span class="fc" id="L253">    return interpretFreeAp(this, transform, applicative);</span>
  }

  /**
   * Analyses the structure of this FreeAp, returning information in the applicative G.
   *
   * &lt;p&gt;This is similar to {@link #foldMap} but is specifically named to emphasise that the
   * structure can be analysed before any actual execution happens.
   *
   * @param transform The natural transformation from F to G. Must not be null.
   * @param applicative The Applicative instance for G. Must not be null.
   * @param &lt;G&gt; The target applicative type
   * @return The analysis result in G
   * @throws NullPointerException if transform or applicative is null
   */
  default &lt;G extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;G, A&gt; analyse(
      Natural&lt;F, G&gt; transform, Applicative&lt;G&gt; applicative) {
<span class="fc" id="L270">    return foldMap(transform, applicative);</span>
  }

  /**
   * Internal helper that interprets a FreeAp using the given natural transformation and
   * applicative.
   *
   * @param freeAp The FreeAp to interpret
   * @param transform The natural transformation from F to G
   * @param applicative The Applicative instance for G
   * @param &lt;F&gt; The source functor type
   * @param &lt;G&gt; The target applicative type
   * @param &lt;A&gt; The result type
   * @return The interpreted result in G
   */
  private static &lt;
          F extends WitnessArity&lt;TypeArity.Unary&gt;, G extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
      Kind&lt;G, A&gt; interpretFreeAp(
          FreeAp&lt;F, A&gt; freeAp, Natural&lt;F, G&gt; transform, Applicative&lt;G&gt; applicative) {

<span class="fc bfc" id="L290" title="All 3 branches covered.">    return switch (freeAp) {</span>
<span class="fc" id="L291">      case Pure&lt;F, A&gt; pure -&gt;</span>
          // Pure values are lifted into the applicative
<span class="fc" id="L293">          applicative.of(pure.value());</span>

<span class="fc" id="L295">      case Lift&lt;F, A&gt; lift -&gt;</span>
          // Lifted instructions are transformed
<span class="fc" id="L297">          transform.apply(lift.fa());</span>

<span class="fc" id="L299">      case Ap&lt;F, ?, A&gt; ap -&gt; {</span>
        // Handle the Ap case by recursively interpreting both branches
        // Both branches are INDEPENDENT - this is where parallelism can happen
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L303">        Ap&lt;F, Object, A&gt; typed = (Ap&lt;F, Object, A&gt;) ap;</span>

<span class="fc" id="L305">        Kind&lt;G, Function&lt;Object, A&gt;&gt; gf = interpretFreeAp(typed.ff(), transform, applicative);</span>
<span class="fc" id="L306">        Kind&lt;G, Object&gt; ga = interpretFreeAp(typed.fa(), transform, applicative);</span>

<span class="fc" id="L308">        yield applicative.ap(gf, ga);</span>
      }
    };
  }

  /**
   * Retract this FreeAp back to F when F is an Applicative.
   *
   * &lt;p&gt;This is the inverse of lift when F has an Applicative instance. It's equivalent to:
   *
   * &lt;pre&gt;{@code
   * freeAp.foldMap(Natural.identity(), applicative)
   * }&lt;/pre&gt;
   *
   * @param applicative The Applicative instance for F. Must not be null.
   * @return The computation in F
   * @throws NullPointerException if applicative is null
   */
  default Kind&lt;F, A&gt; retract(Applicative&lt;F&gt; applicative) {
<span class="fc" id="L327">    requireNonNull(applicative, &quot;Applicative cannot be null&quot;);</span>
<span class="fc" id="L328">    return foldMap(Natural.identity(), applicative);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>