<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SelectiveAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.free_ap</a> &gt; <span class="el_source">SelectiveAnalyzer.java</span></div><h1>SelectiveAnalyzer.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.free_ap;

import static java.util.Objects.requireNonNull;

import java.util.HashSet;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Monoids;
import org.higherkindedj.hkt.Natural;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.constant.Const;
import org.higherkindedj.hkt.constant.ConstApplicative;
import org.higherkindedj.hkt.constant.ConstKind;
import org.higherkindedj.hkt.constant.ConstKindHelper;
import org.jspecify.annotations.NullMarked;

/**
 * Static analysis utilities for programs with selective semantics.
 *
 * &lt;p&gt;This class provides methods to analyse programs that use conditional effects, determining
 * bounds on what effects might or will execute. The analysis is based on the concept of &quot;Under&quot; and
 * &quot;Over&quot; approximations from the Selective Applicative Functors paper.
 *
 * &lt;h2&gt;Under and Over Semantics&lt;/h2&gt;
 *
 * &lt;p&gt;When analysing conditional programs, we can compute two bounds:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Under (minimum effects)&lt;/b&gt;: Effects that will definitely execute regardless of runtime
 *       conditions. This is a conservative lower bound.
 *   &lt;li&gt;&lt;b&gt;Over (maximum effects)&lt;/b&gt;: Effects that might possibly execute if the right conditions
 *       occur. This explores all branches and is an upper bound.
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Integration with FreeAp&lt;/h2&gt;
 *
 * &lt;p&gt;For practical static analysis, programs should be expressed using {@link FreeAp} (Free
 * Applicative). While Selective adds conditional branching on top of Applicative, the static
 * structure remains visible when using FreeAp as the underlying representation.
 *
 * &lt;p&gt;This class provides utilities that work with FreeAp programs interpreted with selective-like
 * semantics, as well as general utilities for understanding effect bounds.
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Build a program with conditional effects
 * FreeAp&lt;Op.Witness, Result&gt; program = ...;
 *
 * // Collect all possible effects (Over semantics)
 * Set&lt;Op&lt;?&gt;&gt; possibleEffects = SelectiveAnalyzer.collectPossibleEffects(
 *     program,
 *     OpHelper::narrow
 * );
 *
 * // Report to user
 * System.out.println(&quot;This program might execute: &quot; + possibleEffects);
 * }&lt;/pre&gt;
 *
 * @see FreeApAnalyzer
 * @see org.higherkindedj.hkt.Selective
 */
@NullMarked
public interface SelectiveAnalyzer {

  /**
   * Collects all possible effects from a FreeAp program (Over semantics).
   *
   * &lt;p&gt;This method returns all effects that might possibly execute, treating conditional branches
   * as if both sides could run. This is useful for:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Permission checking (ensuring all possible operations are authorised)
   *   &lt;li&gt;Resource estimation (maximum possible resource usage)
   *   &lt;li&gt;Audit trails (what could this program do?)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;For FreeAp programs, this is equivalent to {@link FreeApAnalyzer#collectOperations} since
   * FreeAp captures all independent operations. The difference becomes meaningful when programs
   * include conditional logic.
   *
   * @param program The FreeAp program to analyse. Must not be null.
   * @param narrow A function to narrow Kind to the concrete operation type. Must not be null.
   * @param &lt;F&gt; The type constructor of the instruction set
   * @param &lt;A&gt; The result type of the program
   * @param &lt;Op&gt; The base type of operations
   * @return A set of all operations that might execute
   * @throws NullPointerException if any argument is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A, Op&gt; Set&lt;Op&gt; collectPossibleEffects(
      FreeAp&lt;F, A&gt; program, Function&lt;Kind&lt;F, ?&gt;, Op&gt; narrow) {
<span class="fc" id="L98">    requireNonNull(program, &quot;Program cannot be null&quot;);</span>
<span class="fc" id="L99">    requireNonNull(narrow, &quot;Narrow function cannot be null&quot;);</span>

<span class="fc" id="L101">    Monoid&lt;Set&lt;Op&gt;&gt; setMonoid = Monoids.set();</span>
    // Use anonymous class because Natural.apply is a generic method
<span class="fc" id="L103">    Natural&lt;F, ConstKind.Witness&lt;Set&lt;Op&gt;&gt;&gt; toSet =</span>
<span class="fc" id="L104">        new Natural&lt;&gt;() {</span>
          @Override
          public &lt;B&gt; Kind&lt;ConstKind.Witness&lt;Set&lt;Op&gt;&gt;, B&gt; apply(Kind&lt;F, B&gt; fa) {
<span class="fc" id="L107">            Op op = narrow.apply(fa);</span>
<span class="fc" id="L108">            Set&lt;Op&gt; singleton = new HashSet&lt;&gt;();</span>
<span class="fc" id="L109">            singleton.add(op);</span>
<span class="fc" id="L110">            return ConstKindHelper.CONST.widen(new Const&lt;&gt;(singleton));</span>
          }
        };

<span class="fc" id="L114">    ConstApplicative&lt;Set&lt;Op&gt;&gt; constApplicative = new ConstApplicative&lt;&gt;(setMonoid);</span>
<span class="fc" id="L115">    Kind&lt;ConstKind.Witness&lt;Set&lt;Op&gt;&gt;, A&gt; result = program.analyse(toSet, constApplicative);</span>
<span class="fc" id="L116">    return ConstKindHelper.CONST.narrow(result).value();</span>
  }

  /**
   * Counts the maximum possible operations in a program (Over semantics).
   *
   * &lt;p&gt;Returns the total count of operations assuming all branches execute. This provides an upper
   * bound on execution count.
   *
   * @param program The FreeAp program to analyse. Must not be null.
   * @param &lt;F&gt; The type constructor of the instruction set
   * @param &lt;A&gt; The result type of the program
   * @return The maximum number of operations that might execute
   * @throws NullPointerException if program is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; int countMaximumEffects(
      FreeAp&lt;F, A&gt; program) {
<span class="fc" id="L133">    requireNonNull(program, &quot;Program cannot be null&quot;);</span>
<span class="fc" id="L134">    return FreeApAnalyzer.countOperations(program);</span>
  }

  /**
   * Computes effect bounds for a FreeAp program.
   *
   * &lt;p&gt;Returns both the minimum (Under) and maximum (Over) effect counts. For pure FreeAp programs
   * without conditional logic, these will be equal. The difference becomes meaningful when the
   * program includes selective branching.
   *
   * @param program The FreeAp program to analyse. Must not be null.
   * @param &lt;F&gt; The type constructor of the instruction set
   * @param &lt;A&gt; The result type of the program
   * @return An {@link EffectBounds} record containing min and max effect counts
   * @throws NullPointerException if program is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; EffectBounds computeEffectBounds(
      FreeAp&lt;F, A&gt; program) {
<span class="fc" id="L152">    requireNonNull(program, &quot;Program cannot be null&quot;);</span>

    // For pure FreeAp (no conditional logic), min == max
<span class="fc" id="L155">    int count = FreeApAnalyzer.countOperations(program);</span>
<span class="fc" id="L156">    return new EffectBounds(count, count);</span>
  }

  /**
   * Partitions effects into guaranteed and conditional categories.
   *
   * &lt;p&gt;This method analyses a FreeAp program and categorises operations based on whether they will
   * definitely execute or only conditionally execute. For pure FreeAp programs, all operations are
   * guaranteed.
   *
   * @param program The FreeAp program to analyse. Must not be null.
   * @param narrow A function to narrow Kind to the concrete operation type. Must not be null.
   * @param &lt;F&gt; The type constructor of the instruction set
   * @param &lt;A&gt; The result type of the program
   * @param &lt;Op&gt; The base type of operations
   * @return An {@link EffectPartition} containing guaranteed and conditional effect sets
   * @throws NullPointerException if any argument is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A, Op&gt;
      EffectPartition&lt;Op&gt; partitionEffects(FreeAp&lt;F, A&gt; program, Function&lt;Kind&lt;F, ?&gt;, Op&gt; narrow) {
<span class="fc" id="L176">    requireNonNull(program, &quot;Program cannot be null&quot;);</span>
<span class="fc" id="L177">    requireNonNull(narrow, &quot;Narrow function cannot be null&quot;);</span>

    // For pure FreeAp, all effects are guaranteed
<span class="fc" id="L180">    Set&lt;Op&gt; allEffects = collectPossibleEffects(program, narrow);</span>
<span class="fc" id="L181">    return new EffectPartition&lt;&gt;(allEffects, Set.of());</span>
  }

  /**
   * Checks if a program contains any potentially dangerous operations.
   *
   * &lt;p&gt;This method uses Over semantics to check if any possible execution path includes operations
   * matching the given predicate. Useful for permission checking before execution.
   *
   * @param program The FreeAp program to analyse. Must not be null.
   * @param narrow A function to narrow Kind to the concrete operation type. Must not be null.
   * @param isDangerous A predicate identifying dangerous operations. Must not be null.
   * @param &lt;F&gt; The type constructor of the instruction set
   * @param &lt;A&gt; The result type of the program
   * @param &lt;Op&gt; The base type of operations
   * @return {@code true} if any possible execution path includes a dangerous operation
   * @throws NullPointerException if any argument is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A, Op&gt; boolean containsDangerousEffect(
      FreeAp&lt;F, A&gt; program, Function&lt;Kind&lt;F, ?&gt;, Op&gt; narrow, Predicate&lt;Op&gt; isDangerous) {
<span class="fc" id="L201">    requireNonNull(program, &quot;Program cannot be null&quot;);</span>
<span class="fc" id="L202">    requireNonNull(narrow, &quot;Narrow function cannot be null&quot;);</span>
<span class="fc" id="L203">    requireNonNull(isDangerous, &quot;Predicate cannot be null&quot;);</span>

<span class="fc" id="L205">    Set&lt;Op&gt; allEffects = collectPossibleEffects(program, narrow);</span>
<span class="fc" id="L206">    return allEffects.stream().anyMatch(isDangerous);</span>
  }

  /**
   * Represents bounds on effect execution.
   *
   * &lt;p&gt;For programs with conditional logic:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code minimum}: Effects that will definitely execute (Under semantics)
   *   &lt;li&gt;{@code maximum}: Effects that might possibly execute (Over semantics)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;For pure applicative programs, {@code minimum == maximum}.
   *
   * @param minimum The minimum number of effects that will execute
   * @param maximum The maximum number of effects that could execute
   */
  public record EffectBounds(int minimum, int maximum) {

    /**
     * Creates effect bounds.
     *
     * @throws IllegalArgumentException if minimum is negative or greater than maximum
     */
<span class="fc" id="L231">    public EffectBounds {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">      if (minimum &lt; 0) {</span>
<span class="fc" id="L233">        throw new IllegalArgumentException(&quot;Minimum cannot be negative&quot;);</span>
      }
<span class="fc bfc" id="L235" title="All 2 branches covered.">      if (maximum &lt; minimum) {</span>
<span class="fc" id="L236">        throw new IllegalArgumentException(&quot;Maximum cannot be less than minimum&quot;);</span>
      }
<span class="fc" id="L238">    }</span>

    /** Returns {@code true} if the bounds are tight (minimum equals maximum). */
    public boolean isTight() {
<span class="fc bfc" id="L242" title="All 2 branches covered.">      return minimum == maximum;</span>
    }

    /** Returns the range between minimum and maximum effects. */
    public int range() {
<span class="fc" id="L247">      return maximum - minimum;</span>
    }
  }

  /**
   * Represents a partition of effects into guaranteed and conditional categories.
   *
   * @param guaranteed Effects that will definitely execute
   * @param conditional Effects that may or may not execute depending on runtime conditions
   * @param &lt;Op&gt; The type of operations
   */
  public record EffectPartition&lt;Op&gt;(Set&lt;Op&gt; guaranteed, Set&lt;Op&gt; conditional) {

    /** Creates an effect partition with defensive copies. */
<span class="fc" id="L261">    public EffectPartition {</span>
<span class="fc" id="L262">      guaranteed = Set.copyOf(guaranteed);</span>
<span class="fc" id="L263">      conditional = Set.copyOf(conditional);</span>
<span class="fc" id="L264">    }</span>

    /** Returns all possible effects (union of guaranteed and conditional). */
    public Set&lt;Op&gt; allPossible() {
<span class="fc" id="L268">      Set&lt;Op&gt; all = new HashSet&lt;&gt;(guaranteed);</span>
<span class="fc" id="L269">      all.addAll(conditional);</span>
<span class="fc" id="L270">      return all;</span>
    }

    /** Returns {@code true} if all effects are guaranteed (no conditional effects). */
    public boolean allGuaranteed() {
<span class="fc" id="L275">      return conditional.isEmpty();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>