<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Alternative.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt</a> &gt; <span class="el_source">Alternative.java</span></div><h1>Alternative.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt;

import static java.util.Objects.requireNonNull;

import java.util.function.Supplier;
import org.jspecify.annotations.NullMarked;

/**
 * Represents the Alternative type class, which combines the structure of {@link Applicative} with
 * choice and failure.
 *
 * &lt;p&gt;Alternative provides two key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #empty()} - Represents failure or the identity of choice
 *   &lt;li&gt;{@link #orElse(Kind, Supplier)} - Combines two alternatives, preferring the first if it
 *       succeeds
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Alternative sits at the same level as {@link Applicative} in the type class hierarchy,
 * providing a more general abstraction than {@link MonadZero}. While MonadZero provides similar
 * functionality for monads, Alternative works at the applicative level, making it applicable to a
 * broader range of types.
 *
 * &lt;p&gt;&lt;b&gt;Common Use Cases:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Parser combinators:&lt;/b&gt; Try one parser, if it fails, try another
 *   &lt;li&gt;&lt;b&gt;Validation:&lt;/b&gt; Attempt multiple validation strategies
 *   &lt;li&gt;&lt;b&gt;Non-deterministic computation:&lt;/b&gt; Represent multiple possible results (e.g., List)
 *   &lt;li&gt;&lt;b&gt;Optional values:&lt;/b&gt; Provide fallback chains (Maybe, Optional)
 *   &lt;li&gt;&lt;b&gt;Racing computations:&lt;/b&gt; Take the first successful result
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Alternative Laws:&lt;/b&gt;
 *
 * &lt;p&gt;Alternative instances must satisfy these laws:
 *
 * &lt;pre&gt;
 * 1. Left Identity:     orElse(empty(), () -&amp;gt; fa) ≡ fa
 * 2. Right Identity:    orElse(fa, () -&amp;gt; empty()) ≡ fa
 * 3. Associativity:     orElse(fa, () -&amp;gt; orElse(fb, () -&amp;gt; fc)) ≡ orElse(orElse(fa, () -&amp;gt; fb), () -&amp;gt; fc)
 * 4. Left Absorption:   ap(empty(), fa) ≡ empty()
 * 5. Right Absorption:  ap(ff, empty()) ≡ empty()
 * &lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * // Maybe Alternative: first Just wins
 * Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;
 * Kind&lt;MaybeKind.Witness, Integer&gt; result =
 *     alt.orElse(
 *         alt.of(42),
 *         () -&gt; alt.of(10)
 *     ); // Just(42)
 *
 * Kind&lt;MaybeKind.Witness, Integer&gt; fallback =
 *     alt.orElse(
 *         alt.empty(),
 *         () -&gt; alt.of(10)
 *     ); // Just(10)
 *
 * // List Alternative: concatenation
 * Alternative&lt;ListKind.Witness&gt; listAlt = ListMonad.INSTANCE;
 * Kind&lt;ListKind.Witness, Integer&gt; combined =
 *     listAlt.orElse(
 *         ListKind.widen(List.of(1, 2)),
 *         () -&gt; ListKind.widen(List.of(3, 4))
 *     ); // [1, 2, 3, 4]
 *
 * // Guard: conditional success
 * Kind&lt;MaybeKind.Witness, Unit&gt; check = alt.guard(someCondition);
 * // Returns of(Unit.INSTANCE) if true, empty() if false
 * }&lt;/pre&gt;
 *
 * @param &lt;F&gt; The higher-kinded type witness representing the type constructor (e.g., {@code
 *     MaybeKind.Witness}, {@code ListKind.Witness}).
 * @see Applicative
 * @see MonadZero
 * @see Kind
 */
@NullMarked
public interface Alternative&lt;F&gt; extends Applicative&lt;F&gt; {

  /**
   * Returns the identity element for the {@code orElse} operation, representing failure or an empty
   * result.
   *
   * &lt;p&gt;For different types:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code Maybe}: {@code Nothing}
   *   &lt;li&gt;{@code Optional}: {@code Optional.empty()}
   *   &lt;li&gt;{@code List}: {@code []} (empty list)
   *   &lt;li&gt;{@code Stream}: empty stream
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This is the left and right identity for {@link #orElse(Kind, Supplier)}.
   *
   * @param &lt;A&gt; The type parameter of the result, which is not present (phantom type)
   * @return A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the empty/failure state
   */
  &lt;A&gt; Kind&lt;F, A&gt; empty();

  /**
   * Combines two alternatives, preferring the first if it succeeds, otherwise evaluating and
   * returning the second.
   *
   * &lt;p&gt;The second argument is lazy (provided via {@link Supplier}) to avoid unnecessary computation
   * when the first alternative succeeds.
   *
   * &lt;p&gt;&lt;b&gt;Semantics by type:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;&lt;b&gt;Maybe/Optional:&lt;/b&gt; Returns {@code fa} if it's Just/present, otherwise evaluates and
   *       returns {@code fb}
   *   &lt;li&gt;&lt;b&gt;List/Stream:&lt;/b&gt; Concatenates {@code fa} and {@code fb} (always evaluates both)
   *   &lt;li&gt;&lt;b&gt;Parser:&lt;/b&gt; Tries {@code fa}, if it fails, tries {@code fb}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Fallback chain with Maybe
   * Kind&lt;MaybeKind.Witness, String&gt; result =
   *     alt.orElse(
   *         tryPrimarySource(),
   *         () -&gt; alt.orElse(
   *             trySecondarySource(),
   *             () -&gt; alt.of(&quot;default&quot;)
   *         )
   *     );
   * }&lt;/pre&gt;
   *
   * @param fa The first non-null alternative {@code Kind&lt;F, A&gt;}
   * @param fb A non-null {@link Supplier} providing the second alternative (evaluated lazily)
   * @param &lt;A&gt; The type of the value
   * @return A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the combined result
   * @throws NullPointerException if {@code fa} or {@code fb} is null
   */
  &lt;A&gt; Kind&lt;F, A&gt; orElse(Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb);

  /**
   * Conditionally returns a success value based on a boolean condition.
   *
   * &lt;p&gt;If the condition is {@code true}, returns {@code of(Unit.INSTANCE)}. If {@code false},
   * returns {@code empty()}.
   *
   * &lt;p&gt;This is useful for filtering and conditional logic in for-comprehensions and do-notation
   * style code.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Only proceed if user is authenticated
   * Kind&lt;MaybeKind.Witness, Unit&gt; authCheck =
   *     alt.guard(user.isAuthenticated());
   *
   * // In a for-comprehension context:
   * Kind&lt;MaybeKind.Witness, Result&gt; result =
   *     alt.flatMap(
   *         alt.guard(user.hasPermission()),
   *         unit -&gt; performAction()
   *     );
   * // Returns empty() if guard fails, otherwise performs action
   * }&lt;/pre&gt;
   *
   * @param condition The boolean condition to check
   * @return A non-null {@link Kind Kind&amp;lt;F, Unit&amp;gt;} containing {@link Unit#INSTANCE} if the
   *     condition is true, otherwise {@code empty()}
   */
  default Kind&lt;F, Unit&gt; guard(boolean condition) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">    return condition ? of(Unit.INSTANCE) : empty();</span>
  }

  /**
   * Combines multiple alternatives in sequence, returning the result of the first successful one.
   *
   * &lt;p&gt;This is a convenience method for chaining multiple {@link #orElse(Kind, Supplier)} calls.
   * The alternatives are evaluated lazily from left to right.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;MaybeKind.Witness, Config&gt; config =
   *     alt.orElseAll(
   *         readFromEnv(),
   *         () -&gt; readFromFile(),
   *         () -&gt; readFromDefaults()
   *     );
   * }&lt;/pre&gt;
   *
   * @param fa The first non-null alternative
   * @param fb The second non-null alternative supplier
   * @param more Additional non-null alternative suppliers
   * @param &lt;A&gt; The type of the value
   * @return A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the first successful alternative
   * @throws NullPointerException if any argument is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;A&gt; Kind&lt;F, A&gt; orElseAll(
      Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb, Supplier&lt;Kind&lt;F, A&gt;&gt;... more) {
<span class="fc" id="L206">    requireNonNull(fa, &quot;First alternative for orElseAll cannot be null&quot;);</span>
<span class="fc" id="L207">    requireNonNull(fb, &quot;Second alternative for orElseAll cannot be null&quot;);</span>
<span class="fc" id="L208">    requireNonNull(more, &quot;Additional alternatives for orElseAll cannot be null&quot;);</span>

<span class="fc" id="L210">    Kind&lt;F, A&gt; result = orElse(fa, fb);</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">    for (Supplier&lt;Kind&lt;F, A&gt;&gt; supplier : more) {</span>
<span class="fc" id="L213">      requireNonNull(supplier, &quot;Alternative supplier in orElseAll cannot be null&quot;);</span>
<span class="fc" id="L214">      result = orElse(result, supplier);</span>
    }

<span class="fc" id="L217">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>