<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Natural.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt</a> &gt; <span class="el_source">Natural.java</span></div><h1>Natural.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt;

import static java.util.Objects.requireNonNull;

import org.jspecify.annotations.NullMarked;

/**
 * Represents a natural transformation between two type constructors F and G.
 *
 * &lt;p&gt;A natural transformation is a polymorphic function that converts {@code Kind&lt;F, A&gt;} to {@code
 * Kind&lt;G, A&gt;} for &lt;em&gt;all&lt;/em&gt; types A, while preserving the structure. This is often written as
 * {@code F ~&gt; G} or {@code ∀A. F[A] → G[A]} in mathematical notation.
 *
 * &lt;h2&gt;Core Concept&lt;/h2&gt;
 *
 * &lt;p&gt;Natural transformations are &quot;structure-preserving maps between functors&quot;. They transform the
 * container/context without knowing or caring about what's inside:
 *
 * &lt;pre&gt;
 * F[A] ──Natural&amp;lt;F, G&amp;gt;──&amp;gt; G[A]
 *
 * Examples:
 * Maybe[A]     ──maybeToList──&amp;gt;    List[A]      (Nothing → [], Just(x) → [x])
 * List[A]      ──headMaybe──&amp;gt;      Maybe[A]     ([] → Nothing, [x,...] → Just(x))
 * Either[E, A] ──eitherToMaybe──&amp;gt;  Maybe[A]     (Left → Nothing, Right(x) → Just(x))
 * Id[A]        ──idToIO──&amp;gt;         IO[A]        (pure value → pure IO action)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Key Properties&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Polymorphic:&lt;/b&gt; Works for any type A without knowing what A is
 *   &lt;li&gt;&lt;b&gt;Structure-Preserving:&lt;/b&gt; Transforms the &quot;shape&quot; consistently
 *   &lt;li&gt;&lt;b&gt;Composable:&lt;/b&gt; Natural transformations compose to form new natural transformations
 *   &lt;li&gt;&lt;b&gt;Lawful:&lt;/b&gt; Must satisfy the naturality condition (see below)
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Naturality Law&lt;/h2&gt;
 *
 * &lt;p&gt;For a natural transformation {@code nat: F ~&gt; G} to be valid, it must satisfy:
 *
 * &lt;pre&gt;{@code
 * // For any function f: A → B and any fa: F[A]
 * nat.apply(functorF.map(f, fa)) == functorG.map(f, nat.apply(fa))
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;In other words, it doesn't matter whether you map first then transform, or transform first
 * then map—the result is the same. This ensures the transformation is truly &quot;natural&quot; and doesn't
 * depend on the specific values inside.
 *
 * &lt;pre&gt;
 *           map(f)
 *    F[A] ─────────→ F[B]
 *      │               │
 *  nat │               │ nat
 *      ↓               ↓
 *    G[A] ─────────→ G[B]
 *           map(f)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Common Use Cases&lt;/h2&gt;
 *
 * &lt;h3&gt;1. Free Monad Interpretation&lt;/h3&gt;
 *
 * &lt;p&gt;The most common use case is interpreting Free monads. A {@code Natural&lt;F, M&gt;} transforms DSL
 * instructions F into a target monad M:
 *
 * &lt;pre&gt;{@code
 * // Define DSL operations
 * sealed interface ConsoleOp&lt;A&gt; { ... }
 * record ReadLine&lt;A&gt;() implements ConsoleOp&lt;String&gt; {}
 * record PrintLine&lt;A&gt;(String line) implements ConsoleOp&lt;Unit&gt; {}
 *
 * // Interpreter as natural transformation
 * Natural&lt;ConsoleOp.Witness, IO.Witness&gt; consoleToIO = new Natural&lt;&gt;() {
 *   @Override
 *   public &lt;A&gt; Kind&lt;IO.Witness, A&gt; apply(Kind&lt;ConsoleOp.Witness, A&gt; fa) {
 *     return switch (ConsoleOpKindHelper.narrow(fa)) {
 *       case ReadLine&lt;?&gt; r -&gt; IO.of(() -&gt; scanner.nextLine());
 *       case PrintLine&lt;?&gt; p -&gt; IO.of(() -&gt; { System.out.println(p.line()); return Unit.UNIT; });
 *     };
 *   }
 * };
 *
 * // Use with Free monad
 * Free&lt;ConsoleOp.Witness, String&gt; program = ...;
 * IO&lt;String&gt; executable = program.foldMap(consoleToIO, ioMonad);
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;2. Type Conversions&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Maybe to Either
 * Natural&lt;Maybe.Witness, Either.Witness&lt;String&gt;&gt; maybeToEither =
 *     fa -&gt; MaybeKindHelper.narrow(fa)
 *         .fold(
 *             () -&gt; Either.left(&quot;No value&quot;),
 *             Either::right
 *         );
 *
 * // Maybe to List
 * Natural&lt;Maybe.Witness, List.Witness&gt; maybeToList =
 *     fa -&gt; MaybeKindHelper.narrow(fa)
 *         .fold(
 *             () -&gt; List.empty(),
 *             List::of
 *         );
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;3. Monad Transformer Lifting&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Lift M[A] into EitherT[M, E, A]
 * Natural&lt;M, EitherT.Witness&lt;M, E&gt;&gt; liftToEitherT =
 *     ma -&gt; EitherT.liftF(ma, monadM);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composition&lt;/h2&gt;
 *
 * &lt;p&gt;Natural transformations compose horizontally:
 *
 * &lt;pre&gt;{@code
 * Natural&lt;F, G&gt; fg = ...;
 * Natural&lt;G, H&gt; gh = ...;
 * Natural&lt;F, H&gt; fh = fg.andThen(gh);  // F ~&gt; G ~&gt; H = F ~&gt; H
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Relationship to Other Concepts&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Functor:&lt;/b&gt; Natural transformations operate on functors; naturality law involves map
 *   &lt;li&gt;&lt;b&gt;Free Monad:&lt;/b&gt; Interpretation via foldMap uses natural transformations
 *   &lt;li&gt;&lt;b&gt;Monad Transformers:&lt;/b&gt; lift operations are natural transformations
 *   &lt;li&gt;&lt;b&gt;Coyoneda:&lt;/b&gt; lowering from Coyoneda uses natural transformation to apply the functor
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Implementation Notes&lt;/h2&gt;
 *
 * &lt;p&gt;This interface uses a generic method {@code &lt;A&gt; apply(Kind&lt;F, A&gt;)} rather than a type
 * parameter because natural transformations must work for &lt;em&gt;all&lt;/em&gt; types A simultaneously.
 * Java's type system doesn't directly support higher-ranked types, but this encoding achieves the
 * same effect.
 *
 * @param &lt;F&gt; The source type constructor (witness type)
 * @param &lt;G&gt; The target type constructor (witness type)
 * @see Kind
 * @see Functor
 */
@NullMarked
@FunctionalInterface
public interface Natural&lt;F, G&gt; {

  /**
   * Applies this natural transformation to convert a value in context F to context G.
   *
   * &lt;p&gt;This method must be implemented to work uniformly for all types A, transforming the
   * structure F into structure G without inspecting or depending on the specific type A.
   *
   * &lt;p&gt;&lt;b&gt;Implementation Requirements:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Must work for any type A (cannot pattern match on A or use instanceof)
   *   &lt;li&gt;Must satisfy the naturality law (see class documentation)
   *   &lt;li&gt;Should be pure (no side effects)
   *   &lt;li&gt;Should be total (defined for all inputs)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Implementation:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Natural transformation from Maybe to List
   * Natural&lt;Maybe.Witness, List.Witness&gt; maybeToList = new Natural&lt;&gt;() {
   *   @Override
   *   public &lt;A&gt; Kind&lt;List.Witness, A&gt; apply(Kind&lt;Maybe.Witness, A&gt; fa) {
   *     Maybe&lt;A&gt; maybe = MaybeKindHelper.MAYBE.narrow(fa);
   *     return maybe.fold(
   *         () -&gt; ListKindHelper.LIST.widen(List.empty()),
   *         value -&gt; ListKindHelper.LIST.widen(List.of(value))
   *     );
   *   }
   * };
   * }&lt;/pre&gt;
   *
   * @param fa The value in context F to transform. Must not be null.
   * @param &lt;A&gt; The type of the value inside the context (polymorphic)
   * @return The transformed value in context G. Must not be null.
   * @throws NullPointerException if fa is null (implementation-dependent)
   */
  &lt;A&gt; Kind&lt;G, A&gt; apply(Kind&lt;F, A&gt; fa);

  /**
   * Composes this natural transformation with another, creating a transformation from F to H.
   *
   * &lt;p&gt;Given {@code this: F ~&gt; G} and {@code after: G ~&gt; H}, produces {@code F ~&gt; H}.
   *
   * &lt;pre&gt;
   *     this        after
   * F ──────→ G ──────→ H
   *
   *    this.andThen(after)
   * F ─────────────────→ H
   * &lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Associativity:&lt;/b&gt; Composition is associative:
   *
   * &lt;pre&gt;{@code
   * (f.andThen(g)).andThen(h) == f.andThen(g.andThen(h))
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Natural&lt;Maybe.Witness, Either.Witness&lt;String&gt;&gt; maybeToEither = ...;
   * Natural&lt;Either.Witness&lt;String&gt;, IO.Witness&gt; eitherToIO = ...;
   *
   * // Compose to get Maybe ~&gt; IO directly
   * Natural&lt;Maybe.Witness, IO.Witness&gt; maybeToIO = maybeToEither.andThen(eitherToIO);
   * }&lt;/pre&gt;
   *
   * @param after The natural transformation to apply after this one. Must not be null.
   * @param &lt;H&gt; The final target type constructor
   * @return A composed natural transformation from F to H
   * @throws NullPointerException if after is null
   */
  default &lt;H&gt; Natural&lt;F, H&gt; andThen(Natural&lt;G, H&gt; after) {
<span class="fc" id="L228">    requireNonNull(after, &quot;after natural transformation cannot be null&quot;);</span>
<span class="fc" id="L229">    return new Natural&lt;&gt;() {</span>
      @Override
      public &lt;A&gt; Kind&lt;H, A&gt; apply(Kind&lt;F, A&gt; fa) {
<span class="fc" id="L232">        return after.apply(Natural.this.apply(fa));</span>
      }
    };
  }

  /**
   * Composes another natural transformation with this one, creating a transformation from E to G.
   *
   * &lt;p&gt;Given {@code before: E ~&gt; F} and {@code this: F ~&gt; G}, produces {@code E ~&gt; G}.
   *
   * &lt;p&gt;This is the reverse of {@link #andThen(Natural)}:
   *
   * &lt;pre&gt;{@code
   * before.andThen(this) == this.compose(before)
   * }&lt;/pre&gt;
   *
   * @param before The natural transformation to apply before this one. Must not be null.
   * @param &lt;E&gt; The initial source type constructor
   * @return A composed natural transformation from E to G
   * @throws NullPointerException if before is null
   */
  default &lt;E&gt; Natural&lt;E, G&gt; compose(Natural&lt;E, F&gt; before) {
<span class="fc" id="L254">    requireNonNull(before, &quot;before natural transformation cannot be null&quot;);</span>
<span class="fc" id="L255">    return before.andThen(this);</span>
  }

  /**
   * Returns the identity natural transformation for type constructor F.
   *
   * &lt;p&gt;The identity transformation returns its input unchanged:
   *
   * &lt;pre&gt;{@code
   * Natural&lt;F, F&gt; id = Natural.identity();
   * id.apply(fa) == fa  // for all fa
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Identity Laws:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Left identity
   * Natural.identity().andThen(nat) == nat
   *
   * // Right identity
   * nat.andThen(Natural.identity()) == nat
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Use Cases:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Default/no-op transformation
   *   &lt;li&gt;Base case in recursive transformations
   *   &lt;li&gt;Testing and verification
   * &lt;/ul&gt;
   *
   * @param &lt;F&gt; The type constructor
   * @return The identity natural transformation
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;F&gt; Natural&lt;F, F&gt; identity() {
<span class="fc" id="L291">    return (Natural&lt;F, F&gt;) IDENTITY;</span>
  }

  /** Cached identity instance to avoid allocations on each call. */
  @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L296">  Natural IDENTITY =</span>
<span class="fc" id="L297">      new Natural() {</span>
        @Override
        public Kind apply(Kind fa) {
<span class="fc" id="L300">          return fa;</span>
        }
      };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>