<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Selective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt</a> &gt; <span class="el_source">Selective.java</span></div><h1>Selective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt;

import static java.util.Objects.requireNonNull;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;
import org.jspecify.annotations.NullMarked;

/**
 * Represents the Selective Applicative Functor type class, an algebraic structure that lies between
 * {@link Applicative} and {@link Monad} in terms of power.
 *
 * &lt;p&gt;A Selective Functor extends {@link Applicative} with the ability to conditionally apply
 * effects based on the result of a previous computation. Unlike {@link Monad}, which allows
 * arbitrary dynamic choice of effects, Selective provides a more restricted form of conditional
 * execution where all possible branches must be provided upfront.
 *
 * &lt;p&gt;The key operation is {@link #select(Kind, Kind)}, which takes an {@code F&lt;Choice&lt;A, B&gt;&gt;} and
 * an {@code F&lt;Function&lt;A, B&gt;&gt;}, and returns an {@code F&lt;B&gt;}. If the first argument is a {@code
 * Left(a)}, the function from the second argument is applied to {@code a}. If it's a {@code
 * Right(b)}, the second argument is ignored and {@code b} is returned directly.
 *
 * &lt;p&gt;&lt;b&gt;Unit Usage:&lt;/b&gt; This interface makes extensive use of {@link Unit} to represent operations
 * that complete successfully but produce no interesting value. This is semantically different from
 * null and provides type safety.
 *
 * @param &lt;F&gt; The higher-kinded type witness representing the type constructor of the selective
 *     context (e.g., {@code OptionalKind.Witness}, {@code ListKind.Witness}).
 * @see Applicative
 * @see Monad
 * @see Kind
 * @see Unit
 */
@NullMarked
public interface Selective&lt;F&gt; extends Applicative&lt;F&gt; {

  /**
   * The core selective operation. Given an effectful choice {@code fab} and an effectful function
   * {@code ff}, applies the function only if the choice is a {@code Left}.
   *
   * &lt;p&gt;If {@code fab} contains {@code Right(b)}, the result is {@code F&lt;b&gt;} and {@code ff} is not
   * evaluated. If {@code fab} contains {@code Left(a)}, the function from {@code ff} is applied to
   * {@code a} to produce {@code F&lt;b&gt;}.
   *
   * &lt;p&gt;This is the fundamental operation that distinguishes Selective from Applicative. Unlike
   * {@code ap}, which always applies the function, {@code select} conditionally applies based on
   * the result.
   *
   * @param fab A non-null {@link Kind Kind&amp;lt;F, Choice&amp;lt;A, B&amp;gt;&amp;gt;} representing an effectful
   *     conditional value.
   * @param ff A non-null {@link Kind Kind&amp;lt;F, Function&amp;lt;A, B&amp;gt;&amp;gt;} representing an effectful
   *     function to apply if {@code fab} is {@code Left}.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left}).
   * @param &lt;B&gt; The output type and the type inside {@code Right}.
   * @return A non-null {@link Kind Kind&amp;lt;F, B&amp;gt;} representing the result after selective
   *     application.
   */
  &lt;A, B&gt; Kind&lt;F, B&gt; select(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, B&gt;&gt; ff);

  /**
   * A selective version of branching (if-then-else). Given a {@code Choice&lt;A, B&gt;} and handlers for
   * both cases, applies the appropriate handler based on the result.
   *
   * &lt;p&gt;This is a derived operation that can be defined in terms of {@link #select(Kind, Kind)}.
   *
   * @param fab A non-null {@link Kind Kind&amp;lt;F, Choice&amp;lt;A, B&amp;gt;&amp;gt;} representing an effectful
   *     conditional value.
   * @param fl A non-null {@link Kind Kind&amp;lt;F, Function&amp;lt;A, C&amp;gt;&amp;gt;} for handling the {@code
   *     Left} case.
   * @param fr A non-null {@link Kind Kind&amp;lt;F, Function&amp;lt;B, C&amp;gt;&amp;gt;} for handling the {@code
   *     Right} case.
   * @param &lt;A&gt; The type inside {@code Left}.
   * @param &lt;B&gt; The type inside {@code Right}.
   * @param &lt;C&gt; The result type.
   * @return A non-null {@link Kind Kind&amp;lt;F, C&amp;gt;} representing the result after applying the
   *     appropriate handler.
   */
  default &lt;A, B, C&gt; Kind&lt;F, C&gt; branch(
      Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, C&gt;&gt; fl, Kind&lt;F, Function&lt;B, C&gt;&gt; fr) {
<span class="fc" id="L83">    requireNonNull(fab, &quot;Kind&lt;F, Choice&lt;A, B&gt;&gt; fab for branch cannot be null&quot;);</span>
<span class="fc" id="L84">    requireNonNull(fl, &quot;Kind&lt;F, Function&lt;A, C&gt;&gt; fl for branch cannot be null&quot;);</span>
<span class="fc" id="L85">    requireNonNull(fr, &quot;Kind&lt;F, Function&lt;B, C&gt;&gt; fr for branch cannot be null&quot;);</span>

<span class="fc" id="L87">    Kind&lt;F, Choice&lt;A, Choice&lt;B, C&gt;&gt;&gt; transformed =</span>
<span class="fc" id="L88">        map(</span>
            choice -&gt;
<span class="fc bfc" id="L90" title="All 2 branches covered.">                choice.isLeft()</span>
<span class="fc" id="L91">                    ? Selective.left(choice.getLeft()) // Use Selective.left()</span>
<span class="fc" id="L92">                    : Selective.right(</span>
<span class="fc" id="L93">                        Selective.left(choice.getRight())), // Use Selective.right() and left()</span>
            fab);

<span class="fc" id="L96">    Kind&lt;F, Function&lt;A, Choice&lt;B, C&gt;&gt;&gt; leftHandler =</span>
<span class="fc" id="L97">        map(</span>
<span class="fc" id="L98">            f -&gt; (Function&lt;A, Choice&lt;B, C&gt;&gt;) a -&gt; Selective.right(f.apply(a)),</span>
            fl); // Use Selective.right()

<span class="fc" id="L101">    Kind&lt;F, Choice&lt;B, C&gt;&gt; intermediate = select(transformed, leftHandler);</span>

<span class="fc" id="L103">    return select(intermediate, fr);</span>
  }

  /**
   * Conditionally performs a Unit-returning effect based on a boolean condition.
   *
   * &lt;p&gt;If the condition is {@code true}, the effect {@code fa} is executed and its result is
   * returned. If the condition is {@code false}, {@code fa} is not executed and {@code
   * of(Unit.INSTANCE)} is returned.
   *
   * &lt;p&gt;This is the primary conditional effect execution operator for Selective functors. It
   * explicitly uses {@link Unit} to represent &quot;operation completed with no interesting result&quot;,
   * which is semantically clearer than returning null.
   *
   * &lt;p&gt;&lt;b&gt;Semantics:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Condition true: Execute effect, return Unit
   *   &lt;li&gt;Condition false: Skip effect, return Unit.INSTANCE
   *   &lt;li&gt;Condition error: Propagate error (context-dependent)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Log only if debug mode is enabled
   * Kind&lt;IO.Witness, Boolean&gt; debugEnabled = IO.of(Config.isDebugMode());
   * Kind&lt;IO.Witness, Unit&gt; logEffect = IO.fromRunnable(() -&gt; log.debug(&quot;Debug info&quot;));
   * Kind&lt;IO.Witness, Unit&gt; maybeLog = selective.whenS(debugEnabled, logEffect);
   * }&lt;/pre&gt;
   *
   * @param fcond A non-null {@link Kind Kind&amp;lt;F, Boolean&amp;gt;} representing an effectful boolean
   *     condition.
   * @param fa A non-null {@link Kind Kind&amp;lt;F, Unit&amp;gt;} representing the effect to execute if the
   *     condition is true. Must return Unit.
   * @return A non-null {@link Kind Kind&amp;lt;F, Unit&amp;gt;} representing the result. If the condition
   *     was false, returns {@code of(Unit.INSTANCE)}.
   */
  default Kind&lt;F, Unit&gt; whenS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, Unit&gt; fa) {
<span class="fc" id="L142">    requireNonNull(fcond, &quot;Kind&lt;F, Boolean&gt; fcond for whenS cannot be null&quot;);</span>
<span class="fc" id="L143">    requireNonNull(fa, &quot;Kind&lt;F, Unit&gt; fa for whenS cannot be null&quot;);</span>

    // Transform Boolean to Choice&lt;Unit, Unit&gt;
    // If true: Left(unit) - need to execute fa to get the Unit result
    // If false: Right(Unit.INSTANCE) - skip fa, use Unit.INSTANCE directly
<span class="fc" id="L148">    Kind&lt;F, Choice&lt;Unit, Unit&gt;&gt; condition =</span>
<span class="fc" id="L149">        map2(</span>
            fa,
            fcond,
            (unitFromEffect, conditionValue) -&gt;
<span class="fc bfc" id="L153" title="All 2 branches covered.">                conditionValue ? Selective.left(unitFromEffect) : Selective.right(Unit.INSTANCE));</span>

    // Identity function for Unit
<span class="fc" id="L156">    Kind&lt;F, Function&lt;Unit, Unit&gt;&gt; identity = of(u -&gt; Unit.INSTANCE);</span>

<span class="fc" id="L158">    return select(condition, identity);</span>
  }

  /**
   * Convenience method that wraps an effect to return Unit before conditional execution.
   *
   * &lt;p&gt;This is equivalent to: {@code whenS(fcond, map(a -&gt; Unit.INSTANCE, fa))}
   *
   * &lt;p&gt;Use this when you have an effect that returns a value, but you want to discard that value
   * and treat it as a Unit-returning operation. This is useful for side-effecting operations where
   * the return value is not interesting.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Write to database (returns row count, but we don't care)
   * Kind&lt;IO.Witness, Integer&gt; writeResult = database.write(data);
   * Kind&lt;IO.Witness, Boolean&gt; shouldWrite = IO.of(config.shouldPersist());
   *
   * // Discard the Integer result, treat as Unit
   * Kind&lt;IO.Witness, Unit&gt; maybeWrite = selective.whenS_(shouldWrite, writeResult);
   * }&lt;/pre&gt;
   *
   * @param fcond The non-null effectful condition
   * @param fa The non-null effect to execute (result will be discarded)
   * @param &lt;A&gt; The type of fa's result (will be discarded)
   * @return {@code Kind&lt;F, Unit&gt;} representing the effect execution with result discarded
   */
  default &lt;A&gt; Kind&lt;F, Unit&gt; whenS_(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fa) {
<span class="fc" id="L187">    requireNonNull(fcond, &quot;condition cannot be null&quot;);</span>
<span class="fc" id="L188">    requireNonNull(fa, &quot;effect cannot be null&quot;);</span>
<span class="fc" id="L189">    return whenS(fcond, map(a -&gt; Unit.INSTANCE, fa));</span>
  }

  /**
   * A ternary conditional operator for selective functors. If the condition is {@code true},
   * returns the result of {@code fthen}, otherwise returns the result of {@code felse}.
   *
   * &lt;p&gt;Unlike a monadic bind, both {@code fthen} and {@code felse} are visible upfront, allowing
   * for static analysis and potentially parallel execution.
   *
   * @param fcond A non-null {@link Kind Kind&amp;lt;F, Boolean&amp;gt;} representing an effectful boolean
   *     condition.
   * @param fthen A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the effect to execute if the
   *     condition is true.
   * @param felse A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the effect to execute if the
   *     condition is false.
   * @param &lt;A&gt; The type of the result.
   * @return A non-null {@link Kind Kind&amp;lt;F, A&amp;gt;} representing the result of the selected
   *     branch.
   */
  default &lt;A&gt; Kind&lt;F, A&gt; ifS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fthen, Kind&lt;F, A&gt; felse) {
<span class="fc" id="L210">    requireNonNull(fcond, &quot;Kind&lt;F, Boolean&gt; fcond for ifS cannot be null&quot;);</span>
<span class="fc" id="L211">    requireNonNull(fthen, &quot;Kind&lt;F, A&gt; fthen for ifS cannot be null&quot;);</span>
<span class="fc" id="L212">    requireNonNull(felse, &quot;Kind&lt;F, A&gt; felse for ifS cannot be null&quot;);</span>

<span class="fc" id="L214">    Kind&lt;F, Choice&lt;A, A&gt;&gt; eitherChoice =</span>
<span class="fc" id="L215">        map3(</span>
            fthen,
            felse,
            fcond,
            (thenVal, elseVal, b) -&gt;
<span class="fc bfc" id="L220" title="All 2 branches covered.">                b</span>
<span class="fc" id="L221">                    ? Selective.left(thenVal) // Use Selective.left()</span>
<span class="fc" id="L222">                    : Selective.right(elseVal)); // Use Selective.right()</span>

<span class="fc" id="L224">    Kind&lt;F, Function&lt;A, A&gt;&gt; identity = of(a -&gt; a);</span>

<span class="fc" id="L226">    return select(eitherChoice, identity);</span>
  }

  /**
   * Returns the first successful value from a list of alternatives.
   *
   * @param alternatives A non-null {@link java.util.List} of {@link Kind Kind&amp;lt;F, Choice&amp;lt;E,
   *     A&amp;gt;&amp;gt;} representing alternative computations.
   * @param &lt;E&gt; The error type (type inside {@code Left}).
   * @param &lt;A&gt; The success type (type inside {@code Right}).
   * @return A non-null {@link Kind Kind&amp;lt;F, Choice&amp;lt;E, A&amp;gt;&amp;gt;} representing the first
   *     successful alternative, or the last error if all fail.
   */
  default &lt;E, A&gt; Kind&lt;F, Choice&lt;E, A&gt;&gt; orElse(List&lt;Kind&lt;F, Choice&lt;E, A&gt;&gt;&gt; alternatives) {
<span class="fc" id="L240">    requireNonNull(alternatives, &quot;List of alternatives for orElse cannot be null&quot;);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if (alternatives.isEmpty()) {</span>
<span class="fc" id="L242">      throw new IllegalArgumentException(&quot;orElse requires at least one alternative&quot;);</span>
    }

<span class="fc" id="L245">    Kind&lt;F, Choice&lt;E, A&gt;&gt; result = alternatives.get(0);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">    for (int i = 1; i &lt; alternatives.size(); i++) {</span>
<span class="fc" id="L247">      Kind&lt;F, Choice&lt;E, A&gt;&gt; next = alternatives.get(i);</span>
<span class="fc" id="L248">      result = selectOrElse(result, next);</span>
    }
<span class="fc" id="L250">    return result;</span>
  }

  /** Helper method for {@link #orElse(java.util.List)}. */
  private &lt;E, A&gt; Kind&lt;F, Choice&lt;E, A&gt;&gt; selectOrElse(
      Kind&lt;F, Choice&lt;E, A&gt;&gt; first, Kind&lt;F, Choice&lt;E, A&gt;&gt; second) {
<span class="fc" id="L256">    Kind&lt;F, Choice&lt;E, Choice&lt;E, A&gt;&gt;&gt; transformed =</span>
<span class="fc" id="L257">        map(</span>
            choice -&gt;
<span class="fc bfc" id="L259" title="All 2 branches covered.">                choice.isRight()</span>
<span class="fc" id="L260">                    ? Selective.right(</span>
<span class="fc" id="L261">                        Selective.right(choice.getRight())) // Use Selective.right() twice</span>
<span class="fc" id="L262">                    : Selective.left(choice.getLeft()), // Use Selective.left()</span>
            first);

<span class="fc" id="L265">    Kind&lt;F, Function&lt;E, Choice&lt;E, A&gt;&gt;&gt; getSecond =</span>
<span class="fc" id="L266">        map(choiceA -&gt; (Function&lt;E, Choice&lt;E, A&gt;&gt;) e -&gt; choiceA, second);</span>

<span class="fc" id="L268">    return select(transformed, getSecond);</span>
  }

  /**
   * Applies multiple effectful functions in sequence, each depending on whether the previous
   * computation succeeded or failed.
   *
   * @param initial A non-null {@link Kind Kind&amp;lt;F, Choice&amp;lt;E, A&amp;gt;&amp;gt;} representing the
   *     initial value.
   * @param functions A non-null {@link java.util.List} of {@link Kind Kind&amp;lt;F, Function&amp;lt;A,
   *     Choice&amp;lt;E, A&amp;gt;&amp;gt;} representing the functions to apply in sequence.
   * @param &lt;E&gt; The error type.
   * @param &lt;A&gt; The value type.
   * @return A non-null {@link Kind Kind&amp;lt;F, Choice&amp;lt;E, A&amp;gt;&amp;gt;} representing the result after
   *     applying all functions, or the first error encountered.
   */
  default &lt;E, A&gt; Kind&lt;F, Choice&lt;E, A&gt;&gt; apS(
      Kind&lt;F, Choice&lt;E, A&gt;&gt; initial, List&lt;Kind&lt;F, Function&lt;A, Choice&lt;E, A&gt;&gt;&gt;&gt; functions) {
<span class="fc" id="L286">    requireNonNull(initial, &quot;Initial value for apS cannot be null&quot;);</span>
<span class="fc" id="L287">    requireNonNull(functions, &quot;List of functions for apS cannot be null&quot;);</span>

<span class="fc" id="L289">    Kind&lt;F, Choice&lt;E, A&gt;&gt; result = initial;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">    for (Kind&lt;F, Function&lt;A, Choice&lt;E, A&gt;&gt;&gt; func : functions) {</span>
<span class="fc" id="L291">      Kind&lt;F, Choice&lt;A, Choice&lt;E, A&gt;&gt;&gt; transformed =</span>
<span class="fc" id="L292">          map(</span>
              choice -&gt;
<span class="fc bfc" id="L294" title="All 2 branches covered.">                  choice.isRight()</span>
<span class="fc" id="L295">                      ? Selective.left(choice.getRight()) // Use Selective.left()</span>
<span class="fc" id="L296">                      : Selective.right(</span>
<span class="fc" id="L297">                          Selective.left(choice.getLeft())), // Use Selective.right() and left()</span>
              result);

<span class="fc" id="L300">      Kind&lt;F, Choice&lt;E, A&gt;&gt; applied = select(transformed, func);</span>
<span class="fc" id="L301">      result = applied;</span>
<span class="fc" id="L302">    }</span>
<span class="fc" id="L303">    return result;</span>
  }

  /**
   * Creates a Choice representing a Left value, with Unit on the right side.
   *
   * &lt;p&gt;This is a convenience factory method for creating left-biased choices without needing to
   * specify a value for the unused right side.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Choice&lt;String, Integer&gt; left = Selective.left(&quot;error&quot;);
   * // Equivalent to: new SimpleChoice&lt;&gt;(true, &quot;error&quot;, Unit.INSTANCE)
   * }&lt;/pre&gt;
   *
   * @param leftValue The value for the left side
   * @param &lt;L&gt; The left type
   * @param &lt;R&gt; The right type
   * @return A Choice representing a Left value
   */
  static &lt;L, R&gt; Choice&lt;L, R&gt; left(L leftValue) {
<span class="fc" id="L325">    return SimpleChoice.left(leftValue);</span>
  }

  /**
   * Creates a Choice representing a Right value, with Unit on the left side.
   *
   * &lt;p&gt;This is a convenience factory method for creating right-biased choices without needing to
   * specify a value for the unused left side.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Choice&lt;String, Integer&gt; right = Selective.right(42);
   * // Equivalent to: new SimpleChoice&lt;&gt;(false, Unit.INSTANCE, 42)
   * }&lt;/pre&gt;
   *
   * @param rightValue The value for the right side
   * @param &lt;L&gt; The left type
   * @param &lt;R&gt; The right type
   * @return A Choice representing a Right value
   */
  static &lt;L, R&gt; Choice&lt;L, R&gt; right(R rightValue) {
<span class="fc" id="L347">    return SimpleChoice.right(rightValue);</span>
  }

  /** Simple implementation of Choice for use in default methods. */
  final class SimpleChoice&lt;L, R&gt; implements Choice&lt;L, R&gt; {
    private final boolean isLeft;
    private final L left;
    private final R right;

    /**
     * Package-private constructor for SimpleChoice. Users should prefer the static factory methods
     * {@link Selective#left(Object)} and {@link Selective#right(Object)} for type safety and
     * correct Unit handling.
     *
     * @param isLeft true if this represents a Left value
     * @param left the left value (should be non-null if isLeft is true)
     * @param right the right value (should be non-null if isLeft is false)
     */
<span class="fc" id="L365">    SimpleChoice(boolean isLeft, L left, R right) {</span>
<span class="fc" id="L366">      this.isLeft = isLeft;</span>
<span class="fc" id="L367">      this.left = left;</span>
<span class="fc" id="L368">      this.right = right;</span>
<span class="fc" id="L369">    }</span>

    /**
     * Factory method to create a Left Choice with Unit on the right. Prefer using {@link
     * Selective#left(Object)} instead.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;L, R&gt; SimpleChoice&lt;L, R&gt; left(L leftValue) {
<span class="fc" id="L377">      return new SimpleChoice&lt;&gt;(true, leftValue, (R) Unit.INSTANCE);</span>
    }

    /**
     * Factory method to create a Right Choice with Unit on the left. Prefer using {@link
     * Selective#right(Object)} instead.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;L, R&gt; SimpleChoice&lt;L, R&gt; right(R rightValue) {
<span class="fc" id="L386">      return new SimpleChoice&lt;&gt;(false, (L) Unit.INSTANCE, rightValue);</span>
    }

    @Override
    public boolean isLeft() {
<span class="fc" id="L391">      return isLeft;</span>
    }

    @Override
    public boolean isRight() {
<span class="fc bfc" id="L396" title="All 2 branches covered.">      return !isLeft;</span>
    }

    @Override
    public L getLeft() {
<span class="fc bfc" id="L401" title="All 2 branches covered.">      if (!isLeft) throw new NoSuchElementException(&quot;Not a left value&quot;);</span>
<span class="fc" id="L402">      return left;</span>
    }

    @Override
    public R getRight() {
<span class="fc bfc" id="L407" title="All 2 branches covered.">      if (isLeft) throw new NoSuchElementException(&quot;Not a right value&quot;);</span>
<span class="fc" id="L408">      return right;</span>
    }

    @Override
    public &lt;T&gt; T fold(
        Function&lt;? super L, ? extends T&gt; leftMapper, Function&lt;? super R, ? extends T&gt; rightMapper) {
<span class="fc bfc" id="L414" title="All 2 branches covered.">      return isLeft ? leftMapper.apply(left) : rightMapper.apply(right);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;R2&gt; Choice&lt;L, R2&gt; map(Function&lt;? super R, ? extends R2&gt; mapper) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">      return isLeft</span>
<span class="fc" id="L421">          ? new SimpleChoice&lt;&gt;(true, left, (R2) Unit.INSTANCE)</span>
<span class="fc" id="L422">          : new SimpleChoice&lt;&gt;(false, (L) Unit.INSTANCE, mapper.apply(right));</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;L2&gt; Choice&lt;L2, R&gt; mapLeft(Function&lt;? super L, ? extends L2&gt; mapper) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">      return isLeft</span>
<span class="fc" id="L429">          ? new SimpleChoice&lt;&gt;(true, mapper.apply(left), (R) Unit.INSTANCE)</span>
<span class="fc" id="L430">          : new SimpleChoice&lt;&gt;(false, (L2) Unit.INSTANCE, right);</span>
    }

    @Override
    public Choice&lt;R, L&gt; swap() {
<span class="fc bfc" id="L435" title="All 2 branches covered.">      return new SimpleChoice&lt;&gt;(!isLeft, right, left);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;R2&gt; Choice&lt;L, R2&gt; flatMap(Function&lt;? super R, ? extends Choice&lt;L, R2&gt;&gt; mapper) {
<span class="fc bfc" id="L441" title="All 2 branches covered.">      if (isLeft) {</span>
<span class="fc" id="L442">        return new SimpleChoice&lt;&gt;(true, left, (R2) Unit.INSTANCE);</span>
      }
<span class="fc" id="L444">      Choice&lt;L, R2&gt; result = mapper.apply(right);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">      return result.isLeft()</span>
<span class="fc" id="L446">          ? new SimpleChoice&lt;&gt;(true, result.getLeft(), (R2) Unit.INSTANCE)</span>
<span class="fc" id="L447">          : new SimpleChoice&lt;&gt;(false, (L) Unit.INSTANCE, result.getRight());</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>