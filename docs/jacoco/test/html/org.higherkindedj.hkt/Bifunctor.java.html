<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Bifunctor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt</a> &gt; <span class="el_source">Bifunctor.java</span></div><h1>Bifunctor.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt;

import java.util.function.Function;
import org.jspecify.annotations.NullMarked;

/**
 * A Bifunctor is a type constructor {@code F} of kind {@code * -&gt; * -&gt; *} that is covariant in both
 * of its type arguments. In other words, it represents &quot;things that contain two independent types
 * that can both be mapped over&quot;.
 *
 * &lt;p&gt;Bifunctor is similar to {@link Functor}, but operates on types with two type parameters
 * instead of one. Whilst Functor provides {@code map} to transform a single type parameter,
 * Bifunctor provides {@code bimap} to transform both type parameters simultaneously.
 *
 * &lt;p&gt;The key operations are:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code first}: Map over the first type parameter only (covariant)
 *   &lt;li&gt;{@code second}: Map over the second type parameter only (covariant)
 *   &lt;li&gt;{@code bimap}: Map over both type parameters simultaneously
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Core Concept&lt;/h2&gt;
 *
 * &lt;p&gt;If you have a value wrapped in a two-parameter context {@code F&lt;A, B&gt;} (like {@code
 * Either&lt;String, Integer&gt;}, {@code Tuple2&lt;String, Integer&gt;}, or {@code Validated&lt;Error, Success&gt;}),
 * and you have functions {@code A -&gt; C} and {@code B -&gt; D}, the {@code bimap} operation lets you
 * apply both functions to get {@code F&lt;C, D&gt;}, preserving the structure:
 *
 * &lt;pre&gt;
 * F&amp;lt;A, B&amp;gt; + (A -&amp;gt; C) + (B -&amp;gt; D) ──bimap──&amp;gt; F&amp;lt;C, D&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Common Examples&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Example 1: Either&lt;L, R&gt; (sum type representing success or failure)
 * Either&lt;String, Integer&gt; result = Either.right(42);
 * Either&lt;Exception, String&gt; transformed = bifunctor.bimap(
 *     error -&gt; new Exception(error),  // Transform left (error) type
 *     value -&gt; &quot;Value: &quot; + value,     // Transform right (success) type
 *     result
 * );
 * // Result: Either.right(&quot;Value: 42&quot;)
 *
 * Either&lt;String, Integer&gt; failure = Either.left(&quot;not found&quot;);
 * Either&lt;Exception, String&gt; transformedError = bifunctor.bimap(
 *     error -&gt; new Exception(error),
 *     value -&gt; &quot;Value: &quot; + value,
 *     failure
 * );
 * // Result: Either.left(new Exception(&quot;not found&quot;))
 *
 * // Example 2: Tuple2&lt;A, B&gt; (product type representing a pair)
 * Tuple2&lt;String, Integer&gt; pair = new Tuple2&lt;&gt;(&quot;Alice&quot;, 30);
 * Tuple2&lt;Integer, String&gt; transformed = bifunctor.bimap(
 *     String::length,              // Transform first element
 *     age -&gt; age + &quot; years old&quot;,   // Transform second element
 *     pair
 * );
 * // Result: new Tuple2&lt;&gt;(5, &quot;30 years old&quot;)
 *
 * // Example 3: Validated&lt;E, A&gt; (accumulating validation)
 * Validated&lt;List&lt;String&gt;, User&gt; validated = Validated.valid(user);
 * Validated&lt;List&lt;Exception&gt;, String&gt; transformed = bifunctor.bimap(
 *     errors -&gt; errors.stream().map(Exception::new).collect(toList()),
 *     User::getName,
 *     validated
 * );
 * // Result: Validated.valid(user.getName())
 *
 * // Example 4: Using first() to transform only the first parameter
 * Either&lt;String, Integer&gt; result = Either.right(42);
 * Either&lt;Exception, Integer&gt; mapped = bifunctor.first(
 *     Exception::new,
 *     result
 * );
 * // Result: Either.right(42) - right side unchanged
 *
 * // Example 5: Using second() to transform only the second parameter
 * Tuple2&lt;String, Integer&gt; pair = new Tuple2&lt;&gt;(&quot;Alice&quot;, 30);
 * Tuple2&lt;String, String&gt; mapped = bifunctor.second(
 *     age -&gt; age + &quot; years&quot;,
 *     pair
 * );
 * // Result: new Tuple2&lt;&gt;(&quot;Alice&quot;, &quot;30 years&quot;)
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Key Characteristics&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Structure Preservation:&lt;/b&gt; The shape and context of the container remain unchanged;
 *       only the values inside are transformed.
 *   &lt;li&gt;&lt;b&gt;Independent Transformations:&lt;/b&gt; The two type parameters can be transformed completely
 *       independently of each other.
 *   &lt;li&gt;&lt;b&gt;Pure Functions Only:&lt;/b&gt; Functions passed to bifunctor operations must be pure (no side
 *       effects).
 *   &lt;li&gt;&lt;b&gt;Both Parameters are Covariant:&lt;/b&gt; Unlike {@link Profunctor} where the first parameter
 *       is contravariant, Bifunctor is covariant in both parameters.
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Bifunctor vs Profunctor&lt;/h2&gt;
 *
 * &lt;p&gt;It's important to distinguish Bifunctor from {@link Profunctor}:
 *
 * &lt;table border=&quot;1&quot;&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Aspect&lt;/th&gt;
 *     &lt;th&gt;Bifunctor&lt;/th&gt;
 *     &lt;th&gt;Profunctor&lt;/th&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;td&gt;First parameter&lt;/td&gt;
 *     &lt;td&gt;Covariant (output-like)&lt;/td&gt;
 *     &lt;td&gt;Contravariant (input-like)&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;td&gt;Second parameter&lt;/td&gt;
 *     &lt;td&gt;Covariant (output-like)&lt;/td&gt;
 *     &lt;td&gt;Covariant (output-like)&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;td&gt;Core operation&lt;/td&gt;
 *     &lt;td&gt;{@code bimap(f: A→C, g: B→D)}&lt;/td&gt;
 *     &lt;td&gt;{@code dimap(f: C→A, g: B→D)}&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;td&gt;Typical instances&lt;/td&gt;
 *     &lt;td&gt;Either, Tuple2, Validated&lt;/td&gt;
 *     &lt;td&gt;Function, Reader, Optics&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;td&gt;Use case&lt;/td&gt;
 *     &lt;td&gt;Data structures with two types&lt;/td&gt;
 *     &lt;td&gt;Transformations (input → output)&lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;h2&gt;Bifunctor Laws&lt;/h2&gt;
 *
 * &lt;p&gt;All Bifunctor implementations must satisfy two fundamental laws to ensure predictable and
 * composable behaviour:
 *
 * &lt;h3&gt;1. Identity Law&lt;/h3&gt;
 *
 * &lt;p&gt;Mapping both parameters with the identity function does nothing:
 *
 * &lt;pre&gt;{@code
 * bimap(x -&gt; x, y -&gt; y, fab) ≡ fab
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;This ensures that {@code bimap} doesn't add any extra behaviour beyond function application.
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * Either&lt;String, Integer&gt; result = Either.right(42);
 * Either&lt;String, Integer&gt; same = bifunctor.bimap(x -&gt; x, y -&gt; y, result);
 * // same.equals(result) must be true
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;2. Composition Law&lt;/h3&gt;
 *
 * &lt;p&gt;Mapping with composed functions is the same as mapping twice:
 *
 * &lt;pre&gt;{@code
 * bimap(f2.compose(f1), g2.compose(g1), fab) ≡ bimap(f2, g2, bimap(f1, g1, fab))
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;Or equivalently, using {@code andThen}:
 *
 * &lt;pre&gt;{@code
 * bimap(f1.andThen(f2), g1.andThen(g2), fab) ≡ bimap(f2, g2, bimap(f1, g1, fab))
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;This ensures that bifunctor operations compose properly and can be optimised through fusion.
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * Function&lt;String, Integer&gt; f1 = String::length;
 * Function&lt;Integer, String&gt; f2 = Object::toString;
 * Function&lt;Integer, Double&gt; g1 = Integer::doubleValue;
 * Function&lt;Double, String&gt; g2 = d -&gt; String.format(&quot;%.2f&quot;, d);
 *
 * Either&lt;String, Integer&gt; either = Either.right(42);
 *
 * // These two should be equivalent:
 * Either&lt;String, String&gt; composed = bifunctor.bimap(
 *     f1.andThen(f2),
 *     g1.andThen(g2),
 *     either
 * );
 *
 * Either&lt;String, String&gt; chained = bifunctor.bimap(
 *     f2, g2,
 *     bifunctor.bimap(f1, g1, either)
 * );
 * // Both result in: Either.right(&quot;42.00&quot;)
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Why these laws matter:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Enable compiler optimisations (fusion, deforestation)
 *   &lt;li&gt;Guarantee that refactoring doesn't change behaviour
 *   &lt;li&gt;Allow reasoning about code using equational reasoning
 *   &lt;li&gt;Ensure Bifunctors compose properly in larger systems
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Relationship to Other Type Classes&lt;/h2&gt;
 *
 * &lt;p&gt;Bifunctor is related to but distinct from other type classes:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Functor} - Maps over a single type parameter
 *   &lt;li&gt;{@link Profunctor} - Maps over two parameters, but first is contravariant
 *   &lt;li&gt;Any type that is a Bifunctor in its last parameter can be a Functor
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Common Bifunctor Instances&lt;/h2&gt;
 *
 * &lt;p&gt;Many familiar types with two type parameters are Bifunctors:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Either&amp;lt;L, R&amp;gt;:&lt;/b&gt; Sum type - transforms left or right value depending on which is
 *       present
 *   &lt;li&gt;&lt;b&gt;Tuple2&amp;lt;A, B&amp;gt;:&lt;/b&gt; Product type - transforms both elements of the pair
 *   &lt;li&gt;&lt;b&gt;Validated&amp;lt;E, A&amp;gt;:&lt;/b&gt; Validation type - transforms error or success value
 *   &lt;li&gt;&lt;b&gt;Writer&amp;lt;W, A&amp;gt;:&lt;/b&gt; Writer monad - transforms log and result independently
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Implementation Guidelines&lt;/h2&gt;
 *
 * &lt;p&gt;When implementing Bifunctor for a custom type:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;&lt;b&gt;Preserve structure:&lt;/b&gt; Don't change the shape or context, only transform values
 *   &lt;li&gt;&lt;b&gt;Verify laws:&lt;/b&gt; Ensure both identity and composition laws hold
 *   &lt;li&gt;&lt;b&gt;Handle all cases:&lt;/b&gt; Consider all possible states of the bifunctor (left/right, both,
 *       etc.)
 *   &lt;li&gt;&lt;b&gt;Maintain referential transparency:&lt;/b&gt; Functions should be applied purely
 *   &lt;li&gt;&lt;b&gt;Use default methods:&lt;/b&gt; {@code first} and {@code second} have default implementations
 *       via {@code bimap}
 * &lt;/ol&gt;
 *
 * &lt;h2&gt;Performance Considerations&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Fusion:&lt;/b&gt; Multiple {@code bimap} calls can often be fused into a single operation
 *   &lt;li&gt;&lt;b&gt;Efficient implementations:&lt;/b&gt; Types can provide optimised implementations of {@code
 *       first} and {@code second} if more efficient than {@code bimap}
 *   &lt;li&gt;&lt;b&gt;Allocation:&lt;/b&gt; Bifunctor operations typically create new instances; consider immutable
 *       data structures
 * &lt;/ul&gt;
 *
 * @param &lt;F&gt; The witness type representing the type constructor of the bifunctor context (e.g.,
 *     {@code EitherKind2.Witness}, {@code Tuple2Kind2.Witness}). This {@code F} represents the
 *     two-parameter &quot;wrapper&quot; or &quot;context&quot; type.
 * @see Functor
 * @see Profunctor
 * @see Kind2
 */
@NullMarked
public interface Bifunctor&lt;F&gt; {

  /**
   * Maps over both type parameters simultaneously, applying {@code f} to the first parameter and
   * {@code g} to the second parameter.
   *
   * &lt;p&gt;This is the fundamental operation of the Bifunctor type class. It allows you to transform
   * both &quot;contents&quot; of a two-parameter context without affecting the structure itself.
   *
   * &lt;p&gt;&lt;b&gt;Type Transformation:&lt;/b&gt;
   *
   * &lt;pre&gt;
   * F&amp;lt;A, B&amp;gt; ──bimap(f: A → C, g: B → D)──&amp;gt; F&amp;lt;C, D&amp;gt;
   *
   * Examples:
   * Either&amp;lt;String, Integer&amp;gt;         ──bimap(Exception::new, n -&amp;gt; n * 2)──&amp;gt;
   *                                                     Either&amp;lt;Exception, Integer&amp;gt;
   * Tuple2&amp;lt;String, Integer&amp;gt;         ──bimap(String::length, Object::toString)──&amp;gt;
   *                                                     Tuple2&amp;lt;Integer, String&amp;gt;
   * Validated&amp;lt;List&amp;lt;Error&amp;gt;, User&amp;gt;    ──bimap(errors -&amp;gt; ..., User::getName)──&amp;gt;
   *                                                     Validated&amp;lt;List&amp;lt;String&amp;gt;, String&amp;gt;
   * &lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Usage:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Example 1: Transforming an Either
   * Bifunctor&lt;EitherKind2.Witness&gt; eitherBifunctor = ...;
   * Kind2&lt;EitherKind2.Witness, String, Integer&gt; either =
   *     EitherKind2.widen(Either.right(42));
   *
   * Kind2&lt;EitherKind2.Witness, Exception, String&gt; result = eitherBifunctor.bimap(
   *     Exception::new,           // Transform left (error) type
   *     n -&gt; &quot;Number: &quot; + n,      // Transform right (success) type
   *     either
   * );
   * // Result: Either.right(&quot;Number: 42&quot;)
   *
   * // Example 2: Transforming a Tuple2
   * Bifunctor&lt;Tuple2Kind2.Witness&gt; tupleBifunctor = ...;
   * Kind2&lt;Tuple2Kind2.Witness, String, Integer&gt; tuple =
   *     Tuple2Kind2.widen(new Tuple2&lt;&gt;(&quot;Alice&quot;, 30));
   *
   * Kind2&lt;Tuple2Kind2.Witness, Integer, String&gt; result = tupleBifunctor.bimap(
   *     String::length,           // Transform first element
   *     age -&gt; age + &quot; years&quot;,    // Transform second element
   *     tuple
   * );
   * // Result: new Tuple2&lt;&gt;(5, &quot;30 years&quot;)
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Law Verification:&lt;/b&gt;
   *
   * &lt;p&gt;When implementing this method, ensure both Bifunctor laws are satisfied:
   *
   * &lt;pre&gt;{@code
   * // Identity law: mapping both with identity is a no-op
   * bimap(x -&gt; x, y -&gt; y, fab).equals(fab)  // must be true
   *
   * // Composition law: mapping twice = mapping with composed functions
   * bimap(f2.compose(f1), g2.compose(g1), fab).equals(
   *     bimap(f2, g2, bimap(f1, g1, fab))
   * )  // must be true
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the first parameter in the input bifunctor {@code fab}
   * @param &lt;B&gt; The type of the second parameter in the input bifunctor {@code fab}
   * @param &lt;C&gt; The type of the first parameter in the output bifunctor
   * @param &lt;D&gt; The type of the second parameter in the output bifunctor
   * @param f The pure function to apply to the first parameter. Must not be null.
   * @param g The pure function to apply to the second parameter. Must not be null.
   * @param fab The bifunctor structure containing values of types {@code A} and {@code B}. Must not
   *     be null.
   * @return A new bifunctor structure of type {@code Kind2&lt;F, C, D&gt;} with both parameters
   *     transformed. Guaranteed to be non-null.
   * @throws NullPointerException if {@code f}, {@code g}, or {@code fab} is null
   *     (implementation-dependent)
   * @see #first(Function, Kind2)
   * @see #second(Function, Kind2)
   */
  &lt;A, B, C, D&gt; Kind2&lt;F, C, D&gt; bimap(
      Function&lt;? super A, ? extends C&gt; f, Function&lt;? super B, ? extends D&gt; g, Kind2&lt;F, A, B&gt; fab);

  /**
   * Maps over the first type parameter only, leaving the second parameter unchanged.
   *
   * &lt;p&gt;This is a convenience method that applies a transformation to only the first type parameter.
   * It is equivalent to calling {@code bimap(f, Function.identity(), fab)}.
   *
   * &lt;p&gt;&lt;b&gt;Type Transformation:&lt;/b&gt;
   *
   * &lt;pre&gt;
   * F&amp;lt;A, B&amp;gt; ──first(f: A → C)──&amp;gt; F&amp;lt;C, B&amp;gt;
   *
   * Examples:
   * Either&amp;lt;String, Integer&amp;gt;     ──first(Exception::new)──&amp;gt;     Either&amp;lt;Exception, Integer&amp;gt;
   * Tuple2&amp;lt;String, Integer&amp;gt;     ──first(String::length)──&amp;gt;     Tuple2&amp;lt;Integer, Integer&amp;gt;
   * Validated&amp;lt;Error, User&amp;gt;      ──first(Error::getMessage)──&amp;gt;  Validated&amp;lt;String, User&amp;gt;
   * &lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Usage:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Example 1: Transforming only the left side of an Either
   * Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = ...;
   * Kind2&lt;EitherKind2.Witness, String, Integer&gt; either =
   *     EitherKind2.widen(Either.left(&quot;error&quot;));
   *
   * Kind2&lt;EitherKind2.Witness, Exception, Integer&gt; result = bifunctor.first(
   *     Exception::new,
   *     either
   * );
   * // Result: Either.left(new Exception(&quot;error&quot;))
   *
   * // Example 2: Transforming the first element of a Tuple2
   * Bifunctor&lt;Tuple2Kind2.Witness&gt; bifunctor = ...;
   * Kind2&lt;Tuple2Kind2.Witness, String, Integer&gt; tuple =
   *     Tuple2Kind2.widen(new Tuple2&lt;&gt;(&quot;Alice&quot;, 30));
   *
   * Kind2&lt;Tuple2Kind2.Witness, Integer, Integer&gt; result = bifunctor.first(
   *     String::length,
   *     tuple
   * );
   * // Result: new Tuple2&lt;&gt;(5, 30)
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Default Implementation:&lt;/b&gt;
   *
   * &lt;p&gt;The default implementation delegates to {@code bimap} with {@code Function.identity()} for
   * the second parameter. Implementations may override this for better performance.
   *
   * @param &lt;A&gt; The type of the first parameter in the input bifunctor {@code fab}
   * @param &lt;B&gt; The type of the second parameter (unchanged)
   * @param &lt;C&gt; The type of the first parameter in the output bifunctor
   * @param f The pure function to apply to the first parameter. Must not be null.
   * @param fab The bifunctor structure containing values of types {@code A} and {@code B}. Must not
   *     be null.
   * @return A new bifunctor structure of type {@code Kind2&lt;F, C, B&gt;} with the first parameter
   *     transformed. Guaranteed to be non-null.
   * @throws NullPointerException if {@code f} or {@code fab} is null (implementation-dependent)
   * @see #bimap(Function, Function, Kind2)
   * @see #second(Function, Kind2)
   */
  default &lt;A, B, C&gt; Kind2&lt;F, C, B&gt; first(Function&lt;? super A, ? extends C&gt; f, Kind2&lt;F, A, B&gt; fab) {
<span class="fc" id="L411">    return bimap(f, Function.identity(), fab);</span>
  }

  /**
   * Maps over the second type parameter only, leaving the first parameter unchanged.
   *
   * &lt;p&gt;This is a convenience method that applies a transformation to only the second type
   * parameter. It is equivalent to calling {@code bimap(Function.identity(), g, fab)}.
   *
   * &lt;p&gt;&lt;b&gt;Type Transformation:&lt;/b&gt;
   *
   * &lt;pre&gt;
   * F&amp;lt;A, B&amp;gt; ──second(g: B → D)──&amp;gt; F&amp;lt;A, D&amp;gt;
   *
   * Examples:
   * Either&amp;lt;String, Integer&amp;gt;     ──second(n -&amp;gt; n * 2)──&amp;gt;        Either&amp;lt;String, Integer&amp;gt;
   * Tuple2&amp;lt;String, Integer&amp;gt;     ──second(Object::toString)──&amp;gt;  Tuple2&amp;lt;String, String&amp;gt;
   * Validated&amp;lt;Error, User&amp;gt;      ──second(User::getName)──&amp;gt;     Validated&amp;lt;Error, String&amp;gt;
   * &lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Usage:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Example 1: Transforming only the right side of an Either
   * Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = ...;
   * Kind2&lt;EitherKind2.Witness, String, Integer&gt; either =
   *     EitherKind2.widen(Either.right(42));
   *
   * Kind2&lt;EitherKind2.Witness, String, String&gt; result = bifunctor.second(
   *     n -&gt; &quot;Number: &quot; + n,
   *     either
   * );
   * // Result: Either.right(&quot;Number: 42&quot;)
   *
   * // Example 2: Transforming the second element of a Tuple2
   * Bifunctor&lt;Tuple2Kind2.Witness&gt; bifunctor = ...;
   * Kind2&lt;Tuple2Kind2.Witness, String, Integer&gt; tuple =
   *     Tuple2Kind2.widen(new Tuple2&lt;&gt;(&quot;Alice&quot;, 30));
   *
   * Kind2&lt;Tuple2Kind2.Witness, String, String&gt; result = bifunctor.second(
   *     age -&gt; age + &quot; years old&quot;,
   *     tuple
   * );
   * // Result: new Tuple2&lt;&gt;(&quot;Alice&quot;, &quot;30 years old&quot;)
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Default Implementation:&lt;/b&gt;
   *
   * &lt;p&gt;The default implementation delegates to {@code bimap} with {@code Function.identity()} for
   * the first parameter. Implementations may override this for better performance.
   *
   * &lt;p&gt;&lt;b&gt;Note on Functor:&lt;/b&gt;
   *
   * &lt;p&gt;For many bifunctors (like {@code Either}, {@code Validated}), {@code second} is equivalent
   * to the {@link Functor#map} operation, as these types are typically &quot;right-biased&quot; when viewed
   * as single-parameter functors.
   *
   * @param &lt;A&gt; The type of the first parameter (unchanged)
   * @param &lt;B&gt; The type of the second parameter in the input bifunctor {@code fab}
   * @param &lt;D&gt; The type of the second parameter in the output bifunctor
   * @param g The pure function to apply to the second parameter. Must not be null.
   * @param fab The bifunctor structure containing values of types {@code A} and {@code B}. Must not
   *     be null.
   * @return A new bifunctor structure of type {@code Kind2&lt;F, A, D&gt;} with the second parameter
   *     transformed. Guaranteed to be non-null.
   * @throws NullPointerException if {@code g} or {@code fab} is null (implementation-dependent)
   * @see #bimap(Function, Function, Kind2)
   * @see #first(Function, Kind2)
   */
  default &lt;A, B, D&gt; Kind2&lt;F, A, D&gt; second(Function&lt;? super B, ? extends D&gt; g, Kind2&lt;F, A, B&gt; fab) {
<span class="fc" id="L481">    return bimap(Function.identity(), g, fab);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>