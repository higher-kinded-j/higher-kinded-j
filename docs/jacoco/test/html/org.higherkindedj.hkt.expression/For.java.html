<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>For.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">For.java</span></div><h1>For.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.function.Function5;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.hkt.tuple.Tuple4;
import org.higherkindedj.hkt.tuple.Tuple5;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;

/**
 * Provides a statically-typed, fluent for-comprehension builder for monadic types, simulating a
 * feature common in languages like Scala.
 *
 * &lt;p&gt;For-comprehensions offer a convenient and readable syntax for composing sequences of monadic
 * operations (like {@code flatMap} and {@code map}). This builder de-sugars the comprehension into
 * a series of monadic calls, guiding the user through the composition process while ensuring type
 * safety at each step.
 *
 * &lt;h3&gt;Usage&lt;/h3&gt;
 *
 * &lt;p&gt;A comprehension is a chain of operations that includes generators, bindings, filters, and a
 * final projection:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Generators ({@code .from(...)}):&lt;/b&gt; These are the core of the comprehension, equivalent
 *       to a {@code flatMap}. Each generator takes a value from a previous step and produces a new
 *       monadic value, which is then flattened into the ongoing computation. The results of all
 *       generators are accumulated in a tuple.
 *   &lt;li&gt;&lt;b&gt;Bindings ({@code .let(...)}):&lt;/b&gt; Binds the result of a pure computation to a new
 *       variable in the comprehension's scope. This is equivalent to a {@code map} operation that
 *       adds the computed value to the accumulated tuple.
 *   &lt;li&gt;&lt;b&gt;Filters ({@code .when(...)}):&lt;/b&gt; Filters the results based on a predicate. If the
 *       predicate returns {@code false}, the computation for that path is short-circuited. This
 *       operation is only available for monads that implement {@link MonadZero}, which provides an
 *       &quot;empty&quot; or &quot;zero&quot; element (e.g., an empty list, {@code Optional.empty()}).
 *   &lt;li&gt;&lt;b&gt;Projection ({@code .yield(...)}):&lt;/b&gt; Concludes the comprehension by applying a function
 *       to the accumulated results from all previous steps, producing the final monadic value.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example with List (a {@code MonadZero})&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Imports for context
 * import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
 * import java.util.Arrays;
 *
 * ListMonad listMonad = ListMonad.INSTANCE;
 * Kind&lt;ListKind.Witness, Integer&gt; list1 = LIST.widen(Arrays.asList(1, 2, 3));
 * Kind&lt;ListKind.Witness, Integer&gt; list2 = LIST.widen(Arrays.asList(10, 20));
 *
 * // Equivalent to Scala: for { a &lt;- list1; b &lt;- list2 if (a+b) % 2 != 0; c = &quot;Sum: &quot; + (a+b) } yield s&quot;$a + $b = $c&quot;
 * Kind&lt;ListKind.Witness, String&gt; result =
 * For.from(listMonad, list1)                       // Generator: a &lt;- list1
 * .from(a -&gt; list2)                             // Generator: b &lt;- list2
 * .when(t -&gt; (t._1() + t._2()) % 2 != 0)        // Filter: if (a+b) is odd
 * .let(t -&gt; &quot;Sum: &quot; + (t._1() + t._2()))        // Binding: c = &quot;Sum: &quot; + (a+b)
 * .yield((a, b, c) -&gt; a + &quot;+&quot; + b + &quot; = &quot; + c); // Projection
 *
 * List&lt;String&gt; finalResult = LIST.narrow(result);
 * // finalResult: [&quot;1+10 = Sum: 11&quot;, &quot;1+20 = Sum: 21&quot;, &quot;3+10 = Sum: 13&quot;, &quot;3+20 = Sum: 23&quot;]
 * }&lt;/pre&gt;
 *
 * @see Monad
 * @see MonadZero
 * @see Kind
 */
public final class For {

  private static final String YIELD_CANNOT_RETURN_NULL = &quot;The yield function must not return null.&quot;;

  private For() {} // Static access only

  /**
   * Initiates a for-comprehension for any {@link Monad}. The resulting builder chain will not
   * support filtering with {@code .when(...)}.
   *
   * @param monad The Monad instance that defines the behaviour of {@code flatMap} and {@code map}.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the builder, ready for the next operation.
   */
  public static &lt;M, A&gt; MonadicSteps1&lt;M, A&gt; from(Monad&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L98">    return new MonadicSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * Initiates a for-comprehension for a {@link MonadZero}. The resulting builder chain supports
   * filtering with {@code .when(...)}.
   *
   * @param monad The MonadZero instance, providing {@code zero()} for filtering.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the filterable builder, ready for the next operation.
   */
  public static &lt;M, A&gt; FilterableSteps1&lt;M, A&gt; from(MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L112">    return new FilterableSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * A marker interface for all builder steps, ensuring they can be permitted by a sealed interface.
   * This is an internal detail to organise the different step types.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   */
  public sealed interface Steps&lt;M&gt;
      permits MonadicSteps1,
          MonadicSteps2,
          MonadicSteps3,
          MonadicSteps4,
          MonadicSteps5,
          FilterableSteps1,
          FilterableSteps2,
          FilterableSteps3,
          FilterableSteps4,
          FilterableSteps5 {}

  // --- Monadic (Non-Filterable) Steps ---

  /**
   * Represents the first step in a non-filterable for-comprehension, holding a single monadic
   * value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class MonadicSteps1&lt;M, A&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L146">    private MonadicSteps1(Monad&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L147">      this.monad = monad;</span>
<span class="fc" id="L148">      this.computation = computation;</span>
<span class="fc" id="L149">    }</span>

    /**
     * Binds the result of another monadic computation (a generator).
     *
     * &lt;p&gt;This corresponds to a {@code flatMap} operation. The function {@code next} is applied to
     * the result of the first step, and the resulting monadic value is flattened into the
     * comprehension.
     *
     * @param next A function that takes the result of the first step (type {@code A}) and returns a
     *     new monadic computation {@code Kind&lt;M, B&gt;}.
     * @param &lt;B&gt; The value type of the new monadic computation.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L165">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L166">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L167">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Binds the result of a pure computation.
     *
     * &lt;p&gt;This corresponds to a {@code map} operation. The function {@code f} is applied to the
     * result of the first step to produce a new value, which is then carried along in the
     * comprehension.
     *
     * @param f A function that takes the result of the first step (type {@code A}) and returns a
     *     pure value of type {@code B}.
     * @param &lt;B&gt; The type of the computed value.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L184">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L185">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L186">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * &lt;p&gt;This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value. The extracted value is accumulated
     * alongside the original value.
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     *
     * &lt;pre&gt;{@code
     * record User(String name, Address address) {}
     * record Address(String city) {}
     *
     * Lens&lt;User, Address&gt; addressLens = Lens.of(User::address, User::withAddress);
     *
     * Kind&lt;IdKind.Witness, String&gt; result =
     *     For.from(idMonad, Id.of(new User(&quot;Alice&quot;, new Address(&quot;NYC&quot;))))
     *         .focus(addressLens)
     *         .yield((user, address) -&gt; user.name() + &quot; lives in &quot; + address.city());
     * // Result: &quot;Alice lives in NYC&quot;
     * }&lt;/pre&gt;
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param &lt;B&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; focus(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L220">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L221">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L222">          monad.map(a -&gt; Tuple.of(a, lens.get(a)), this.computation);</span>
<span class="fc" id="L223">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value of type {@code A} into the result type
     *     {@code R}.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L235">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a non-filterable for-comprehension, holding a tuple of two
   * results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class MonadicSteps2&lt;M, A, B&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L251">    private MonadicSteps2(Monad&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L252">      this.monad = monad;</span>
<span class="fc" id="L253">      this.computation = computation;</span>
<span class="fc" id="L254">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L266">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L267">          monad.flatMap(</span>
<span class="fc" id="L268">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L270">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L283">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L284">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L285">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * &lt;p&gt;This is a more flexible version of {@code focus} that allows extracting values based on
     * the entire accumulated state.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;C&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking three values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; focus(Function&lt;Tuple2&lt;A, B&gt;, C&gt; extractor) {
<span class="fc" id="L301">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L302">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L303">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), extractor.apply(ab)), this.computation);</span>
<span class="fc" id="L304">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results ({@code A}, {@code B}) into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L315">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results (a {@code Tuple2&lt;A, B&gt;}) into a
     *     final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L327">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a non-filterable for-comprehension, holding a tuple of three
   * results.
   */
  public static final class MonadicSteps3&lt;M, A, B, C&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L339">    private MonadicSteps3(Monad&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L340">      this.monad = monad;</span>
<span class="fc" id="L341">      this.computation = computation;</span>
<span class="fc" id="L342">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 3-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L353">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L354">          monad.flatMap(</span>
<span class="fc" id="L355">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L357">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 3-tuple of results and returning a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L368">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L369">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L370">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;D&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking four values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; focus(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; extractor) {
<span class="fc" id="L383">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L384">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L385">          monad.map(</span>
<span class="fc" id="L386">              abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), extractor.apply(abc)),</span>
              this.computation);
<span class="fc" id="L388">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L399">      return monad.map(</span>
<span class="fc" id="L400">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L412">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a non-filterable for-comprehension, holding a tuple of four
   * results.
   */
  public static final class MonadicSteps4&lt;M, A, B, C, D&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L424">    private MonadicSteps4(Monad&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L425">      this.monad = monad;</span>
<span class="fc" id="L426">      this.computation = computation;</span>
<span class="fc" id="L427">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 4-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; from(Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L438">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L439">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L441">                  monad.map(</span>
<span class="fc" id="L442">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L443">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L445">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 4-tuple of results and returning a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L456">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L457">          monad.map(</span>
<span class="fc" id="L458">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L460">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;E&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking five values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; focus(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; extractor) {
<span class="fc" id="L473">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L474">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L475">          monad.map(</span>
<span class="fc" id="L476">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), extractor.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L478">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L489">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L491">              Objects.requireNonNull(</span>
<span class="fc" id="L492">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L504">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth (and final supported) step in a non-filterable for-comprehension, holding
   * a tuple of five results.
   */
  public static final class MonadicSteps5&lt;M, A, B, C, D, E&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L516">    private MonadicSteps5(Monad&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L517">      this.monad = monad;</span>
<span class="fc" id="L518">      this.computation = computation;</span>
<span class="fc" id="L519">    }</span>

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L529">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L531">              Objects.requireNonNull(</span>
<span class="fc" id="L532">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L544">      return monad.map(f, computation);</span>
    }
  }

  // --- Filterable Steps (for MonadZero) ---

  /**
   * Represents the first step in a filterable for-comprehension, holding a single monadic value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class FilterableSteps1&lt;M, A&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L560">    private FilterableSteps1(MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L561">      this.monad = monad;</span>
<span class="fc" id="L562">      this.computation = computation;</span>
<span class="fc" id="L563">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;B&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L573">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L574">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L575">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;B&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L586">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L587">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L588">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate. If the predicate returns
     * {@code false}, the comprehension short-circuits for that path by using the monad's {@link
     * MonadZero#zero()} element (e.g., an empty list).
     *
     * @param filter The predicate to apply to the current value {@code A}.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps1&lt;M, A&gt; when(Predicate&lt;A&gt; filter) {
<span class="fc" id="L600">      Kind&lt;M, A&gt; newComputation =</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">          monad.flatMap(a -&gt; filter.test(a) ? monad.of(a) : monad.zero(), this.computation);</span>
<span class="fc" id="L602">      return new FilterableSteps1&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * &lt;p&gt;This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value.
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param &lt;B&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; focus(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L620">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L621">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L622">          monad.map(a -&gt; Tuple.of(a, lens.get(a)), this.computation);</span>
<span class="fc" id="L623">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using the provided {@link Prism}. If the prism matches, the
     * extracted value is added to the accumulated tuple. If it doesn't match, the computation
     * short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * &lt;p&gt;This provides type-safe pattern matching within for-comprehensions, eliminating the need
     * for {@code instanceof} checks and casts.
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     *
     * &lt;pre&gt;{@code
     * sealed interface Result permits Success, Failure {}
     * record Success(String value) implements Result {}
     * record Failure(String error) implements Result {}
     *
     * Prism&lt;Result, Success&gt; successPrism = Prism.of(
     *     r -&gt; r instanceof Success s ? Optional.of(s) : Optional.empty(),
     *     s -&gt; s
     * );
     *
     * Kind&lt;MaybeKind.Witness, String&gt; result =
     *     For.from(maybeMonad, MAYBE.just(someResult))
     *         .match(successPrism)
     *         .yield((original, success) -&gt; success.value());
     * // Returns Just(value) if someResult is Success, Nothing otherwise
     * }&lt;/pre&gt;
     *
     * @param prism The {@link Prism} to use for pattern matching.
     * @param &lt;B&gt; The type of the extracted value when the prism matches.
     * @return The next step in the builder if the prism matches, or short-circuits to zero.
     * @throws NullPointerException if {@code prism} is null.
     * @see Prism
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; match(Prism&lt;A, B&gt; prism) {
<span class="fc" id="L660">      Objects.requireNonNull(prism, &quot;prism must not be null&quot;);</span>
<span class="fc" id="L661">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L662">          monad.flatMap(</span>
<span class="fc" id="L663">              a -&gt; prism.getOptional(a).map(b -&gt; monad.of(Tuple.of(a, b))).orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L665">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L676">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a filterable for-comprehension, holding a tuple of two results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class FilterableSteps2&lt;M, A, B&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L691">    private FilterableSteps2(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L692">      this.monad = monad;</span>
<span class="fc" id="L693">      this.computation = computation;</span>
<span class="fc" id="L694">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L704">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L705">          monad.flatMap(</span>
<span class="fc" id="L706">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L708">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L719">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L720">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L721">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps2&lt;M, A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; filter) {
<span class="fc" id="L731">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">          monad.flatMap(ab -&gt; filter.test(ab) ? monad.of(ab) : monad.zero(), this.computation);</span>
<span class="fc" id="L733">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;C&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking three values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; focus(Function&lt;Tuple2&lt;A, B&gt;, C&gt; extractor) {
<span class="fc" id="L746">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L747">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L748">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), extractor.apply(ab)), this.computation);</span>
<span class="fc" id="L749">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;C&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; match(Function&lt;Tuple2&lt;A, B&gt;, Optional&lt;C&gt;&gt; matcher) {
<span class="fc" id="L764">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L765">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L766">          monad.flatMap(</span>
              ab -&gt;
                  matcher
<span class="fc" id="L769">                      .apply(ab)</span>
<span class="fc" id="L770">                      .map(c -&gt; monad.of(Tuple.of(ab._1(), ab._2(), c)))</span>
<span class="fc" id="L771">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L773">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L784">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L795">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a filterable for-comprehension, holding a tuple of three results.
   */
  public static final class FilterableSteps3&lt;M, A, B, C&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L806">    private FilterableSteps3(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L807">      this.monad = monad;</span>
<span class="fc" id="L808">      this.computation = computation;</span>
<span class="fc" id="L809">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L819">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L820">          monad.flatMap(</span>
<span class="fc" id="L821">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L823">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L834">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L835">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L836">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps3&lt;M, A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; filter) {
<span class="fc" id="L846">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">          monad.flatMap(abc -&gt; filter.test(abc) ? monad.of(abc) : monad.zero(), this.computation);</span>
<span class="fc" id="L848">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;D&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking four values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; focus(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; extractor) {
<span class="fc" id="L861">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L862">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L863">          monad.map(</span>
<span class="fc" id="L864">              abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), extractor.apply(abc)),</span>
              this.computation);
<span class="fc" id="L866">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;D&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; match(
        Function&lt;Tuple3&lt;A, B, C&gt;, Optional&lt;D&gt;&gt; matcher) {
<span class="fc" id="L882">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L883">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L884">          monad.flatMap(</span>
              abc -&gt;
                  matcher
<span class="fc" id="L887">                      .apply(abc)</span>
<span class="fc" id="L888">                      .map(d -&gt; monad.of(Tuple.of(abc._1(), abc._2(), abc._3(), d)))</span>
<span class="fc" id="L889">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L891">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L902">      return monad.map(</span>
<span class="fc" id="L903">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L915">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a filterable for-comprehension, holding a tuple of four results.
   */
  public static final class FilterableSteps4&lt;M, A, B, C, D&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L926">    private FilterableSteps4(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L927">      this.monad = monad;</span>
<span class="fc" id="L928">      this.computation = computation;</span>
<span class="fc" id="L929">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; from(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L940">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L941">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L943">                  monad.map(</span>
<span class="fc" id="L944">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L945">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L947">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L958">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L959">          monad.map(</span>
<span class="fc" id="L960">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L962">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps4&lt;M, A, B, C, D&gt; when(Predicate&lt;Tuple4&lt;A, B, C, D&gt;&gt; filter) {
<span class="fc" id="L972">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L973">          monad.flatMap(</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">              abcd -&gt; filter.test(abcd) ? monad.of(abcd) : monad.zero(), this.computation);</span>
<span class="fc" id="L975">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;E&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking five values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; focus(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; extractor) {
<span class="fc" id="L988">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L989">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L990">          monad.map(</span>
<span class="fc" id="L991">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), extractor.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L993">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;E&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; match(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, Optional&lt;E&gt;&gt; matcher) {
<span class="fc" id="L1009">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L1010">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L1011">          monad.flatMap(</span>
              abcd -&gt;
                  matcher
<span class="fc" id="L1014">                      .apply(abcd)</span>
<span class="fc" id="L1015">                      .map(e -&gt; monad.of(Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e)))</span>
<span class="fc" id="L1016">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L1018">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L1029">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L1031">              Objects.requireNonNull(</span>
<span class="fc" id="L1032">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L1044">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth step in a filterable for-comprehension, holding a tuple of five results.
   */
  public static final class FilterableSteps5&lt;M, A, B, C, D, E&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L1055">    private FilterableSteps5(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L1056">      this.monad = monad;</span>
<span class="fc" id="L1057">      this.computation = computation;</span>
<span class="fc" id="L1058">    }</span>

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps5&lt;M, A, B, C, D, E&gt; when(Predicate&lt;Tuple5&lt;A, B, C, D, E&gt;&gt; filter) {
<span class="fc" id="L1067">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L1068">          monad.flatMap(</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">              abcde -&gt; filter.test(abcde) ? monad.of(abcde) : monad.zero(), this.computation);</span>
<span class="fc" id="L1070">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L1081">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L1083">              Objects.requireNonNull(</span>
<span class="fc" id="L1084">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L1096">      return monad.map(f, computation);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>