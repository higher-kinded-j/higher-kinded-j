<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>For.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">For.java</span></div><h1>For.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.function.Function5;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.hkt.tuple.Tuple4;
import org.higherkindedj.hkt.tuple.Tuple5;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;

/**
 * Provides a statically-typed, fluent for-comprehension builder for monadic types, simulating a
 * feature common in languages like Scala.
 *
 * &lt;p&gt;For-comprehensions offer a convenient and readable syntax for composing sequences of monadic
 * operations (like {@code flatMap} and {@code map}). This builder de-sugars the comprehension into
 * a series of monadic calls, guiding the user through the composition process while ensuring type
 * safety at each step.
 *
 * &lt;h3&gt;Usage&lt;/h3&gt;
 *
 * &lt;p&gt;A comprehension is a chain of operations that includes generators, bindings, filters, and a
 * final projection:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Generators ({@code .from(...)}):&lt;/b&gt; These are the core of the comprehension, equivalent
 *       to a {@code flatMap}. Each generator takes a value from a previous step and produces a new
 *       monadic value, which is then flattened into the ongoing computation. The results of all
 *       generators are accumulated in a tuple.
 *   &lt;li&gt;&lt;b&gt;Bindings ({@code .let(...)}):&lt;/b&gt; Binds the result of a pure computation to a new
 *       variable in the comprehension's scope. This is equivalent to a {@code map} operation that
 *       adds the computed value to the accumulated tuple.
 *   &lt;li&gt;&lt;b&gt;Filters ({@code .when(...)}):&lt;/b&gt; Filters the results based on a predicate. If the
 *       predicate returns {@code false}, the computation for that path is short-circuited. This
 *       operation is only available for monads that implement {@link MonadZero}, which provides an
 *       &quot;empty&quot; or &quot;zero&quot; element (e.g., an empty list, {@code Optional.empty()}).
 *   &lt;li&gt;&lt;b&gt;Projection ({@code .yield(...)}):&lt;/b&gt; Concludes the comprehension by applying a function
 *       to the accumulated results from all previous steps, producing the final monadic value.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example with List (a {@code MonadZero})&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Imports for context
 * import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
 * import java.util.Arrays;
 *
 * ListMonad listMonad = ListMonad.INSTANCE;
 * Kind&lt;ListKind.Witness, Integer&gt; list1 = LIST.widen(Arrays.asList(1, 2, 3));
 * Kind&lt;ListKind.Witness, Integer&gt; list2 = LIST.widen(Arrays.asList(10, 20));
 *
 * // Equivalent to Scala: for { a &lt;- list1; b &lt;- list2 if (a+b) % 2 != 0; c = &quot;Sum: &quot; + (a+b) } yield s&quot;$a + $b = $c&quot;
 * Kind&lt;ListKind.Witness, String&gt; result =
 * For.from(listMonad, list1)                       // Generator: a &lt;- list1
 * .from(a -&gt; list2)                             // Generator: b &lt;- list2
 * .when(t -&gt; (t._1() + t._2()) % 2 != 0)        // Filter: if (a+b) is odd
 * .let(t -&gt; &quot;Sum: &quot; + (t._1() + t._2()))        // Binding: c = &quot;Sum: &quot; + (a+b)
 * .yield((a, b, c) -&gt; a + &quot;+&quot; + b + &quot; = &quot; + c); // Projection
 *
 * List&lt;String&gt; finalResult = LIST.narrow(result);
 * // finalResult: [&quot;1+10 = Sum: 11&quot;, &quot;1+20 = Sum: 21&quot;, &quot;3+10 = Sum: 13&quot;, &quot;3+20 = Sum: 23&quot;]
 * }&lt;/pre&gt;
 *
 * @see Monad
 * @see MonadZero
 * @see Kind
 */
public final class For {

  private static final String YIELD_CANNOT_RETURN_NULL = &quot;The yield function must not return null.&quot;;

  private For() {} // Static access only

  /**
   * Initiates a for-comprehension for any {@link Monad}. The resulting builder chain will not
   * support filtering with {@code .when(...)}.
   *
   * @param monad The Monad instance that defines the behaviour of {@code flatMap} and {@code map}.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the builder, ready for the next operation.
   */
  public static &lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; MonadicSteps1&lt;M, A&gt; from(
      Monad&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L101">    return new MonadicSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * Initiates a for-comprehension for a {@link MonadZero}. The resulting builder chain supports
   * filtering with {@code .when(...)}.
   *
   * @param monad The MonadZero instance, providing {@code zero()} for filtering.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the filterable builder, ready for the next operation.
   */
  public static &lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FilterableSteps1&lt;M, A&gt; from(
      MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L116">    return new FilterableSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * A marker interface for all builder steps, ensuring they can be permitted by a sealed interface.
   * This is an internal detail to organise the different step types.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   */
  public sealed interface Steps&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;&gt;
      permits MonadicSteps1,
          MonadicSteps2,
          MonadicSteps3,
          MonadicSteps4,
          MonadicSteps5,
          FilterableSteps1,
          FilterableSteps2,
          FilterableSteps3,
          FilterableSteps4,
          FilterableSteps5 {}

  // --- Monadic (Non-Filterable) Steps ---

  /**
   * Represents the first step in a non-filterable for-comprehension, holding a single monadic
   * value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class MonadicSteps1&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
      implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L151">    private MonadicSteps1(Monad&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L152">      this.monad = monad;</span>
<span class="fc" id="L153">      this.computation = computation;</span>
<span class="fc" id="L154">    }</span>

    /**
     * Binds the result of another monadic computation (a generator).
     *
     * &lt;p&gt;This corresponds to a {@code flatMap} operation. The function {@code next} is applied to
     * the result of the first step, and the resulting monadic value is flattened into the
     * comprehension.
     *
     * @param next A function that takes the result of the first step (type {@code A}) and returns a
     *     new monadic computation {@code Kind&lt;M, B&gt;}.
     * @param &lt;B&gt; The value type of the new monadic computation.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L170">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L171">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L172">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Binds the result of a pure computation.
     *
     * &lt;p&gt;This corresponds to a {@code map} operation. The function {@code f} is applied to the
     * result of the first step to produce a new value, which is then carried along in the
     * comprehension.
     *
     * @param f A function that takes the result of the first step (type {@code A}) and returns a
     *     pure value of type {@code B}.
     * @param &lt;B&gt; The type of the computed value.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L189">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L190">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L191">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * &lt;p&gt;This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value. The extracted value is accumulated
     * alongside the original value.
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     *
     * &lt;pre&gt;{@code
     * record User(String name, Address address) {}
     * record Address(String city) {}
     *
     * Lens&lt;User, Address&gt; addressLens = Lens.of(User::address, User::withAddress);
     *
     * Kind&lt;IdKind.Witness, String&gt; result =
     *     For.from(idMonad, Id.of(new User(&quot;Alice&quot;, new Address(&quot;NYC&quot;))))
     *         .focus(addressLens)
     *         .yield((user, address) -&gt; user.name() + &quot; lives in &quot; + address.city());
     * // Result: &quot;Alice lives in NYC&quot;
     * }&lt;/pre&gt;
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param &lt;B&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; focus(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L225">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L226">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L227">          monad.map(a -&gt; Tuple.of(a, lens.get(a)), this.computation);</span>
<span class="fc" id="L228">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value of type {@code A} into the result type
     *     {@code R}.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L240">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a non-filterable for-comprehension, holding a tuple of two
   * results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class MonadicSteps2&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B&gt;
      implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L257">    private MonadicSteps2(Monad&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L258">      this.monad = monad;</span>
<span class="fc" id="L259">      this.computation = computation;</span>
<span class="fc" id="L260">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L272">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L273">          monad.flatMap(</span>
<span class="fc" id="L274">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L276">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L289">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L290">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L291">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * &lt;p&gt;This is a more flexible version of {@code focus} that allows extracting values based on
     * the entire accumulated state.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;C&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking three values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; focus(Function&lt;Tuple2&lt;A, B&gt;, C&gt; extractor) {
<span class="fc" id="L307">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L308">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L309">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), extractor.apply(ab)), this.computation);</span>
<span class="fc" id="L310">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results ({@code A}, {@code B}) into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L321">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results (a {@code Tuple2&lt;A, B&gt;}) into a
     *     final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L333">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a non-filterable for-comprehension, holding a tuple of three
   * results.
   */
  public static final class MonadicSteps3&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C&gt;
      implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L346">    private MonadicSteps3(Monad&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L347">      this.monad = monad;</span>
<span class="fc" id="L348">      this.computation = computation;</span>
<span class="fc" id="L349">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 3-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L360">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L361">          monad.flatMap(</span>
<span class="fc" id="L362">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L364">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 3-tuple of results and returning a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L375">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L376">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L377">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;D&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking four values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; focus(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; extractor) {
<span class="fc" id="L390">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L391">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L392">          monad.map(</span>
<span class="fc" id="L393">              abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), extractor.apply(abc)),</span>
              this.computation);
<span class="fc" id="L395">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L406">      return monad.map(</span>
<span class="fc" id="L407">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L419">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a non-filterable for-comprehension, holding a tuple of four
   * results.
   */
  public static final class MonadicSteps4&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C, D&gt;
      implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L432">    private MonadicSteps4(Monad&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L433">      this.monad = monad;</span>
<span class="fc" id="L434">      this.computation = computation;</span>
<span class="fc" id="L435">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 4-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; from(Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L446">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L447">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L449">                  monad.map(</span>
<span class="fc" id="L450">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L451">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L453">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 4-tuple of results and returning a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L464">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L465">          monad.map(</span>
<span class="fc" id="L466">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L468">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;E&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking five values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; focus(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; extractor) {
<span class="fc" id="L481">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L482">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L483">          monad.map(</span>
<span class="fc" id="L484">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), extractor.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L486">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L497">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L499">              Objects.requireNonNull(</span>
<span class="fc" id="L500">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L512">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth (and final supported) step in a non-filterable for-comprehension, holding
   * a tuple of five results.
   */
  public static final class MonadicSteps5&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C, D, E&gt;
      implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L525">    private MonadicSteps5(Monad&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L526">      this.monad = monad;</span>
<span class="fc" id="L527">      this.computation = computation;</span>
<span class="fc" id="L528">    }</span>

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L538">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L540">              Objects.requireNonNull(</span>
<span class="fc" id="L541">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L553">      return monad.map(f, computation);</span>
    }
  }

  // --- Filterable Steps (for MonadZero) ---

  /**
   * Represents the first step in a filterable for-comprehension, holding a single monadic value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class FilterableSteps1&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
      implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L570">    private FilterableSteps1(MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L571">      this.monad = monad;</span>
<span class="fc" id="L572">      this.computation = computation;</span>
<span class="fc" id="L573">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;B&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L583">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L584">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L585">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;B&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L596">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L597">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L598">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate. If the predicate returns
     * {@code false}, the comprehension short-circuits for that path by using the monad's {@link
     * MonadZero#zero()} element (e.g., an empty list).
     *
     * @param filter The predicate to apply to the current value {@code A}.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps1&lt;M, A&gt; when(Predicate&lt;A&gt; filter) {
<span class="fc" id="L610">      Kind&lt;M, A&gt; newComputation =</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">          monad.flatMap(a -&gt; filter.test(a) ? monad.of(a) : monad.zero(), this.computation);</span>
<span class="fc" id="L612">      return new FilterableSteps1&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * &lt;p&gt;This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value.
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param &lt;B&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; focus(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L630">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L631">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L632">          monad.map(a -&gt; Tuple.of(a, lens.get(a)), this.computation);</span>
<span class="fc" id="L633">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using the provided {@link Prism}. If the prism matches, the
     * extracted value is added to the accumulated tuple. If it doesn't match, the computation
     * short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * &lt;p&gt;This provides type-safe pattern matching within for-comprehensions, eliminating the need
     * for {@code instanceof} checks and casts.
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     *
     * &lt;pre&gt;{@code
     * sealed interface Result permits Success, Failure {}
     * record Success(String value) implements Result {}
     * record Failure(String error) implements Result {}
     *
     * Prism&lt;Result, Success&gt; successPrism = Prism.of(
     *     r -&gt; r instanceof Success s ? Optional.of(s) : Optional.empty(),
     *     s -&gt; s
     * );
     *
     * Kind&lt;MaybeKind.Witness, String&gt; result =
     *     For.from(maybeMonad, MAYBE.just(someResult))
     *         .match(successPrism)
     *         .yield((original, success) -&gt; success.value());
     * // Returns Just(value) if someResult is Success, Nothing otherwise
     * }&lt;/pre&gt;
     *
     * @param prism The {@link Prism} to use for pattern matching.
     * @param &lt;B&gt; The type of the extracted value when the prism matches.
     * @return The next step in the builder if the prism matches, or short-circuits to zero.
     * @throws NullPointerException if {@code prism} is null.
     * @see Prism
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; match(Prism&lt;A, B&gt; prism) {
<span class="fc" id="L670">      Objects.requireNonNull(prism, &quot;prism must not be null&quot;);</span>
<span class="fc" id="L671">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L672">          monad.flatMap(</span>
<span class="fc" id="L673">              a -&gt; prism.getOptional(a).map(b -&gt; monad.of(Tuple.of(a, b))).orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L675">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L686">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a filterable for-comprehension, holding a tuple of two results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class FilterableSteps2&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B&gt;
      implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L702">    private FilterableSteps2(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L703">      this.monad = monad;</span>
<span class="fc" id="L704">      this.computation = computation;</span>
<span class="fc" id="L705">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L715">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L716">          monad.flatMap(</span>
<span class="fc" id="L717">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L719">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L730">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L731">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L732">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps2&lt;M, A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; filter) {
<span class="fc" id="L742">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">          monad.flatMap(ab -&gt; filter.test(ab) ? monad.of(ab) : monad.zero(), this.computation);</span>
<span class="fc" id="L744">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;C&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking three values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; focus(Function&lt;Tuple2&lt;A, B&gt;, C&gt; extractor) {
<span class="fc" id="L757">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L758">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L759">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), extractor.apply(ab)), this.computation);</span>
<span class="fc" id="L760">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;C&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; match(Function&lt;Tuple2&lt;A, B&gt;, Optional&lt;C&gt;&gt; matcher) {
<span class="fc" id="L775">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L776">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L777">          monad.flatMap(</span>
              ab -&gt;
                  matcher
<span class="fc" id="L780">                      .apply(ab)</span>
<span class="fc" id="L781">                      .map(c -&gt; monad.of(Tuple.of(ab._1(), ab._2(), c)))</span>
<span class="fc" id="L782">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L784">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L795">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L806">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a filterable for-comprehension, holding a tuple of three results.
   */
  public static final class FilterableSteps3&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C&gt;
      implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L818">    private FilterableSteps3(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L819">      this.monad = monad;</span>
<span class="fc" id="L820">      this.computation = computation;</span>
<span class="fc" id="L821">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L831">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L832">          monad.flatMap(</span>
<span class="fc" id="L833">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L835">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L846">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L847">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L848">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps3&lt;M, A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; filter) {
<span class="fc" id="L858">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">          monad.flatMap(abc -&gt; filter.test(abc) ? monad.of(abc) : monad.zero(), this.computation);</span>
<span class="fc" id="L860">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;D&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking four values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; focus(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; extractor) {
<span class="fc" id="L873">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L874">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L875">          monad.map(</span>
<span class="fc" id="L876">              abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), extractor.apply(abc)),</span>
              this.computation);
<span class="fc" id="L878">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;D&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; match(
        Function&lt;Tuple3&lt;A, B, C&gt;, Optional&lt;D&gt;&gt; matcher) {
<span class="fc" id="L894">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L895">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L896">          monad.flatMap(</span>
              abc -&gt;
                  matcher
<span class="fc" id="L899">                      .apply(abc)</span>
<span class="fc" id="L900">                      .map(d -&gt; monad.of(Tuple.of(abc._1(), abc._2(), abc._3(), d)))</span>
<span class="fc" id="L901">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L903">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L914">      return monad.map(</span>
<span class="fc" id="L915">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L927">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a filterable for-comprehension, holding a tuple of four results.
   */
  public static final class FilterableSteps4&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C, D&gt;
      implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L939">    private FilterableSteps4(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L940">      this.monad = monad;</span>
<span class="fc" id="L941">      this.computation = computation;</span>
<span class="fc" id="L942">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; from(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L953">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L954">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L956">                  monad.map(</span>
<span class="fc" id="L957">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L958">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L960">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L971">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L972">          monad.map(</span>
<span class="fc" id="L973">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L975">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps4&lt;M, A, B, C, D&gt; when(Predicate&lt;Tuple4&lt;A, B, C, D&gt;&gt; filter) {
<span class="fc" id="L985">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L986">          monad.flatMap(</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">              abcd -&gt; filter.test(abcd) ? monad.of(abcd) : monad.zero(), this.computation);</span>
<span class="fc" id="L988">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Extracts a value using a function that accesses the current tuple and adds the result to the
     * accumulated tuple.
     *
     * @param extractor A function that takes the current tuple and returns the extracted value.
     * @param &lt;E&gt; The type of the extracted value.
     * @return The next step in the builder, now tracking five values.
     * @throws NullPointerException if {@code extractor} is null.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; focus(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; extractor) {
<span class="fc" id="L1001">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L1002">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L1003">          monad.map(</span>
<span class="fc" id="L1004">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), extractor.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L1006">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Attempts to extract a value using a function that returns an {@link Optional}. If the
     * optional is present, the extracted value is added to the accumulated tuple. If it's empty,
     * the computation short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * @param matcher A function that takes the current tuple and returns an optional extracted
     *     value.
     * @param &lt;E&gt; The type of the extracted value when present.
     * @return The next step in the builder if the match succeeds, or short-circuits to zero.
     * @throws NullPointerException if {@code matcher} is null.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; match(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, Optional&lt;E&gt;&gt; matcher) {
<span class="fc" id="L1022">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L1023">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L1024">          monad.flatMap(</span>
              abcd -&gt;
                  matcher
<span class="fc" id="L1027">                      .apply(abcd)</span>
<span class="fc" id="L1028">                      .map(e -&gt; monad.of(Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e)))</span>
<span class="fc" id="L1029">                      .orElseGet(monad::zero),</span>
              this.computation);
<span class="fc" id="L1031">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L1042">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L1044">              Objects.requireNonNull(</span>
<span class="fc" id="L1045">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L1057">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth step in a filterable for-comprehension, holding a tuple of five results.
   */
  public static final class FilterableSteps5&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C, D, E&gt;
      implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L1069">    private FilterableSteps5(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L1070">      this.monad = monad;</span>
<span class="fc" id="L1071">      this.computation = computation;</span>
<span class="fc" id="L1072">    }</span>

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps5&lt;M, A, B, C, D, E&gt; when(Predicate&lt;Tuple5&lt;A, B, C, D, E&gt;&gt; filter) {
<span class="fc" id="L1081">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L1082">          monad.flatMap(</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">              abcde -&gt; filter.test(abcde) ? monad.of(abcde) : monad.zero(), this.computation);</span>
<span class="fc" id="L1084">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L1095">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L1097">              Objects.requireNonNull(</span>
<span class="fc" id="L1098">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L1110">      return monad.map(f, computation);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>