<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>For.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">For.java</span></div><h1>For.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.function.Function5;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.hkt.tuple.Tuple4;
import org.higherkindedj.hkt.tuple.Tuple5;

/**
 * Provides a statically-typed, fluent for-comprehension builder for monadic types, simulating a
 * feature common in languages like Scala.
 *
 * &lt;p&gt;For-comprehensions offer a convenient and readable syntax for composing sequences of monadic
 * operations (like {@code flatMap} and {@code map}). This builder de-sugars the comprehension into
 * a series of monadic calls, guiding the user through the composition process while ensuring type
 * safety at each step.
 *
 * &lt;h3&gt;Usage&lt;/h3&gt;
 *
 * &lt;p&gt;A comprehension is a chain of operations that includes generators, bindings, filters, and a
 * final projection:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Generators ({@code .from(...)}):&lt;/b&gt; These are the core of the comprehension, equivalent
 *       to a {@code flatMap}. Each generator takes a value from a previous step and produces a new
 *       monadic value, which is then flattened into the ongoing computation. The results of all
 *       generators are accumulated in a tuple.
 *   &lt;li&gt;&lt;b&gt;Bindings ({@code .let(...)}):&lt;/b&gt; Binds the result of a pure computation to a new
 *       variable in the comprehension's scope. This is equivalent to a {@code map} operation that
 *       adds the computed value to the accumulated tuple.
 *   &lt;li&gt;&lt;b&gt;Filters ({@code .when(...)}):&lt;/b&gt; Filters the results based on a predicate. If the
 *       predicate returns {@code false}, the computation for that path is short-circuited. This
 *       operation is only available for monads that implement {@link MonadZero}, which provides an
 *       &quot;empty&quot; or &quot;zero&quot; element (e.g., an empty list, {@code Optional.empty()}).
 *   &lt;li&gt;&lt;b&gt;Projection ({@code .yield(...)}):&lt;/b&gt; Concludes the comprehension by applying a function
 *       to the accumulated results from all previous steps, producing the final monadic value.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example with List (a {@code MonadZero})&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Imports for context
 * import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
 * import java.util.Arrays;
 *
 * ListMonad listMonad = ListMonad.INSTANCE;
 * Kind&lt;ListKind.Witness, Integer&gt; list1 = LIST.widen(Arrays.asList(1, 2, 3));
 * Kind&lt;ListKind.Witness, Integer&gt; list2 = LIST.widen(Arrays.asList(10, 20));
 *
 * // Equivalent to Scala: for { a &lt;- list1; b &lt;- list2 if (a+b) % 2 != 0; c = &quot;Sum: &quot; + (a+b) } yield s&quot;$a + $b = $c&quot;
 * Kind&lt;ListKind.Witness, String&gt; result =
 * For.from(listMonad, list1)                       // Generator: a &lt;- list1
 * .from(a -&gt; list2)                             // Generator: b &lt;- list2
 * .when(t -&gt; (t._1() + t._2()) % 2 != 0)        // Filter: if (a+b) is odd
 * .let(t -&gt; &quot;Sum: &quot; + (t._1() + t._2()))        // Binding: c = &quot;Sum: &quot; + (a+b)
 * .yield((a, b, c) -&gt; a + &quot;+&quot; + b + &quot; = &quot; + c); // Projection
 *
 * List&lt;String&gt; finalResult = LIST.narrow(result);
 * // finalResult: [&quot;1+10 = Sum: 11&quot;, &quot;1+20 = Sum: 21&quot;, &quot;3+10 = Sum: 13&quot;, &quot;3+20 = Sum: 23&quot;]
 * }&lt;/pre&gt;
 *
 * @see Monad
 * @see MonadZero
 * @see Kind
 */
public final class For {

  private static final String YIELD_CANNOT_RETURN_NULL = &quot;The yield function must not return null.&quot;;

  private For() {} // Static access only

  /**
   * Initiates a for-comprehension for any {@link Monad}. The resulting builder chain will not
   * support filtering with {@code .when(...)}.
   *
   * @param monad The Monad instance that defines the behaviour of {@code flatMap} and {@code map}.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the builder, ready for the next operation.
   */
  public static &lt;M, A&gt; MonadicSteps1&lt;M, A&gt; from(Monad&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L95">    return new MonadicSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * Initiates a for-comprehension for a {@link MonadZero}. The resulting builder chain supports
   * filtering with {@code .when(...)}.
   *
   * @param monad The MonadZero instance, providing {@code zero()} for filtering.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the source.
   * @return The first step of the filterable builder, ready for the next operation.
   */
  public static &lt;M, A&gt; FilterableSteps1&lt;M, A&gt; from(MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; source) {
<span class="fc" id="L109">    return new FilterableSteps1&lt;&gt;(monad, source);</span>
  }

  /**
   * A marker interface for all builder steps, ensuring they can be permitted by a sealed interface.
   * This is an internal detail to organise the different step types.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   */
  public sealed interface Steps&lt;M&gt;
      permits MonadicSteps1,
          MonadicSteps2,
          MonadicSteps3,
          MonadicSteps4,
          MonadicSteps5,
          FilterableSteps1,
          FilterableSteps2,
          FilterableSteps3,
          FilterableSteps4,
          FilterableSteps5 {}

  // --- Monadic (Non-Filterable) Steps ---

  /**
   * Represents the first step in a non-filterable for-comprehension, holding a single monadic
   * value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class MonadicSteps1&lt;M, A&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L143">    private MonadicSteps1(Monad&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L144">      this.monad = monad;</span>
<span class="fc" id="L145">      this.computation = computation;</span>
<span class="fc" id="L146">    }</span>

    /**
     * Binds the result of another monadic computation (a generator).
     *
     * &lt;p&gt;This corresponds to a {@code flatMap} operation. The function {@code next} is applied to
     * the result of the first step, and the resulting monadic value is flattened into the
     * comprehension.
     *
     * @param next A function that takes the result of the first step (type {@code A}) and returns a
     *     new monadic computation {@code Kind&lt;M, B&gt;}.
     * @param &lt;B&gt; The value type of the new monadic computation.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L162">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L163">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L164">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Binds the result of a pure computation.
     *
     * &lt;p&gt;This corresponds to a {@code map} operation. The function {@code f} is applied to the
     * result of the first step to produce a new value, which is then carried along in the
     * comprehension.
     *
     * @param f A function that takes the result of the first step (type {@code A}) and returns a
     *     pure value of type {@code B}.
     * @param &lt;B&gt; The type of the computed value.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2&lt;A, B&gt;}.
     */
    public &lt;B&gt; MonadicSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L181">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L182">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L183">      return new MonadicSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value of type {@code A} into the result type
     *     {@code R}.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L195">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a non-filterable for-comprehension, holding a tuple of two
   * results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class MonadicSteps2&lt;M, A, B&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L211">    private MonadicSteps2(Monad&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L212">      this.monad = monad;</span>
<span class="fc" id="L213">      this.computation = computation;</span>
<span class="fc" id="L214">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L226">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L227">          monad.flatMap(</span>
<span class="fc" id="L228">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L230">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function that takes the current tuple of results (a {@code Tuple2&lt;A, B&gt;}) and
     *     returns a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results as a {@code Tuple3&lt;A, B,
     *     C&gt;}.
     */
    public &lt;C&gt; MonadicSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L243">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L244">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L245">      return new MonadicSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results ({@code A}, {@code B}) into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L256">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results (a {@code Tuple2&lt;A, B&gt;}) into a
     *     final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L268">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a non-filterable for-comprehension, holding a tuple of three
   * results.
   */
  public static final class MonadicSteps3&lt;M, A, B, C&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L280">    private MonadicSteps3(Monad&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L281">      this.monad = monad;</span>
<span class="fc" id="L282">      this.computation = computation;</span>
<span class="fc" id="L283">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 3-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L294">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L295">          monad.flatMap(</span>
<span class="fc" id="L296">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L298">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 3-tuple of results and returning a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; MonadicSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L309">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L310">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L311">      return new MonadicSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L322">      return monad.map(</span>
<span class="fc" id="L323">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L335">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a non-filterable for-comprehension, holding a tuple of four
   * results.
   */
  public static final class MonadicSteps4&lt;M, A, B, C, D&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L347">    private MonadicSteps4(Monad&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L348">      this.monad = monad;</span>
<span class="fc" id="L349">      this.computation = computation;</span>
<span class="fc" id="L350">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function taking the current 4-tuple of results and returning a new monadic
     *     computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; from(Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L361">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L362">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L364">                  monad.map(</span>
<span class="fc" id="L365">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L366">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L368">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function taking the current 4-tuple of results and returning a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; MonadicSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L379">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L380">          monad.map(</span>
<span class="fc" id="L381">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L383">      return new MonadicSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L394">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L396">              Objects.requireNonNull(</span>
<span class="fc" id="L397">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L409">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth (and final supported) step in a non-filterable for-comprehension, holding
   * a tuple of five results.
   */
  public static final class MonadicSteps5&lt;M, A, B, C, D, E&gt; implements Steps&lt;M&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L421">    private MonadicSteps5(Monad&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L422">      this.monad = monad;</span>
<span class="fc" id="L423">      this.computation = computation;</span>
<span class="fc" id="L424">    }</span>

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L434">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L436">              Objects.requireNonNull(</span>
<span class="fc" id="L437">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results into a final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L449">      return monad.map(f, computation);</span>
    }
  }

  // --- Filterable Steps (for MonadZero) ---

  /**
   * Represents the first step in a filterable for-comprehension, holding a single monadic value.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the initial computation.
   */
  public static final class FilterableSteps1&lt;M, A&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, A&gt; computation;

<span class="fc" id="L465">    private FilterableSteps1(MonadZero&lt;M&gt; monad, Kind&lt;M, A&gt; computation) {</span>
<span class="fc" id="L466">      this.monad = monad;</span>
<span class="fc" id="L467">      this.computation = computation;</span>
<span class="fc" id="L468">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;B&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; from(Function&lt;A, Kind&lt;M, B&gt;&gt; next) {
<span class="fc" id="L478">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L479">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a)), this.computation);</span>
<span class="fc" id="L480">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;B&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking two results.
     */
    public &lt;B&gt; FilterableSteps2&lt;M, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L491">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc" id="L492">          monad.map(a -&gt; Tuple.of(a, f.apply(a)), this.computation);</span>
<span class="fc" id="L493">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate. If the predicate returns
     * {@code false}, the comprehension short-circuits for that path by using the monad's {@link
     * MonadZero#zero()} element (e.g., an empty list).
     *
     * @param filter The predicate to apply to the current value {@code A}.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps1&lt;M, A&gt; when(Predicate&lt;A&gt; filter) {
<span class="fc" id="L505">      Kind&lt;M, A&gt; newComputation =</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">          monad.flatMap(a -&gt; filter.test(a) ? monad.of(a) : monad.zero(), this.computation);</span>
<span class="fc" id="L507">      return new FilterableSteps1&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L518">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the second step in a filterable for-comprehension, holding a tuple of two results.
   *
   * @param &lt;M&gt; The witness type of the Monad.
   * @param &lt;A&gt; The value type of the first result.
   * @param &lt;B&gt; The value type of the second result.
   */
  public static final class FilterableSteps2&lt;M, A, B&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L533">    private FilterableSteps2(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L534">      this.monad = monad;</span>
<span class="fc" id="L535">      this.computation = computation;</span>
<span class="fc" id="L536">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;C&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, Kind&lt;M, C&gt;&gt; next) {
<span class="fc" id="L546">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L547">          monad.flatMap(</span>
<span class="fc" id="L548">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab)),</span>
              this.computation);
<span class="fc" id="L550">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;C&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking three results.
     */
    public &lt;C&gt; FilterableSteps3&lt;M, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L561">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc" id="L562">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), this.computation);</span>
<span class="fc" id="L563">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps2&lt;M, A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; filter) {
<span class="fc" id="L573">      Kind&lt;M, Tuple2&lt;A, B&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">          monad.flatMap(ab -&gt; filter.test(ab) ? monad.of(ab) : monad.zero(), this.computation);</span>
<span class="fc" id="L575">      return new FilterableSteps2&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the two accumulated values.
     *
     * @param f A function that combines the two results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L586">      return monad.map(t -&gt; f.apply(t._1(), t._2()), computation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L597">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the third step in a filterable for-comprehension, holding a tuple of three results.
   */
  public static final class FilterableSteps3&lt;M, A, B, C&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L608">    private FilterableSteps3(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L609">      this.monad = monad;</span>
<span class="fc" id="L610">      this.computation = computation;</span>
<span class="fc" id="L611">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;D&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, Kind&lt;M, D&gt;&gt; next) {
<span class="fc" id="L621">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L622">          monad.flatMap(</span>
<span class="fc" id="L623">              abc -&gt; monad.map(d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d), next.apply(abc)),</span>
              this.computation);
<span class="fc" id="L625">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;D&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking four results.
     */
    public &lt;D&gt; FilterableSteps4&lt;M, A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L636">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L637">          monad.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), this.computation);</span>
<span class="fc" id="L638">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps3&lt;M, A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; filter) {
<span class="fc" id="L648">      Kind&lt;M, Tuple3&lt;A, B, C&gt;&gt; newComputation =</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">          monad.flatMap(abc -&gt; filter.test(abc) ? monad.of(abc) : monad.zero(), this.computation);</span>
<span class="fc" id="L650">      return new FilterableSteps3&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the three accumulated values.
     *
     * @param f A function that combines the three results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L661">      return monad.map(</span>
<span class="fc" id="L662">          t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L674">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fourth step in a filterable for-comprehension, holding a tuple of four results.
   */
  public static final class FilterableSteps4&lt;M, A, B, C, D&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L685">    private FilterableSteps4(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L686">      this.monad = monad;</span>
<span class="fc" id="L687">      this.computation = computation;</span>
<span class="fc" id="L688">    }</span>

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param &lt;E&gt; The value type of the new computation.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; from(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, Kind&lt;M, E&gt;&gt; next) {
<span class="fc" id="L699">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L700">          monad.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L702">                  monad.map(</span>
<span class="fc" id="L703">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L704">                      next.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L706">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param &lt;E&gt; The type of the new computed value.
     * @return The next step in the builder, now tracking five results.
     */
    public &lt;E&gt; FilterableSteps5&lt;M, A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L717">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L718">          monad.map(</span>
<span class="fc" id="L719">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              this.computation);
<span class="fc" id="L721">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps4&lt;M, A, B, C, D&gt; when(Predicate&lt;Tuple4&lt;A, B, C, D&gt;&gt; filter) {
<span class="fc" id="L731">      Kind&lt;M, Tuple4&lt;A, B, C, D&gt;&gt; newComputation =</span>
<span class="fc" id="L732">          monad.flatMap(</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">              abcd -&gt; filter.test(abcd) ? monad.of(abcd) : monad.zero(), this.computation);</span>
<span class="fc" id="L734">      return new FilterableSteps4&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the four accumulated values.
     *
     * @param f A function that combines the four results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L745">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L747">              Objects.requireNonNull(</span>
<span class="fc" id="L748">                  f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L760">      return monad.map(f, computation);</span>
    }
  }

  /**
   * Represents the fifth step in a filterable for-comprehension, holding a tuple of five results.
   */
  public static final class FilterableSteps5&lt;M, A, B, C, D, E&gt; implements Steps&lt;M&gt; {
    private final MonadZero&lt;M&gt; monad;
    private final Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L771">    private FilterableSteps5(MonadZero&lt;M&gt; monad, Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L772">      this.monad = monad;</span>
<span class="fc" id="L773">      this.computation = computation;</span>
<span class="fc" id="L774">    }</span>

    /**
     * Filters the results of the comprehension based on a predicate.
     *
     * @param filter The predicate to apply to the tuple of results.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps5&lt;M, A, B, C, D, E&gt; when(Predicate&lt;Tuple5&lt;A, B, C, D, E&gt;&gt; filter) {
<span class="fc" id="L783">      Kind&lt;M, Tuple5&lt;A, B, C, D, E&gt;&gt; newComputation =</span>
<span class="fc" id="L784">          monad.flatMap(</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">              abcde -&gt; filter.test(abcde) ? monad.of(abcde) : monad.zero(), this.computation);</span>
<span class="fc" id="L786">      return new FilterableSteps5&lt;&gt;(monad, newComputation);</span>
    }

    /**
     * Completes the comprehension by yielding a final result from the five accumulated values.
     *
     * @param f A function that combines the five results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L797">      return monad.map(</span>
          t -&gt;
<span class="fc" id="L799">              Objects.requireNonNull(</span>
<span class="fc" id="L800">                  f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
          computation);
    }

    /**
     * Completes the comprehension by yielding a final result from the tuple of accumulated values.
     *
     * @param f A function that transforms the tuple of results.
     * @param &lt;R&gt; The final result type.
     * @return A monadic value of type {@code R}.
     */
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L812">      return monad.map(f, computation);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>