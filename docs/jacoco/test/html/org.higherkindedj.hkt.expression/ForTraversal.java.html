<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ForTraversal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">ForTraversal.java</span></div><h1>ForTraversal.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;

/**
 * Provides a fluent builder for traversal-based comprehensions, enabling bulk operations over
 * structures using {@link Traversal} optics within an {@link Applicative} context.
 *
 * &lt;p&gt;This class bridges the gap between for-comprehensions and traversals, allowing declarative
 * bulk updates, transformations, and queries over multiple elements focused by a traversal.
 *
 * &lt;h3&gt;Key Features&lt;/h3&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Bulk transformations:&lt;/b&gt; Apply functions to all focused elements
 *   &lt;li&gt;&lt;b&gt;Effectful operations:&lt;/b&gt; Transform elements within an applicative context
 *   &lt;li&gt;&lt;b&gt;Filtering:&lt;/b&gt; Skip elements that don't match a predicate
 *   &lt;li&gt;&lt;b&gt;Lens integration:&lt;/b&gt; Modify specific fields within each focused element
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example Usage&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * record Player(String name, int score) {}
 *
 * Traversal&lt;List&lt;Player&gt;, Player&gt; playersTraversal = Traversals.forList();
 * Lens&lt;Player, Integer&gt; scoreLens = Lens.of(Player::score, (p, s) -&gt; new Player(p.name(), s));
 *
 * List&lt;Player&gt; players = List.of(new Player(&quot;Alice&quot;, 100), new Player(&quot;Bob&quot;, 200));
 *
 * // Double all scores
 * List&lt;Player&gt; updated = ForTraversal.over(playersTraversal, players, idApplicative)
 *     .modify(scoreLens, score -&gt; score * 2)
 *     .run();
 *
 * // Filter and modify only high scorers
 * List&lt;Player&gt; updated2 = ForTraversal.over(playersTraversal, players, idApplicative)
 *     .filter(p -&gt; p.score() &gt;= 150)
 *     .modify(scoreLens, score -&gt; score + 50)
 *     .run();
 * }&lt;/pre&gt;
 *
 * @see Traversal
 * @see Applicative
 */
public final class ForTraversal {

  private ForTraversal() {} // Static access only

  /**
   * Starts a traversal-based comprehension over elements of a structure.
   *
   * @param traversal The {@link Traversal} that focuses on the elements to operate on.
   * @param source The source structure containing the elements.
   * @param applicative The {@link Applicative} instance for the effect context.
   * @param &lt;F&gt; The witness type for the applicative context.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused elements.
   * @return A {@link TraversalSteps} builder for chaining operations.
   * @throws NullPointerException if any argument is null.
   */
  public static &lt;F, S, A&gt; TraversalSteps&lt;F, S, A&gt; over(
      Traversal&lt;S, A&gt; traversal, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L74">    Objects.requireNonNull(traversal, &quot;traversal must not be null&quot;);</span>
<span class="fc" id="L75">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L76">    Objects.requireNonNull(applicative, &quot;applicative must not be null&quot;);</span>
<span class="fc" id="L77">    return new TraversalStepsImpl&lt;&gt;(traversal, source, applicative, applicative::of);</span>
  }

  /**
   * A builder interface for chaining operations on traversal-focused elements.
   *
   * @param &lt;F&gt; The witness type for the applicative context.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused elements.
   */
  public interface TraversalSteps&lt;F, S, A&gt; {

    /**
     * Filters elements, only applying subsequent operations to those that match the predicate.
     *
     * &lt;p&gt;Elements that don't match are preserved unchanged in the structure during modifications.
     *
     * @param predicate The predicate to test elements against.
     * @return A new builder with the filter applied.
     * @throws NullPointerException if {@code predicate} is null.
     */
    TraversalSteps&lt;F, S, A&gt; filter(Predicate&lt;A&gt; predicate);

    /**
     * Modifies a specific field within each focused element using a lens.
     *
     * @param lens The lens focusing on the field to modify.
     * @param modifier The function to apply to the field.
     * @param &lt;B&gt; The type of the field being modified.
     * @return A new builder with the modification applied.
     * @throws NullPointerException if any argument is null.
     */
    &lt;B&gt; TraversalSteps&lt;F, S, A&gt; modify(Lens&lt;A, B&gt; lens, Function&lt;B, B&gt; modifier);

    /**
     * Sets a specific field within each focused element using a lens.
     *
     * @param lens The lens focusing on the field to set.
     * @param value The new value for the field.
     * @param &lt;B&gt; The type of the field being set.
     * @return A new builder with the field set.
     * @throws NullPointerException if {@code lens} is null.
     */
    &lt;B&gt; TraversalSteps&lt;F, S, A&gt; set(Lens&lt;A, B&gt; lens, B value);

    /**
     * Completes the traversal and returns the modified structure wrapped in the applicative
     * context.
     *
     * @return The modified structure in the applicative context.
     */
    Kind&lt;F, S&gt; run();

    /**
     * Collects all focused elements into a list.
     *
     * &lt;p&gt;Note: This operation extracts the current state of elements and collects them. It does not
     * apply any pending transformations that would modify the structure.
     *
     * @return A list of all focused elements in the applicative context.
     */
    Kind&lt;F, List&lt;A&gt;&gt; toList();
  }

  /** Implementation of the traversal steps builder. */
  private static final class TraversalStepsImpl&lt;F, S, A&gt; implements TraversalSteps&lt;F, S, A&gt; {
    private final Traversal&lt;S, A&gt; traversal;
    private final S source;
    private final Applicative&lt;F&gt; applicative;
    private final Function&lt;A, Kind&lt;F, A&gt;&gt; transformation;
    private final Predicate&lt;A&gt; filterPredicate;

    TraversalStepsImpl(
        Traversal&lt;S, A&gt; traversal,
        S source,
        Applicative&lt;F&gt; applicative,
        Function&lt;A, Kind&lt;F, A&gt;&gt; transformation) {
<span class="fc" id="L154">      this(traversal, source, applicative, transformation, a -&gt; true);</span>
<span class="fc" id="L155">    }</span>

    TraversalStepsImpl(
        Traversal&lt;S, A&gt; traversal,
        S source,
        Applicative&lt;F&gt; applicative,
        Function&lt;A, Kind&lt;F, A&gt;&gt; transformation,
<span class="fc" id="L162">        Predicate&lt;A&gt; filterPredicate) {</span>
<span class="fc" id="L163">      this.traversal = traversal;</span>
<span class="fc" id="L164">      this.source = source;</span>
<span class="fc" id="L165">      this.applicative = applicative;</span>
<span class="fc" id="L166">      this.transformation = transformation;</span>
<span class="fc" id="L167">      this.filterPredicate = filterPredicate;</span>
<span class="fc" id="L168">    }</span>

    @Override
    public TraversalSteps&lt;F, S, A&gt; filter(Predicate&lt;A&gt; predicate) {
<span class="fc" id="L172">      Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
      // Combine predicates: both must pass
<span class="fc" id="L174">      return new TraversalStepsImpl&lt;&gt;(</span>
<span class="fc" id="L175">          traversal, source, applicative, transformation, filterPredicate.and(predicate));</span>
    }

    @Override
    public &lt;B&gt; TraversalSteps&lt;F, S, A&gt; modify(Lens&lt;A, B&gt; lens, Function&lt;B, B&gt; modifier) {
<span class="fc" id="L180">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L181">      Objects.requireNonNull(modifier, &quot;modifier must not be null&quot;);</span>

      // Only modify elements that pass the filter predicate
<span class="fc" id="L184">      Function&lt;A, Kind&lt;F, A&gt;&gt; modifiedTransformation =</span>
          a -&gt;
<span class="fc bfc" id="L186" title="All 2 branches covered.">              filterPredicate.test(a)</span>
<span class="fc" id="L187">                  ? applicative.map(newA -&gt; lens.modify(modifier, newA), transformation.apply(a))</span>
<span class="fc" id="L188">                  : transformation.apply(a);</span>

<span class="fc" id="L190">      return new TraversalStepsImpl&lt;&gt;(</span>
          traversal, source, applicative, modifiedTransformation, filterPredicate);
    }

    @Override
    public &lt;B&gt; TraversalSteps&lt;F, S, A&gt; set(Lens&lt;A, B&gt; lens, B value) {
<span class="fc" id="L196">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>

      // Only set on elements that pass the filter predicate
<span class="fc" id="L199">      Function&lt;A, Kind&lt;F, A&gt;&gt; setTransformation =</span>
          a -&gt;
<span class="fc bfc" id="L201" title="All 2 branches covered.">              filterPredicate.test(a)</span>
<span class="fc" id="L202">                  ? applicative.map(newA -&gt; lens.set(value, newA), transformation.apply(a))</span>
<span class="fc" id="L203">                  : transformation.apply(a);</span>

<span class="fc" id="L205">      return new TraversalStepsImpl&lt;&gt;(</span>
          traversal, source, applicative, setTransformation, filterPredicate);
    }

    @Override
    public Kind&lt;F, S&gt; run() {
<span class="fc" id="L211">      return traversal.modifyF(transformation, source, applicative);</span>
    }

    @Override
    public Kind&lt;F, List&lt;A&gt;&gt; toList() {
      // Collect all elements using a list-building traversal
<span class="fc" id="L217">      List&lt;A&gt; collected = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L218">      traversal.modifyF(</span>
          a -&gt; {
<span class="fc" id="L220">            collected.add(a);</span>
<span class="fc" id="L221">            return applicative.of(a);</span>
          },
          source,
          applicative);
<span class="fc" id="L225">      return applicative.of(collected);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>