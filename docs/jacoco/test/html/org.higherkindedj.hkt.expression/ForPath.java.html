<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ForPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">ForPath.java</span></div><h1>ForPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.GenericPath;
import org.higherkindedj.hkt.effect.IOPath;
import org.higherkindedj.hkt.effect.IdPath;
import org.higherkindedj.hkt.effect.MaybePath;
import org.higherkindedj.hkt.effect.NonDetPath;
import org.higherkindedj.hkt.effect.OptionalPath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.effect.TryPath;
import org.higherkindedj.hkt.effect.VTaskPath;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.either.EitherKind;
import org.higherkindedj.hkt.either.EitherKindHelper;
import org.higherkindedj.hkt.either.EitherMonad;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.function.Function5;
import org.higherkindedj.hkt.id.IdKind;
import org.higherkindedj.hkt.id.IdKindHelper;
import org.higherkindedj.hkt.id.IdMonad;
import org.higherkindedj.hkt.io.IOKind;
import org.higherkindedj.hkt.io.IOKindHelper;
import org.higherkindedj.hkt.io.IOMonad;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListKindHelper;
import org.higherkindedj.hkt.list.ListMonad;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeKindHelper;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.optional.OptionalKind;
import org.higherkindedj.hkt.optional.OptionalKindHelper;
import org.higherkindedj.hkt.optional.OptionalMonad;
import org.higherkindedj.hkt.trymonad.TryKind;
import org.higherkindedj.hkt.trymonad.TryKindHelper;
import org.higherkindedj.hkt.trymonad.TryMonad;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.hkt.tuple.Tuple4;
import org.higherkindedj.hkt.tuple.Tuple5;
import org.higherkindedj.hkt.vtask.VTaskKind;
import org.higherkindedj.hkt.vtask.VTaskKindHelper;
import org.higherkindedj.hkt.vtask.VTaskMonad;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPath;

/**
 * Path-native for-comprehension builder that works directly with Effect Path types.
 *
 * &lt;p&gt;This class bridges the gap between the {@link For} comprehension system and the Effect Path
 * API, allowing users to compose Path types using for-comprehension style while preserving Path
 * semantics and returning Path types directly.
 *
 * &lt;h2&gt;Motivation&lt;/h2&gt;
 *
 * &lt;p&gt;The standard {@link For} class works with raw {@link Kind} values and {@link Monad} instances,
 * requiring manual extraction and rewrapping when working with Path types. {@code ForPath} provides
 * a seamless experience:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Entry points accept Path types directly
 *   &lt;li&gt;All operations preserve Path types
 *   &lt;li&gt;{@code yield} returns Path types
 *   &lt;li&gt;Full FocusPath/AffinePath integration
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Usage Examples&lt;/h2&gt;
 *
 * &lt;h3&gt;MaybePath Comprehension&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * MaybePath&lt;String&gt; result = ForPath.from(Path.just(user))
 *     .from(u -&gt; Path.maybe(u.getAddress()))       // flatMap
 *     .let(addr -&gt; addr.getCity())                  // map
 *     .when(t -&gt; !t._2().isEmpty())                 // filter
 *     .yield((user, addr, city) -&gt; city + &quot;, &quot; + addr.getCountry());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;EitherPath Comprehension&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * EitherPath&lt;Error, Order&gt; result = ForPath.from(Path.&lt;Error, User&gt;right(user))
 *     .from(u -&gt; validateUser(u))                   // returns EitherPath
 *     .from((u, valid) -&gt; createOrder(u))           // returns EitherPath
 *     .yield((user, validated, order) -&gt; order);
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;With FocusPath Integration&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * FocusPath&lt;User, Address&gt; addressPath = UserFocus.address();
 *
 * MaybePath&lt;String&gt; city = ForPath.from(Path.just(user))
 *     .focus(addressPath)                           // extract address
 *     .yield((user, address) -&gt; address.getCity());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;With AffinePath (Optional Focus)&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * AffinePath&lt;User, Email&gt; emailPath = UserFocus.optionalEmail();
 *
 * MaybePath&lt;String&gt; email = ForPath.from(Path.just(user))
 *     .match(emailPath)                             // extract optional email
 *     .yield((user, email) -&gt; email.toString());
 * // Returns Nothing if user has no email
 * }&lt;/pre&gt;
 *
 * @see For
 * @see Path
 * @see Chainable
 * @see FocusPath
 * @see AffinePath
 */
public final class ForPath {

  private static final String YIELD_CANNOT_RETURN_NULL = &quot;The yield function must not return null.&quot;;

  private ForPath() {} // Static access only

  // ===== MaybePath Entry Points =====

  /**
   * Initiates a for-comprehension with a MaybePath.
   *
   * &lt;p&gt;MaybePath supports filtering via {@code when()}, making it a filterable comprehension.
   *
   * @param source the initial MaybePath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; MaybePathSteps1&lt;A&gt; from(MaybePath&lt;A&gt; source) {
<span class="fc" id="L146">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L147">    return new MaybePathSteps1&lt;&gt;(source);</span>
  }

  // ===== OptionalPath Entry Points =====

  /**
   * Initiates a for-comprehension with an OptionalPath.
   *
   * &lt;p&gt;OptionalPath supports filtering via {@code when()}, making it a filterable comprehension.
   *
   * @param source the initial OptionalPath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; OptionalPathSteps1&lt;A&gt; from(OptionalPath&lt;A&gt; source) {
<span class="fc" id="L162">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L163">    return new OptionalPathSteps1&lt;&gt;(source);</span>
  }

  // ===== EitherPath Entry Points =====

  /**
   * Initiates a for-comprehension with an EitherPath.
   *
   * @param source the initial EitherPath
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;E, A&gt; EitherPathSteps1&lt;E, A&gt; from(EitherPath&lt;E, A&gt; source) {
<span class="fc" id="L177">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L178">    return new EitherPathSteps1&lt;&gt;(source);</span>
  }

  // ===== TryPath Entry Points =====

  /**
   * Initiates a for-comprehension with a TryPath.
   *
   * @param source the initial TryPath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; TryPathSteps1&lt;A&gt; from(TryPath&lt;A&gt; source) {
<span class="fc" id="L191">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L192">    return new TryPathSteps1&lt;&gt;(source);</span>
  }

  // ===== IOPath Entry Points =====

  /**
   * Initiates a for-comprehension with an IOPath.
   *
   * @param source the initial IOPath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; IOPathSteps1&lt;A&gt; from(IOPath&lt;A&gt; source) {
<span class="fc" id="L205">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L206">    return new IOPathSteps1&lt;&gt;(source);</span>
  }

  // ===== VTaskPath Entry Points =====

  /**
   * Initiates a for-comprehension with a VTaskPath.
   *
   * &lt;p&gt;VTaskPath computations execute on virtual threads, providing lightweight concurrency.
   *
   * @param source the initial VTaskPath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; VTaskPathSteps1&lt;A&gt; from(VTaskPath&lt;A&gt; source) {
<span class="fc" id="L221">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L222">    return new VTaskPathSteps1&lt;&gt;(source);</span>
  }

  // ===== IdPath Entry Points =====

  /**
   * Initiates a for-comprehension with an IdPath.
   *
   * @param source the initial IdPath
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;A&gt; IdPathSteps1&lt;A&gt; from(IdPath&lt;A&gt; source) {
<span class="fc" id="L235">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L236">    return new IdPathSteps1&lt;&gt;(source);</span>
  }

  // ===== NonDetPath (List) Entry Points =====

  /**
   * Initiates a for-comprehension with a NonDetPath (list with Cartesian product semantics).
   *
   * &lt;p&gt;NonDetPath supports filtering via {@code when()}, making it a filterable comprehension.
   *
   * @param source the initial NonDetPath
   * @param &lt;A&gt; the element type
   * @return the first step of the builder
   */
  public static &lt;A&gt; NonDetPathSteps1&lt;A&gt; from(NonDetPath&lt;A&gt; source) {
<span class="fc" id="L251">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L252">    return new NonDetPathSteps1&lt;&gt;(source);</span>
  }

  // ===== Generic Entry Point =====

  /**
   * Initiates a for-comprehension with a GenericPath.
   *
   * &lt;p&gt;This is the escape hatch for custom monad types not covered by specific entry points.
   *
   * @param source the initial GenericPath
   * @param &lt;F&gt; the witness type
   * @param &lt;A&gt; the value type
   * @return the first step of the builder
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; GenericPathSteps1&lt;F, A&gt; from(
      GenericPath&lt;F, A&gt; source) {
<span class="fc" id="L269">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L270">    return new GenericPathSteps1&lt;&gt;(source);</span>
  }

  // ========================================================================
  // MaybePath Steps (Filterable)
  // ========================================================================

  /** First step in a MaybePath comprehension. */
  public static final class MaybePathSteps1&lt;A&gt; {
<span class="fc" id="L279">    private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;</span>
    private final Kind&lt;MaybeKind.Witness, A&gt; computation;

<span class="fc" id="L282">    private MaybePathSteps1(MaybePath&lt;A&gt; source) {</span>
<span class="fc" id="L283">      this.computation = MaybeKindHelper.MAYBE.widen(source.run());</span>
<span class="fc" id="L284">    }</span>

<span class="fc" id="L286">    private MaybePathSteps1(Kind&lt;MaybeKind.Witness, A&gt; computation) {</span>
<span class="fc" id="L287">      this.computation = computation;</span>
<span class="fc" id="L288">    }</span>

    /**
     * Adds a generator that produces another MaybePath.
     *
     * @param next function producing the next MaybePath
     * @param &lt;B&gt; the new value type
     * @return the next step
     */
    public &lt;B&gt; MaybePathSteps2&lt;A, B&gt; from(Function&lt;A, MaybePath&lt;B&gt;&gt; next) {
<span class="fc" id="L298">      Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L299">          MONAD.flatMap(</span>
<span class="fc" id="L300">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), MaybeKindHelper.MAYBE.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L302">      return new MaybePathSteps2&lt;&gt;(newComp);</span>
    }

    /**
     * Binds the result of a pure computation.
     *
     * @param f the pure computation
     * @param &lt;B&gt; the result type
     * @return the next step
     */
    public &lt;B&gt; MaybePathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L313">      Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L314">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L315">      return new MaybePathSteps2&lt;&gt;(newComp);</span>
    }

    /**
     * Extracts a value using a FocusPath.
     *
     * @param focusPath the lens to apply
     * @param &lt;B&gt; the focused type
     * @return the next step
     */
    public &lt;B&gt; MaybePathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L326">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L327">      Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L328">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L329">      return new MaybePathSteps2&lt;&gt;(newComp);</span>
    }

    /**
     * Pattern matches using an AffinePath, short-circuiting if the match fails.
     *
     * @param affinePath the optional focus to apply
     * @param &lt;B&gt; the focused type
     * @return the next step
     */
    public &lt;B&gt; MaybePathSteps2&lt;A, B&gt; match(AffinePath&lt;A, B&gt; affinePath) {
<span class="fc" id="L340">      Objects.requireNonNull(affinePath, &quot;affinePath must not be null&quot;);</span>
<span class="fc" id="L341">      Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L342">          MONAD.flatMap(</span>
              a -&gt;
                  affinePath
<span class="fc" id="L345">                      .getOptional(a)</span>
<span class="fc" id="L346">                      .map(b -&gt; MONAD.of(Tuple.of(a, b)))</span>
<span class="fc" id="L347">                      .orElseGet(MONAD::zero),</span>
              computation);
<span class="fc" id="L349">      return new MaybePathSteps2&lt;&gt;(newComp);</span>
    }

    /**
     * Filters the value based on a predicate.
     *
     * @param predicate the filter condition
     * @return this step with the filter applied
     */
    public MaybePathSteps1&lt;A&gt; when(Predicate&lt;A&gt; predicate) {
<span class="fc" id="L359">      Kind&lt;MaybeKind.Witness, A&gt; newComp =</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">          MONAD.flatMap(a -&gt; predicate.test(a) ? MONAD.of(a) : MONAD.zero(), computation);</span>
<span class="fc" id="L361">      return new MaybePathSteps1&lt;&gt;(newComp);</span>
    }

    /**
     * Completes the comprehension by yielding a final result.
     *
     * @param f the yield function
     * @param &lt;R&gt; the result type
     * @return the resulting MaybePath
     */
    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L372">      Kind&lt;MaybeKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L373">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }
  }

  /** Second step in a MaybePath comprehension. */
  public static final class MaybePathSteps2&lt;A, B&gt; {
<span class="fc" id="L379">    private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;</span>
    private final Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L382">    private MaybePathSteps2(Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L383">      this.computation = computation;</span>
<span class="fc" id="L384">    }</span>

    public &lt;C&gt; MaybePathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, MaybePath&lt;C&gt;&gt; next) {
<span class="fc" id="L387">      Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L388">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L390">                  MONAD.map(</span>
<span class="fc" id="L391">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L392">                      MaybeKindHelper.MAYBE.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L394">      return new MaybePathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; MaybePathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L398">      Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L399">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L400">      return new MaybePathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; MaybePathSteps3&lt;A, B, C&gt; focus(Function&lt;Tuple2&lt;A, B&gt;, C&gt; extractor) {
<span class="fc" id="L404">      Objects.requireNonNull(extractor, &quot;extractor must not be null&quot;);</span>
<span class="fc" id="L405">      return let(extractor);</span>
    }

    public &lt;C&gt; MaybePathSteps3&lt;A, B, C&gt; match(Function&lt;Tuple2&lt;A, B&gt;, Optional&lt;C&gt;&gt; matcher) {
<span class="fc" id="L409">      Objects.requireNonNull(matcher, &quot;matcher must not be null&quot;);</span>
<span class="fc" id="L410">      Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L411">          MONAD.flatMap(</span>
              ab -&gt;
                  matcher
<span class="fc" id="L414">                      .apply(ab)</span>
<span class="fc" id="L415">                      .map(c -&gt; MONAD.of(Tuple.of(ab._1(), ab._2(), c)))</span>
<span class="fc" id="L416">                      .orElseGet(MONAD::zero),</span>
              computation);
<span class="fc" id="L418">      return new MaybePathSteps3&lt;&gt;(newComp);</span>
    }

    public MaybePathSteps2&lt;A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; predicate) {
<span class="fc" id="L422">      Kind&lt;MaybeKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">          MONAD.flatMap(ab -&gt; predicate.test(ab) ? MONAD.of(ab) : MONAD.zero(), computation);</span>
<span class="fc" id="L424">      return new MaybePathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L428">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L429">          MONAD.map(</span>
<span class="fc" id="L430">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L432">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L436">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L437">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L438">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }
  }

  /** Third step in a MaybePath comprehension. */
  public static final class MaybePathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L444">    private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;</span>
    private final Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L447">    private MaybePathSteps3(Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L448">      this.computation = computation;</span>
<span class="fc" id="L449">    }</span>

    public &lt;D&gt; MaybePathSteps4&lt;A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, MaybePath&lt;D&gt;&gt; next) {
<span class="fc" id="L452">      Kind&lt;MaybeKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; newComp =</span>
<span class="fc" id="L453">          MONAD.flatMap(</span>
              abc -&gt;
<span class="fc" id="L455">                  MONAD.map(</span>
<span class="fc" id="L456">                      d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d),</span>
<span class="fc" id="L457">                      MaybeKindHelper.MAYBE.widen(next.apply(abc).run())),</span>
              computation);
<span class="fc" id="L459">      return new MaybePathSteps4&lt;&gt;(newComp);</span>
    }

    public &lt;D&gt; MaybePathSteps4&lt;A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L463">      Kind&lt;MaybeKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; newComp =</span>
<span class="fc" id="L464">          MONAD.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), computation);</span>
<span class="fc" id="L465">      return new MaybePathSteps4&lt;&gt;(newComp);</span>
    }

    public MaybePathSteps3&lt;A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; predicate) {
<span class="fc" id="L469">      Kind&lt;MaybeKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">          MONAD.flatMap(abc -&gt; predicate.test(abc) ? MONAD.of(abc) : MONAD.zero(), computation);</span>
<span class="fc" id="L471">      return new MaybePathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L475">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L476">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L478">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L480">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L484">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L485">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L486">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }
  }

  /** Fourth step in a MaybePath comprehension. */
  public static final class MaybePathSteps4&lt;A, B, C, D&gt; {
<span class="fc" id="L492">    private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;</span>
    private final Kind&lt;MaybeKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L495">    private MaybePathSteps4(Kind&lt;MaybeKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L496">      this.computation = computation;</span>
<span class="fc" id="L497">    }</span>

    public &lt;E&gt; MaybePathSteps5&lt;A, B, C, D, E&gt; from(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, MaybePath&lt;E&gt;&gt; next) {
<span class="fc" id="L501">      Kind&lt;MaybeKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; newComp =</span>
<span class="fc" id="L502">          MONAD.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L504">                  MONAD.map(</span>
<span class="fc" id="L505">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L506">                      MaybeKindHelper.MAYBE.widen(next.apply(abcd).run())),</span>
              computation);
<span class="fc" id="L508">      return new MaybePathSteps5&lt;&gt;(newComp);</span>
    }

    public &lt;E&gt; MaybePathSteps5&lt;A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L512">      Kind&lt;MaybeKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; newComp =</span>
<span class="fc" id="L513">          MONAD.map(</span>
<span class="fc" id="L514">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              computation);
<span class="fc" id="L516">      return new MaybePathSteps5&lt;&gt;(newComp);</span>
    }

    public MaybePathSteps4&lt;A, B, C, D&gt; when(Predicate&lt;Tuple4&lt;A, B, C, D&gt;&gt; predicate) {
<span class="fc" id="L520">      Kind&lt;MaybeKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; newComp =</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">          MONAD.flatMap(abcd -&gt; predicate.test(abcd) ? MONAD.of(abcd) : MONAD.zero(), computation);</span>
<span class="fc" id="L522">      return new MaybePathSteps4&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L526">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L527">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L529">                  Objects.requireNonNull(</span>
<span class="fc" id="L530">                      f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L532">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L536">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L537">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L538">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }
  }

  /** Fifth step in a MaybePath comprehension. */
  public static final class MaybePathSteps5&lt;A, B, C, D, E&gt; {
<span class="fc" id="L544">    private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;</span>
    private final Kind&lt;MaybeKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L547">    private MaybePathSteps5(Kind&lt;MaybeKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L548">      this.computation = computation;</span>
<span class="fc" id="L549">    }</span>

    public MaybePathSteps5&lt;A, B, C, D, E&gt; when(Predicate&lt;Tuple5&lt;A, B, C, D, E&gt;&gt; predicate) {
<span class="fc" id="L552">      Kind&lt;MaybeKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; newComp =</span>
<span class="fc" id="L553">          MONAD.flatMap(</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">              abcde -&gt; predicate.test(abcde) ? MONAD.of(abcde) : MONAD.zero(), computation);</span>
<span class="fc" id="L555">      return new MaybePathSteps5&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L559">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L560">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L562">                  Objects.requireNonNull(</span>
<span class="fc" id="L563">                      f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L565">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }

    public &lt;R&gt; MaybePath&lt;R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L569">      Kind&lt;MaybeKind.Witness, R&gt; result =</span>
<span class="fc" id="L570">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L571">      return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));</span>
    }
  }

  // ========================================================================
  // OptionalPath Steps (Filterable)
  // ========================================================================

  /** First step in an OptionalPath comprehension. */
  public static final class OptionalPathSteps1&lt;A&gt; {
<span class="fc" id="L581">    private static final OptionalMonad MONAD = OptionalMonad.INSTANCE;</span>
    private final Kind&lt;OptionalKind.Witness, A&gt; computation;

<span class="fc" id="L584">    private OptionalPathSteps1(OptionalPath&lt;A&gt; source) {</span>
<span class="fc" id="L585">      this.computation = OptionalKindHelper.OPTIONAL.widen(source.run());</span>
<span class="fc" id="L586">    }</span>

<span class="fc" id="L588">    private OptionalPathSteps1(Kind&lt;OptionalKind.Witness, A&gt; computation) {</span>
<span class="fc" id="L589">      this.computation = computation;</span>
<span class="fc" id="L590">    }</span>

    public &lt;B&gt; OptionalPathSteps2&lt;A, B&gt; from(Function&lt;A, OptionalPath&lt;B&gt;&gt; next) {
<span class="fc" id="L593">      Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L594">          MONAD.flatMap(</span>
              a -&gt;
<span class="fc" id="L596">                  MONAD.map(</span>
<span class="fc" id="L597">                      b -&gt; Tuple.of(a, b), OptionalKindHelper.OPTIONAL.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L599">      return new OptionalPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; OptionalPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L603">      Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L604">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L605">      return new OptionalPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; OptionalPathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L609">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L610">      Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L611">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L612">      return new OptionalPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; OptionalPathSteps2&lt;A, B&gt; match(AffinePath&lt;A, B&gt; affinePath) {
<span class="fc" id="L616">      Objects.requireNonNull(affinePath, &quot;affinePath must not be null&quot;);</span>
<span class="fc" id="L617">      Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L618">          MONAD.flatMap(</span>
              a -&gt;
                  affinePath
<span class="fc" id="L621">                      .getOptional(a)</span>
<span class="fc" id="L622">                      .map(b -&gt; MONAD.of(Tuple.of(a, b)))</span>
<span class="fc" id="L623">                      .orElseGet(MONAD::zero),</span>
              computation);
<span class="fc" id="L625">      return new OptionalPathSteps2&lt;&gt;(newComp);</span>
    }

    public OptionalPathSteps1&lt;A&gt; when(Predicate&lt;A&gt; predicate) {
<span class="fc" id="L629">      Kind&lt;OptionalKind.Witness, A&gt; newComp =</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">          MONAD.flatMap(a -&gt; predicate.test(a) ? MONAD.of(a) : MONAD.zero(), computation);</span>
<span class="fc" id="L631">      return new OptionalPathSteps1&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; OptionalPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L635">      Kind&lt;OptionalKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L636">      return Path.optional(OptionalKindHelper.OPTIONAL.narrow(result));</span>
    }
  }

  /** Second step in an OptionalPath comprehension. */
  public static final class OptionalPathSteps2&lt;A, B&gt; {
<span class="fc" id="L642">    private static final OptionalMonad MONAD = OptionalMonad.INSTANCE;</span>
    private final Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L645">    private OptionalPathSteps2(Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L646">      this.computation = computation;</span>
<span class="fc" id="L647">    }</span>

    public &lt;C&gt; OptionalPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, OptionalPath&lt;C&gt;&gt; next) {
<span class="fc" id="L650">      Kind&lt;OptionalKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L651">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L653">                  MONAD.map(</span>
<span class="fc" id="L654">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L655">                      OptionalKindHelper.OPTIONAL.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L657">      return new OptionalPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; OptionalPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L661">      Kind&lt;OptionalKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L662">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L663">      return new OptionalPathSteps3&lt;&gt;(newComp);</span>
    }

    public OptionalPathSteps2&lt;A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; predicate) {
<span class="fc" id="L667">      Kind&lt;OptionalKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">          MONAD.flatMap(ab -&gt; predicate.test(ab) ? MONAD.of(ab) : MONAD.zero(), computation);</span>
<span class="fc" id="L669">      return new OptionalPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; OptionalPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L673">      Kind&lt;OptionalKind.Witness, R&gt; result =</span>
<span class="fc" id="L674">          MONAD.map(</span>
<span class="fc" id="L675">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L677">      return Path.optional(OptionalKindHelper.OPTIONAL.narrow(result));</span>
    }

    public &lt;R&gt; OptionalPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L681">      Kind&lt;OptionalKind.Witness, R&gt; result =</span>
<span class="fc" id="L682">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L683">      return Path.optional(OptionalKindHelper.OPTIONAL.narrow(result));</span>
    }
  }

  /** Third step in an OptionalPath comprehension. */
  public static final class OptionalPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L689">    private static final OptionalMonad MONAD = OptionalMonad.INSTANCE;</span>
    private final Kind&lt;OptionalKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L692">    private OptionalPathSteps3(Kind&lt;OptionalKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L693">      this.computation = computation;</span>
<span class="fc" id="L694">    }</span>

    public OptionalPathSteps3&lt;A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; predicate) {
<span class="fc" id="L697">      Kind&lt;OptionalKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">          MONAD.flatMap(abc -&gt; predicate.test(abc) ? MONAD.of(abc) : MONAD.zero(), computation);</span>
<span class="fc" id="L699">      return new OptionalPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; OptionalPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L703">      Kind&lt;OptionalKind.Witness, R&gt; result =</span>
<span class="fc" id="L704">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L706">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L708">      return Path.optional(OptionalKindHelper.OPTIONAL.narrow(result));</span>
    }

    public &lt;R&gt; OptionalPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L712">      Kind&lt;OptionalKind.Witness, R&gt; result =</span>
<span class="fc" id="L713">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L714">      return Path.optional(OptionalKindHelper.OPTIONAL.narrow(result));</span>
    }
  }

  // ========================================================================
  // EitherPath Steps (Non-Filterable)
  // ========================================================================

  /** First step in an EitherPath comprehension. */
  public static final class EitherPathSteps1&lt;E, A&gt; {
    private final Kind&lt;EitherKind.Witness&lt;E&gt;, A&gt; computation;

    private static &lt;E&gt; EitherMonad&lt;E&gt; monad() {
<span class="fc" id="L727">      return EitherMonad.instance();</span>
    }

<span class="fc" id="L730">    private EitherPathSteps1(EitherPath&lt;E, A&gt; source) {</span>
<span class="fc" id="L731">      this.computation = EitherKindHelper.EITHER.widen(source.run());</span>
<span class="fc" id="L732">    }</span>

    public &lt;B&gt; EitherPathSteps2&lt;E, A, B&gt; from(Function&lt;A, EitherPath&lt;E, B&gt;&gt; next) {
<span class="fc" id="L735">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L736">      Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L737">          m.flatMap(</span>
<span class="fc" id="L738">              a -&gt; m.map(b -&gt; Tuple.of(a, b), EitherKindHelper.EITHER.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L740">      return new EitherPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; EitherPathSteps2&lt;E, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L744">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L745">      Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L746">          m.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L747">      return new EitherPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; EitherPathSteps2&lt;E, A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L751">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L752">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L753">      Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L754">          m.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L755">      return new EitherPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; EitherPath&lt;E, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L759">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L760">      Kind&lt;EitherKind.Witness&lt;E&gt;, R&gt; result = m.map(f, computation);</span>
<span class="fc" id="L761">      return Path.either(EitherKindHelper.EITHER.narrow(result));</span>
    }
  }

  /** Second step in an EitherPath comprehension. */
  public static final class EitherPathSteps2&lt;E, A, B&gt; {
    private final Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple2&lt;A, B&gt;&gt; computation;

    private static &lt;E&gt; EitherMonad&lt;E&gt; monad() {
<span class="fc" id="L770">      return EitherMonad.instance();</span>
    }

<span class="fc" id="L773">    private EitherPathSteps2(Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L774">      this.computation = computation;</span>
<span class="fc" id="L775">    }</span>

    public &lt;C&gt; EitherPathSteps3&lt;E, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, EitherPath&lt;E, C&gt;&gt; next) {
<span class="fc" id="L778">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L779">      Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L780">          m.flatMap(</span>
              ab -&gt;
<span class="fc" id="L782">                  m.map(</span>
<span class="fc" id="L783">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L784">                      EitherKindHelper.EITHER.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L786">      return new EitherPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; EitherPathSteps3&lt;E, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L790">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L791">      Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L792">          m.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L793">      return new EitherPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; EitherPath&lt;E, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L797">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L798">      Kind&lt;EitherKind.Witness&lt;E&gt;, R&gt; result =</span>
<span class="fc" id="L799">          m.map(</span>
<span class="fc" id="L800">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L802">      return Path.either(EitherKindHelper.EITHER.narrow(result));</span>
    }

    public &lt;R&gt; EitherPath&lt;E, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L806">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L807">      Kind&lt;EitherKind.Witness&lt;E&gt;, R&gt; result =</span>
<span class="fc" id="L808">          m.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L809">      return Path.either(EitherKindHelper.EITHER.narrow(result));</span>
    }
  }

  /** Third step in an EitherPath comprehension. */
  public static final class EitherPathSteps3&lt;E, A, B, C&gt; {
    private final Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple3&lt;A, B, C&gt;&gt; computation;

    private static &lt;E&gt; EitherMonad&lt;E&gt; monad() {
<span class="fc" id="L818">      return EitherMonad.instance();</span>
    }

<span class="fc" id="L821">    private EitherPathSteps3(Kind&lt;EitherKind.Witness&lt;E&gt;, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L822">      this.computation = computation;</span>
<span class="fc" id="L823">    }</span>

    public &lt;R&gt; EitherPath&lt;E, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L826">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L827">      Kind&lt;EitherKind.Witness&lt;E&gt;, R&gt; result =</span>
<span class="fc" id="L828">          m.map(</span>
              t -&gt;
<span class="fc" id="L830">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L832">      return Path.either(EitherKindHelper.EITHER.narrow(result));</span>
    }

    public &lt;R&gt; EitherPath&lt;E, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L836">      EitherMonad&lt;E&gt; m = monad();</span>
<span class="fc" id="L837">      Kind&lt;EitherKind.Witness&lt;E&gt;, R&gt; result =</span>
<span class="fc" id="L838">          m.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L839">      return Path.either(EitherKindHelper.EITHER.narrow(result));</span>
    }
  }

  // ========================================================================
  // TryPath Steps
  // ========================================================================

  /** First step in a TryPath comprehension. */
  public static final class TryPathSteps1&lt;A&gt; {
<span class="fc" id="L849">    private static final TryMonad MONAD = TryMonad.INSTANCE;</span>
    private final Kind&lt;TryKind.Witness, A&gt; computation;

<span class="fc" id="L852">    private TryPathSteps1(TryPath&lt;A&gt; source) {</span>
<span class="fc" id="L853">      this.computation = TryKindHelper.TRY.widen(source.run());</span>
<span class="fc" id="L854">    }</span>

    public &lt;B&gt; TryPathSteps2&lt;A, B&gt; from(Function&lt;A, TryPath&lt;B&gt;&gt; next) {
<span class="fc" id="L857">      Kind&lt;TryKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L858">          MONAD.flatMap(</span>
<span class="fc" id="L859">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), TryKindHelper.TRY.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L861">      return new TryPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; TryPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L865">      Kind&lt;TryKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L866">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L867">      return new TryPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; TryPathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L871">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L872">      Kind&lt;TryKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L873">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L874">      return new TryPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; TryPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L878">      Kind&lt;TryKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L879">      return Path.tryPath(TryKindHelper.TRY.narrow(result));</span>
    }
  }

  /** Second step in a TryPath comprehension. */
  public static final class TryPathSteps2&lt;A, B&gt; {
<span class="fc" id="L885">    private static final TryMonad MONAD = TryMonad.INSTANCE;</span>
    private final Kind&lt;TryKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L888">    private TryPathSteps2(Kind&lt;TryKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L889">      this.computation = computation;</span>
<span class="fc" id="L890">    }</span>

    public &lt;C&gt; TryPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, TryPath&lt;C&gt;&gt; next) {
<span class="fc" id="L893">      Kind&lt;TryKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L894">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L896">                  MONAD.map(</span>
<span class="fc" id="L897">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L898">                      TryKindHelper.TRY.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L900">      return new TryPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; TryPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L904">      Kind&lt;TryKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L905">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L906">      return new TryPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; TryPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L910">      Kind&lt;TryKind.Witness, R&gt; result =</span>
<span class="fc" id="L911">          MONAD.map(</span>
<span class="fc" id="L912">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L914">      return Path.tryPath(TryKindHelper.TRY.narrow(result));</span>
    }

    public &lt;R&gt; TryPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L918">      Kind&lt;TryKind.Witness, R&gt; result =</span>
<span class="fc" id="L919">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L920">      return Path.tryPath(TryKindHelper.TRY.narrow(result));</span>
    }
  }

  /** Third step in a TryPath comprehension. */
  public static final class TryPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L926">    private static final TryMonad MONAD = TryMonad.INSTANCE;</span>
    private final Kind&lt;TryKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L929">    private TryPathSteps3(Kind&lt;TryKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L930">      this.computation = computation;</span>
<span class="fc" id="L931">    }</span>

    public &lt;R&gt; TryPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L934">      Kind&lt;TryKind.Witness, R&gt; result =</span>
<span class="fc" id="L935">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L937">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L939">      return Path.tryPath(TryKindHelper.TRY.narrow(result));</span>
    }

    public &lt;R&gt; TryPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L943">      Kind&lt;TryKind.Witness, R&gt; result =</span>
<span class="fc" id="L944">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L945">      return Path.tryPath(TryKindHelper.TRY.narrow(result));</span>
    }
  }

  // ========================================================================
  // IOPath Steps
  // ========================================================================

  /** First step in an IOPath comprehension. */
  public static final class IOPathSteps1&lt;A&gt; {
<span class="fc" id="L955">    private static final IOMonad MONAD = IOMonad.INSTANCE;</span>
    private final Kind&lt;IOKind.Witness, A&gt; computation;

<span class="fc" id="L958">    private IOPathSteps1(IOPath&lt;A&gt; source) {</span>
<span class="fc" id="L959">      this.computation = IOKindHelper.IO_OP.widen(source.run());</span>
<span class="fc" id="L960">    }</span>

    public &lt;B&gt; IOPathSteps2&lt;A, B&gt; from(Function&lt;A, IOPath&lt;B&gt;&gt; next) {
<span class="fc" id="L963">      Kind&lt;IOKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L964">          MONAD.flatMap(</span>
<span class="fc" id="L965">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), IOKindHelper.IO_OP.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L967">      return new IOPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; IOPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L971">      Kind&lt;IOKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L972">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L973">      return new IOPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; IOPathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L977">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L978">      Kind&lt;IOKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L979">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L980">      return new IOPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; IOPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L984">      Kind&lt;IOKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L985">      return Path.ioPath(IOKindHelper.IO_OP.narrow(result));</span>
    }
  }

  /** Second step in an IOPath comprehension. */
  public static final class IOPathSteps2&lt;A, B&gt; {
<span class="fc" id="L991">    private static final IOMonad MONAD = IOMonad.INSTANCE;</span>
    private final Kind&lt;IOKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L994">    private IOPathSteps2(Kind&lt;IOKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L995">      this.computation = computation;</span>
<span class="fc" id="L996">    }</span>

    public &lt;C&gt; IOPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, IOPath&lt;C&gt;&gt; next) {
<span class="fc" id="L999">      Kind&lt;IOKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1000">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L1002">                  MONAD.map(</span>
<span class="fc" id="L1003">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L1004">                      IOKindHelper.IO_OP.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L1006">      return new IOPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; IOPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L1010">      Kind&lt;IOKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1011">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L1012">      return new IOPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; IOPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L1016">      Kind&lt;IOKind.Witness, R&gt; result =</span>
<span class="fc" id="L1017">          MONAD.map(</span>
<span class="fc" id="L1018">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1020">      return Path.ioPath(IOKindHelper.IO_OP.narrow(result));</span>
    }

    public &lt;R&gt; IOPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L1024">      Kind&lt;IOKind.Witness, R&gt; result =</span>
<span class="fc" id="L1025">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1026">      return Path.ioPath(IOKindHelper.IO_OP.narrow(result));</span>
    }
  }

  /** Third step in an IOPath comprehension. */
  public static final class IOPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L1032">    private static final IOMonad MONAD = IOMonad.INSTANCE;</span>
    private final Kind&lt;IOKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L1035">    private IOPathSteps3(Kind&lt;IOKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L1036">      this.computation = computation;</span>
<span class="fc" id="L1037">    }</span>

    public &lt;R&gt; IOPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L1040">      Kind&lt;IOKind.Witness, R&gt; result =</span>
<span class="fc" id="L1041">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1043">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1045">      return Path.ioPath(IOKindHelper.IO_OP.narrow(result));</span>
    }

    public &lt;R&gt; IOPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L1049">      Kind&lt;IOKind.Witness, R&gt; result =</span>
<span class="fc" id="L1050">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1051">      return Path.ioPath(IOKindHelper.IO_OP.narrow(result));</span>
    }
  }

  // ========================================================================
  // VTaskPath Steps
  // ========================================================================

  /** First step in a VTaskPath comprehension. */
  public static final class VTaskPathSteps1&lt;A&gt; {
<span class="fc" id="L1061">    private static final VTaskMonad MONAD = VTaskMonad.INSTANCE;</span>
    private final Kind&lt;VTaskKind.Witness, A&gt; computation;

<span class="fc" id="L1064">    private VTaskPathSteps1(VTaskPath&lt;A&gt; source) {</span>
<span class="fc" id="L1065">      this.computation = VTaskKindHelper.VTASK.widen(source.run());</span>
<span class="fc" id="L1066">    }</span>

    public &lt;B&gt; VTaskPathSteps2&lt;A, B&gt; from(Function&lt;A, VTaskPath&lt;B&gt;&gt; next) {
<span class="fc" id="L1069">      Kind&lt;VTaskKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1070">          MONAD.flatMap(</span>
<span class="fc" id="L1071">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), VTaskKindHelper.VTASK.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L1073">      return new VTaskPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; VTaskPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L1077">      Kind&lt;VTaskKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1078">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L1079">      return new VTaskPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; VTaskPathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L1083">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L1084">      Kind&lt;VTaskKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1085">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L1086">      return new VTaskPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L1090">      Kind&lt;VTaskKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L1091">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }
  }

  /** Second step in a VTaskPath comprehension. */
  public static final class VTaskPathSteps2&lt;A, B&gt; {
<span class="fc" id="L1097">    private static final VTaskMonad MONAD = VTaskMonad.INSTANCE;</span>
    private final Kind&lt;VTaskKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L1100">    private VTaskPathSteps2(Kind&lt;VTaskKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L1101">      this.computation = computation;</span>
<span class="fc" id="L1102">    }</span>

    public &lt;C&gt; VTaskPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, VTaskPath&lt;C&gt;&gt; next) {
<span class="fc" id="L1105">      Kind&lt;VTaskKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1106">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L1108">                  MONAD.map(</span>
<span class="fc" id="L1109">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L1110">                      VTaskKindHelper.VTASK.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L1112">      return new VTaskPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; VTaskPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L1116">      Kind&lt;VTaskKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1117">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L1118">      return new VTaskPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L1122">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1123">          MONAD.map(</span>
<span class="fc" id="L1124">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1126">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L1130">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1131">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1132">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }
  }

  /** Third step in a VTaskPath comprehension. */
  public static final class VTaskPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L1138">    private static final VTaskMonad MONAD = VTaskMonad.INSTANCE;</span>
    private final Kind&lt;VTaskKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L1141">    private VTaskPathSteps3(Kind&lt;VTaskKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L1142">      this.computation = computation;</span>
<span class="fc" id="L1143">    }</span>

    public &lt;D&gt; VTaskPathSteps4&lt;A, B, C, D&gt; from(Function&lt;Tuple3&lt;A, B, C&gt;, VTaskPath&lt;D&gt;&gt; next) {
<span class="fc" id="L1146">      Kind&lt;VTaskKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; newComp =</span>
<span class="fc" id="L1147">          MONAD.flatMap(</span>
              abc -&gt;
<span class="fc" id="L1149">                  MONAD.map(</span>
<span class="fc" id="L1150">                      d -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), d),</span>
<span class="fc" id="L1151">                      VTaskKindHelper.VTASK.widen(next.apply(abc).run())),</span>
              computation);
<span class="fc" id="L1153">      return new VTaskPathSteps4&lt;&gt;(newComp);</span>
    }

    public &lt;D&gt; VTaskPathSteps4&lt;A, B, C, D&gt; let(Function&lt;Tuple3&lt;A, B, C&gt;, D&gt; f) {
<span class="fc" id="L1157">      Kind&lt;VTaskKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; newComp =</span>
<span class="fc" id="L1158">          MONAD.map(abc -&gt; Tuple.of(abc._1(), abc._2(), abc._3(), f.apply(abc)), computation);</span>
<span class="fc" id="L1159">      return new VTaskPathSteps4&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L1163">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1164">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1166">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1168">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L1172">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1173">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1174">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }
  }

  /** Fourth step in a VTaskPath comprehension. */
  public static final class VTaskPathSteps4&lt;A, B, C, D&gt; {
<span class="fc" id="L1180">    private static final VTaskMonad MONAD = VTaskMonad.INSTANCE;</span>
    private final Kind&lt;VTaskKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; computation;

<span class="fc" id="L1183">    private VTaskPathSteps4(Kind&lt;VTaskKind.Witness, Tuple4&lt;A, B, C, D&gt;&gt; computation) {</span>
<span class="fc" id="L1184">      this.computation = computation;</span>
<span class="fc" id="L1185">    }</span>

    public &lt;E&gt; VTaskPathSteps5&lt;A, B, C, D, E&gt; from(
        Function&lt;Tuple4&lt;A, B, C, D&gt;, VTaskPath&lt;E&gt;&gt; next) {
<span class="fc" id="L1189">      Kind&lt;VTaskKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; newComp =</span>
<span class="fc" id="L1190">          MONAD.flatMap(</span>
              abcd -&gt;
<span class="fc" id="L1192">                  MONAD.map(</span>
<span class="fc" id="L1193">                      e -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), e),</span>
<span class="fc" id="L1194">                      VTaskKindHelper.VTASK.widen(next.apply(abcd).run())),</span>
              computation);
<span class="fc" id="L1196">      return new VTaskPathSteps5&lt;&gt;(newComp);</span>
    }

    public &lt;E&gt; VTaskPathSteps5&lt;A, B, C, D, E&gt; let(Function&lt;Tuple4&lt;A, B, C, D&gt;, E&gt; f) {
<span class="fc" id="L1200">      Kind&lt;VTaskKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; newComp =</span>
<span class="fc" id="L1201">          MONAD.map(</span>
<span class="fc" id="L1202">              abcd -&gt; Tuple.of(abcd._1(), abcd._2(), abcd._3(), abcd._4(), f.apply(abcd)),</span>
              computation);
<span class="fc" id="L1204">      return new VTaskPathSteps5&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function4&lt;A, B, C, D, R&gt; f) {
<span class="fc" id="L1208">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1209">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1211">                  Objects.requireNonNull(</span>
<span class="fc" id="L1212">                      f.apply(t._1(), t._2(), t._3(), t._4()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1214">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function&lt;Tuple4&lt;A, B, C, D&gt;, R&gt; f) {
<span class="fc" id="L1218">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1219">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1220">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }
  }

  /** Fifth step in a VTaskPath comprehension. */
  public static final class VTaskPathSteps5&lt;A, B, C, D, E&gt; {
<span class="fc" id="L1226">    private static final VTaskMonad MONAD = VTaskMonad.INSTANCE;</span>
    private final Kind&lt;VTaskKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; computation;

<span class="fc" id="L1229">    private VTaskPathSteps5(Kind&lt;VTaskKind.Witness, Tuple5&lt;A, B, C, D, E&gt;&gt; computation) {</span>
<span class="fc" id="L1230">      this.computation = computation;</span>
<span class="fc" id="L1231">    }</span>

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function5&lt;A, B, C, D, E, R&gt; f) {
<span class="fc" id="L1234">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1235">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1237">                  Objects.requireNonNull(</span>
<span class="fc" id="L1238">                      f.apply(t._1(), t._2(), t._3(), t._4(), t._5()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1240">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }

    public &lt;R&gt; VTaskPath&lt;R&gt; yield(Function&lt;Tuple5&lt;A, B, C, D, E&gt;, R&gt; f) {
<span class="fc" id="L1244">      Kind&lt;VTaskKind.Witness, R&gt; result =</span>
<span class="fc" id="L1245">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1246">      return Path.vtaskPath(VTaskKindHelper.VTASK.narrow(result));</span>
    }
  }

  // ========================================================================
  // IdPath Steps
  // ========================================================================

  /** First step in an IdPath comprehension. */
  public static final class IdPathSteps1&lt;A&gt; {
<span class="fc" id="L1256">    private static final IdMonad MONAD = IdMonad.instance();</span>
    private final Kind&lt;IdKind.Witness, A&gt; computation;

<span class="fc" id="L1259">    private IdPathSteps1(IdPath&lt;A&gt; source) {</span>
<span class="fc" id="L1260">      this.computation = IdKindHelper.ID.widen(source.run());</span>
<span class="fc" id="L1261">    }</span>

    public &lt;B&gt; IdPathSteps2&lt;A, B&gt; from(Function&lt;A, IdPath&lt;B&gt;&gt; next) {
<span class="fc" id="L1264">      Kind&lt;IdKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1265">          MONAD.flatMap(</span>
<span class="fc" id="L1266">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), IdKindHelper.ID.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L1268">      return new IdPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; IdPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L1272">      Kind&lt;IdKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1273">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L1274">      return new IdPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; IdPathSteps2&lt;A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L1278">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L1279">      Kind&lt;IdKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1280">          MONAD.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L1281">      return new IdPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; IdPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L1285">      Kind&lt;IdKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L1286">      return Path.idPath(IdKindHelper.ID.narrow(result));</span>
    }
  }

  /** Second step in an IdPath comprehension. */
  public static final class IdPathSteps2&lt;A, B&gt; {
<span class="fc" id="L1292">    private static final IdMonad MONAD = IdMonad.instance();</span>
    private final Kind&lt;IdKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L1295">    private IdPathSteps2(Kind&lt;IdKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L1296">      this.computation = computation;</span>
<span class="fc" id="L1297">    }</span>

    public &lt;C&gt; IdPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, IdPath&lt;C&gt;&gt; next) {
<span class="fc" id="L1300">      Kind&lt;IdKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1301">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L1303">                  MONAD.map(</span>
<span class="fc" id="L1304">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L1305">                      IdKindHelper.ID.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L1307">      return new IdPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; IdPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L1311">      Kind&lt;IdKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1312">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L1313">      return new IdPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; IdPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L1317">      Kind&lt;IdKind.Witness, R&gt; result =</span>
<span class="fc" id="L1318">          MONAD.map(</span>
<span class="fc" id="L1319">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1321">      return Path.idPath(IdKindHelper.ID.narrow(result));</span>
    }

    public &lt;R&gt; IdPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L1325">      Kind&lt;IdKind.Witness, R&gt; result =</span>
<span class="fc" id="L1326">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1327">      return Path.idPath(IdKindHelper.ID.narrow(result));</span>
    }
  }

  /** Third step in an IdPath comprehension. */
  public static final class IdPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L1333">    private static final IdMonad MONAD = IdMonad.instance();</span>
    private final Kind&lt;IdKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L1336">    private IdPathSteps3(Kind&lt;IdKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L1337">      this.computation = computation;</span>
<span class="fc" id="L1338">    }</span>

    public &lt;R&gt; IdPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L1341">      Kind&lt;IdKind.Witness, R&gt; result =</span>
<span class="fc" id="L1342">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1344">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1346">      return Path.idPath(IdKindHelper.ID.narrow(result));</span>
    }

    public &lt;R&gt; IdPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L1350">      Kind&lt;IdKind.Witness, R&gt; result =</span>
<span class="fc" id="L1351">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1352">      return Path.idPath(IdKindHelper.ID.narrow(result));</span>
    }
  }

  // ========================================================================
  // NonDetPath Steps (Filterable, uses Cartesian product semantics)
  // ========================================================================

  /** First step in a NonDetPath comprehension. */
  public static final class NonDetPathSteps1&lt;A&gt; {
<span class="fc" id="L1362">    private static final ListMonad MONAD = ListMonad.INSTANCE;</span>
    private final Kind&lt;ListKind.Witness, A&gt; computation;

<span class="fc" id="L1365">    private NonDetPathSteps1(NonDetPath&lt;A&gt; source) {</span>
<span class="fc" id="L1366">      this.computation = ListKindHelper.LIST.widen(source.run());</span>
<span class="fc" id="L1367">    }</span>

<span class="fc" id="L1369">    private NonDetPathSteps1(Kind&lt;ListKind.Witness, A&gt; computation) {</span>
<span class="fc" id="L1370">      this.computation = computation;</span>
<span class="fc" id="L1371">    }</span>

    public &lt;B&gt; NonDetPathSteps2&lt;A, B&gt; from(Function&lt;A, NonDetPath&lt;B&gt;&gt; next) {
<span class="fc" id="L1374">      Kind&lt;ListKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1375">          MONAD.flatMap(</span>
<span class="fc" id="L1376">              a -&gt; MONAD.map(b -&gt; Tuple.of(a, b), ListKindHelper.LIST.widen(next.apply(a).run())),</span>
              computation);
<span class="fc" id="L1378">      return new NonDetPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;B&gt; NonDetPathSteps2&lt;A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L1382">      Kind&lt;ListKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1383">          MONAD.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L1384">      return new NonDetPathSteps2&lt;&gt;(newComp);</span>
    }

    public NonDetPathSteps1&lt;A&gt; when(Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1388">      Kind&lt;ListKind.Witness, A&gt; newComp =</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">          MONAD.flatMap(a -&gt; predicate.test(a) ? MONAD.of(a) : MONAD.zero(), computation);</span>
<span class="fc" id="L1390">      return new NonDetPathSteps1&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; NonDetPath&lt;R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L1394">      Kind&lt;ListKind.Witness, R&gt; result = MONAD.map(f, computation);</span>
<span class="fc" id="L1395">      return NonDetPath.of(ListKindHelper.LIST.narrow(result));</span>
    }
  }

  /** Second step in a NonDetPath comprehension. */
  public static final class NonDetPathSteps2&lt;A, B&gt; {
<span class="fc" id="L1401">    private static final ListMonad MONAD = ListMonad.INSTANCE;</span>
    private final Kind&lt;ListKind.Witness, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L1404">    private NonDetPathSteps2(Kind&lt;ListKind.Witness, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L1405">      this.computation = computation;</span>
<span class="fc" id="L1406">    }</span>

    public &lt;C&gt; NonDetPathSteps3&lt;A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, NonDetPath&lt;C&gt;&gt; next) {
<span class="fc" id="L1409">      Kind&lt;ListKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1410">          MONAD.flatMap(</span>
              ab -&gt;
<span class="fc" id="L1412">                  MONAD.map(</span>
<span class="fc" id="L1413">                      c -&gt; Tuple.of(ab._1(), ab._2(), c),</span>
<span class="fc" id="L1414">                      ListKindHelper.LIST.widen(next.apply(ab).run())),</span>
              computation);
<span class="fc" id="L1416">      return new NonDetPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;C&gt; NonDetPathSteps3&lt;A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L1420">      Kind&lt;ListKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1421">          MONAD.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L1422">      return new NonDetPathSteps3&lt;&gt;(newComp);</span>
    }

    public NonDetPathSteps2&lt;A, B&gt; when(Predicate&lt;Tuple2&lt;A, B&gt;&gt; predicate) {
<span class="fc" id="L1426">      Kind&lt;ListKind.Witness, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">          MONAD.flatMap(ab -&gt; predicate.test(ab) ? MONAD.of(ab) : MONAD.zero(), computation);</span>
<span class="fc" id="L1428">      return new NonDetPathSteps2&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; NonDetPath&lt;R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L1432">      Kind&lt;ListKind.Witness, R&gt; result =</span>
<span class="fc" id="L1433">          MONAD.map(</span>
<span class="fc" id="L1434">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1436">      return NonDetPath.of(ListKindHelper.LIST.narrow(result));</span>
    }

    public &lt;R&gt; NonDetPath&lt;R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L1440">      Kind&lt;ListKind.Witness, R&gt; result =</span>
<span class="fc" id="L1441">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1442">      return NonDetPath.of(ListKindHelper.LIST.narrow(result));</span>
    }
  }

  /** Third step in a NonDetPath comprehension. */
  public static final class NonDetPathSteps3&lt;A, B, C&gt; {
<span class="fc" id="L1448">    private static final ListMonad MONAD = ListMonad.INSTANCE;</span>
    private final Kind&lt;ListKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L1451">    private NonDetPathSteps3(Kind&lt;ListKind.Witness, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L1452">      this.computation = computation;</span>
<span class="fc" id="L1453">    }</span>

    public NonDetPathSteps3&lt;A, B, C&gt; when(Predicate&lt;Tuple3&lt;A, B, C&gt;&gt; predicate) {
<span class="fc" id="L1456">      Kind&lt;ListKind.Witness, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">          MONAD.flatMap(abc -&gt; predicate.test(abc) ? MONAD.of(abc) : MONAD.zero(), computation);</span>
<span class="fc" id="L1458">      return new NonDetPathSteps3&lt;&gt;(newComp);</span>
    }

    public &lt;R&gt; NonDetPath&lt;R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L1462">      Kind&lt;ListKind.Witness, R&gt; result =</span>
<span class="fc" id="L1463">          MONAD.map(</span>
              t -&gt;
<span class="fc" id="L1465">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1467">      return NonDetPath.of(ListKindHelper.LIST.narrow(result));</span>
    }

    public &lt;R&gt; NonDetPath&lt;R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L1471">      Kind&lt;ListKind.Witness, R&gt; result =</span>
<span class="fc" id="L1472">          MONAD.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1473">      return NonDetPath.of(ListKindHelper.LIST.narrow(result));</span>
    }
  }

  // ========================================================================
  // GenericPath Steps (Escape Hatch)
  // ========================================================================

  /** First step in a GenericPath comprehension. */
  public static final class GenericPathSteps1&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; {
    private final Monad&lt;F&gt; monad;
    private final Kind&lt;F, A&gt; computation;

<span class="fc" id="L1486">    private GenericPathSteps1(GenericPath&lt;F, A&gt; source) {</span>
<span class="fc" id="L1487">      this.monad = source.monad();</span>
<span class="fc" id="L1488">      this.computation = source.runKind();</span>
<span class="fc" id="L1489">    }</span>

    public &lt;B&gt; GenericPathSteps2&lt;F, A, B&gt; from(Function&lt;A, GenericPath&lt;F, B&gt;&gt; next) {
<span class="fc" id="L1492">      Kind&lt;F, Tuple2&lt;A, B&gt;&gt; newComp =</span>
<span class="fc" id="L1493">          monad.flatMap(a -&gt; monad.map(b -&gt; Tuple.of(a, b), next.apply(a).runKind()), computation);</span>
<span class="fc" id="L1494">      return new GenericPathSteps2&lt;&gt;(monad, newComp);</span>
    }

    public &lt;B&gt; GenericPathSteps2&lt;F, A, B&gt; let(Function&lt;A, B&gt; f) {
<span class="fc" id="L1498">      Kind&lt;F, Tuple2&lt;A, B&gt;&gt; newComp = monad.map(a -&gt; Tuple.of(a, f.apply(a)), computation);</span>
<span class="fc" id="L1499">      return new GenericPathSteps2&lt;&gt;(monad, newComp);</span>
    }

    public &lt;B&gt; GenericPathSteps2&lt;F, A, B&gt; focus(FocusPath&lt;A, B&gt; focusPath) {
<span class="fc" id="L1503">      Objects.requireNonNull(focusPath, &quot;focusPath must not be null&quot;);</span>
<span class="fc" id="L1504">      Kind&lt;F, Tuple2&lt;A, B&gt;&gt; newComp = monad.map(a -&gt; Tuple.of(a, focusPath.get(a)), computation);</span>
<span class="fc" id="L1505">      return new GenericPathSteps2&lt;&gt;(monad, newComp);</span>
    }

    public &lt;R&gt; GenericPath&lt;F, R&gt; yield(Function&lt;A, R&gt; f) {
<span class="fc" id="L1509">      Kind&lt;F, R&gt; result = monad.map(f, computation);</span>
<span class="fc" id="L1510">      return GenericPath.of(result, monad);</span>
    }
  }

  /** Second step in a GenericPath comprehension. */
  public static final class GenericPathSteps2&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A, B&gt; {
    private final Monad&lt;F&gt; monad;
    private final Kind&lt;F, Tuple2&lt;A, B&gt;&gt; computation;

<span class="fc" id="L1519">    private GenericPathSteps2(Monad&lt;F&gt; monad, Kind&lt;F, Tuple2&lt;A, B&gt;&gt; computation) {</span>
<span class="fc" id="L1520">      this.monad = monad;</span>
<span class="fc" id="L1521">      this.computation = computation;</span>
<span class="fc" id="L1522">    }</span>

    public &lt;C&gt; GenericPathSteps3&lt;F, A, B, C&gt; from(Function&lt;Tuple2&lt;A, B&gt;, GenericPath&lt;F, C&gt;&gt; next) {
<span class="fc" id="L1525">      Kind&lt;F, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1526">          monad.flatMap(</span>
<span class="fc" id="L1527">              ab -&gt; monad.map(c -&gt; Tuple.of(ab._1(), ab._2(), c), next.apply(ab).runKind()),</span>
              computation);
<span class="fc" id="L1529">      return new GenericPathSteps3&lt;&gt;(monad, newComp);</span>
    }

    public &lt;C&gt; GenericPathSteps3&lt;F, A, B, C&gt; let(Function&lt;Tuple2&lt;A, B&gt;, C&gt; f) {
<span class="fc" id="L1533">      Kind&lt;F, Tuple3&lt;A, B, C&gt;&gt; newComp =</span>
<span class="fc" id="L1534">          monad.map(ab -&gt; Tuple.of(ab._1(), ab._2(), f.apply(ab)), computation);</span>
<span class="fc" id="L1535">      return new GenericPathSteps3&lt;&gt;(monad, newComp);</span>
    }

    public &lt;R&gt; GenericPath&lt;F, R&gt; yield(BiFunction&lt;A, B, R&gt; f) {
<span class="fc" id="L1539">      Kind&lt;F, R&gt; result =</span>
<span class="fc" id="L1540">          monad.map(</span>
<span class="fc" id="L1541">              t -&gt; Objects.requireNonNull(f.apply(t._1(), t._2()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1543">      return GenericPath.of(result, monad);</span>
    }

    public &lt;R&gt; GenericPath&lt;F, R&gt; yield(Function&lt;Tuple2&lt;A, B&gt;, R&gt; f) {
<span class="fc" id="L1547">      Kind&lt;F, R&gt; result =</span>
<span class="fc" id="L1548">          monad.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1549">      return GenericPath.of(result, monad);</span>
    }
  }

  /** Third step in a GenericPath comprehension. */
  public static final class GenericPathSteps3&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A, B, C&gt; {
    private final Monad&lt;F&gt; monad;
    private final Kind&lt;F, Tuple3&lt;A, B, C&gt;&gt; computation;

<span class="fc" id="L1558">    private GenericPathSteps3(Monad&lt;F&gt; monad, Kind&lt;F, Tuple3&lt;A, B, C&gt;&gt; computation) {</span>
<span class="fc" id="L1559">      this.monad = monad;</span>
<span class="fc" id="L1560">      this.computation = computation;</span>
<span class="fc" id="L1561">    }</span>

    public &lt;R&gt; GenericPath&lt;F, R&gt; yield(Function3&lt;A, B, C, R&gt; f) {
<span class="fc" id="L1564">      Kind&lt;F, R&gt; result =</span>
<span class="fc" id="L1565">          monad.map(</span>
              t -&gt;
<span class="fc" id="L1567">                  Objects.requireNonNull(f.apply(t._1(), t._2(), t._3()), YIELD_CANNOT_RETURN_NULL),</span>
              computation);
<span class="fc" id="L1569">      return GenericPath.of(result, monad);</span>
    }

    public &lt;R&gt; GenericPath&lt;F, R&gt; yield(Function&lt;Tuple3&lt;A, B, C&gt;, R&gt; f) {
<span class="fc" id="L1573">      Kind&lt;F, R&gt; result =</span>
<span class="fc" id="L1574">          monad.map(t -&gt; Objects.requireNonNull(f.apply(t), YIELD_CANNOT_RETURN_NULL), computation);</span>
<span class="fc" id="L1575">      return GenericPath.of(result, monad);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>