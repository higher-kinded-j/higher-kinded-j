<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ForIndexed.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">ForIndexed.java</span></div><h1>ForIndexed.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.indexed.IndexedTraversal;
import org.higherkindedj.optics.indexed.Pair;

/**
 * Provides a fluent builder for indexed traversal-based comprehensions, enabling position-aware
 * bulk operations over structures using {@link IndexedTraversal} optics within an {@link
 * Applicative} context.
 *
 * &lt;p&gt;This class extends the For comprehension pattern to include index/position awareness, allowing
 * transformations that depend on element position.
 *
 * &lt;h3&gt;Key Features&lt;/h3&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Position-aware transformations:&lt;/b&gt; Access both index and value in operations
 *   &lt;li&gt;&lt;b&gt;Index-based filtering:&lt;/b&gt; Filter elements by their position
 *   &lt;li&gt;&lt;b&gt;Combined filtering:&lt;/b&gt; Filter based on both index and value
 *   &lt;li&gt;&lt;b&gt;Lens integration:&lt;/b&gt; Modify specific fields with index awareness
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example Usage&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * record Player(String name, int score) {}
 *
 * IndexedTraversal&lt;Integer, List&lt;Player&gt;, Player&gt; iplayersTraversal = IndexedTraversals.forList();
 * Lens&lt;Player, Integer&gt; scoreLens = Lens.of(Player::score, (p, s) -&gt; new Player(p.name(), s));
 *
 * List&lt;Player&gt; players = List.of(new Player(&quot;Alice&quot;, 100), new Player(&quot;Bob&quot;, 200));
 *
 * // Add bonus based on position (first place gets more)
 * List&lt;Player&gt; updated = ForIndexed.overIndexed(iplayersTraversal, players, idApplicative)
 *     .modify(scoreLens, (index, score) -&gt; score + (100 - index * 10))
 *     .run();
 *
 * // Filter by position and modify
 * List&lt;Player&gt; topThree = ForIndexed.overIndexed(iplayersTraversal, players, idApplicative)
 *     .filterIndex(i -&gt; i &lt; 3)
 *     .modify(scoreLens, (i, s) -&gt; s * 2)
 *     .run();
 * }&lt;/pre&gt;
 *
 * @see IndexedTraversal
 * @see Applicative
 */
public final class ForIndexed {

  private ForIndexed() {} // Static access only

  /**
   * Starts an indexed traversal-based comprehension over elements of a structure.
   *
   * @param traversal The {@link IndexedTraversal} that focuses on elements with their indices.
   * @param source The source structure containing the elements.
   * @param applicative The {@link Applicative} instance for the effect context.
   * @param &lt;F&gt; The witness type for the applicative context.
   * @param &lt;I&gt; The index type.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused elements.
   * @return An {@link IndexedSteps} builder for chaining operations.
   * @throws NullPointerException if any argument is null.
   */
  public static &lt;F, I, S, A&gt; IndexedSteps&lt;F, I, S, A&gt; overIndexed(
      IndexedTraversal&lt;I, S, A&gt; traversal, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L79">    Objects.requireNonNull(traversal, &quot;traversal must not be null&quot;);</span>
<span class="fc" id="L80">    Objects.requireNonNull(source, &quot;source must not be null&quot;);</span>
<span class="fc" id="L81">    Objects.requireNonNull(applicative, &quot;applicative must not be null&quot;);</span>
<span class="fc" id="L82">    return new IndexedStepsImpl&lt;&gt;(traversal, source, applicative, (i, a) -&gt; applicative.of(a));</span>
  }

  /**
   * A builder interface for chaining operations on indexed traversal-focused elements.
   *
   * @param &lt;F&gt; The witness type for the applicative context.
   * @param &lt;I&gt; The index type.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused elements.
   */
  public interface IndexedSteps&lt;F, I, S, A&gt; {

    /**
     * Filters elements based on their index only.
     *
     * &lt;p&gt;Elements whose indices don't match the predicate are preserved unchanged.
     *
     * @param predicate The predicate to test indices against.
     * @return A new builder with the index filter applied.
     * @throws NullPointerException if {@code predicate} is null.
     */
    IndexedSteps&lt;F, I, S, A&gt; filterIndex(Predicate&lt;I&gt; predicate);

    /**
     * Filters elements based on both their index and value.
     *
     * &lt;p&gt;Elements that don't match the predicate are preserved unchanged.
     *
     * @param predicate The predicate to test index-value pairs against.
     * @return A new builder with the filter applied.
     * @throws NullPointerException if {@code predicate} is null.
     */
    IndexedSteps&lt;F, I, S, A&gt; filter(BiPredicate&lt;I, A&gt; predicate);

    /**
     * Modifies a specific field within each focused element using a lens, with index awareness.
     *
     * @param lens The lens focusing on the field to modify.
     * @param modifier A function taking index and current field value, returning new value.
     * @param &lt;B&gt; The type of the field being modified.
     * @return A new builder with the modification applied.
     * @throws NullPointerException if any argument is null.
     */
    &lt;B&gt; IndexedSteps&lt;F, I, S, A&gt; modify(Lens&lt;A, B&gt; lens, BiFunction&lt;I, B, B&gt; modifier);

    /**
     * Sets a specific field within each focused element using a lens, with index-based values.
     *
     * @param lens The lens focusing on the field to set.
     * @param valueFunction A function taking index and returning the value to set.
     * @param &lt;B&gt; The type of the field being set.
     * @return A new builder with the field set.
     * @throws NullPointerException if any argument is null.
     */
    &lt;B&gt; IndexedSteps&lt;F, I, S, A&gt; set(Lens&lt;A, B&gt; lens, Function&lt;I, B&gt; valueFunction);

    /**
     * Completes the traversal and returns the modified structure wrapped in the applicative
     * context.
     *
     * @return The modified structure in the applicative context.
     */
    Kind&lt;F, S&gt; run();

    /**
     * Collects all focused elements along with their indices into a list.
     *
     * @return A list of index-value pairs in the applicative context.
     */
    Kind&lt;F, List&lt;Pair&lt;I, A&gt;&gt;&gt; toIndexedList();
  }

  /** Implementation of the indexed traversal steps builder. */
  private static final class IndexedStepsImpl&lt;F, I, S, A&gt; implements IndexedSteps&lt;F, I, S, A&gt; {
    private final IndexedTraversal&lt;I, S, A&gt; traversal;
    private final S source;
    private final Applicative&lt;F&gt; applicative;
    private final BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; transformation;
    private final BiPredicate&lt;I, A&gt; filterPredicate;

    IndexedStepsImpl(
        IndexedTraversal&lt;I, S, A&gt; traversal,
        S source,
        Applicative&lt;F&gt; applicative,
        BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; transformation) {
<span class="fc" id="L168">      this(traversal, source, applicative, transformation, (i, a) -&gt; true);</span>
<span class="fc" id="L169">    }</span>

    IndexedStepsImpl(
        IndexedTraversal&lt;I, S, A&gt; traversal,
        S source,
        Applicative&lt;F&gt; applicative,
        BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; transformation,
<span class="fc" id="L176">        BiPredicate&lt;I, A&gt; filterPredicate) {</span>
<span class="fc" id="L177">      this.traversal = traversal;</span>
<span class="fc" id="L178">      this.source = source;</span>
<span class="fc" id="L179">      this.applicative = applicative;</span>
<span class="fc" id="L180">      this.transformation = transformation;</span>
<span class="fc" id="L181">      this.filterPredicate = filterPredicate;</span>
<span class="fc" id="L182">    }</span>

    @Override
    public IndexedSteps&lt;F, I, S, A&gt; filterIndex(Predicate&lt;I&gt; predicate) {
<span class="fc" id="L186">      Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
      // Combine predicates: adapt index-only predicate to BiPredicate
<span class="fc" id="L188">      BiPredicate&lt;I, A&gt; indexPredicate = (i, a) -&gt; predicate.test(i);</span>
<span class="fc" id="L189">      return new IndexedStepsImpl&lt;&gt;(</span>
<span class="fc" id="L190">          traversal, source, applicative, transformation, filterPredicate.and(indexPredicate));</span>
    }

    @Override
    public IndexedSteps&lt;F, I, S, A&gt; filter(BiPredicate&lt;I, A&gt; predicate) {
<span class="fc" id="L195">      Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L196">      return new IndexedStepsImpl&lt;&gt;(</span>
<span class="fc" id="L197">          traversal, source, applicative, transformation, filterPredicate.and(predicate));</span>
    }

    @Override
    public &lt;B&gt; IndexedSteps&lt;F, I, S, A&gt; modify(Lens&lt;A, B&gt; lens, BiFunction&lt;I, B, B&gt; modifier) {
<span class="fc" id="L202">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L203">      Objects.requireNonNull(modifier, &quot;modifier must not be null&quot;);</span>

      // Only modify elements that pass the filter predicate
<span class="fc" id="L206">      BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; modifiedTransformation =</span>
          (i, a) -&gt;
<span class="fc bfc" id="L208" title="All 2 branches covered.">              filterPredicate.test(i, a)</span>
<span class="fc" id="L209">                  ? applicative.map(</span>
<span class="fc" id="L210">                      newA -&gt; lens.modify(b -&gt; modifier.apply(i, b), newA),</span>
<span class="fc" id="L211">                      transformation.apply(i, a))</span>
<span class="fc" id="L212">                  : transformation.apply(i, a);</span>

<span class="fc" id="L214">      return new IndexedStepsImpl&lt;&gt;(</span>
          traversal, source, applicative, modifiedTransformation, filterPredicate);
    }

    @Override
    public &lt;B&gt; IndexedSteps&lt;F, I, S, A&gt; set(Lens&lt;A, B&gt; lens, Function&lt;I, B&gt; valueFunction) {
<span class="fc" id="L220">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L221">      Objects.requireNonNull(valueFunction, &quot;valueFunction must not be null&quot;);</span>

      // Only set on elements that pass the filter predicate
<span class="fc" id="L224">      BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; setTransformation =</span>
          (i, a) -&gt;
<span class="fc bfc" id="L226" title="All 2 branches covered.">              filterPredicate.test(i, a)</span>
<span class="fc" id="L227">                  ? applicative.map(</span>
<span class="fc" id="L228">                      newA -&gt; lens.set(valueFunction.apply(i), newA), transformation.apply(i, a))</span>
<span class="fc" id="L229">                  : transformation.apply(i, a);</span>

<span class="fc" id="L231">      return new IndexedStepsImpl&lt;&gt;(</span>
          traversal, source, applicative, setTransformation, filterPredicate);
    }

    @Override
    public Kind&lt;F, S&gt; run() {
<span class="fc" id="L237">      return traversal.imodifyF(transformation, source, applicative);</span>
    }

    @Override
    public Kind&lt;F, List&lt;Pair&lt;I, A&gt;&gt;&gt; toIndexedList() {
      // Collect all elements with their indices
<span class="fc" id="L243">      List&lt;Pair&lt;I, A&gt;&gt; collected = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L244">      traversal.imodifyF(</span>
          (i, a) -&gt; {
<span class="fc" id="L246">            collected.add(new Pair&lt;&gt;(i, a));</span>
<span class="fc" id="L247">            return applicative.of(a);</span>
          },
          source,
          applicative);
<span class="fc" id="L251">      return applicative.of(collected);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>