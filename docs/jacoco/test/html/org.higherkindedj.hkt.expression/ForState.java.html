<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ForState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.expression</a> &gt; <span class="el_source">ForState.java</span></div><h1>ForState.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.optics.Lens;

/**
 * Provides a fluent builder for state-threaded comprehensions using {@link Lens} optics.
 *
 * &lt;p&gt;This class enables declarative state management within monadic workflows, where state updates
 * are expressed through lenses rather than manual record copying. The state is automatically
 * threaded through each step, and lens operations provide type-safe, composable updates.
 *
 * &lt;h3&gt;Key Features&lt;/h3&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;State threading:&lt;/b&gt; Automatically carry state through each computation step
 *   &lt;li&gt;&lt;b&gt;Lens-based updates:&lt;/b&gt; Update state fields using lenses for type safety
 *   &lt;li&gt;&lt;b&gt;Monadic composition:&lt;/b&gt; Combine effectful operations with state management
 *   &lt;li&gt;&lt;b&gt;Declarative syntax:&lt;/b&gt; Clean, readable workflow definitions
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example Usage&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * record WorkflowContext(String orderId, boolean validated, String confirmationId) {}
 *
 * Lens&lt;WorkflowContext, Boolean&gt; validatedLens =
 *     Lens.of(WorkflowContext::validated, (ctx, v) -&gt; new WorkflowContext(ctx.orderId(), v, ctx.confirmationId()));
 * Lens&lt;WorkflowContext, String&gt; confirmationIdLens =
 *     Lens.of(WorkflowContext::confirmationId, (ctx, id) -&gt; new WorkflowContext(ctx.orderId(), ctx.validated(), id));
 *
 * Kind&lt;EitherT.Witness, WorkflowContext&gt; result =
 *     ForState.withState(eitherTMonad, eitherTMonad.of(new WorkflowContext(&quot;ORD-123&quot;, false, null)))
 *         .update(validatedLens, true)
 *         .fromThen(ctx -&gt; validateOrder(ctx.orderId()), validatedLens)
 *         .fromThen(ctx -&gt; processPayment(ctx), confirmationIdLens)
 *         .yield();
 * }&lt;/pre&gt;
 *
 * @see Lens
 * @see Monad
 */
public final class ForState {

  private ForState() {} // Static access only

  /**
   * Starts a state-threaded comprehension with an initial state wrapped in a monad.
   *
   * @param monad The {@link Monad} instance for the effect context.
   * @param initialState The initial state wrapped in the monad.
   * @param &lt;M&gt; The witness type for the monad context.
   * @param &lt;S&gt; The type of the state.
   * @return A {@link Steps} builder for chaining operations.
   * @throws NullPointerException if any argument is null.
   */
  public static &lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, S&gt; Steps&lt;M, S&gt; withState(
      Monad&lt;M&gt; monad, Kind&lt;M, S&gt; initialState) {
<span class="fc" id="L66">    Objects.requireNonNull(monad, &quot;monad must not be null&quot;);</span>
<span class="fc" id="L67">    Objects.requireNonNull(initialState, &quot;initialState must not be null&quot;);</span>
<span class="fc" id="L68">    return new ForStateStepsImpl&lt;&gt;(monad, initialState);</span>
  }

  /**
   * A builder interface for chaining state-threaded operations.
   *
   * @param &lt;M&gt; The witness type for the monad context.
   * @param &lt;S&gt; The type of the state.
   */
  public interface Steps&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, S&gt; {

    /**
     * Performs a monadic operation using the current state, keeping the state unchanged.
     *
     * @param f A function that takes the current state and returns a monadic computation.
     * @param &lt;A&gt; The type of the computation result.
     * @return A new builder with the operation queued.
     * @throws NullPointerException if {@code f} is null.
     */
    &lt;A&gt; Steps&lt;M, S&gt; from(Function&lt;S, Kind&lt;M, A&gt;&gt; f);

    /**
     * Performs a monadic operation and uses the result to update state via a lens.
     *
     * &lt;p&gt;This is the primary way to update state in a workflow: perform an operation that produces
     * a value, then store that value in the state using a lens.
     *
     * @param f A function that takes the current state and returns a monadic computation.
     * @param lens The lens to use for updating the state with the result.
     * @param &lt;A&gt; The type of the computation result (must match the lens focus type).
     * @return A new builder with the operation and update queued.
     * @throws NullPointerException if any argument is null.
     */
    &lt;A&gt; Steps&lt;M, S&gt; fromThen(Function&lt;S, Kind&lt;M, A&gt;&gt; f, Lens&lt;S, A&gt; lens);

    /**
     * Updates a field in the state using a lens and a pure function.
     *
     * @param lens The lens focusing on the field to update.
     * @param modifier A function to compute the new value from the current value.
     * @param &lt;A&gt; The type of the field.
     * @return A new builder with the update queued.
     * @throws NullPointerException if any argument is null.
     */
    &lt;A&gt; Steps&lt;M, S&gt; modify(Lens&lt;S, A&gt; lens, Function&lt;A, A&gt; modifier);

    /**
     * Sets a field in the state using a lens.
     *
     * @param lens The lens focusing on the field to set.
     * @param value The new value for the field.
     * @param &lt;A&gt; The type of the field.
     * @return A new builder with the update queued.
     * @throws NullPointerException if {@code lens} is null.
     */
    &lt;A&gt; Steps&lt;M, S&gt; update(Lens&lt;S, A&gt; lens, A value);

    /**
     * Completes the comprehension and returns the final state.
     *
     * @return The final state wrapped in the monad context.
     */
    Kind&lt;M, S&gt; yield();

    /**
     * Completes the comprehension by applying a projection to the final state.
     *
     * @param f A function to transform the final state into a result.
     * @param &lt;R&gt; The type of the result.
     * @return The projected result wrapped in the monad context.
     * @throws NullPointerException if {@code f} is null.
     */
    &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;S, R&gt; f);
  }

  /** Implementation of the state steps builder. */
  private static final class ForStateStepsImpl&lt;M extends WitnessArity&lt;TypeArity.Unary&gt;, S&gt;
      implements Steps&lt;M, S&gt; {
    private final Monad&lt;M&gt; monad;
    private final Kind&lt;M, S&gt; state;

<span class="fc" id="L149">    ForStateStepsImpl(Monad&lt;M&gt; monad, Kind&lt;M, S&gt; state) {</span>
<span class="fc" id="L150">      this.monad = monad;</span>
<span class="fc" id="L151">      this.state = state;</span>
<span class="fc" id="L152">    }</span>

    @Override
    public &lt;A&gt; Steps&lt;M, S&gt; from(Function&lt;S, Kind&lt;M, A&gt;&gt; f) {
<span class="fc" id="L156">      Objects.requireNonNull(f, &quot;function must not be null&quot;);</span>
      // Perform the operation but discard the result, keeping state unchanged
<span class="fc" id="L158">      Kind&lt;M, S&gt; newState = monad.flatMap(s -&gt; monad.map(ignored -&gt; s, f.apply(s)), state);</span>
<span class="fc" id="L159">      return new ForStateStepsImpl&lt;&gt;(monad, newState);</span>
    }

    @Override
    public &lt;A&gt; Steps&lt;M, S&gt; fromThen(Function&lt;S, Kind&lt;M, A&gt;&gt; f, Lens&lt;S, A&gt; lens) {
<span class="fc" id="L164">      Objects.requireNonNull(f, &quot;function must not be null&quot;);</span>
<span class="fc" id="L165">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
      // Perform the operation and update state using the lens
<span class="fc" id="L167">      Kind&lt;M, S&gt; newState =</span>
<span class="fc" id="L168">          monad.flatMap(s -&gt; monad.map(result -&gt; lens.set(result, s), f.apply(s)), state);</span>
<span class="fc" id="L169">      return new ForStateStepsImpl&lt;&gt;(monad, newState);</span>
    }

    @Override
    public &lt;A&gt; Steps&lt;M, S&gt; modify(Lens&lt;S, A&gt; lens, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L174">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L175">      Objects.requireNonNull(modifier, &quot;modifier must not be null&quot;);</span>
<span class="fc" id="L176">      Kind&lt;M, S&gt; newState = monad.map(s -&gt; lens.modify(modifier, s), state);</span>
<span class="fc" id="L177">      return new ForStateStepsImpl&lt;&gt;(monad, newState);</span>
    }

    @Override
    public &lt;A&gt; Steps&lt;M, S&gt; update(Lens&lt;S, A&gt; lens, A value) {
<span class="fc" id="L182">      Objects.requireNonNull(lens, &quot;lens must not be null&quot;);</span>
<span class="fc" id="L183">      Kind&lt;M, S&gt; newState = monad.map(s -&gt; lens.set(value, s), state);</span>
<span class="fc" id="L184">      return new ForStateStepsImpl&lt;&gt;(monad, newState);</span>
    }

    @Override
    public Kind&lt;M, S&gt; yield() {
<span class="fc" id="L189">      return state;</span>
    }

    @Override
    public &lt;R&gt; Kind&lt;M, R&gt; yield(Function&lt;S, R&gt; f) {
<span class="fc" id="L194">      Objects.requireNonNull(f, &quot;projection function must not be null&quot;);</span>
<span class="fc" id="L195">      return monad.map(f, state);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>