<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IdSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.id</a> &gt; <span class="el_source">IdSelective.java</span></div><h1>IdSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.id;

import static org.higherkindedj.hkt.id.IdKindHelper.ID;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Choice;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link Id}.
 *
 * &lt;p&gt;The Identity selective is the simplest selective functor. Since Id has no effects or branching
 * logic, all conditional operations eagerly evaluate and simply unwrap the values.
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies a function based on a Choice.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with different
 *       handlers.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes an effect based on a boolean.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional for selective functors.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Since Id has no effects, all operations evaluate eagerly and immediately return results.
 *
 * &lt;p&gt;This class is a singleton, accessible via {@link #instance()}.
 *
 * @see Id
 * @see IdMonad
 * @see Selective
 * @see Choice
 */
public final class IdSelective extends IdMonad implements Selective&lt;IdKind.Witness&gt; {

<span class="fc" id="L42">  private static final IdSelective INSTANCE = new IdSelective();</span>
<span class="fc" id="L43">  private static final Class&lt;IdSelective&gt; ID_SELECTIVE_CLASS = IdSelective.class;</span>

  /** Private constructor to enforce singleton pattern. */
  private IdSelective() {
    super();
  }

  /**
   * Returns the singleton instance of {@link IdSelective}.
   *
   * @return The singleton {@code IdSelective} instance.
   */
  public static IdSelective instance() {
<span class="fc" id="L56">    return INSTANCE;</span>
  }

  /**
   * The core selective operation for Id.
   *
   * &lt;p&gt;Since Id has no effects, this eagerly evaluates the choice. If the choice contains a Left
   * value, the function is applied. If it contains a Right value, that value is returned directly.
   *
   * &lt;p&gt;Behavior:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If choice is {@code Right(b)}: Returns {@code Id(b)}, function is not evaluated.
   *   &lt;li&gt;If choice is {@code Left(a)}: Applies the function to {@code a} and returns {@code
   *       Id(f(a))}.
   * &lt;/ul&gt;
   *
   * @param fab A non-null {@link Kind Kind&amp;lt;IdKind.Witness, Choice&amp;lt;A, B&amp;gt;&amp;gt;} containing
   *     the choice
   * @param ff A non-null {@link Kind Kind&amp;lt;IdKind.Witness, Function&amp;lt;A, B&amp;gt;&amp;gt;} containing
   *     the function
   * @param &lt;A&gt; The input type of the function (the type inside Left)
   * @param &lt;B&gt; The output type and the type inside Right
   * @return A non-null {@link Kind Kind&amp;lt;IdKind.Witness, B&amp;gt;} with the result
   * @throws NullPointerException if {@code fab} or {@code ff} is null, or if the unwrapped values
   *     are null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;IdKind.Witness, B&gt; select(
      Kind&lt;IdKind.Witness, Choice&lt;A, B&gt;&gt; fab, Kind&lt;IdKind.Witness, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L89">    Validation.kind().requireNonNull(fab, ID_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L90">    Validation.kind().requireNonNull(ff, ID_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L92">    Choice&lt;A, B&gt; choice = ID.narrow(fab).value();</span>
<span class="fc" id="L93">    Function&lt;A, B&gt; function = ID.narrow(ff).value();</span>

<span class="fc" id="L95">    Validation.function().requireFunction(choice, &quot;choice&quot;, ID_SELECTIVE_CLASS, SELECT);</span>
<span class="fc" id="L96">    Validation.function().requireFunction(function, &quot;function&quot;, ID_SELECTIVE_CLASS, SELECT);</span>

    // If choice is Right(b), we already have our value
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (choice.isRight()) {</span>
<span class="fc" id="L100">      return ID.widen(Id.of(choice.getRight()));</span>
    }

    // Choice is Left(a), so apply the function
<span class="fc" id="L104">    A value = choice.getLeft();</span>
<span class="fc" id="L105">    B result = function.apply(value);</span>

<span class="fc" id="L107">    return ID.widen(Id.of(result));</span>
  }

  /**
   * Selective branching for Id.
   *
   * &lt;p&gt;Eagerly evaluates the choice and applies the appropriate handler.
   *
   * @param fab A {@link Kind} representing {@code Id&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code Id&lt;Function&lt;A, C&gt;&gt;} for the Left case. Must not be
   *     null.
   * @param fr A {@link Kind} representing {@code Id&lt;Function&lt;B, C&gt;&gt;} for the Right case. Must not
   *     be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code Id&lt;C&gt;}. Never null.
   * @throws NullPointerException if any parameter is null, or if unwrapped values are null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if parameters cannot be unwrapped.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;IdKind.Witness, C&gt; branch(
      Kind&lt;IdKind.Witness, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;IdKind.Witness, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;IdKind.Witness, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L133">    Validation.kind().requireNonNull(fab, ID_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L134">    Validation.kind().requireNonNull(fl, ID_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L135">    Validation.kind().requireNonNull(fr, ID_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L137">    Choice&lt;A, B&gt; choice = ID.narrow(fab).value();</span>
<span class="fc" id="L138">    Validation.function().requireFunction(choice, &quot;choice&quot;, ID_SELECTIVE_CLASS, BRANCH);</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">    if (choice.isLeft()) {</span>
      // Use left handler
<span class="fc" id="L142">      Function&lt;A, C&gt; leftFunction = ID.narrow(fl).value();</span>
<span class="fc" id="L143">      Validation.function()</span>
<span class="fc" id="L144">          .requireFunction(leftFunction, &quot;leftHandler&quot;, ID_SELECTIVE_CLASS, BRANCH);</span>
<span class="fc" id="L145">      C result = leftFunction.apply(choice.getLeft());</span>
<span class="fc" id="L146">      return ID.widen(Id.of(result));</span>
    } else {
      // Use right handler
<span class="fc" id="L149">      Function&lt;B, C&gt; rightFunction = ID.narrow(fr).value();</span>
<span class="fc" id="L150">      Validation.function()</span>
<span class="fc" id="L151">          .requireFunction(rightFunction, &quot;rightHandler&quot;, ID_SELECTIVE_CLASS, BRANCH);</span>
<span class="fc" id="L152">      C result = rightFunction.apply(choice.getRight());</span>
<span class="fc" id="L153">      return ID.widen(Id.of(result));</span>
    }
  }

  /**
   * Conditionally executes a Unit-returning effect based on a boolean condition.
   *
   * &lt;p&gt;Eagerly evaluates the condition. If true, validates and returns the effect's Unit result. If
   * false, returns Unit.INSTANCE without evaluating the effect.
   *
   * &lt;p&gt;Key improvement: Returns {@code Id.of(Unit.INSTANCE)} instead of {@code Id.of(null)}, making
   * the &quot;no-op&quot; case explicit and type-safe.
   *
   * &lt;p&gt;&lt;b&gt;Validation:&lt;/b&gt; When the condition is true, the Unit value inside the effect is validated
   * to ensure it's not null. When the condition is false, the effect is not evaluated or validated.
   *
   * @param fcond A {@link Kind} representing {@code Id&lt;Boolean&gt;}. Must not be null.
   * @param fa A {@link Kind} representing {@code Id&lt;Unit&gt;} the effect to execute if condition is
   *     true. Must not be null, and the Unit value must not be null if the condition is true.
   * @return A {@link Kind} representing {@code Id&lt;Unit&gt;}. Never null.
   * @throws NullPointerException if any parameter is null, or if unwrapped values are null when
   *     accessed.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if parameters cannot be unwrapped.
   */
  @Override
  public Kind&lt;IdKind.Witness, Unit&gt; whenS(
      Kind&lt;IdKind.Witness, Boolean&gt; fcond, Kind&lt;IdKind.Witness, Unit&gt; fa) {

<span class="fc" id="L181">    Validation.kind().requireNonNull(fcond, ID_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L182">    Validation.kind().requireNonNull(fa, ID_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L184">    Boolean condition = ID.narrow(fcond).value();</span>
<span class="fc" id="L185">    Validation.function().requireFunction(condition, &quot;condition&quot;, ID_SELECTIVE_CLASS, WHEN_S);</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (condition) {</span>
      // Execute and return the effect - but validate its Unit value first
<span class="fc" id="L189">      Unit unit = ID.narrow(fa).value();</span>
<span class="fc" id="L190">      Validation.function().requireFunction(unit, &quot;effect&quot;, ID_SELECTIVE_CLASS, WHEN_S);</span>
<span class="fc" id="L191">      return fa;</span>
    } else {
      // Condition is false, return Unit wrapped in Id (not null!)
<span class="fc" id="L194">      return ID.widen(Id.of(Unit.INSTANCE));</span>
    }
  }

  /**
   * A ternary conditional operator for Id selective functors.
   *
   * &lt;p&gt;Eagerly evaluates the condition and returns the appropriate branch without evaluating the
   * other.
   *
   * @param fcond A {@link Kind} representing {@code Id&lt;Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code Id&lt;A&gt;} for the true branch. Must not be null.
   * @param felse A {@link Kind} representing {@code Id&lt;A&gt;} for the false branch. Must not be null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code Id&lt;A&gt;}. Never null.
   * @throws NullPointerException if any parameter is null, or if the condition value is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if parameters cannot be unwrapped.
   */
  @Override
  public &lt;A&gt; Kind&lt;IdKind.Witness, A&gt; ifS(
      Kind&lt;IdKind.Witness, Boolean&gt; fcond,
      Kind&lt;IdKind.Witness, A&gt; fthen,
      Kind&lt;IdKind.Witness, A&gt; felse) {

<span class="fc" id="L218">    Validation.kind().requireNonNull(fcond, ID_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L219">    Validation.kind().requireNonNull(fthen, ID_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L220">    Validation.kind().requireNonNull(felse, ID_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L222">    Boolean condition = ID.narrow(fcond).value();</span>
<span class="fc" id="L223">    Validation.function().requireFunction(condition, &quot;condition&quot;, ID_SELECTIVE_CLASS, IF_S);</span>

    // Return the appropriate branch
    // Note: We don't evaluate both branches - this is key for selective functors
<span class="fc bfc" id="L227" title="All 2 branches covered.">    return condition ? fthen : felse;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L232">    return &quot;IdSelective&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>