<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OptionalMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.optional</a> &gt; <span class="el_source">OptionalMonad.java</span></div><h1>OptionalMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.optional;

import static org.higherkindedj.hkt.optional.OptionalKindHelper.*;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.Optional;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Implements the {@link MonadError} type class for {@link java.util.Optional}, using {@link
 * OptionalKind.Witness} as the higher-kinded type witness.
 *
 * &lt;p&gt;This class provides monadic operations for {@code Optional}, allowing it to be used in a
 * generic, functional, and composable manner within the Higher-Kinded-J framework. It treats {@link
 * Optional#empty()} as the error state, with {@link Unit} as the phantom error type, signifying
 * absence rather than a specific error value.
 *
 * &lt;p&gt;Key operations include:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #of(Object)}: Lifts a potentially nullable value into an {@code OptionalKind}. A
 *       null value results in an empty {@code OptionalKind}.
 *   &lt;li&gt;{@link #map(Function, Kind)}: Applies a function to the value within an {@code
 *       OptionalKind} if it's present.
 *   &lt;li&gt;{@link #flatMap(Function, Kind)}: Applies a function that returns an {@code OptionalKind}
 *       to the value within an {@code OptionalKind} if present, and flattens the result.
 *   &lt;li&gt;{@link #ap(Kind, Kind)}: Applies an {@code OptionalKind} of a function to an {@code
 *       OptionalKind} of a value.
 *   &lt;li&gt;{@link #raiseError(Unit)}: Returns an empty {@code OptionalKind}.
 *   &lt;li&gt;{@link #handleErrorWith(Kind, Function)}: Allows recovery from an empty {@code
 *       OptionalKind}.
 *   &lt;li&gt;It treats {@link Optional#empty()} as both the error state and the &quot;zero&quot; element.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This class extends {@link OptionalFunctor} and transitively implements {@link
 * org.higherkindedj.hkt.MonadZero}, {@link org.higherkindedj.hkt.Applicative}, and {@link
 * org.higherkindedj.hkt.Functor}.
 *
 * &lt;p&gt;This class is a final singleton, accessible via the static {@link #INSTANCE} field.
 *
 * @see Optional
 * @see OptionalKind
 * @see OptionalKindHelper
 * @see OptionalFunctor
 * @see MonadError
 * @see Kind
 * @see Unit
 */
public class OptionalMonad extends OptionalFunctor
    implements MonadError&lt;OptionalKind.Witness, Unit&gt;, MonadZero&lt;OptionalKind.Witness&gt; {

<span class="fc" id="L61">  private static final Class&lt;OptionalMonad&gt; OPTIONAL_MONAD_CLASS = OptionalMonad.class;</span>

  /** Singleton instance of {@code OptionalMonad}. */
<span class="fc" id="L64">  public static final OptionalMonad INSTANCE = new OptionalMonad();</span>

  /** Private constructor to enforce the singleton pattern. */
<span class="fc" id="L67">  protected OptionalMonad() {</span>
    // Default constructor
<span class="fc" id="L69">  }</span>

  /**
   * Lifts a value into the {@code OptionalKind} context. If the provided {@code value} is {@code
   * null}, this method returns an empty {@code OptionalKind}. Otherwise, it returns an {@code
   * OptionalKind} containing the value. This is equivalent to {@code Optional.ofNullable(value)}
   * wrapped in {@code OptionalKind}.
   *
   * @param &lt;A&gt; The type of the value.
   * @param value The value to lift. Can be {@code null}.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} representing {@code
   *     Optional.ofNullable(value)}.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalKind.Witness, A&gt; of(@Nullable A value) {
<span class="fc" id="L84">    return OPTIONAL.widen(Optional.ofNullable(value));</span>
  }

  /**
   * Applies a function to the value contained within an {@code OptionalKind} context, if a value is
   * present.
   *
   * &lt;p&gt;This method overrides the inherited {@link OptionalFunctor#map(Function, Kind)} to provide
   * validation messages that identify this operation as belonging to {@code OptionalMonad} rather
   * than {@code OptionalFunctor}.
   *
   * &lt;p&gt;If the input {@code OptionalKind} ({@code fa}) represents an {@code Optional.of(a)}, the
   * function {@code f} is applied to {@code a}. If {@code f} returns a non-null value {@code b},
   * the result is an {@code OptionalKind} representing {@code Optional.of(b)}. If {@code f} returns
   * {@code null}, the result is an empty {@code OptionalKind} (representing {@code
   * Optional.empty()}).
   *
   * &lt;p&gt;If {@code fa} represents {@code Optional.empty()}, an empty {@code OptionalKind} is
   * returned, and the function {@code f} is not applied.
   *
   * @param &lt;A&gt; The type of the value in the input {@code OptionalKind}.
   * @param &lt;B&gt; The type of the value in the output {@code OptionalKind} after applying the
   *     function.
   * @param f The non-null function to apply to the value inside the {@code OptionalKind} if
   *     present. This function can return {@code @Nullable B}.
   * @param fa The non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} representing the {@code
   *     Optional&lt;A&gt;} whose value is to be transformed.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, B&gt;} representing a new {@code Optional&lt;B&gt;}
   *     that will contain the transformed value if the input was present and the function returned
   *     non-null, or will be empty otherwise.
   * @throws NullPointerException if {@code f} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fa} is not a valid {@code
   *     OptionalKind} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalKind.Witness, B&gt; map(
      Function&lt;? super A, ? extends @Nullable B&gt; f, Kind&lt;OptionalKind.Witness, A&gt; fa) {

<span class="fc" id="L122">    Validation.function().requireMapper(f, &quot;f&quot;, OPTIONAL_MONAD_CLASS, MAP);</span>
<span class="fc" id="L123">    Validation.kind().requireNonNull(fa, OPTIONAL_MONAD_CLASS, MAP);</span>

<span class="fc" id="L125">    Optional&lt;A&gt; optionalA = OPTIONAL.narrow(fa);</span>
    // Optional.map correctly handles f returning null by creating Optional.empty()
<span class="fc" id="L127">    Optional&lt;B&gt; resultOptional = optionalA.map(f);</span>
<span class="fc" id="L128">    return OPTIONAL.widen(resultOptional);</span>
  }

  /**
   * Applies a function to the value within an {@code OptionalKind} if it is present, and flattens
   * the {@code OptionalKind} result. If the input {@code OptionalKind} ({@code ma}) is empty, or if
   * the function {@code f} applied to the present value results in an empty {@code OptionalKind},
   * an empty {@code OptionalKind} is returned.
   *
   * @param &lt;A&gt; The type of the value in the input {@code OptionalKind}.
   * @param &lt;B&gt; The type of the value in the {@code OptionalKind} returned by the function {@code
   *     f}.
   * @param f The non-null function to apply to the value if present. This function must return a
   *     {@code Kind&lt;OptionalKind.Witness, B&gt;}.
   * @param ma The non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} to transform.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, B&gt;} representing the result of the flatMap
   *     operation.
   * @throws NullPointerException if {@code f} or {@code ma} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} is not a valid {@code
   *     OptionalKind} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalKind.Witness, B&gt; flatMap(
      Function&lt;? super A, ? extends Kind&lt;OptionalKind.Witness, B&gt;&gt; f,
      Kind&lt;OptionalKind.Witness, A&gt; ma) {

<span class="fc" id="L154">    Validation.function().validateFlatMap(f, ma, OPTIONAL_MONAD_CLASS);</span>

<span class="fc" id="L156">    Optional&lt;A&gt; optA = OPTIONAL.narrow(ma);</span>
<span class="fc" id="L157">    Optional&lt;B&gt; resultOpt =</span>
<span class="fc" id="L158">        optA.flatMap(</span>
            a -&gt; {
<span class="fc" id="L160">              Kind&lt;OptionalKind.Witness, B&gt; kindB = f.apply(a);</span>
<span class="fc" id="L161">              Validation.function()</span>
<span class="fc" id="L162">                  .requireNonNullResult(kindB, &quot;f&quot;, OPTIONAL_MONAD_CLASS, FLAT_MAP, Optional.class);</span>
<span class="fc" id="L163">              return OPTIONAL.narrow(kindB);</span>
            });
<span class="fc" id="L165">    return OPTIONAL.widen(resultOpt);</span>
  }

  /**
   * Applies an {@code OptionalKind} containing a function to an {@code OptionalKind} containing a
   * value. If both the function and the value are present, the function is applied to the value,
   * and the result is wrapped in an {@code OptionalKind}. If either is empty, an empty {@code
   * OptionalKind} is returned.
   *
   * @param &lt;A&gt; The input type of the function.
   * @param &lt;B&gt; The output type of the function.
   * @param ff The non-null {@code Kind&lt;OptionalKind.Witness, Function&lt;A, B&gt;&gt;} containing the
   *     function.
   * @param fa The non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} containing the value.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, B&gt;} representing the result of the
   *     application.
   * @throws NullPointerException if {@code ff} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ff} or {@code fa} is not
   *     a valid {@code OptionalKind} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalKind.Witness, B&gt; ap(
      Kind&lt;OptionalKind.Witness, ? extends Function&lt;A, B&gt;&gt; ff, Kind&lt;OptionalKind.Witness, A&gt; fa) {

<span class="fc" id="L189">    Validation.kind().validateAp(ff, fa, OPTIONAL_MONAD_CLASS);</span>

<span class="fc" id="L191">    Optional&lt;? extends Function&lt;A, B&gt;&gt; optF = OPTIONAL.narrow(ff);</span>
<span class="fc" id="L192">    Optional&lt;A&gt; optA = OPTIONAL.narrow(fa);</span>
<span class="fc" id="L193">    Optional&lt;B&gt; resultOpt = optF.flatMap(optA::map);</span>
<span class="fc" id="L194">    return OPTIONAL.widen(resultOpt);</span>
  }

  /**
   * Raises an error in the {@code OptionalKind} context, which corresponds to an empty {@code
   * Optional}. The error parameter (of type {@link Unit}) is typically {@link Unit#INSTANCE}.
   *
   * @param &lt;A&gt; The phantom type of the value for the resulting empty {@code OptionalKind}.
   * @param error The error value (typically {@link Unit#INSTANCE}). Must be non-null.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} representing {@code Optional.empty()}.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalKind.Witness, A&gt; raiseError(Unit error) {
    // No need to validate the Unit parameter as it's a marker type
<span class="fc" id="L208">    return OPTIONAL.widen(Optional.empty());</span>
  }

  /**
   * Handles an error (an empty {@code OptionalKind}) by applying a recovery function. If the input
   * {@code OptionalKind} ({@code ma}) is empty, the {@code handler} function is invoked (with
   * {@link Unit#INSTANCE} as the argument) to produce a new {@code OptionalKind}. If {@code ma} is
   * present, it is returned unchanged.
   *
   * @param &lt;A&gt; The type of the value.
   * @param ma The non-null {@code Kind&lt;OptionalKind.Witness, A&gt;} to handle.
   * @param handler The non-null function to apply if {@code ma} is empty. It takes {@link
   *     Unit#INSTANCE} and returns a new {@code Kind&lt;OptionalKind.Witness, A&gt;}.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, A&gt;}, either the original if present, or
   *     the result of the handler if empty.
   * @throws NullPointerException if {@code ma} or {@code handler} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} is not a valid {@code
   *     OptionalKind} representation.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalKind.Witness, A&gt; handleErrorWith(
      Kind&lt;OptionalKind.Witness, A&gt; ma,
      Function&lt;? super Unit, ? extends Kind&lt;OptionalKind.Witness, A&gt;&gt; handler) {

<span class="fc" id="L232">    Validation.function().validateHandleErrorWith(ma, handler, OPTIONAL_MONAD_CLASS);</span>

<span class="fc" id="L234">    Optional&lt;A&gt; optional = OPTIONAL.narrow(ma);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (optional.isEmpty()) {</span>
<span class="fc" id="L236">      Kind&lt;OptionalKind.Witness, A&gt; recoveryKind = handler.apply(Unit.INSTANCE);</span>
<span class="fc" id="L237">      Validation.function()</span>
<span class="fc" id="L238">          .requireNonNullResult(</span>
              recoveryKind, &quot;handler&quot;, OPTIONAL_MONAD_CLASS, HANDLE_ERROR_WITH, Optional.class);
<span class="fc" id="L240">      return recoveryKind;</span>
    } else {
<span class="fc" id="L242">      return ma;</span>
    }
  }

  /**
   * Returns the &quot;zero&quot; or &quot;empty&quot; value for this Monad, which is {@code Optional.empty()}.
   *
   * @param &lt;T&gt; The type parameter of the Kind.
   * @return A non-null {@code Kind&lt;OptionalKind.Witness, T&gt;} representing {@code Optional.empty()}.
   */
  @Override
  public &lt;T&gt; Kind&lt;OptionalKind.Witness, T&gt; zero() {
<span class="fc" id="L254">    return OPTIONAL.widen(Optional.empty());</span>
  }

  // --- Alternative Methods ---

  /**
   * Combines two Optional values, returning the first if it's present, otherwise evaluating and
   * returning the second.
   *
   * &lt;p&gt;This implements the Alternative pattern for Optional, providing a fallback mechanism. The
   * second argument is lazy (supplied via {@link java.util.function.Supplier}) to avoid unnecessary
   * computation when the first Optional is present.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Kind&lt;OptionalKind.Witness, String&gt; primary = OPTIONAL.widen(Optional.of(&quot;value&quot;));
   * Kind&lt;OptionalKind.Witness, String&gt; fallback = () -&gt; OPTIONAL.widen(Optional.of(&quot;default&quot;));
   *
   * Kind&lt;OptionalKind.Witness, String&gt; result = orElse(primary, fallback);
   * // result is Optional.of(&quot;value&quot;)
   *
   * Kind&lt;OptionalKind.Witness, String&gt; result2 = orElse(OPTIONAL.widen(Optional.empty()), fallback);
   * // result2 is Optional.of(&quot;default&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value within the Optional
   * @param oa The first Optional to try. Must not be null.
   * @param ob A {@link java.util.function.Supplier} providing the fallback Optional. Must not be
   *     null.
   * @return The first Optional if it's present, otherwise the result of the supplier
   * @throws NullPointerException if oa or ob is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if oa cannot be unwrapped
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalKind.Witness, A&gt; orElse(
      Kind&lt;OptionalKind.Witness, A&gt; oa, Supplier&lt;Kind&lt;OptionalKind.Witness, A&gt;&gt; ob) {

<span class="fc" id="L292">    Validation.kind().requireNonNull(oa, OPTIONAL_MONAD_CLASS, OR_ELSE, &quot;first alternative&quot;);</span>
<span class="fc" id="L293">    Validation.function().requireFunction(ob, &quot;ob&quot;, OPTIONAL_MONAD_CLASS, OR_ELSE);</span>

<span class="fc" id="L295">    Optional&lt;A&gt; optionalA = OPTIONAL.narrow(oa);</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">    if (optionalA.isPresent()) {</span>
<span class="fc" id="L298">      return oa;</span>
    }

<span class="fc" id="L301">    Kind&lt;OptionalKind.Witness, A&gt; result = ob.get();</span>
<span class="fc" id="L302">    Validation.function()</span>
<span class="fc" id="L303">        .requireNonNullResult(result, &quot;ob&quot;, OPTIONAL_MONAD_CLASS, OR_ELSE, Optional.class);</span>

<span class="fc" id="L305">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>