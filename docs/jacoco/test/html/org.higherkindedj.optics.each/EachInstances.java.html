<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EachInstances.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.each</a> &gt; <span class="el_source">EachInstances.java</span></div><h1>EachInstances.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.each;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Stream;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Traverse;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.optics.Each;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.focus.FocusPaths;
import org.higherkindedj.optics.indexed.IndexedTraversal;
import org.higherkindedj.optics.util.IndexedTraversals;
import org.higherkindedj.optics.util.Traversals;
import org.higherkindedj.optics.util.TraverseTraversals;
import org.jspecify.annotations.NullMarked;

/**
 * Provides standard {@link Each} instances for common Java types.
 *
 * &lt;p&gt;This class contains factory methods that create {@code Each} instances for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link List} - traverses all elements with Integer index support
 *   &lt;li&gt;{@link Set} - traverses all elements (no index support)
 *   &lt;li&gt;{@link Map} - traverses all values with key as index
 *   &lt;li&gt;{@link Optional} - traverses the value if present (0 or 1 element)
 *   &lt;li&gt;Arrays - traverses all elements with Integer index support
 *   &lt;li&gt;{@link Stream} - traverses all elements (consumed during traversal)
 *   &lt;li&gt;{@link String} - traverses all characters with Integer index support
 * &lt;/ul&gt;
 *
 * &lt;p&gt;For hkj-core types (Maybe, Either, Try, Validated), see {@link
 * org.higherkindedj.optics.extensions.EachExtensions}.
 *
 * &lt;h3&gt;Usage Examples:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // List traversal
 * Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
 * Traversal&lt;List&lt;String&gt;, String&gt; trav = listEach.each();
 * List&lt;String&gt; upper = Traversals.modify(trav, String::toUpperCase, list);
 *
 * // Map values traversal
 * Each&lt;Map&lt;String, Integer&gt;, Integer&gt; mapEach = EachInstances.mapValuesEach();
 * List&lt;Integer&gt; values = Traversals.getAll(mapEach.each(), map);
 *
 * // With indexed access
 * Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
 * listEach.&lt;Integer&gt;eachWithIndex().ifPresent(indexed -&gt; {
 *     List&lt;String&gt; numbered = IndexedTraversals.imodify(
 *         indexed,
 *         (i, s) -&gt; (i + 1) + &quot;. &quot; + s,
 *         list
 *     );
 * });
 *
 * // Use with FocusDSL
 * TraversalPath&lt;User, Order&gt; allOrders = userPath.via(ordersLens).each(listEach);
 * }&lt;/pre&gt;
 *
 * @see Each
 * @see Traversal
 * @see IndexedTraversal
 */
@NullMarked
public final class EachInstances {

  /** Private constructor to prevent instantiation. */
  private EachInstances() {}

  // ===== List =====

  /**
   * Creates an {@link Each} instance for {@link List} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses all elements in order and supports indexed access via
   * {@link Each#eachWithIndex()}.
   *
   * @param &lt;A&gt; The element type of the list
   * @return An {@code Each} instance for lists
   */
  public static &lt;A&gt; Each&lt;List&lt;A&gt;, A&gt; listEach() {
<span class="fc" id="L93">    return new ListEach&lt;&gt;();</span>
  }

  private static final class ListEach&lt;A&gt; implements Each&lt;List&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;List&lt;A&gt;, A&gt; each() {
<span class="fc" id="L99">      return Traversals.forList();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;I&gt; Optional&lt;IndexedTraversal&lt;I, List&lt;A&gt;, A&gt;&gt; eachWithIndex() {
<span class="fc" id="L105">      IndexedTraversal&lt;Integer, List&lt;A&gt;, A&gt; indexed = IndexedTraversals.forList();</span>
<span class="fc" id="L106">      return Optional.of((IndexedTraversal&lt;I, List&lt;A&gt;, A&gt;) indexed);</span>
    }
  }

  // ===== Set =====

  /**
   * Creates an {@link Each} instance for {@link Set} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses all elements. Traversal order depends on the Set
   * implementation. Does not support indexed access.
   *
   * @param &lt;A&gt; The element type of the set
   * @return An {@code Each} instance for sets
   */
  public static &lt;A&gt; Each&lt;Set&lt;A&gt;, A&gt; setEach() {
<span class="fc" id="L122">    return new SetEach&lt;&gt;();</span>
  }

  private static final class SetEach&lt;A&gt; implements Each&lt;Set&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;Set&lt;A&gt;, A&gt; each() {
<span class="fc" id="L128">      return TraverseTraversals.forSet();</span>
    }
    // No indexed traversal for Set
  }

  // ===== Map Values =====

  /**
   * Creates an {@link Each} instance for {@link Map} values.
   *
   * &lt;p&gt;The returned {@code Each} traverses all values in the map, with the corresponding key as the
   * index in {@link Each#eachWithIndex()}.
   *
   * @param &lt;K&gt; The key type of the map
   * @param &lt;V&gt; The value type of the map
   * @return An {@code Each} instance for map values
   */
  public static &lt;K, V&gt; Each&lt;Map&lt;K, V&gt;, V&gt; mapValuesEach() {
<span class="fc" id="L146">    return new MapValuesEach&lt;&gt;();</span>
  }

  private static final class MapValuesEach&lt;K, V&gt; implements Each&lt;Map&lt;K, V&gt;, V&gt; {
    @Override
    public Traversal&lt;Map&lt;K, V&gt;, V&gt; each() {
<span class="fc" id="L152">      return Traversals.forMapValues();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;I&gt; Optional&lt;IndexedTraversal&lt;I, Map&lt;K, V&gt;, V&gt;&gt; eachWithIndex() {
<span class="fc" id="L158">      IndexedTraversal&lt;K, Map&lt;K, V&gt;, V&gt; indexed = IndexedTraversals.forMap();</span>
<span class="fc" id="L159">      return Optional.of((IndexedTraversal&lt;I, Map&lt;K, V&gt;, V&gt;) indexed);</span>
    }
  }

  // ===== Optional =====

  /**
   * Creates an {@link Each} instance for {@link Optional} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses the value if present (0 or 1 element). Does not support
   * indexed access.
   *
   * @param &lt;A&gt; The element type of the optional
   * @return An {@code Each} instance for optionals
   */
  public static &lt;A&gt; Each&lt;Optional&lt;A&gt;, A&gt; optionalEach() {
<span class="fc" id="L175">    return new OptionalEach&lt;&gt;();</span>
  }

  private static final class OptionalEach&lt;A&gt; implements Each&lt;Optional&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;Optional&lt;A&gt;, A&gt; each() {
<span class="fc" id="L181">      return Traversals.forOptional();</span>
    }
    // No indexed traversal for Optional
  }

  // ===== Array =====

  /**
   * Creates an {@link Each} instance for array types.
   *
   * &lt;p&gt;The returned {@code Each} traverses all elements in order and supports indexed access via
   * {@link Each#eachWithIndex()}.
   *
   * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Due to Java's type erasure, array instances cannot be cached and a
   * new instance is created for each call.
   *
   * @param &lt;A&gt; The element type of the array
   * @return An {@code Each} instance for arrays
   */
  public static &lt;A&gt; Each&lt;A[], A&gt; arrayEach() {
<span class="fc" id="L201">    return new ArrayEach&lt;&gt;();</span>
  }

  private static final class ArrayEach&lt;A&gt; implements Each&lt;A[], A&gt; {
    @Override
    public Traversal&lt;A[], A&gt; each() {
<span class="fc" id="L207">      return FocusPaths.arrayElements();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;I&gt; Optional&lt;IndexedTraversal&lt;I, A[], A&gt;&gt; eachWithIndex() {
<span class="fc" id="L213">      return Optional.of((IndexedTraversal&lt;I, A[], A&gt;) createArrayIndexedTraversal());</span>
    }

    private IndexedTraversal&lt;Integer, A[], A&gt; createArrayIndexedTraversal() {
<span class="fc" id="L217">      return new IndexedTraversal&lt;&gt;() {</span>
        @Override
        public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, A[]&gt; imodifyF(
            BiFunction&lt;Integer, A, Kind&lt;F, A&gt;&gt; f, A[] source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">          if (source.length == 0) {</span>
<span class="fc" id="L222">            return app.of(source);</span>
          }

<span class="fc" id="L225">          List&lt;Kind&lt;F, A&gt;&gt; modifiedEffects = new ArrayList&lt;&gt;(source.length);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">          for (int i = 0; i &lt; source.length; i++) {</span>
<span class="fc" id="L227">            modifiedEffects.add(f.apply(i, source[i]));</span>
          }

<span class="fc" id="L230">          Kind&lt;F, List&lt;A&gt;&gt; sequenced = IndexedTraversals.sequenceList(modifiedEffects, app);</span>

<span class="fc" id="L232">          return app.map(</span>
              list -&gt; {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L235">                A[] result =</span>
                    (A[])
<span class="fc" id="L237">                        java.lang.reflect.Array.newInstance(</span>
<span class="fc" id="L238">                            source.getClass().getComponentType(), list.size());</span>
<span class="fc" id="L239">                list.toArray(result);</span>
<span class="fc" id="L240">                return result;</span>
              },
              sequenced);
        }
      };
    }
  }

  // ===== Stream =====

  /**
   * Creates an {@link Each} instance for {@link Stream} types.
   *
   * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Streams can only be consumed once. After using this traversal, the
   * original stream will be exhausted. The result will be a new stream.
   *
   * @param &lt;A&gt; The element type of the stream
   * @return An {@code Each} instance for streams
   */
  public static &lt;A&gt; Each&lt;Stream&lt;A&gt;, A&gt; streamEach() {
<span class="fc" id="L260">    return new StreamEach&lt;&gt;();</span>
  }

  private static final class StreamEach&lt;A&gt; implements Each&lt;Stream&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;Stream&lt;A&gt;, A&gt; each() {
<span class="fc" id="L266">      return TraverseTraversals.forStream();</span>
    }
    // No indexed traversal for Stream
  }

  // ===== String (Characters) =====

  /**
   * Creates an {@link Each} instance for {@link String} that traverses individual characters.
   *
   * &lt;p&gt;The returned {@code Each} traverses all characters in order and supports indexed access via
   * {@link Each#eachWithIndex()}.
   *
   * @return An {@code Each} instance for string characters
   */
  public static Each&lt;String, Character&gt; stringCharsEach() {
<span class="fc" id="L282">    return new StringCharsEach();</span>
  }

  private static final class StringCharsEach implements Each&lt;String, Character&gt; {
    @Override
    public Traversal&lt;String, Character&gt; each() {
<span class="fc" id="L288">      return new StringCharsTraversal();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;I&gt; Optional&lt;IndexedTraversal&lt;I, String, Character&gt;&gt; eachWithIndex() {
<span class="fc" id="L294">      return Optional.of(</span>
          (IndexedTraversal&lt;I, String, Character&gt;) new StringCharsIndexedTraversal());
    }
  }

  private static final class StringCharsTraversal implements Traversal&lt;String, Character&gt; {
    @Override
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, String&gt; modifyF(
        Function&lt;Character, Kind&lt;F, Character&gt;&gt; f, String source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L303" title="All 2 branches covered.">      if (source.isEmpty()) {</span>
<span class="fc" id="L304">        return app.of(source);</span>
      }

<span class="fc" id="L307">      List&lt;Kind&lt;F, Character&gt;&gt; modifiedEffects = new ArrayList&lt;&gt;(source.length());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">      for (int i = 0; i &lt; source.length(); i++) {</span>
<span class="fc" id="L309">        modifiedEffects.add(f.apply(source.charAt(i)));</span>
      }

<span class="fc" id="L312">      Kind&lt;F, List&lt;Character&gt;&gt; sequenced = IndexedTraversals.sequenceList(modifiedEffects, app);</span>

<span class="fc" id="L314">      return app.map(</span>
          chars -&gt; {
<span class="fc" id="L316">            StringBuilder sb = new StringBuilder(chars.size());</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            for (Character c : chars) {</span>
<span class="fc" id="L318">              sb.append(c);</span>
<span class="fc" id="L319">            }</span>
<span class="fc" id="L320">            return sb.toString();</span>
          },
          sequenced);
    }
  }

  private static final class StringCharsIndexedTraversal
      implements IndexedTraversal&lt;Integer, String, Character&gt; {
    @Override
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, String&gt; imodifyF(
        BiFunction&lt;Integer, Character, Kind&lt;F, Character&gt;&gt; f, String source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">      if (source.isEmpty()) {</span>
<span class="fc" id="L332">        return app.of(source);</span>
      }

<span class="fc" id="L335">      List&lt;Kind&lt;F, Character&gt;&gt; modifiedEffects = new ArrayList&lt;&gt;(source.length());</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">      for (int i = 0; i &lt; source.length(); i++) {</span>
<span class="fc" id="L337">        modifiedEffects.add(f.apply(i, source.charAt(i)));</span>
      }

<span class="fc" id="L340">      Kind&lt;F, List&lt;Character&gt;&gt; sequenced = IndexedTraversals.sequenceList(modifiedEffects, app);</span>

<span class="fc" id="L342">      return app.map(</span>
          chars -&gt; {
<span class="fc" id="L344">            StringBuilder sb = new StringBuilder(chars.size());</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            for (Character c : chars) {</span>
<span class="fc" id="L346">              sb.append(c);</span>
<span class="fc" id="L347">            }</span>
<span class="fc" id="L348">            return sb.toString();</span>
          },
          sequenced);
    }
  }

  // ===== From Traverse (Generic) =====

  /**
   * Creates an {@link Each} instance from a {@link Traverse} type class instance.
   *
   * &lt;p&gt;This factory method bridges the {@code Traverse} type class (which works on higher-kinded
   * types {@code Kind&lt;F, A&gt;}) to the {@code Each} type class (which works on concrete types).
   *
   * &lt;pre&gt;{@code
   * // Create Each from a Traverse instance
   * Traverse&lt;TreeKind.Witness&gt; treeTraverse = TreeTraverse.INSTANCE;
   * Each&lt;Kind&lt;TreeKind.Witness, String&gt;, String&gt; treeEach =
   *     EachInstances.fromTraverse(treeTraverse);
   *
   * // Use like any other Each
   * Traversal&lt;Kind&lt;TreeKind.Witness, String&gt;, String&gt; trav = treeEach.each();
   * }&lt;/pre&gt;
   *
   * @param &lt;F&gt; The witness type of the traversable container
   * @param &lt;A&gt; The element type within the container
   * @param traverse The Traverse instance for the container type; must not be null
   * @return An {@code Each} instance wrapping the Traverse
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; Each&lt;Kind&lt;F, A&gt;, A&gt; fromTraverse(
      Traverse&lt;F&gt; traverse) {
<span class="fc" id="L379">    return () -&gt; TraverseTraversals.forTraverse(traverse);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>