<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Resource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.vtask</a> &gt; <span class="el_source">Resource.java</span></div><h1>Resource.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.vtask;

import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * A functional resource type that guarantees cleanup via the bracket pattern.
 *
 * &lt;p&gt;Resource provides safe resource management for VTask computations. It ensures that resources
 * are always released, even when exceptions occur or structured concurrency tasks are cancelled.
 *
 * &lt;h2&gt;The Bracket Pattern&lt;/h2&gt;
 *
 * &lt;p&gt;Resource implements the bracket pattern (acquire-use-release):
 *
 * &lt;ol&gt;
 *   &lt;li&gt;&lt;b&gt;Acquire:&lt;/b&gt; The resource is acquired (connection opened, file handle created, etc.)
 *   &lt;li&gt;&lt;b&gt;Use:&lt;/b&gt; The resource is used to perform some computation
 *   &lt;li&gt;&lt;b&gt;Release:&lt;/b&gt; The resource is released (connection closed, file handle closed, etc.)
 * &lt;/ol&gt;
 *
 * &lt;p&gt;The release step is &lt;b&gt;guaranteed&lt;/b&gt; to run regardless of whether the use step succeeds or
 * fails. Resources are released in reverse order of acquisition (LIFO).
 *
 * &lt;h2&gt;Basic Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create a resource from AutoCloseable
 * Resource&lt;Connection&gt; connResource = Resource.fromAutoCloseable(
 *     () -&gt; dataSource.getConnection()
 * );
 *
 * // Use the resource
 * VTask&lt;List&lt;User&gt;&gt; users = connResource.use(conn -&gt;
 *     VTask.of(() -&gt; userDao.findAll(conn))
 * );
 *
 * // Resource is automatically closed after use
 * List&lt;User&gt; result = users.run();
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing Resources&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Combine two resources - both are acquired, used, then released in reverse order
 * Resource&lt;Tuple2&lt;Connection, Statement&gt;&gt; combined =
 *     connResource.and(stmtResource);
 *
 * // Chain resource acquisition
 * Resource&lt;PreparedStatement&gt; chained = connResource.flatMap(conn -&gt;
 *     Resource.make(
 *         () -&gt; conn.prepareStatement(sql),
 *         PreparedStatement::close
 *     )
 * );
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Preview API Notice&lt;/h2&gt;
 *
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; When used with structured concurrency, Resource respects task cancellation. If a
 * task is cancelled, acquired resources are still released.
 *
 * @param &lt;A&gt; the type of the managed resource
 * @see VTask
 * @see Scope
 */
public final class Resource&lt;A&gt; {

  private final Callable&lt;A&gt; acquire;
  private final Consumer&lt;A&gt; release;

<span class="fc" id="L76">  private Resource(Callable&lt;A&gt; acquire, Consumer&lt;A&gt; release) {</span>
<span class="fc" id="L77">    this.acquire = acquire;</span>
<span class="fc" id="L78">    this.release = release;</span>
<span class="fc" id="L79">  }</span>

  // ==================== Factory Methods ====================

  /**
   * Creates a Resource from explicit acquire and release functions.
   *
   * &lt;p&gt;This is the fundamental way to create a Resource. The acquire function is called when the
   * resource is needed, and the release function is guaranteed to be called after use.
   *
   * @param &lt;A&gt; the type of the managed resource
   * @param acquire function to acquire the resource; must not be null
   * @param release function to release the resource; must not be null
   * @return a new Resource
   * @throws NullPointerException if acquire or release is null
   */
  public static &lt;A&gt; Resource&lt;A&gt; make(Callable&lt;A&gt; acquire, Consumer&lt;A&gt; release) {
<span class="fc" id="L96">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L97">    Objects.requireNonNull(release, &quot;release must not be null&quot;);</span>
<span class="fc" id="L98">    return new Resource&lt;&gt;(acquire, release);</span>
  }

  /**
   * Creates a Resource from an AutoCloseable.
   *
   * &lt;p&gt;The resource's close() method is called automatically after use.
   *
   * @param &lt;A&gt; the type of the AutoCloseable resource
   * @param acquire function to acquire the AutoCloseable; must not be null
   * @return a new Resource that calls close() on release
   * @throws NullPointerException if acquire is null
   */
  public static &lt;A extends AutoCloseable&gt; Resource&lt;A&gt; fromAutoCloseable(Callable&lt;A&gt; acquire) {
<span class="fc" id="L112">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L113">    return new Resource&lt;&gt;(</span>
        acquire,
        resource -&gt; {
          try {
<span class="fc" id="L117">            resource.close();</span>
<span class="fc" id="L118">          } catch (Exception e) {</span>
            // Silently ignore close exceptions, as is standard with try-with-resources
            // Consider logging in production code
<span class="fc" id="L121">          }</span>
<span class="fc" id="L122">        });</span>
  }

  /**
   * Creates a Resource that does nothing (unit resource).
   *
   * &lt;p&gt;Useful as an identity element for resource composition.
   *
   * @param &lt;A&gt; the type parameter (arbitrary since no resource is managed)
   * @param value the value to return
   * @return a Resource that returns the value without any acquire/release behavior
   */
  public static &lt;A&gt; Resource&lt;A&gt; pure(A value) {
<span class="fc" id="L135">    return new Resource&lt;&gt;(() -&gt; value, a -&gt; {});</span>
  }

  // ==================== Core Operations ====================

  /**
   * Uses the resource with the given function, returning a VTask.
   *
   * &lt;p&gt;This is the primary way to use a Resource. The pattern is:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Acquire the resource
   *   &lt;li&gt;Apply the function to get a VTask
   *   &lt;li&gt;Execute the VTask
   *   &lt;li&gt;Release the resource (even if the VTask fails)
   *   &lt;li&gt;Return the result (or rethrow the exception)
   * &lt;/ol&gt;
   *
   * @param &lt;B&gt; the type of the result
   * @param f function that uses the resource; must not be null
   * @return a VTask that manages the resource lifecycle
   * @throws NullPointerException if f is null
   */
  public &lt;B&gt; VTask&lt;B&gt; use(Function&lt;? super A, ? extends VTask&lt;B&gt;&gt; f) {
<span class="fc" id="L159">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L161">    return () -&gt; {</span>
<span class="fc" id="L162">      A resource = acquire.call();</span>
      try {
<span class="fc" id="L164">        VTask&lt;B&gt; task = f.apply(resource);</span>
<span class="fc" id="L165">        Objects.requireNonNull(task, &quot;function must not return null&quot;);</span>
<span class="fc" id="L166">        return task.run();</span>
      } finally {
<span class="fc" id="L168">        release.accept(resource);</span>
      }
    };
  }

  /**
   * Uses the resource with a simple function (non-effectful).
   *
   * &lt;p&gt;Convenience method for when the use function doesn't need to return a VTask.
   *
   * @param &lt;B&gt; the type of the result
   * @param f function that uses the resource; must not be null
   * @return a VTask that manages the resource lifecycle
   * @throws NullPointerException if f is null
   */
  public &lt;B&gt; VTask&lt;B&gt; useSync(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L184">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L185">    return use(a -&gt; VTask.succeed(f.apply(a)));</span>
  }

  // ==================== Composition ====================

  /**
   * Transforms the resource value using the given function.
   *
   * &lt;p&gt;The transformation is applied after acquire, and the original resource is properly released.
   * Note that the release operates on the original resource type, not the transformed type.
   *
   * @param &lt;B&gt; the type of the transformed resource
   * @param f the transformation function; must not be null
   * @return a new Resource with transformed value
   * @throws NullPointerException if f is null
   */
  public &lt;B&gt; Resource&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L202">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

    // Use a holder to capture the original resource for release
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L206">    Object[] holder = new Object[1];</span>

<span class="fc" id="L208">    return new Resource&lt;&gt;(</span>
        () -&gt; {
<span class="fc" id="L210">          A a = acquire.call();</span>
<span class="fc" id="L211">          holder[0] = a;</span>
<span class="fc" id="L212">          return f.apply(a);</span>
        },
        b -&gt; {
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L216">          A a = (A) holder[0];</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">          if (a != null) {</span>
<span class="fc" id="L218">            release.accept(a);</span>
          }
<span class="fc" id="L220">        });</span>
  }

  /**
   * Chains resource acquisition.
   *
   * &lt;p&gt;The function is called with the first resource to acquire a second resource. Both resources
   * are released in reverse order (second first, then first).
   *
   * @param &lt;B&gt; the type of the second resource
   * @param f function that creates a second resource from the first; must not be null
   * @return a new Resource that manages both resources
   * @throws NullPointerException if f is null
   */
  public &lt;B&gt; Resource&lt;B&gt; flatMap(Function&lt;? super A, ? extends Resource&lt;B&gt;&gt; f) {
<span class="fc" id="L235">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

    // Holders to capture the outer resource and inner release for proper cleanup
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L239">    Object[] outerHolder = new Object[1];</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L241">    Consumer&lt;B&gt;[] innerReleaseHolder = new Consumer[1];</span>

<span class="fc" id="L243">    return new Resource&lt;&gt;(</span>
        () -&gt; {
<span class="fc" id="L245">          A a = acquire.call();</span>
<span class="fc" id="L246">          outerHolder[0] = a;</span>
          try {
<span class="fc" id="L248">            Resource&lt;B&gt; resourceB = f.apply(a);</span>
<span class="fc" id="L249">            Objects.requireNonNull(resourceB, &quot;function must not return null&quot;);</span>
<span class="fc" id="L250">            innerReleaseHolder[0] = resourceB.release;</span>
<span class="fc" id="L251">            return resourceB.acquire.call();</span>
<span class="fc" id="L252">          } catch (Throwable t) {</span>
            // If acquiring B fails, release A
            try {
<span class="fc" id="L255">              release.accept(a);</span>
<span class="fc" id="L256">            } catch (Exception e) {</span>
<span class="fc" id="L257">              t.addSuppressed(e);</span>
<span class="fc" id="L258">            }</span>
<span class="fc" id="L259">            throw t;</span>
          }
        },
        b -&gt; {
<span class="fc" id="L263">          Throwable firstException = null;</span>

          // Release inner resource (B) first
<span class="fc" id="L266">          Consumer&lt;B&gt; innerRelease = innerReleaseHolder[0];</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">          if (innerRelease != null) {</span>
            try {
<span class="fc" id="L269">              innerRelease.accept(b);</span>
<span class="fc" id="L270">            } catch (Throwable t) {</span>
<span class="fc" id="L271">              firstException = t;</span>
<span class="fc" id="L272">            }</span>
          }

          // Release outer resource (A) second
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L277">          A a = (A) outerHolder[0];</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">          if (a != null) {</span>
            try {
<span class="fc" id="L280">              release.accept(a);</span>
<span class="fc" id="L281">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">              if (firstException != null) {</span>
<span class="fc" id="L283">                t.addSuppressed(firstException);</span>
              }
<span class="fc" id="L285">              throw new RuntimeException(&quot;Failed to release outer resource&quot;, t);</span>
<span class="fc" id="L286">            }</span>
          }

<span class="fc bfc" id="L289" title="All 2 branches covered.">          if (firstException != null) {</span>
<span class="fc" id="L290">            throw new RuntimeException(&quot;Failed to release inner resource&quot;, firstException);</span>
          }
<span class="fc" id="L292">        });</span>
  }

  /**
   * Combines this resource with another, acquiring both and releasing in reverse order.
   *
   * &lt;p&gt;Both resources are acquired, used together, then released in LIFO order.
   *
   * @param &lt;B&gt; the type of the other resource
   * @param other the other resource to combine with; must not be null
   * @return a Resource producing a tuple of both values
   * @throws NullPointerException if other is null
   */
  public &lt;B&gt; Resource&lt;Par.Tuple2&lt;A, B&gt;&gt; and(Resource&lt;B&gt; other) {
<span class="fc" id="L306">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>

<span class="fc" id="L308">    return new Resource&lt;&gt;(</span>
        () -&gt; {
<span class="fc" id="L310">          A a = this.acquire.call();</span>
          try {
<span class="fc" id="L312">            B b = other.acquire.call();</span>
<span class="fc" id="L313">            return new Par.Tuple2&lt;&gt;(a, b);</span>
<span class="fc" id="L314">          } catch (Throwable t) {</span>
            try {
<span class="fc" id="L316">              this.release.accept(a);</span>
<span class="fc" id="L317">            } catch (Exception e) {</span>
<span class="fc" id="L318">              t.addSuppressed(e);</span>
<span class="fc" id="L319">            }</span>
<span class="fc" id="L320">            throw t;</span>
          }
        },
        tuple -&gt; {
<span class="fc" id="L324">          Throwable firstException = null;</span>
          try {
            // Release in reverse order (B first, then A)
<span class="fc" id="L327">            other.release.accept(tuple.second());</span>
<span class="fc" id="L328">          } catch (Throwable t) {</span>
<span class="fc" id="L329">            firstException = t;</span>
<span class="fc" id="L330">          }</span>
          try {
<span class="fc" id="L332">            this.release.accept(tuple.first());</span>
<span class="fc" id="L333">          } catch (Throwable t) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            if (firstException != null) {</span>
<span class="fc" id="L335">              t.addSuppressed(firstException);</span>
            }
<span class="fc" id="L337">            throw new RuntimeException(&quot;Failed to release resource&quot;, t);</span>
<span class="fc" id="L338">          }</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">          if (firstException != null) {</span>
<span class="fc" id="L340">            throw new RuntimeException(&quot;Failed to release resource&quot;, firstException);</span>
          }
<span class="fc" id="L342">        });</span>
  }

  /**
   * Combines three resources, acquiring all and releasing in reverse order.
   *
   * @param &lt;B&gt; the type of the second resource
   * @param &lt;C&gt; the type of the third resource
   * @param second the second resource; must not be null
   * @param third the third resource; must not be null
   * @return a Resource producing a tuple of all three values
   * @throws NullPointerException if second or third is null
   */
  public &lt;B, C&gt; Resource&lt;Par.Tuple3&lt;A, B, C&gt;&gt; and(Resource&lt;B&gt; second, Resource&lt;C&gt; third) {
<span class="fc" id="L356">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L357">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>

<span class="fc" id="L359">    return new Resource&lt;&gt;(</span>
        () -&gt; {
<span class="fc" id="L361">          A a = this.acquire.call();</span>
          try {
<span class="fc" id="L363">            B b = second.acquire.call();</span>
            try {
<span class="fc" id="L365">              C c = third.acquire.call();</span>
<span class="fc" id="L366">              return new Par.Tuple3&lt;&gt;(a, b, c);</span>
<span class="fc" id="L367">            } catch (Throwable t) {</span>
              try {
<span class="fc" id="L369">                second.release.accept(b);</span>
<span class="fc" id="L370">              } catch (Exception e) {</span>
<span class="fc" id="L371">                t.addSuppressed(e);</span>
<span class="fc" id="L372">              }</span>
<span class="fc" id="L373">              throw t;</span>
            }
<span class="fc" id="L375">          } catch (Throwable t) {</span>
            try {
<span class="fc" id="L377">              this.release.accept(a);</span>
<span class="fc" id="L378">            } catch (Exception e) {</span>
<span class="fc" id="L379">              t.addSuppressed(e);</span>
<span class="fc" id="L380">            }</span>
<span class="fc" id="L381">            throw t;</span>
          }
        },
        tuple -&gt; {
<span class="fc" id="L385">          Throwable firstException = null;</span>
          // Release in reverse order: C, B, A
          try {
<span class="fc" id="L388">            third.release.accept(tuple.third());</span>
<span class="fc" id="L389">          } catch (Throwable t) {</span>
<span class="fc" id="L390">            firstException = t;</span>
<span class="fc" id="L391">          }</span>
          try {
<span class="fc" id="L393">            second.release.accept(tuple.second());</span>
<span class="fc" id="L394">          } catch (Throwable t) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (firstException != null) {</span>
<span class="fc" id="L396">              t.addSuppressed(firstException);</span>
            }
<span class="fc" id="L398">            firstException = t;</span>
<span class="fc" id="L399">          }</span>
          try {
<span class="fc" id="L401">            this.release.accept(tuple.first());</span>
<span class="fc" id="L402">          } catch (Throwable t) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (firstException != null) {</span>
<span class="fc" id="L404">              t.addSuppressed(firstException);</span>
            }
<span class="fc" id="L406">            throw new RuntimeException(&quot;Failed to release resource&quot;, t);</span>
<span class="fc" id="L407">          }</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">          if (firstException != null) {</span>
<span class="fc" id="L409">            throw new RuntimeException(&quot;Failed to release resource&quot;, firstException);</span>
          }
<span class="fc" id="L411">        });</span>
  }

  // ==================== Finalizer Support ====================

  /**
   * Adds a finalizer that runs after the primary release.
   *
   * &lt;p&gt;The finalizer is guaranteed to run even if the primary release throws an exception.
   *
   * @param finalizer the finalizer to run; must not be null
   * @return a new Resource with the finalizer added
   * @throws NullPointerException if finalizer is null
   */
  public Resource&lt;A&gt; withFinalizer(Runnable finalizer) {
<span class="fc" id="L426">    Objects.requireNonNull(finalizer, &quot;finalizer must not be null&quot;);</span>

<span class="fc" id="L428">    return new Resource&lt;&gt;(</span>
        acquire,
        a -&gt; {
          try {
<span class="fc" id="L432">            release.accept(a);</span>
          } finally {
<span class="fc" id="L434">            finalizer.run();</span>
          }
<span class="fc" id="L436">        });</span>
  }

  /**
   * Adds cleanup that runs on failure only.
   *
   * &lt;p&gt;Useful for resources that need special handling when the use function fails.
   *
   * @param onFailure the cleanup to run on failure; must not be null
   * @return a Resource with failure cleanup added
   */
  public Resource&lt;A&gt; onFailure(Consumer&lt;? super A&gt; onFailure) {
<span class="fc" id="L448">    Objects.requireNonNull(onFailure, &quot;onFailure must not be null&quot;);</span>

<span class="fc" id="L450">    return new Resource&lt;&gt;(acquire, release);</span>
    // Note: Full implementation would track failure state in use()
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>