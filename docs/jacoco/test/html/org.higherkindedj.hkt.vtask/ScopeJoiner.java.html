<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScopeJoiner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.vtask</a> &gt; <span class="el_source">ScopeJoiner.java</span></div><h1>ScopeJoiner.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.vtask;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.StructuredTaskScope;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Stream;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.validated.Validated;

/**
 * A functional wrapper around Java 25's {@link StructuredTaskScope.Joiner} interface.
 *
 * &lt;p&gt;ScopeJoiner provides a hybrid approach that:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Wraps Java 25's native {@code Joiner} for direct interoperability
 *   &lt;li&gt;Provides functional result accessors via {@link Either} and {@link Validated}
 *   &lt;li&gt;Offers HKJ-specific joiners like error accumulation with {@link Validated}
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Use built-in joiner for all-succeed semantics
 * ScopeJoiner&lt;String, List&lt;String&gt;&gt; joiner = ScopeJoiner.allSucceed();
 *
 * // Use accumulating joiner for error collection
 * ScopeJoiner&lt;String, Validated&lt;List&lt;Error&gt;, List&lt;String&gt;&gt;&gt; accum =
 *     ScopeJoiner.accumulating(Error::fromException);
 *
 * // Access Java 25 Joiner directly when needed
 * StructuredTaskScope.Joiner&lt;String, List&lt;String&gt;&gt; java25Joiner = joiner.joiner();
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Preview API Notice&lt;/h2&gt;
 *
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This class uses Java 25's structured concurrency APIs which are currently in
 * preview (JEP 505/525). The underlying API may change in future Java releases. The ScopeJoiner
 * abstraction provides a buffer against such changes.
 *
 * @param &lt;T&gt; the type of values produced by subtasks
 * @param &lt;R&gt; the type of the final result after joining
 * @see StructuredTaskScope
 * @see StructuredTaskScope.Joiner
 */
public sealed interface ScopeJoiner&lt;T, R&gt;
    permits AllSucceedJoiner, AnySucceedJoiner, FirstCompleteJoiner, AccumulatingJoiner {

  /**
   * Returns the underlying Java 25 {@link StructuredTaskScope.Joiner}.
   *
   * &lt;p&gt;Use this method when you need direct access to Java's native structured concurrency API, for
   * example when passing to {@code StructuredTaskScope.open(Joiner)}.
   *
   * @return the underlying Java 25 Joiner; never null
   */
  StructuredTaskScope.Joiner&lt;T, R&gt; joiner();

  /**
   * Returns the result wrapped in an {@link Either}, capturing any exceptions.
   *
   * &lt;p&gt;This provides a functional alternative to the throwing {@code result()} method of Java 25's
   * Joiner. Exceptions are captured in the Left side of the Either.
   *
   * @return {@code Either.right(result)} on success, {@code Either.left(exception)} on failure
   */
  default Either&lt;Throwable, R&gt; resultEither() {
    try {
<span class="fc" id="L75">      return Either.right(joiner().result());</span>
<span class="fc" id="L76">    } catch (Throwable t) {</span>
<span class="fc" id="L77">      return Either.left(t);</span>
    }
  }

  // ==================== Factory Methods ====================

  /**
   * Creates a joiner that waits for all subtasks to succeed.
   *
   * &lt;p&gt;If any subtask fails, the entire operation fails with that exception. Results are collected
   * in the order tasks were forked.
   *
   * @param &lt;T&gt; the type of values produced by subtasks
   * @return a joiner that collects all successful results into a list
   */
  static &lt;T&gt; ScopeJoiner&lt;T, List&lt;T&gt;&gt; allSucceed() {
<span class="fc" id="L93">    return new AllSucceedJoiner&lt;&gt;();</span>
  }

  /**
   * Creates a joiner that returns the first successful result.
   *
   * &lt;p&gt;As soon as any subtask succeeds, its result is returned and other tasks are cancelled. If
   * all tasks fail, the operation fails with the last exception.
   *
   * @param &lt;T&gt; the type of values produced by subtasks
   * @return a joiner that returns the first successful result
   */
  static &lt;T&gt; ScopeJoiner&lt;T, T&gt; anySucceed() {
<span class="fc" id="L106">    return new AnySucceedJoiner&lt;&gt;();</span>
  }

  /**
   * Creates a joiner that returns the first completed result (success or failure).
   *
   * &lt;p&gt;This is useful for racing tasks where you want the fastest response, regardless of whether
   * it succeeded or failed.
   *
   * @param &lt;T&gt; the type of values produced by subtasks
   * @return a joiner that returns the first result to complete
   */
  static &lt;T&gt; ScopeJoiner&lt;T, T&gt; firstComplete() {
<span class="fc" id="L119">    return new FirstCompleteJoiner&lt;&gt;();</span>
  }

  /**
   * Creates a joiner that accumulates errors using {@link Validated}.
   *
   * &lt;p&gt;Unlike fail-fast joiners, this joiner waits for all tasks to complete and collects both
   * successes and failures. The result is a {@code Validated} that is:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code Valid(List&lt;T&gt;)} if all tasks succeeded
   *   &lt;li&gt;{@code Invalid(List&lt;E&gt;)} if any task failed, containing all mapped errors
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This is particularly useful for validation scenarios where you want to report all errors at
   * once rather than stopping at the first failure.
   *
   * @param &lt;E&gt; the error type after mapping
   * @param &lt;T&gt; the type of values produced by subtasks
   * @param errorMapper function to convert exceptions to error type E; must not be null
   * @return a joiner that accumulates all errors
   * @throws NullPointerException if errorMapper is null
   */
  static &lt;E, T&gt; ScopeJoiner&lt;T, Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt;&gt; accumulating(
      Function&lt;Throwable, E&gt; errorMapper) {
<span class="fc" id="L144">    Objects.requireNonNull(errorMapper, &quot;errorMapper must not be null&quot;);</span>
<span class="fc" id="L145">    return new AccumulatingJoiner&lt;&gt;(errorMapper);</span>
  }
}

// ==================== Implementation Classes ====================

/**
 * Joiner that waits for all subtasks to succeed.
 *
 * &lt;p&gt;Uses Java 25's built-in {@code Joiner.allSuccessfulOrThrow()} internally and converts the
 * Stream result to a List.
 *
 * @param &lt;T&gt; the type of values produced by subtasks
 */
@SuppressWarnings(&quot;preview&quot;)
final class AllSucceedJoiner&lt;T&gt; implements ScopeJoiner&lt;T, List&lt;T&gt;&gt; {

  private final StructuredTaskScope.Joiner&lt;T, List&lt;T&gt;&gt; delegate;

<span class="fc" id="L164">  AllSucceedJoiner() {</span>
    // Use the built-in joiner that handles all the logic
    // Note: allSuccessfulOrThrow() returns Stream&lt;Subtask&lt;T&gt;&gt;, not Stream&lt;T&gt;
    StructuredTaskScope.Joiner&lt;T, Stream&lt;StructuredTaskScope.Subtask&lt;T&gt;&gt;&gt; builtIn =
<span class="fc" id="L168">        StructuredTaskScope.Joiner.allSuccessfulOrThrow();</span>

<span class="fc" id="L170">    this.delegate =</span>
<span class="fc" id="L171">        new StructuredTaskScope.Joiner&lt;&gt;() {</span>
          @Override
          public boolean onFork(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc" id="L174">            return builtIn.onFork(subtask);</span>
          }

          @Override
          public boolean onComplete(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc" id="L179">            return builtIn.onComplete(subtask);</span>
          }

          @Override
          public List&lt;T&gt; result() throws Throwable {
            // Extract values from Subtasks and collect to List
<span class="fc" id="L185">            return builtIn.result().map(StructuredTaskScope.Subtask::get).toList();</span>
          }
        };
<span class="fc" id="L188">  }</span>

  @Override
  public StructuredTaskScope.Joiner&lt;T, List&lt;T&gt;&gt; joiner() {
<span class="fc" id="L192">    return delegate;</span>
  }
}

/**
 * Joiner that returns the first successful result.
 *
 * @param &lt;T&gt; the type of values produced by subtasks
 */
@SuppressWarnings(&quot;preview&quot;)
final class AnySucceedJoiner&lt;T&gt; implements ScopeJoiner&lt;T, T&gt; {

  private final StructuredTaskScope.Joiner&lt;T, T&gt; delegate;

<span class="fc" id="L206">  AnySucceedJoiner() {</span>
<span class="fc" id="L207">    this.delegate = StructuredTaskScope.Joiner.anySuccessfulResultOrThrow();</span>
<span class="fc" id="L208">  }</span>

  @Override
  public StructuredTaskScope.Joiner&lt;T, T&gt; joiner() {
<span class="fc" id="L212">    return delegate;</span>
  }
}

/**
 * Joiner that returns the first completed result (success or failure).
 *
 * &lt;p&gt;Stores the first completed subtask and returns its result. Other subtasks are cancelled.
 *
 * @param &lt;T&gt; the type of values produced by subtasks
 */
@SuppressWarnings(&quot;preview&quot;)
final class FirstCompleteJoiner&lt;T&gt; implements ScopeJoiner&lt;T, T&gt; {

  private final StructuredTaskScope.Joiner&lt;T, T&gt; delegate;

<span class="fc" id="L228">  FirstCompleteJoiner() {</span>
<span class="fc" id="L229">    AtomicReference&lt;StructuredTaskScope.Subtask&lt;? extends T&gt;&gt; firstCompleted =</span>
        new AtomicReference&lt;&gt;();

    // Use awaitAll() for proper completion tracking
<span class="fc" id="L233">    StructuredTaskScope.Joiner&lt;T, Void&gt; completionTracker = StructuredTaskScope.Joiner.awaitAll();</span>

<span class="fc" id="L235">    this.delegate =</span>
<span class="fc" id="L236">        new StructuredTaskScope.Joiner&lt;&gt;() {</span>
          @Override
          public boolean onFork(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (firstCompleted.get() != null) {</span>
<span class="fc" id="L240">              return false; // Don't fork if we already have a result</span>
            }
<span class="fc" id="L242">            return completionTracker.onFork(subtask);</span>
          }

          @Override
          public boolean onComplete(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (firstCompleted.compareAndSet(null, subtask)) {</span>
<span class="fc" id="L248">              return false; // Cancel remaining tasks - we have our result</span>
            }
<span class="fc" id="L250">            return completionTracker.onComplete(subtask);</span>
          }

          @Override
          public T result() throws Throwable {
<span class="fc" id="L255">            StructuredTaskScope.Subtask&lt;? extends T&gt; subtask = firstCompleted.get();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (subtask == null) {</span>
<span class="fc" id="L257">              throw new IllegalStateException(&quot;No subtask completed&quot;);</span>
            }
<span class="pc bpc" id="L259" title="1 of 3 branches missed.">            return switch (subtask.state()) {</span>
<span class="fc" id="L260">              case SUCCESS -&gt; subtask.get();</span>
<span class="fc" id="L261">              case FAILED -&gt; throw subtask.exception();</span>
              default -&gt;
<span class="nc" id="L263">                  throw new IllegalStateException(&quot;Subtask not completed: &quot; + subtask.state());</span>
            };
          }
        };
<span class="fc" id="L267">  }</span>

  @Override
  public StructuredTaskScope.Joiner&lt;T, T&gt; joiner() {
<span class="fc" id="L271">    return delegate;</span>
  }
}

/**
 * Joiner that accumulates all errors using {@link Validated}.
 *
 * &lt;p&gt;Unlike fail-fast joiners, this waits for ALL subtasks to complete, collecting both successes
 * and failures. Subtasks are tracked when forked and processed in the result() method.
 *
 * @param &lt;E&gt; the error type after mapping
 * @param &lt;T&gt; the type of values produced by subtasks
 */
@SuppressWarnings(&quot;preview&quot;)
final class AccumulatingJoiner&lt;E, T&gt; implements ScopeJoiner&lt;T, Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt;&gt; {

  // Store as class field to ensure proper capture
<span class="fc" id="L288">  private final List&lt;StructuredTaskScope.Subtask&lt;? extends T&gt;&gt; allSubtasks =</span>
<span class="fc" id="L289">      Collections.synchronizedList(new ArrayList&lt;&gt;());</span>
  private final Function&lt;Throwable, E&gt; errorMapper;
  private final StructuredTaskScope.Joiner&lt;T, Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt;&gt; delegate;

<span class="fc" id="L293">  AccumulatingJoiner(Function&lt;Throwable, E&gt; errorMapper) {</span>
<span class="fc" id="L294">    this.errorMapper = errorMapper;</span>

    // Use awaitAll() for proper completion tracking - it knows when all tasks are done
<span class="fc" id="L297">    StructuredTaskScope.Joiner&lt;T, Void&gt; completionTracker = StructuredTaskScope.Joiner.awaitAll();</span>

<span class="fc" id="L299">    this.delegate =</span>
<span class="fc" id="L300">        new StructuredTaskScope.Joiner&lt;&gt;() {</span>
          @Override
          public boolean onFork(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc" id="L303">            allSubtasks.add(subtask);</span>
<span class="fc" id="L304">            return completionTracker.onFork(subtask); // Let awaitAll track completion</span>
          }

          @Override
          public boolean onComplete(StructuredTaskScope.Subtask&lt;? extends T&gt; subtask) {
<span class="fc" id="L309">            return completionTracker.onComplete(subtask); // Let awaitAll track completion</span>
          }

          @Override
          public Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt; result() throws Throwable {
            // awaitAll ensures all tasks are complete before this is called
<span class="fc" id="L315">            completionTracker.result();</span>

<span class="fc" id="L317">            List&lt;E&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L318">            List&lt;T&gt; successes = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (StructuredTaskScope.Subtask&lt;? extends T&gt; subtask : allSubtasks) {</span>
<span class="pc bpc" id="L321" title="1 of 3 branches missed.">              switch (subtask.state()) {</span>
<span class="fc" id="L322">                case SUCCESS -&gt; successes.add(subtask.get());</span>
<span class="fc" id="L323">                case FAILED -&gt; errors.add(errorMapper.apply(subtask.exception()));</span>
                default -&gt; {} // UNAVAILABLE shouldn't happen after join
              }
<span class="fc" id="L326">            }</span>

<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (errors.isEmpty()) {</span>
<span class="fc" id="L329">              return Validated.valid(successes);</span>
            } else {
<span class="fc" id="L331">              return Validated.invalid(errors);</span>
            }
          }
        };
<span class="fc" id="L335">  }</span>

  @Override
  public StructuredTaskScope.Joiner&lt;T, Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt;&gt; joiner() {
<span class="fc" id="L339">    return delegate;</span>
  }

  /**
   * Returns the result wrapped in Either, adapting the Validated result.
   *
   * @return Either containing the Validated result
   */
  @Override
  public Either&lt;Throwable, Validated&lt;List&lt;E&gt;, List&lt;T&gt;&gt;&gt; resultEither() {
    try {
<span class="fc" id="L350">      return Either.right(delegate.result());</span>
<span class="nc" id="L351">    } catch (Throwable t) {</span>
<span class="nc" id="L352">      return Either.left(t);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>