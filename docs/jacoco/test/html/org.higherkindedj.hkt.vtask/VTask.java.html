<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.vtask</a> &gt; <span class="el_source">VTask.java</span></div><h1>VTask.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.vtask;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Represents a lazy computation that, when executed, runs on a Java virtual thread and produces a
 * value of type {@code A}. {@code VTask} is the primary effect type for virtual thread-based
 * concurrency in Higher-Kinded-J.
 *
 * &lt;p&gt;A {@code VTask&lt;A&gt;} instance does not perform any action when it's created. Instead, it acts as
 * a description or &quot;recipe&quot; for a computation that will be executed only when explicitly run via
 * {@link #run()}, {@link #runSafe()}, or {@link #runAsync()}. This deferred execution allows for
 * referential transparency and enables building complex concurrent programs that remain testable
 * and composable.
 *
 * &lt;p&gt;&lt;b&gt;Key Characteristics:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Laziness:&lt;/b&gt; Effects are not executed upon creation of a {@code VTask} value, but only
 *       when explicitly run.
 *   &lt;li&gt;&lt;b&gt;Virtual Threads:&lt;/b&gt; Computations execute on virtual threads, enabling millions of
 *       concurrent tasks with minimal memory overhead.
 *   &lt;li&gt;&lt;b&gt;Structured Concurrency:&lt;/b&gt; Uses Java 25's {@code StructuredTaskScope} for proper
 *       cancellation and error propagation.
 *   &lt;li&gt;&lt;b&gt;Composability:&lt;/b&gt; {@code VTask} operations can be easily chained using {@link
 *       #map(Function)}, {@link #flatMap(Function)}, and other combinators.
 *   &lt;li&gt;&lt;b&gt;HKT Integration:&lt;/b&gt; {@code VTask&lt;A&gt;} directly extends {@link VTaskKind VTaskKind&lt;A&gt;},
 *       making it a first-class participant in the Higher-Kinded-J HKT simulation.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * // Describe a computation that fetches data
 * VTask&lt;String&gt; fetchData = VTask.of(() -&gt; {
 *     // This runs on a virtual thread
 *     return httpClient.get(&quot;https://api.example.com/data&quot;);
 * });
 *
 * // Chain computations
 * VTask&lt;Integer&gt; processData = fetchData
 *     .map(String::length)
 *     .flatMap(len -&gt; VTask.of(() -&gt; processLength(len)));
 *
 * // Nothing has executed yet. To run:
 * Try&lt;Integer&gt; result = processData.runSafe();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; The type of the value produced by the computation when executed.
 * @see VTaskKind
 * @see Par
 */
@FunctionalInterface
public interface VTask&lt;A&gt; extends VTaskKind&lt;A&gt; {

  /**
   * The core operation representing the computation. This method is invoked internally when the
   * task is executed. Implementations should not call this directly; use {@link #run()}, {@link
   * #runSafe()}, or {@link #runAsync()} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method declares {@code throws Throwable} to allow lambda implementations
   * to throw checked exceptions. The public execution methods ({@link #run()}, {@link #runSafe()},
   * {@link #runAsync()}) handle exception translation at the boundary.
   *
   * @return The result of the computation of type {@code A}.
   * @throws Throwable If the computation fails.
   */
  @Nullable A execute() throws Throwable;

  /**
   * Returns this VTask as a {@link Callable} for use with {@code StructuredTaskScope.fork()}.
   *
   * &lt;p&gt;This method wraps the {@link #execute()} method to handle the exception type mismatch
   * between {@code execute()} (which throws {@code Throwable}) and {@code Callable.call()} (which
   * throws {@code Exception}).
   *
   * @return A {@link Callable} that invokes this task's execute method. Never null.
   */
  default Callable&lt;A&gt; asCallable() {
<span class="fc" id="L93">    return () -&gt; {</span>
      try {
<span class="fc" id="L95">        return execute();</span>
<span class="fc" id="L96">      } catch (Exception e) {</span>
<span class="fc" id="L97">        throw e;</span>
<span class="fc" id="L98">      } catch (Throwable t) {</span>
        // Error is unchecked and can be thrown directly
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (t instanceof Error) throw (Error) t;</span>
        // Wrap any other Throwable (rare) in RuntimeException
<span class="fc" id="L102">        throw new RuntimeException(t);</span>
      }
    };
  }

  // ===== FACTORY METHODS =====

  /**
   * Creates a {@code VTask&lt;A&gt;} from a {@link Callable}. The callable will be executed on a virtual
   * thread when the task is run.
   *
   * @param callable The computation to execute. Must not be null.
   * @param &lt;A&gt; The type of the value produced by the callable.
   * @return A new {@code VTask&lt;A&gt;} representing the deferred computation. Never null.
   * @throws NullPointerException if {@code callable} is null.
   */
  static &lt;A&gt; VTask&lt;A&gt; of(Callable&lt;A&gt; callable) {
<span class="fc" id="L119">    Objects.requireNonNull(callable, &quot;callable cannot be null&quot;);</span>
<span class="fc" id="L120">    return callable::call;</span>
  }

  /**
   * Creates a {@code VTask&lt;A&gt;} that defers a computation described by the given {@link Supplier}.
   * This is the primary way to lift an arbitrary block of code into a {@code VTask} context.
   *
   * @param thunk A {@link Supplier} that produces a value of type {@code A}. Must not be null.
   * @param &lt;A&gt; The type of the value produced.
   * @return A new {@code VTask&lt;A&gt;} representing the deferred computation. Never null.
   * @throws NullPointerException if {@code thunk} is null.
   */
  static &lt;A&gt; VTask&lt;A&gt; delay(Supplier&lt;A&gt; thunk) {
<span class="fc" id="L133">    Validation.function().requireFunction(thunk, &quot;thunk&quot;, VTask.class, DELAY);</span>
<span class="fc" id="L134">    return thunk::get;</span>
  }

  /**
   * Creates a {@code VTask&lt;A&gt;} that immediately succeeds with the given value when executed. This
   * is the &quot;pure&quot; or &quot;return&quot; operation for the VTask monad.
   *
   * @param value The value to wrap. Can be {@code null}.
   * @param &lt;A&gt; The type of the value.
   * @return A new {@code VTask&lt;A&gt;} that succeeds with the given value. Never null.
   */
  static &lt;A&gt; VTask&lt;A&gt; succeed(@Nullable A value) {
<span class="fc" id="L146">    return () -&gt; value;</span>
  }

  /**
   * Creates a {@code VTask&lt;A&gt;} that immediately fails with the given throwable when executed.
   *
   * @param error The throwable representing the failure. Must not be null.
   * @param &lt;A&gt; The phantom type parameter of the value.
   * @return A new {@code VTask&lt;A&gt;} that fails with the given error. Never null.
   * @throws NullPointerException if {@code error} is null.
   */
  static &lt;A&gt; VTask&lt;A&gt; fail(Throwable error) {
<span class="fc" id="L158">    Validation.coreType().requireError(error, VTask.class, RAISE_ERROR);</span>
<span class="fc" id="L159">    return () -&gt; {</span>
<span class="fc" id="L160">      throw error;</span>
    };
  }

  /**
   * Creates a {@code VTask&lt;Unit&gt;} from a {@link Runnable}. The task will execute the runnable and
   * return {@link Unit#INSTANCE}.
   *
   * @param runnable The side effect to execute. Must not be null.
   * @return A new {@code VTask&lt;Unit&gt;} that executes the runnable. Never null.
   * @throws NullPointerException if {@code runnable} is null.
   */
  static VTask&lt;Unit&gt; exec(Runnable runnable) {
<span class="fc" id="L173">    Objects.requireNonNull(runnable, &quot;runnable cannot be null&quot;);</span>
<span class="fc" id="L174">    return () -&gt; {</span>
<span class="fc" id="L175">      runnable.run();</span>
<span class="fc" id="L176">      return Unit.INSTANCE;</span>
    };
  }

  /**
   * Creates a {@code VTask&lt;A&gt;} that explicitly marks the computation as blocking. This is a hint
   * that the operation may block for I/O or other external resources.
   *
   * &lt;p&gt;In virtual thread contexts, blocking operations automatically unmount from the carrier
   * thread, so this marker is primarily for documentation and potential future optimisations.
   *
   * @param callable The blocking computation. Must not be null.
   * @param &lt;A&gt; The type of the value produced.
   * @return A new {@code VTask&lt;A&gt;} representing the blocking computation. Never null.
   * @throws NullPointerException if {@code callable} is null.
   */
  static &lt;A&gt; VTask&lt;A&gt; blocking(Callable&lt;A&gt; callable) {
<span class="fc" id="L193">    Objects.requireNonNull(callable, &quot;callable cannot be null&quot;);</span>
    // Virtual threads handle blocking automatically, but we mark it for clarity
<span class="fc" id="L195">    return callable::call;</span>
  }

  // ===== EXECUTION METHODS =====

  /**
   * Executes this {@code VTask} synchronously, blocking until completion.
   *
   * &lt;p&gt;This method executes the computation on the current thread. For asynchronous execution on a
   * virtual thread, use {@link #runAsync()}. For parallel execution of multiple tasks, use the
   * combinators in {@link Par}.
   *
   * &lt;p&gt;&lt;b&gt;Exception handling:&lt;/b&gt; Unchecked exceptions ({@link RuntimeException} and {@link Error})
   * are thrown directly. Checked exceptions are wrapped in {@link VTaskExecutionException}. For
   * functional error handling that preserves the original exception type, use {@link #runSafe()}
   * instead.
   *
   * @return The result of the computation of type {@code A}.
   * @throws VTaskExecutionException if the computation throws a checked exception
   * @throws RuntimeException if the computation throws an unchecked exception
   */
  default @Nullable A run() {
    try {
<span class="fc" id="L218">      return execute();</span>
<span class="fc" id="L219">    } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L220">      throw e;</span>
<span class="fc" id="L221">    } catch (Throwable t) {</span>
<span class="fc" id="L222">      throw new VTaskExecutionException(t);</span>
    }
  }

  /**
   * Executes this {@code VTask}, returning the result as a {@link Try}.
   *
   * &lt;p&gt;This is the preferred method for error handling. Unlike {@link #run()}, which wraps checked
   * exceptions in {@link VTaskExecutionException}, this method preserves the original exception
   * type in the {@code Try.Failure}.
   *
   * @return A {@link Try} containing either the successful result or the failure. Never null.
   */
  default Try&lt;A&gt; runSafe() {
    try {
<span class="fc" id="L237">      return Try.success(execute());</span>
<span class="fc" id="L238">    } catch (Throwable t) {</span>
<span class="fc" id="L239">      return Try.failure(t);</span>
    }
  }

  /**
   * Executes this {@code VTask} asynchronously on a virtual thread, returning a {@link
   * CompletableFuture}.
   *
   * &lt;p&gt;The computation starts immediately on a virtual thread. The returned future can be used to
   * wait for the result or combine with other asynchronous operations.
   *
   * @return A {@link CompletableFuture} that will complete with the result. Never null.
   */
  default CompletableFuture&lt;A&gt; runAsync() {
<span class="fc" id="L253">    return CompletableFuture.supplyAsync(</span>
        () -&gt; {
          try {
<span class="fc" id="L256">            return execute();</span>
<span class="fc" id="L257">          } catch (Throwable t) {</span>
<span class="fc" id="L258">            throw new CompletionException(t);</span>
          }
        },
<span class="fc" id="L261">        r -&gt; Thread.ofVirtual().start(r));</span>
  }

  // ===== COMPOSITION METHODS =====

  /**
   * Transforms the result of this {@code VTask} using the provided mapping function, without
   * altering its effectful nature. This is the Functor {@code map} operation for {@code VTask}.
   *
   * @param f A function to apply to the result. Must not be null.
   * @param &lt;B&gt; The type of the transformed value.
   * @return A new {@code VTask&lt;B&gt;} that applies the function to the result. Never null.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; VTask&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L276">    Validation.function().requireMapper(f, &quot;f&quot;, VTask.class, MAP);</span>
<span class="fc" id="L277">    return () -&gt; f.apply(this.execute());</span>
  }

  /**
   * Composes this {@code VTask} with another {@code VTask}-producing function. This is the Monad
   * {@code flatMap} (or {@code bind}) operation for {@code VTask}.
   *
   * &lt;p&gt;First, this task is executed to get a value. Then, the function {@code f} is applied to that
   * value to get a new {@code VTask}, which is then executed to get the final result.
   *
   * @param f A function that produces a new {@code VTask} from the result. Must not be null.
   * @param &lt;B&gt; The type of the value produced by the resulting task.
   * @return A new {@code VTask&lt;B&gt;} representing the composed computation. Never null.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; VTask&lt;B&gt; flatMap(Function&lt;? super A, ? extends VTask&lt;B&gt;&gt; f) {
<span class="fc" id="L293">    Validation.function().requireFlatMapper(f, &quot;f&quot;, VTask.class, FLAT_MAP);</span>
<span class="fc" id="L294">    return () -&gt; {</span>
<span class="fc" id="L295">      A a = this.execute();</span>
<span class="fc" id="L296">      VTask&lt;B&gt; next = f.apply(a);</span>
<span class="fc" id="L297">      Validation.function().requireNonNullResult(next, &quot;f&quot;, VTask.class, FLAT_MAP, VTask.class);</span>
<span class="fc" id="L298">      return next.execute();</span>
    };
  }

  /**
   * Alias for {@link #flatMap(Function)}. Chains this task with another task-producing function.
   *
   * @param f A function that produces a new {@code VTask} from the result. Must not be null.
   * @param &lt;B&gt; The type of the value produced by the resulting task.
   * @return A new {@code VTask&lt;B&gt;} representing the composed computation. Never null.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; VTask&lt;B&gt; via(Function&lt;? super A, ? extends VTask&lt;B&gt;&gt; f) {
<span class="fc" id="L311">    return flatMap(f);</span>
  }

  /**
   * Sequences this task with another task, discarding the result of this task.
   *
   * @param next A supplier that produces the next task. Must not be null.
   * @param &lt;B&gt; The type of the value produced by the next task.
   * @return A new {@code VTask&lt;B&gt;} that executes both tasks in sequence. Never null.
   * @throws NullPointerException if {@code next} is null.
   */
  default &lt;B&gt; VTask&lt;B&gt; then(Supplier&lt;? extends VTask&lt;B&gt;&gt; next) {
<span class="fc" id="L323">    Objects.requireNonNull(next, &quot;next cannot be null&quot;);</span>
<span class="fc" id="L324">    return () -&gt; {</span>
<span class="fc" id="L325">      this.execute(); // Execute and discard result</span>
<span class="fc" id="L326">      VTask&lt;B&gt; nextTask = next.get();</span>
<span class="fc" id="L327">      Objects.requireNonNull(nextTask, &quot;next supplier returned null&quot;);</span>
<span class="fc" id="L328">      return nextTask.execute();</span>
    };
  }

  /**
   * Performs a side-effect action on the successful result without modifying it.
   *
   * @param action The action to perform on the result. Must not be null.
   * @return A new {@code VTask&lt;A&gt;} that performs the action and returns the original value. Never
   *     null.
   * @throws NullPointerException if {@code action} is null.
   */
  default VTask&lt;A&gt; peek(Consumer&lt;? super A&gt; action) {
<span class="fc" id="L341">    Objects.requireNonNull(action, &quot;action cannot be null&quot;);</span>
<span class="fc" id="L342">    return () -&gt; {</span>
<span class="fc" id="L343">      A result = this.execute();</span>
<span class="fc" id="L344">      action.accept(result);</span>
<span class="fc" id="L345">      return result;</span>
    };
  }

  // ===== TIMEOUT AND CANCELLATION =====

  /**
   * Creates a new task that fails if this task does not complete within the specified duration.
   *
   * @param duration The maximum time to wait. Must not be null.
   * @return A new {@code VTask&lt;A&gt;} with timeout behaviour. Never null.
   * @throws NullPointerException if {@code duration} is null.
   */
  default VTask&lt;A&gt; timeout(Duration duration) {
<span class="fc" id="L359">    Objects.requireNonNull(duration, &quot;duration cannot be null&quot;);</span>
<span class="fc" id="L360">    return () -&gt; {</span>
      try {
<span class="fc" id="L362">        return runAsync().orTimeout(duration.toMillis(), TimeUnit.MILLISECONDS).join();</span>
<span class="fc" id="L363">      } catch (CompletionException e) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (e.getCause() instanceof TimeoutException) {</span>
<span class="fc" id="L365">          throw new TimeoutException(&quot;VTask timed out after &quot; + duration);</span>
        }
<span class="fc" id="L367">        throw e.getCause();</span>
      }
    };
  }

  // ===== ERROR HANDLING =====

  /**
   * Recovers from a failure by applying the given function to the exception.
   *
   * @param recoveryFunction A function that produces a recovery value from the exception. Must not
   *     be null.
   * @return A new {@code VTask&lt;A&gt;} that recovers from failures. Never null.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default VTask&lt;A&gt; recover(Function&lt;? super Throwable, ? extends A&gt; recoveryFunction) {
<span class="fc" id="L383">    Validation.function()</span>
<span class="fc" id="L384">        .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, VTask.class, RECOVER);</span>
<span class="fc" id="L385">    return () -&gt; {</span>
      try {
<span class="fc" id="L387">        return this.execute();</span>
<span class="fc" id="L388">      } catch (Throwable t) {</span>
<span class="fc" id="L389">        return recoveryFunction.apply(t);</span>
      }
    };
  }

  /**
   * Recovers from a failure by applying the given function to produce a new task.
   *
   * @param recoveryFunction A function that produces a recovery task from the exception. Must not
   *     be null.
   * @return A new {@code VTask&lt;A&gt;} that recovers from failures. Never null.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default VTask&lt;A&gt; recoverWith(Function&lt;? super Throwable, ? extends VTask&lt;A&gt;&gt; recoveryFunction) {
<span class="fc" id="L403">    Validation.function()</span>
<span class="fc" id="L404">        .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, VTask.class, RECOVER_WITH);</span>
<span class="fc" id="L405">    return () -&gt; {</span>
      try {
<span class="fc" id="L407">        return this.execute();</span>
<span class="fc" id="L408">      } catch (Throwable t) {</span>
<span class="fc" id="L409">        VTask&lt;A&gt; recovery = recoveryFunction.apply(t);</span>
<span class="fc" id="L410">        Validation.function()</span>
<span class="fc" id="L411">            .requireNonNullResult(</span>
                recovery, &quot;recoveryFunction&quot;, VTask.class, RECOVER_WITH, VTask.class);
<span class="fc" id="L413">        return recovery.execute();</span>
      }
    };
  }

  /**
   * Transforms the error of a failed task using the given function.
   *
   * @param f A function that transforms the exception. Must not be null.
   * @return A new {@code VTask&lt;A&gt;} with the transformed error. Never null.
   * @throws NullPointerException if {@code f} is null.
   */
  default VTask&lt;A&gt; mapError(Function&lt;? super Throwable, ? extends Throwable&gt; f) {
<span class="fc" id="L426">    Validation.function().requireMapper(f, &quot;f&quot;, VTask.class, MAP_ERROR);</span>
<span class="fc" id="L427">    return () -&gt; {</span>
      try {
<span class="fc" id="L429">        return this.execute();</span>
<span class="fc" id="L430">      } catch (Throwable t) {</span>
<span class="fc" id="L431">        throw f.apply(t);</span>
      }
    };
  }

  /**
   * Discards the result of this task, replacing it with {@link Unit}.
   *
   * @return A new {@code VTask&lt;Unit&gt;} that performs the same effect but returns {@link
   *     Unit#INSTANCE}. Never null.
   */
  default VTask&lt;Unit&gt; asUnit() {
<span class="fc" id="L443">    return this.map(_ -&gt; Unit.INSTANCE);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>