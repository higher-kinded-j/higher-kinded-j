<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Par.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.vtask</a> &gt; <span class="el_source">Par.java</span></div><h1>Par.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.vtask;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.StructuredTaskScope;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.function.Function3;

/**
 * Utility class providing parallel combinators for {@link VTask} computations.
 *
 * &lt;p&gt;{@code Par} provides operations for executing multiple VTasks concurrently using Java 25's
 * {@code StructuredTaskScope}. All operations in this class leverage virtual threads for
 * lightweight concurrent execution with proper cancellation semantics.
 *
 * &lt;p&gt;&lt;b&gt;Key operations:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #zip(VTask, VTask)} - Execute two tasks in parallel, combine results
 *   &lt;li&gt;{@link #zip3(VTask, VTask, VTask)} - Execute three tasks in parallel, combine results
 *   &lt;li&gt;{@link #map2(VTask, VTask, BiFunction)} - Execute two tasks in parallel, apply function
 *   &lt;li&gt;{@link #race(List)} - Return the first task to complete
 *   &lt;li&gt;{@link #all(List)} - Wait for all tasks to complete
 *   &lt;li&gt;{@link #traverse(List, Function)} - Apply function to list, execute results in parallel
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Error handling:&lt;/b&gt; Most operations use fail-fast semantics - if any task fails, the entire
 * operation fails and other tasks are cancelled. The {@link #race(List)} operation returns the
 * first successful result or fails if all tasks fail.
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * VTask&lt;String&gt; fetchUser = VTask.of(() -&gt; userService.getUser(id));
 * VTask&lt;String&gt; fetchProfile = VTask.of(() -&gt; profileService.getProfile(id));
 *
 * // Execute both in parallel and combine results
 * VTask&lt;UserProfile&gt; combined = Par.map2(
 *     fetchUser,
 *     fetchProfile,
 *     (user, profile) -&gt; new UserProfile(user, profile)
 * );
 *
 * UserProfile result = combined.run();
 * }&lt;/pre&gt;
 *
 * @see VTask
 * @see StructuredTaskScope
 */
public final class Par {

  private Par() {
    // Utility class - prevent instantiation
  }

  /**
   * Executes two tasks in parallel and combines their results into a tuple-like record.
   *
   * &lt;p&gt;Both tasks are forked simultaneously using {@code StructuredTaskScope}. If either task
   * fails, the entire operation fails and the other task is cancelled.
   *
   * @param &lt;A&gt; The type of the first task's result.
   * @param &lt;B&gt; The type of the second task's result.
   * @param taskA The first task. Must not be null.
   * @param taskB The second task. Must not be null.
   * @return A {@code VTask} that produces a {@link Tuple2} containing both results. Never null.
   * @throws NullPointerException if either task is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A, B&gt; VTask&lt;Tuple2&lt;A, B&gt;&gt; zip(VTask&lt;A&gt; taskA, VTask&lt;B&gt; taskB) {
<span class="fc" id="L75">    Objects.requireNonNull(taskA, &quot;taskA cannot be null&quot;);</span>
<span class="fc" id="L76">    Objects.requireNonNull(taskB, &quot;taskB cannot be null&quot;);</span>

<span class="fc" id="L78">    return () -&gt; {</span>
<span class="fc" id="L79">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L80">        var subtaskA = scope.fork(taskA.asCallable());</span>
<span class="fc" id="L81">        var subtaskB = scope.fork(taskB.asCallable());</span>

<span class="fc" id="L83">        scope.join();</span>

<span class="fc" id="L85">        return new Tuple2&lt;&gt;(subtaskA.get(), subtaskB.get());</span>
<span class="fc" id="L86">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L87">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Executes three tasks in parallel and combines their results into a tuple-like record.
   *
   * &lt;p&gt;All tasks are forked simultaneously using {@code StructuredTaskScope}. If any task fails,
   * the entire operation fails and the other tasks are cancelled.
   *
   * @param &lt;A&gt; The type of the first task's result.
   * @param &lt;B&gt; The type of the second task's result.
   * @param &lt;C&gt; The type of the third task's result.
   * @param taskA The first task. Must not be null.
   * @param taskB The second task. Must not be null.
   * @param taskC The third task. Must not be null.
   * @return A {@code VTask} that produces a {@link Tuple3} containing all results. Never null.
   * @throws NullPointerException if any task is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A, B, C&gt; VTask&lt;Tuple3&lt;A, B, C&gt;&gt; zip3(
      VTask&lt;A&gt; taskA, VTask&lt;B&gt; taskB, VTask&lt;C&gt; taskC) {
<span class="fc" id="L110">    Objects.requireNonNull(taskA, &quot;taskA cannot be null&quot;);</span>
<span class="fc" id="L111">    Objects.requireNonNull(taskB, &quot;taskB cannot be null&quot;);</span>
<span class="fc" id="L112">    Objects.requireNonNull(taskC, &quot;taskC cannot be null&quot;);</span>

<span class="fc" id="L114">    return () -&gt; {</span>
<span class="fc" id="L115">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L116">        var subtaskA = scope.fork(taskA.asCallable());</span>
<span class="fc" id="L117">        var subtaskB = scope.fork(taskB.asCallable());</span>
<span class="fc" id="L118">        var subtaskC = scope.fork(taskC.asCallable());</span>

<span class="fc" id="L120">        scope.join();</span>

<span class="fc" id="L122">        return new Tuple3&lt;&gt;(subtaskA.get(), subtaskB.get(), subtaskC.get());</span>
<span class="fc" id="L123">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L124">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Executes two tasks in parallel and applies a combining function to their results.
   *
   * @param &lt;A&gt; The type of the first task's result.
   * @param &lt;B&gt; The type of the second task's result.
   * @param &lt;R&gt; The type of the combined result.
   * @param taskA The first task. Must not be null.
   * @param taskB The second task. Must not be null.
   * @param combiner The function to combine the results. Must not be null.
   * @return A {@code VTask} that produces the combined result. Never null.
   * @throws NullPointerException if any argument is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A, B, R&gt; VTask&lt;R&gt; map2(
      VTask&lt;A&gt; taskA, VTask&lt;B&gt; taskB, BiFunction&lt;? super A, ? super B, ? extends R&gt; combiner) {
<span class="fc" id="L144">    Objects.requireNonNull(taskA, &quot;taskA cannot be null&quot;);</span>
<span class="fc" id="L145">    Objects.requireNonNull(taskB, &quot;taskB cannot be null&quot;);</span>
<span class="fc" id="L146">    Objects.requireNonNull(combiner, &quot;combiner cannot be null&quot;);</span>

<span class="fc" id="L148">    return () -&gt; {</span>
<span class="fc" id="L149">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L150">        var subtaskA = scope.fork(taskA.asCallable());</span>
<span class="fc" id="L151">        var subtaskB = scope.fork(taskB.asCallable());</span>

<span class="fc" id="L153">        scope.join();</span>

<span class="fc" id="L155">        return combiner.apply(subtaskA.get(), subtaskB.get());</span>
<span class="fc" id="L156">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L157">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Executes three tasks in parallel and applies a combining function to their results.
   *
   * @param &lt;A&gt; The type of the first task's result.
   * @param &lt;B&gt; The type of the second task's result.
   * @param &lt;C&gt; The type of the third task's result.
   * @param &lt;R&gt; The type of the combined result.
   * @param taskA The first task. Must not be null.
   * @param taskB The second task. Must not be null.
   * @param taskC The third task. Must not be null.
   * @param combiner The function to combine the results. Must not be null.
   * @return A {@code VTask} that produces the combined result. Never null.
   * @throws NullPointerException if any argument is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A, B, C, R&gt; VTask&lt;R&gt; map3(
      VTask&lt;A&gt; taskA, VTask&lt;B&gt; taskB, VTask&lt;C&gt; taskC, Function3&lt;A, B, C, R&gt; combiner) {
<span class="fc" id="L179">    Objects.requireNonNull(taskA, &quot;taskA cannot be null&quot;);</span>
<span class="fc" id="L180">    Objects.requireNonNull(taskB, &quot;taskB cannot be null&quot;);</span>
<span class="fc" id="L181">    Objects.requireNonNull(taskC, &quot;taskC cannot be null&quot;);</span>
<span class="fc" id="L182">    Objects.requireNonNull(combiner, &quot;combiner cannot be null&quot;);</span>

<span class="fc" id="L184">    return () -&gt; {</span>
<span class="fc" id="L185">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L186">        var subtaskA = scope.fork(taskA.asCallable());</span>
<span class="fc" id="L187">        var subtaskB = scope.fork(taskB.asCallable());</span>
<span class="fc" id="L188">        var subtaskC = scope.fork(taskC.asCallable());</span>

<span class="fc" id="L190">        scope.join();</span>

<span class="fc" id="L192">        return combiner.apply(subtaskA.get(), subtaskB.get(), subtaskC.get());</span>
<span class="fc" id="L193">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L194">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Races multiple tasks, returning the result of the first one to complete successfully.
   *
   * &lt;p&gt;All tasks are started in parallel. As soon as one task completes successfully, its result is
   * returned and other tasks are cancelled. If all tasks fail, the exception from the last task to
   * fail is thrown.
   *
   * @param &lt;A&gt; The type of the tasks' results.
   * @param tasks The list of tasks to race. Must not be null or empty.
   * @return A {@code VTask} that produces the first successful result. Never null.
   * @throws NullPointerException if {@code tasks} is null.
   * @throws IllegalArgumentException if {@code tasks} is empty.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A&gt; VTask&lt;A&gt; race(List&lt;VTask&lt;A&gt;&gt; tasks) {
<span class="fc" id="L214">    Objects.requireNonNull(tasks, &quot;tasks cannot be null&quot;);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (tasks.isEmpty()) {</span>
<span class="fc" id="L216">      throw new IllegalArgumentException(&quot;tasks cannot be empty&quot;);</span>
    }

<span class="fc" id="L219">    return () -&gt; {</span>
      try (var scope =
<span class="fc" id="L221">          StructuredTaskScope.open(StructuredTaskScope.Joiner.&lt;A&gt;anySuccessfulResultOrThrow())) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (VTask&lt;A&gt; task : tasks) {</span>
<span class="fc" id="L223">          scope.fork(task.asCallable());</span>
<span class="fc" id="L224">        }</span>

<span class="fc" id="L226">        return scope.join();</span>
<span class="fc" id="L227">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L228">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Executes all tasks in parallel and collects their results into a list.
   *
   * &lt;p&gt;All tasks are forked simultaneously. If any task fails, the entire operation fails and other
   * tasks are cancelled. Results are collected in the same order as the input tasks.
   *
   * @param &lt;A&gt; The type of the tasks' results.
   * @param tasks The list of tasks to execute. Must not be null.
   * @return A {@code VTask} that produces a list of all results. Never null.
   * @throws NullPointerException if {@code tasks} is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A&gt; VTask&lt;List&lt;A&gt;&gt; all(List&lt;VTask&lt;A&gt;&gt; tasks) {
<span class="fc" id="L246">    Objects.requireNonNull(tasks, &quot;tasks cannot be null&quot;);</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">    if (tasks.isEmpty()) {</span>
<span class="fc" id="L249">      return VTask.succeed(List.of());</span>
    }

<span class="fc" id="L252">    return () -&gt; {</span>
<span class="fc" id="L253">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L254">        List&lt;StructuredTaskScope.Subtask&lt;A&gt;&gt; subtasks = new ArrayList&lt;&gt;(tasks.size());</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (VTask&lt;A&gt; task : tasks) {</span>
<span class="fc" id="L257">          subtasks.add(scope.fork(task.asCallable()));</span>
<span class="fc" id="L258">        }</span>

<span class="fc" id="L260">        scope.join();</span>

<span class="fc" id="L262">        List&lt;A&gt; results = new ArrayList&lt;&gt;(subtasks.size());</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (var subtask : subtasks) {</span>
<span class="fc" id="L264">          results.add(subtask.get());</span>
<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">        return results;</span>
<span class="fc" id="L267">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L268">        throw e.getCause();</span>
      }
    };
  }

  /**
   * Applies a function to each element in a list and executes the resulting tasks in parallel.
   *
   * &lt;p&gt;This is equivalent to mapping a function over a list to produce tasks, then executing all
   * tasks in parallel with {@link #all(List)}.
   *
   * @param &lt;A&gt; The type of elements in the input list.
   * @param &lt;B&gt; The type of results from the tasks.
   * @param items The list of items to process. Must not be null.
   * @param f The function that creates a task for each item. Must not be null.
   * @return A {@code VTask} that produces a list of all results. Never null.
   * @throws NullPointerException if any argument is null.
   */
  @SuppressWarnings(&quot;preview&quot;)
  public static &lt;A, B&gt; VTask&lt;List&lt;B&gt;&gt; traverse(List&lt;A&gt; items, Function&lt;A, VTask&lt;B&gt;&gt; f) {
<span class="fc" id="L288">    Objects.requireNonNull(items, &quot;items cannot be null&quot;);</span>
<span class="fc" id="L289">    Objects.requireNonNull(f, &quot;f cannot be null&quot;);</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L292">      return VTask.succeed(List.of());</span>
    }

<span class="fc" id="L295">    return () -&gt; {</span>
<span class="fc" id="L296">      try (var scope = StructuredTaskScope.open()) {</span>
<span class="fc" id="L297">        List&lt;StructuredTaskScope.Subtask&lt;B&gt;&gt; subtasks = new ArrayList&lt;&gt;(items.size());</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">        for (A item : items) {</span>
<span class="fc" id="L300">          VTask&lt;B&gt; task = f.apply(item);</span>
<span class="fc" id="L301">          Objects.requireNonNull(task, &quot;function returned null task for item: &quot; + item);</span>
<span class="fc" id="L302">          subtasks.add(scope.fork(task.asCallable()));</span>
<span class="fc" id="L303">        }</span>

<span class="fc" id="L305">        scope.join();</span>

<span class="fc" id="L307">        List&lt;B&gt; results = new ArrayList&lt;&gt;(subtasks.size());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (var subtask : subtasks) {</span>
<span class="fc" id="L309">          results.add(subtask.get());</span>
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">        return results;</span>
<span class="fc" id="L312">      } catch (StructuredTaskScope.FailedException e) {</span>
<span class="fc" id="L313">        throw e.getCause();</span>
      }
    };
  }

  /**
   * A simple tuple type for holding two values.
   *
   * @param &lt;A&gt; The type of the first value.
   * @param &lt;B&gt; The type of the second value.
   * @param first The first value.
   * @param second The second value.
   */
<span class="fc" id="L326">  public record Tuple2&lt;A, B&gt;(A first, B second) {}</span>

  /**
   * A simple tuple type for holding three values.
   *
   * @param &lt;A&gt; The type of the first value.
   * @param &lt;B&gt; The type of the second value.
   * @param &lt;C&gt; The type of the third value.
   * @param first The first value.
   * @param second The second value.
   * @param third The third value.
   */
<span class="fc" id="L338">  public record Tuple3&lt;A, B, C&gt;(A first, B second, C third) {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>