<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.io</a> &gt; <span class="el_source">IOSelective.java</span></div><h1>IOSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.io;

import static org.higherkindedj.hkt.io.IOKindHelper.IO_OP;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Choice;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link IO}. This provides selective applicative
 * operations that allow conditional execution based on the result of previous computations.
 *
 * &lt;p&gt;The Selective interface sits between {@link org.higherkindedj.hkt.Applicative} and {@link
 * org.higherkindedj.hkt.Monad} in terms of power. It allows for static analysis of effects while
 * still supporting conditional behaviour.
 *
 * &lt;p&gt;For IO, selective operations maintain lazy evaluation semantics. This means that effects are
 * only executed when necessary based on the conditions evaluated at runtime. This can lead to more
 * efficient programs where unnecessary side effects are avoided.
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies an effectful function based on a Choice.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with different
 *       handlers.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes an effect based on a boolean.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional for selective functors.
 * &lt;/ul&gt;
 *
 * @see IO
 * @see IOMonad
 * @see Selective
 * @see Choice
 */
public final class IOSelective extends IOMonad implements Selective&lt;IOKind.Witness&gt; {

  /** Singleton instance of {@code IOSelective}. */
<span class="fc" id="L45">  public static final IOSelective INSTANCE = new IOSelective();</span>

<span class="fc" id="L47">  private static final Class&lt;IOSelective&gt; IO_SELECTIVE_CLASS = IOSelective.class;</span>

  /** Private constructor to enforce singleton pattern. */
  private IOSelective() {
    super();
  }

  /**
   * The core selective operation for IO. Given an effectful choice {@code fab} and an effectful
   * function {@code ff}, applies the function only if the choice is a {@code Left}.
   *
   * &lt;p&gt;This operation maintains IO's lazy evaluation semantics. The function IO is only executed if
   * the choice IO produces a {@code Left} value.
   *
   * &lt;p&gt;Behavior:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If {@code fab} produces {@code Right(b)}: Returns an IO that produces {@code b}, {@code
   *       ff} is not executed.
   *   &lt;li&gt;If {@code fab} produces {@code Left(a)}: Executes {@code ff} to get a function, then
   *       applies it to {@code a}.
   * &lt;/ul&gt;
   *
   * @param fab A {@link Kind} representing {@code IO&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param ff A {@link Kind} representing {@code IO&lt;Function&lt;A, B&gt;&gt;}. Must not be null.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left} of the Choice).
   * @param &lt;B&gt; The output type and the type inside {@code Right} of the Choice.
   * @return A {@link Kind} representing {@code IO&lt;B&gt;}. Never null.
   * @throws NullPointerException if {@code fab} or {@code ff} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;IOKind.Witness, B&gt; select(
      Kind&lt;IOKind.Witness, Choice&lt;A, B&gt;&gt; fab, Kind&lt;IOKind.Witness, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L83">    Validation.kind().requireNonNull(fab, IO_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L84">    Validation.kind().requireNonNull(ff, IO_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L86">    IO&lt;Choice&lt;A, B&gt;&gt; ioChoice = IO_OP.narrow(fab);</span>
<span class="fc" id="L87">    IO&lt;Function&lt;A, B&gt;&gt; ioFunction = IO_OP.narrow(ff);</span>

<span class="fc" id="L89">    IO&lt;B&gt; ioB =</span>
<span class="fc" id="L90">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L92">              Choice&lt;A, B&gt; choice = ioChoice.unsafeRunSync();</span>

              // If choice is Right(b), we already have our value
<span class="fc bfc" id="L95" title="All 2 branches covered.">              if (choice.isRight()) {</span>
<span class="fc" id="L96">                return choice.getRight();</span>
              }

              // Choice is Left(a), so we need to apply the function
<span class="fc" id="L100">              A value = choice.getLeft();</span>
<span class="fc" id="L101">              Function&lt;A, B&gt; function = ioFunction.unsafeRunSync();</span>
<span class="fc" id="L102">              return function.apply(value);</span>
            });

<span class="fc" id="L105">    return IO_OP.widen(ioB);</span>
  }

  /**
   * Optimised implementation of {@code branch} for IO. Provides a two-way conditional choice,
   * applying the appropriate handler based on whether the Choice is Left or Right.
   *
   * &lt;p&gt;Only the relevant handler IO is executed based on the choice result.
   *
   * @param fab A {@link Kind} representing {@code IO&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code IO&lt;Function&lt;A, C&gt;&gt;} for the Left case. Must not be
   *     null.
   * @param fr A {@link Kind} representing {@code IO&lt;Function&lt;B, C&gt;&gt;} for the Right case. Must not
   *     be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code IO&lt;C&gt;}. Never null.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;IOKind.Witness, C&gt; branch(
      Kind&lt;IOKind.Witness, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;IOKind.Witness, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;IOKind.Witness, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L130">    Validation.kind().requireNonNull(fab, IO_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L131">    Validation.kind().requireNonNull(fl, IO_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L132">    Validation.kind().requireNonNull(fr, IO_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L134">    IO&lt;Choice&lt;A, B&gt;&gt; ioChoice = IO_OP.narrow(fab);</span>
<span class="fc" id="L135">    IO&lt;Function&lt;A, C&gt;&gt; leftHandler = IO_OP.narrow(fl);</span>
<span class="fc" id="L136">    IO&lt;Function&lt;B, C&gt;&gt; rightHandler = IO_OP.narrow(fr);</span>

<span class="fc" id="L138">    IO&lt;C&gt; ioC =</span>
<span class="fc" id="L139">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L141">              Choice&lt;A, B&gt; choice = ioChoice.unsafeRunSync();</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">              if (choice.isLeft()) {</span>
<span class="fc" id="L144">                Function&lt;A, C&gt; leftFunc = leftHandler.unsafeRunSync();</span>
<span class="fc" id="L145">                return leftFunc.apply(choice.getLeft());</span>
              } else {
<span class="fc" id="L147">                Function&lt;B, C&gt; rightFunc = rightHandler.unsafeRunSync();</span>
<span class="fc" id="L148">                return rightFunc.apply(choice.getRight());</span>
              }
            });

<span class="fc" id="L152">    return IO_OP.widen(ioC);</span>
  }

  /**
   * Conditionally executes a Unit-returning effect based on a boolean condition.
   *
   * &lt;p&gt;Key improvement: Returns Unit.INSTANCE instead of null, making the lazy computation's result
   * type-safe and explicit.
   *
   * @param fcond The effectful condition
   * @param fa The Unit-returning effect to execute if condition is true
   * @return IO with Unit result
   */
  @Override
  public Kind&lt;IOKind.Witness, Unit&gt; whenS(
      Kind&lt;IOKind.Witness, Boolean&gt; fcond, Kind&lt;IOKind.Witness, Unit&gt; fa) {

<span class="fc" id="L169">    Validation.kind().requireNonNull(fcond, IO_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L170">    Validation.kind().requireNonNull(fa, IO_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L172">    IO&lt;Boolean&gt; condIO = IO_OP.narrow(fcond);</span>
<span class="fc" id="L173">    IO&lt;Unit&gt; effectIO = IO_OP.narrow(fa);</span>

<span class="fc" id="L175">    IO&lt;Unit&gt; ioUnit =</span>
<span class="fc" id="L176">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L178">              boolean condition = condIO.unsafeRunSync();</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">              if (condition) {</span>
<span class="fc" id="L181">                return effectIO.unsafeRunSync();</span>
              } else {
                // Condition is false, return Unit (not null!)
<span class="fc" id="L184">                return Unit.INSTANCE;</span>
              }
            });

<span class="fc" id="L188">    return IO_OP.widen(ioUnit);</span>
  }

  /**
   * Optimised implementation of {@code ifS} for IO. A ternary conditional operator for selective
   * functors.
   *
   * &lt;p&gt;Only the selected branch IO is executed based on the condition result.
   *
   * @param fcond A {@link Kind} representing {@code IO&lt;Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code IO&lt;A&gt;} for the true branch. Must not be null.
   * @param felse A {@link Kind} representing {@code IO&lt;A&gt;} for the false branch. Must not be null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code IO&lt;A&gt;}. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;IOKind.Witness, A&gt; ifS(
      Kind&lt;IOKind.Witness, Boolean&gt; fcond,
      Kind&lt;IOKind.Witness, A&gt; fthen,
      Kind&lt;IOKind.Witness, A&gt; felse) {

<span class="fc" id="L209">    Validation.kind().requireNonNull(fcond, IO_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L210">    Validation.kind().requireNonNull(fthen, IO_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L211">    Validation.kind().requireNonNull(felse, IO_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L213">    IO&lt;Boolean&gt; condIO = IO_OP.narrow(fcond);</span>
<span class="fc" id="L214">    IO&lt;A&gt; thenIO = IO_OP.narrow(fthen);</span>
<span class="fc" id="L215">    IO&lt;A&gt; elseIO = IO_OP.narrow(felse);</span>

<span class="fc" id="L217">    IO&lt;A&gt; ioA =</span>
<span class="fc" id="L218">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L220">              boolean condition = condIO.unsafeRunSync();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">              return condition ? thenIO.unsafeRunSync() : elseIO.unsafeRunSync();</span>
            });

<span class="fc" id="L224">    return IO_OP.widen(ioA);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>