<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpticOps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.fluent</a> &gt; <span class="el_source">OpticOps.java</span></div><h1>OpticOps.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.fluent;

import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Semigroups;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.constant.Const;
import org.higherkindedj.hkt.constant.ConstApplicative;
import org.higherkindedj.hkt.constant.ConstKind;
import org.higherkindedj.hkt.constant.ConstKindHelper;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherKind;
import org.higherkindedj.hkt.either.EitherKindHelper;
import org.higherkindedj.hkt.either.EitherMonad;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import org.higherkindedj.hkt.validated.ValidatedKindHelper;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.optics.Affine;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Getter;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.util.Traversals;
import org.jspecify.annotations.NullMarked;

/**
 * Fluent API for common optic operations with Java-friendly naming conventions.
 *
 * &lt;p&gt;This class provides two styles of optic operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Static methods&lt;/b&gt; - Direct, concise operations for simple cases
 *   &lt;li&gt;&lt;b&gt;Fluent builders&lt;/b&gt; - Method chaining for more explicit workflows
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Static Methods (Simple &amp;amp; Direct)&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Get a value
 * String name = OpticOps.get(person, PersonLenses.name());
 *
 * // Set a value
 * Person updated = OpticOps.set(person, PersonLenses.age(), 30);
 *
 * // Modify a value
 * Person modified = OpticOps.modify(person, PersonLenses.age(), age -&gt; age + 1);
 *
 * // Get all values
 * List&lt;String&gt; names = OpticOps.getAll(team, TeamTraversals.playerNames());
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Fluent Builders (Explicit Workflows)&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Getting values
 * String name = OpticOps.getting(person).through(PersonLenses.name());
 * Optional&lt;Address&gt; addr = OpticOps.getting(person).maybeThrough(addressPrism);
 * List&lt;String&gt; names = OpticOps.getting(team).allThrough(playerNames);
 *
 * // Setting values
 * Person updated = OpticOps.setting(person).through(PersonLenses.age(), 30);
 *
 * // Modifying values
 * Person modified = OpticOps.modifying(person).through(PersonLenses.age(), age -&gt; age + 1);
 *
 * // Querying
 * boolean hasAdults = OpticOps.querying(team)
 *     .anyMatch(playerAges, age -&gt; age &gt;= 18);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;When to Use Each Style&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Static methods&lt;/b&gt;: Simple, one-off operations where brevity is preferred
 *   &lt;li&gt;&lt;b&gt;Fluent builders&lt;/b&gt;: Complex workflows, or when IDE autocomplete guidance is helpful
 * &lt;/ul&gt;
 */
@NullMarked
public final class OpticOps {

<span class="fc" id="L92">  private OpticOps() {</span>
<span class="fc" id="L93">    throw new UnsupportedOperationException(&quot;Utility class&quot;);</span>
  }

  /**
   * Converts a Traversal to a Fold by running it with the Id monad.
   *
   * @param traversal The traversal to convert
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Fold that represents the traversal
   */
  private static &lt;S, A&gt; Fold&lt;S, A&gt; traversalToFold(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L105">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
        // Use the Const applicative to fold over the traversal efficiently
        // This is the standard functional programming approach that avoids side effects
<span class="fc" id="L110">        ConstApplicative&lt;M&gt; constApp = new ConstApplicative&lt;&gt;(monoid);</span>

        // Apply the traversal with the Const applicative
        // The traversal will accumulate values using the monoid whilst traversing
<span class="fc" id="L114">        Kind&lt;ConstKind.Witness&lt;M&gt;, S&gt; result =</span>
<span class="fc" id="L115">            traversal.modifyF(</span>
<span class="fc" id="L116">                a -&gt; ConstKindHelper.CONST.widen(new Const&lt;&gt;(f.apply(a))), source, constApp);</span>

        // Extract the accumulated result from the Const
<span class="fc" id="L119">        Const&lt;M, S&gt; finalConst = ConstKindHelper.CONST.narrow(result);</span>
<span class="fc" id="L120">        return finalConst.value();</span>
      }
    };
  }

  // ============================================================================
  // Static Methods - Direct Operations
  // ============================================================================

  /**
   * Gets the value focused by a {@link Getter} or {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * String name = OpticOps.get(person, PersonLenses.name());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param getter The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The focused value
   */
  public static &lt;S, A&gt; A get(S source, Getter&lt;S, A&gt; getter) {
<span class="fc" id="L145">    return getter.get(source);</span>
  }

  /**
   * Gets the value focused by a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * String name = OpticOps.get(person, PersonLenses.name());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The focused value
   */
  public static &lt;S, A&gt; A get(S source, Lens&lt;S, A&gt; lens) {
<span class="fc" id="L164">    return lens.get(source);</span>
  }

  /**
   * Gets the first value focused by a {@link Fold}, {@link Traversal}, or {@link
   * org.higherkindedj.optics.Prism}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Optional&lt;Address&gt; address = OpticOps.preview(person, addressPrism);
   * Optional&lt;String&gt; firstName = OpticOps.preview(team, playerNames);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return An {@link Optional} containing the first focused value, or empty if none exist
   */
  public static &lt;S, A&gt; Optional&lt;A&gt; preview(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L185">    return fold.preview(source);</span>
  }

  /**
   * Gets the first value focused by a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Optional&lt;String&gt; firstName = OpticOps.preview(team, playerNames);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return An {@link Optional} containing the first focused value, or empty if none exist
   */
  public static &lt;S, A&gt; Optional&lt;A&gt; preview(S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L204">    return traversalToFold(traversal).preview(source);</span>
  }

  /**
   * Gets the value focused by an {@link Affine}, if present.
   *
   * &lt;p&gt;Affines focus on zero or one element, making them ideal for optional fields. This method
   * returns the focused value wrapped in an {@link Optional}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Optional&lt;String&gt; phone = OpticOps.getOptional(user, userPhoneAffine);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param affine The affine to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return An {@link Optional} containing the focused value, or empty if not present
   */
  public static &lt;S, A&gt; Optional&lt;A&gt; getOptional(S source, Affine&lt;S, A&gt; affine) {
<span class="fc" id="L226">    return affine.getOptional(source);</span>
  }

  /**
   * Sets a new value through an {@link Affine}.
   *
   * &lt;p&gt;Affines can set values even when the focus is not currently present, as long as the
   * underlying structure supports it.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * User updated = OpticOps.set(user, userPhoneAffine, &quot;+44 7700 900000&quot;);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param affine The affine to focus with
   * @param value The new value to set
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with the value updated
   */
  public static &lt;S, A&gt; S set(S source, Affine&lt;S, A&gt; affine, A value) {
<span class="fc" id="L249">    return affine.set(value, source);</span>
  }

  /**
   * Modifies the value focused by an {@link Affine}, if present.
   *
   * &lt;p&gt;If the affine does not focus on a value (i.e., the optional field is absent), the source is
   * returned unchanged.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * User updated = OpticOps.modify(user, userPhoneAffine, phone -&gt; phone.replace(&quot; &quot;, &quot;-&quot;));
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param affine The affine to focus with
   * @param modifier The function to transform the focused value
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with the value modified, or the original if no value was focused
   */
  public static &lt;S, A&gt; S modify(S source, Affine&lt;S, A&gt; affine, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L272">    return affine.modify(modifier, source);</span>
  }

  /**
   * Checks if the {@link Affine} focuses on a value in the given structure.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean hasPhone = OpticOps.matches(user, userPhoneAffine);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param affine The affine to check
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if a value is present, {@code false} otherwise
   */
  public static &lt;S, A&gt; boolean matches(S source, Affine&lt;S, A&gt; affine) {
<span class="fc" id="L291">    return affine.matches(source);</span>
  }

  /**
   * Gets all values focused by a {@link Fold} or {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * List&lt;String&gt; names = OpticOps.getAll(team, TeamTraversals.playerNames());
   * List&lt;Integer&gt; scores = OpticOps.getAll(league, allPlayerScores);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A list of all focused values
   */
  public static &lt;S, A&gt; List&lt;A&gt; getAll(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L311">    return fold.getAll(source);</span>
  }

  /**
   * Gets all values focused by a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * List&lt;String&gt; names = OpticOps.getAll(team, TeamTraversals.playerNames());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A list of all focused values
   */
  public static &lt;S, A&gt; List&lt;A&gt; getAll(S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L330">    return traversalToFold(traversal).getAll(source);</span>
  }

  /**
   * Sets a new value through a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Person updated = OpticOps.set(person, PersonLenses.age(), 30);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param value The new value to set
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with the value updated
   */
  public static &lt;S, A&gt; S set(S source, Lens&lt;S, A&gt; lens, A value) {
<span class="fc" id="L350">    return lens.set(value, source);</span>
  }

  /**
   * Sets all values focused by a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Team allScores100 = OpticOps.setAll(team, playerScores, 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param value The new value to set for all focused elements
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with all focused values updated
   */
  public static &lt;S, A&gt; S setAll(S source, Traversal&lt;S, A&gt; traversal, A value) {
<span class="fc" id="L370">    return Traversals.modify(traversal, ignored -&gt; value, source);</span>
  }

  /**
   * Modifies the value focused by a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Person older = OpticOps.modify(person, PersonLenses.age(), age -&gt; age + 1);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param modifier The function to transform the focused value
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with the value modified
   */
  public static &lt;S, A&gt; S modify(S source, Lens&lt;S, A&gt; lens, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L390">    return lens.modify(modifier, source);</span>
  }

  /**
   * Modifies all values focused by a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Team bonusApplied = OpticOps.modifyAll(team, playerScores, score -&gt; score + 10);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param modifier The function to transform each focused value
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A new structure with all focused values modified
   */
  public static &lt;S, A&gt; S modifyAll(S source, Traversal&lt;S, A&gt; traversal, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L410">    return Traversals.modify(traversal, modifier, source);</span>
  }

  /**
   * Modifies the value focused by a {@link Lens} with an effectful function.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Kind&lt;IO, Person&gt; result = OpticOps.modifyF(
   *     person,
   *     PersonLenses.name(),
   *     name -&gt; fetchNameFromDatabase(name),
   *     ioFunctor
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param modifier The effectful function to transform the focused value
   * @param functor The functor instance for the effect type
   * @param &lt;F&gt; The effect type witness
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The modified structure wrapped in the effect
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, S, A&gt; Kind&lt;F, S&gt; modifyF(
      S source, Lens&lt;S, A&gt; lens, Function&lt;A, Kind&lt;F, A&gt;&gt; modifier, Functor&lt;F&gt; functor) {
<span class="fc" id="L438">    return lens.modifyF(modifier, source, functor);</span>
  }

  /**
   * Modifies all values focused by a {@link Traversal} with an effectful function.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Kind&lt;IO, Team&gt; result = OpticOps.modifyAllF(
   *     team,
   *     playerNames,
   *     name -&gt; validateNameInDatabase(name),
   *     ioApplicative
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param modifier The effectful function to transform each focused value
   * @param applicative The applicative instance for the effect type
   * @param &lt;F&gt; The effect type witness
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The modified structure wrapped in the effect
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, S, A&gt; Kind&lt;F, S&gt; modifyAllF(
      S source,
      Traversal&lt;S, A&gt; traversal,
      Function&lt;A, Kind&lt;F, A&gt;&gt; modifier,
      Applicative&lt;F&gt; applicative) {
<span class="fc" id="L469">    return traversal.modifyF(modifier, source, applicative);</span>
  }

  // ============================================================================
  // Validation-Aware Operations
  // ============================================================================

  /**
   * Modifies the value focused by a {@link Lens} with Either-based validation.
   *
   * &lt;p&gt;This method provides a convenient way to modify a value with validation that can fail. The
   * validator function returns {@code Either.right(validValue)} on success or {@code
   * Either.left(error)} on failure.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Function&lt;String, Either&lt;String, String&gt;&gt; validateEmail = email -&gt;
   *     email.contains(&quot;@&quot;)
   *         ? Either.right(email.toLowerCase())
   *         : Either.left(&quot;Invalid email format&quot;);
   *
   * Either&lt;String, User&gt; result = OpticOps.modifyEither(
   *     user,
   *     UserLenses.email(),
   *     validateEmail
   * );
   *
   * result.fold(
   *     error -&gt; System.out.println(&quot;Validation failed: &quot; + error),
   *     validUser -&gt; System.out.println(&quot;Updated user: &quot; + validUser)
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param validator Function that returns Either.right(validValue) or Either.left(error)
   * @param &lt;E&gt; The error type
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return Either.right(updated structure) if validation succeeds, Either.left(error) otherwise
   */
  public static &lt;E, S, A&gt; Either&lt;E, S&gt; modifyEither(
      S source, Lens&lt;S, A&gt; lens, Function&lt;A, Either&lt;E, A&gt;&gt; validator) {
<span class="fc" id="L513">    A currentValue = lens.get(source);</span>
<span class="fc" id="L514">    return validator.apply(currentValue).map(validatedValue -&gt; lens.set(validatedValue, source));</span>
  }

  /**
   * Modifies the value focused by a {@link Lens} with Maybe-based validation.
   *
   * &lt;p&gt;This method provides a convenient way to modify a value with optional validation. The
   * validator function returns {@code Maybe.just(validValue)} on success or {@code Maybe.nothing()}
   * on failure.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Function&lt;Integer, Maybe&lt;Integer&gt;&gt; validateAge = age -&gt;
   *     (age &gt;= 0 &amp;&amp; age &lt;= 150) ? Maybe.just(age) : Maybe.nothing();
   *
   * Maybe&lt;Person&gt; result = OpticOps.modifyMaybe(
   *     person,
   *     PersonLenses.age(),
   *     validateAge
   * );
   *
   * result.fold(
   *     () -&gt; System.out.println(&quot;Validation failed&quot;),
   *     validPerson -&gt; System.out.println(&quot;Updated person: &quot; + validPerson)
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param validator Function that returns Maybe.just(validValue) or Maybe.nothing()
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return Maybe.just(updated structure) if validation succeeds, Maybe.nothing() otherwise
   */
  public static &lt;S, A&gt; Maybe&lt;S&gt; modifyMaybe(
      S source, Lens&lt;S, A&gt; lens, Function&lt;A, Maybe&lt;A&gt;&gt; validator) {
<span class="fc" id="L551">    A currentValue = lens.get(source);</span>
<span class="fc" id="L552">    return validator.apply(currentValue).map(validatedValue -&gt; lens.set(validatedValue, source));</span>
  }

  /**
   * Modifies all values focused by a {@link Traversal} with Validated-based error accumulation.
   *
   * &lt;p&gt;This method validates and modifies all focused values, accumulating all errors rather than
   * short-circuiting on the first failure. This is ideal when you want to collect all validation
   * errors and present them to the user at once.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Function&lt;Double, Validated&lt;String, Double&gt;&gt; validatePrice = price -&gt; {
   *     if (price &lt; 0) {
   *         return Validated.invalid(&quot;Price cannot be negative&quot;);
   *     } else if (price &gt; 10000) {
   *         return Validated.invalid(&quot;Price exceeds maximum&quot;);
   *     } else {
   *         return Validated.valid(price);
   *     }
   * };
   *
   * Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
   *     order,
   *     OrderTraversals.itemPrices(),
   *     validatePrice
   * );
   *
   * result.fold(
   *     errors -&gt; System.out.println(&quot;Validation errors: &quot; + errors),
   *     validOrder -&gt; System.out.println(&quot;All prices valid: &quot; + validOrder)
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param validator Function that returns Validated.valid or Validated.invalid
   * @param &lt;E&gt; The error type
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return Validated.valid(updated structure) if all validations succeed, Validated.invalid(all
   *     errors) otherwise
   */
  public static &lt;E, S, A&gt; Validated&lt;List&lt;E&gt;, S&gt; modifyAllValidated(
      S source, Traversal&lt;S, A&gt; traversal, Function&lt;A, Validated&lt;E, A&gt;&gt; validator) {
    // Create applicative for Validated with List semigroup for error accumulation

    Applicative&lt;ValidatedKind.Witness&lt;List&lt;E&gt;&gt;&gt; applicative =
<span class="fc" id="L601">        ValidatedMonad.instance(Semigroups.list());</span>

    // Lift the validator to work with List&lt;E&gt; errors
<span class="fc" id="L604">    Function&lt;A, Kind&lt;ValidatedKind.Witness&lt;List&lt;E&gt;&gt;, A&gt;&gt; liftedValidator =</span>
        a -&gt; {
<span class="fc" id="L606">          Validated&lt;E, A&gt; validated = validator.apply(a);</span>
          // Convert Validated&lt;E, A&gt; to Validated&lt;List&lt;E&gt;, A&gt;
<span class="fc" id="L608">          Validated&lt;List&lt;E&gt;, A&gt; result = validated.bimap(List::of, Function.identity());</span>
<span class="fc" id="L609">          return ValidatedKindHelper.VALIDATED.widen(result);</span>
        };

    // Use traversal's modifyF with the applicative
<span class="fc" id="L613">    Kind&lt;ValidatedKind.Witness&lt;List&lt;E&gt;&gt;, S&gt; resultKind =</span>
<span class="fc" id="L614">        traversal.modifyF(liftedValidator, source, applicative);</span>

<span class="fc" id="L616">    return ValidatedKindHelper.VALIDATED.narrow(resultKind);</span>
  }

  /**
   * Modifies all values focused by a {@link Traversal} with Either-based short-circuiting.
   *
   * &lt;p&gt;This method validates and modifies all focused values, but stops at the first validation
   * error (short-circuits). This is ideal when you want to fail fast and don't need to collect all
   * errors.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Function&lt;String, Either&lt;String, String&gt;&gt; validateUsername = username -&gt;
   *     username.length() &gt;= 3
   *         ? Either.right(username.toLowerCase())
   *         : Either.left(&quot;Username too short: &quot; + username);
   *
   * Either&lt;String, Team&gt; result = OpticOps.modifyAllEither(
   *     team,
   *     TeamTraversals.playerUsernames(),
   *     validateUsername
   * );
   *
   * result.fold(
   *     error -&gt; System.out.println(&quot;First error: &quot; + error),
   *     validTeam -&gt; System.out.println(&quot;All usernames valid: &quot; + validTeam)
   * );
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param validator Function that returns Either.right or Either.left
   * @param &lt;E&gt; The error type
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return Either.right(updated structure) if all validations succeed, Either.left(first error)
   *     otherwise
   */
  public static &lt;E, S, A&gt; Either&lt;E, S&gt; modifyAllEither(
      S source, Traversal&lt;S, A&gt; traversal, Function&lt;A, Either&lt;E, A&gt;&gt; validator) {
    // Create applicative for Either (short-circuits on first Left)
<span class="fc" id="L658">    Applicative&lt;EitherKind.Witness&lt;E&gt;&gt; applicative = EitherMonad.instance();</span>

    // Lift the validator to the Kind type
<span class="fc" id="L661">    Function&lt;A, Kind&lt;EitherKind.Witness&lt;E&gt;, A&gt;&gt; liftedValidator =</span>
<span class="fc" id="L662">        a -&gt; EitherKindHelper.EITHER.widen(validator.apply(a));</span>

    // Use traversal's modifyF with the applicative
<span class="fc" id="L665">    Kind&lt;EitherKind.Witness&lt;E&gt;, S&gt; resultKind =</span>
<span class="fc" id="L666">        traversal.modifyF(liftedValidator, source, applicative);</span>

<span class="fc" id="L668">    return EitherKindHelper.EITHER.narrow(resultKind);</span>
  }

  // ============================================================================
  // Query Operations
  // ============================================================================

  /**
   * Checks if any focused element matches the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean hasExpensive = OpticOps.exists(order, itemPrices, price -&gt; price &gt; 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if any focused element matches
   */
  public static &lt;S, A&gt; boolean exists(S source, Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L692">    return fold.exists(predicate, source);</span>
  }

  /**
   * Checks if any focused element matches the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean hasExpensive = OpticOps.exists(order, itemPrices, price -&gt; price &gt; 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if any focused element matches
   */
  public static &lt;S, A&gt; boolean exists(S source, Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L712">    return traversalToFold(traversal).exists(predicate, source);</span>
  }

  /**
   * Checks if all focused elements match the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean allAdults = OpticOps.all(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if all focused elements match
   */
  public static &lt;S, A&gt; boolean all(S source, Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L732">    return fold.all(predicate, source);</span>
  }

  /**
   * Checks if all focused elements match the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean allAdults = OpticOps.all(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if all focused elements match
   */
  public static &lt;S, A&gt; boolean all(S source, Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L752">    return traversalToFold(traversal).all(predicate, source);</span>
  }

  /**
   * Finds the first focused element that matches the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Optional&lt;Item&gt; expensive = OpticOps.find(order, items, item -&gt; item.price() &gt; 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return An {@link Optional} containing the first matching element, or empty if none match
   */
  public static &lt;S, A&gt; Optional&lt;A&gt; find(S source, Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L772">    return fold.find(predicate, source);</span>
  }

  /**
   * Finds the first focused element that matches the given predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Optional&lt;Item&gt; expensive = OpticOps.find(order, items, item -&gt; item.price() &gt; 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return An {@link Optional} containing the first matching element, or empty if none match
   */
  public static &lt;S, A&gt; Optional&lt;A&gt; find(
      S source, Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L793">    return traversalToFold(traversal).find(predicate, source);</span>
  }

  /**
   * Counts the number of focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * int playerCount = OpticOps.count(team, players);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The number of focused elements
   */
  public static &lt;S, A&gt; int count(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L812">    return fold.length(source);</span>
  }

  /**
   * Counts the number of focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * int playerCount = OpticOps.count(team, players);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return The number of focused elements
   */
  public static &lt;S, A&gt; int count(S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L831">    return traversalToFold(traversal).length(source);</span>
  }

  /**
   * Checks if there are no focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean noItems = OpticOps.isEmpty(order, items);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if there are no focused elements
   */
  public static &lt;S, A&gt; boolean isEmpty(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L850">    return fold.isEmpty(source);</span>
  }

  /**
   * Checks if there are no focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean noItems = OpticOps.isEmpty(order, items);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code true} if there are no focused elements
   */
  public static &lt;S, A&gt; boolean isEmpty(S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L869">    return traversalToFold(traversal).isEmpty(source);</span>
  }

  // ============================================================================
  // Fluent Builder Factories
  // ============================================================================

  /**
   * Starts a fluent workflow for getting values.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * String name = OpticOps.getting(person).through(PersonLenses.name());
   * Optional&lt;Address&gt; addr = OpticOps.getting(person).maybeThrough(addressPrism);
   * List&lt;String&gt; names = OpticOps.getting(team).allThrough(playerNames);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param &lt;S&gt; The source type
   * @return A {@link GetBuilder} for fluent method chaining
   */
  public static &lt;S&gt; GetBuilder&lt;S&gt; getting(S source) {
<span class="fc" id="L892">    return new GetBuilder&lt;&gt;(source);</span>
  }

  /**
   * Starts a fluent workflow for setting values.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Person updated = OpticOps.setting(person).through(PersonLenses.age(), 30);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param &lt;S&gt; The source type
   * @return A {@link SetBuilder} for fluent method chaining
   */
  public static &lt;S&gt; SetBuilder&lt;S&gt; setting(S source) {
<span class="fc" id="L909">    return new SetBuilder&lt;&gt;(source);</span>
  }

  /**
   * Starts a fluent workflow for modifying values.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Person older = OpticOps.modifying(person).through(PersonLenses.age(), age -&gt; age + 1);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param &lt;S&gt; The source type
   * @return A {@link ModifyBuilder} for fluent method chaining
   */
  public static &lt;S&gt; ModifyBuilder&lt;S&gt; modifying(S source) {
<span class="fc" id="L926">    return new ModifyBuilder&lt;&gt;(source);</span>
  }

  /**
   * Starts a fluent workflow for querying values.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * boolean hasAdults = OpticOps.querying(team).anyMatch(playerAges, age -&gt; age &gt;= 18);
   * int count = OpticOps.querying(team).count(players);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param &lt;S&gt; The source type
   * @return A {@link QueryBuilder} for fluent method chaining
   */
  public static &lt;S&gt; QueryBuilder&lt;S&gt; querying(S source) {
<span class="fc" id="L944">    return new QueryBuilder&lt;&gt;(source);</span>
  }

  /**
   * Starts a fluent workflow for validation-aware modifications.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, User&gt; result = OpticOps.modifyingWithValidation(user)
   *     .throughEither(emailLens, this::validateEmail);
   *
   * Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyingWithValidation(order)
   *     .allThroughValidated(itemPrices, this::validatePrice);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param &lt;S&gt; The source type
   * @return A {@link ModifyingWithValidation} builder for fluent method chaining
   */
  public static &lt;S&gt; ModifyingWithValidation&lt;S&gt; modifyingWithValidation(S source) {
<span class="fc" id="L965">    return new ModifyingWithValidation&lt;&gt;(source);</span>
  }

  // ============================================================================
  // Fluent Builders
  // ============================================================================

  /**
   * Builder for fluent get/read operations.
   *
   * @param &lt;S&gt; The source type
   */
  public static final class GetBuilder&lt;S&gt; {
    private final S source;

<span class="fc" id="L980">    GetBuilder(S source) {</span>
<span class="fc" id="L981">      this.source = source;</span>
<span class="fc" id="L982">    }</span>

    /**
     * Gets the value through a {@link Getter} or {@link Lens}.
     *
     * @param getter The optic to focus with
     * @param &lt;A&gt; The focused value type
     * @return The focused value
     */
    public &lt;A&gt; A through(Getter&lt;S, A&gt; getter) {
<span class="fc" id="L992">      return getter.get(source);</span>
    }

    /**
     * Gets the value through a {@link Lens}.
     *
     * @param lens The lens to focus with
     * @param &lt;A&gt; The focused value type
     * @return The focused value
     */
    public &lt;A&gt; A through(Lens&lt;S, A&gt; lens) {
<span class="fc" id="L1003">      return lens.get(source);</span>
    }

    /**
     * Gets the first value through a {@link Fold}, returning {@link Optional}.
     *
     * @param fold The optic to focus with
     * @param &lt;A&gt; The focused value type
     * @return An {@link Optional} containing the first focused value, or empty if none exist
     */
    public &lt;A&gt; Optional&lt;A&gt; maybeThrough(Fold&lt;S, A&gt; fold) {
<span class="fc" id="L1014">      return fold.preview(source);</span>
    }

    /**
     * Gets the first value through a {@link Traversal}, returning {@link Optional}.
     *
     * @param traversal The traversal to focus with
     * @param &lt;A&gt; The focused value type
     * @return An {@link Optional} containing the first focused value, or empty if none exist
     */
    public &lt;A&gt; Optional&lt;A&gt; maybeThrough(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L1025">      return traversalToFold(traversal).preview(source);</span>
    }

    /**
     * Gets the value through an {@link Affine}, returning {@link Optional}.
     *
     * &lt;p&gt;Affines focus on zero or one element, making them ideal for optional fields.
     *
     * @param affine The affine to focus with
     * @param &lt;A&gt; The focused value type
     * @return An {@link Optional} containing the focused value, or empty if not present
     */
    public &lt;A&gt; Optional&lt;A&gt; maybeThrough(Affine&lt;S, A&gt; affine) {
<span class="fc" id="L1038">      return affine.getOptional(source);</span>
    }

    /**
     * Gets all values through a {@link Fold} or {@link Traversal}.
     *
     * @param fold The optic to focus with
     * @param &lt;A&gt; The focused value type
     * @return A list of all focused values
     */
    public &lt;A&gt; List&lt;A&gt; allThrough(Fold&lt;S, A&gt; fold) {
<span class="fc" id="L1049">      return fold.getAll(source);</span>
    }

    /**
     * Gets all values through a {@link Traversal}.
     *
     * @param traversal The traversal to focus with
     * @param &lt;A&gt; The focused value type
     * @return A list of all focused values
     */
    public &lt;A&gt; List&lt;A&gt; allThrough(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L1060">      return traversalToFold(traversal).getAll(source);</span>
    }
  }

  /**
   * Builder for fluent set/write operations.
   *
   * @param &lt;S&gt; The source type
   */
  public static final class SetBuilder&lt;S&gt; {
    private final S source;

<span class="fc" id="L1072">    SetBuilder(S source) {</span>
<span class="fc" id="L1073">      this.source = source;</span>
<span class="fc" id="L1074">    }</span>

    /**
     * Sets a value through a {@link Lens}.
     *
     * @param lens The lens to focus with
     * @param value The new value to set
     * @param &lt;A&gt; The focused value type
     * @return A new structure with the value updated
     */
    public &lt;A&gt; S through(Lens&lt;S, A&gt; lens, A value) {
<span class="fc" id="L1085">      return lens.set(value, source);</span>
    }

    /**
     * Sets a value through an {@link Affine}.
     *
     * &lt;p&gt;Affines can set values even when the focus is not currently present, as long as the
     * underlying structure supports it.
     *
     * @param affine The affine to focus with
     * @param value The new value to set
     * @param &lt;A&gt; The focused value type
     * @return A new structure with the value updated
     */
    public &lt;A&gt; S through(Affine&lt;S, A&gt; affine, A value) {
<span class="fc" id="L1100">      return affine.set(value, source);</span>
    }

    /**
     * Sets all values through a {@link Traversal}.
     *
     * @param traversal The traversal to focus with
     * @param value The new value to set for all focused elements
     * @param &lt;A&gt; The focused value type
     * @return A new structure with all focused values updated
     */
    public &lt;A&gt; S allThrough(Traversal&lt;S, A&gt; traversal, A value) {
<span class="fc" id="L1112">      return Traversals.modify(traversal, ignored -&gt; value, source);</span>
    }
  }

  /**
   * Builder for fluent modify/update operations.
   *
   * @param &lt;S&gt; The source type
   */
  public static final class ModifyBuilder&lt;S&gt; {
    private final S source;

<span class="fc" id="L1124">    ModifyBuilder(S source) {</span>
<span class="fc" id="L1125">      this.source = source;</span>
<span class="fc" id="L1126">    }</span>

    /**
     * Modifies a value through a {@link Lens}.
     *
     * @param lens The lens to focus with
     * @param modifier The function to transform the focused value
     * @param &lt;A&gt; The focused value type
     * @return A new structure with the value modified
     */
    public &lt;A&gt; S through(Lens&lt;S, A&gt; lens, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L1137">      return lens.modify(modifier, source);</span>
    }

    /**
     * Modifies a value through an {@link Affine}, if present.
     *
     * &lt;p&gt;If the affine does not focus on a value (i.e., the optional field is absent), the source
     * is returned unchanged.
     *
     * @param affine The affine to focus with
     * @param modifier The function to transform the focused value
     * @param &lt;A&gt; The focused value type
     * @return A new structure with the value modified, or unchanged if no value was focused
     */
    public &lt;A&gt; S through(Affine&lt;S, A&gt; affine, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L1152">      return affine.modify(modifier, source);</span>
    }

    /**
     * Modifies all values through a {@link Traversal}.
     *
     * @param traversal The traversal to focus with
     * @param modifier The function to transform each focused value
     * @param &lt;A&gt; The focused value type
     * @return A new structure with all focused values modified
     */
    public &lt;A&gt; S allThrough(Traversal&lt;S, A&gt; traversal, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L1164">      return Traversals.modify(traversal, modifier, source);</span>
    }

    /**
     * Modifies a value through a {@link Lens} with an effectful function.
     *
     * @param lens The lens to focus with
     * @param modifier The effectful function to transform the focused value
     * @param functor The functor instance for the effect type
     * @param &lt;F&gt; The effect type witness
     * @param &lt;A&gt; The focused value type
     * @return The modified structure wrapped in the effect
     */
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; Kind&lt;F, S&gt; throughF(
        Lens&lt;S, A&gt; lens, Function&lt;A, Kind&lt;F, A&gt;&gt; modifier, Functor&lt;F&gt; functor) {
<span class="fc" id="L1179">      return lens.modifyF(modifier, source, functor);</span>
    }

    /**
     * Modifies all values through a {@link Traversal} with an effectful function.
     *
     * @param traversal The traversal to focus with
     * @param modifier The effectful function to transform each focused value
     * @param applicative The applicative instance for the effect type
     * @param &lt;F&gt; The effect type witness
     * @param &lt;A&gt; The focused value type
     * @return The modified structure wrapped in the effect
     */
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; Kind&lt;F, S&gt; allThroughF(
        Traversal&lt;S, A&gt; traversal, Function&lt;A, Kind&lt;F, A&gt;&gt; modifier, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L1194">      return traversal.modifyF(modifier, source, applicative);</span>
    }
  }

  /**
   * Builder for fluent query operations.
   *
   * @param &lt;S&gt; The source type
   */
  public static final class QueryBuilder&lt;S&gt; {
    private final S source;

<span class="fc" id="L1206">    QueryBuilder(S source) {</span>
<span class="fc" id="L1207">      this.source = source;</span>
<span class="fc" id="L1208">    }</span>

    /**
     * Checks if any focused element matches the given predicate.
     *
     * @param fold The optic to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if any focused element matches
     */
    public &lt;A&gt; boolean anyMatch(Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1219">      return fold.exists(predicate, source);</span>
    }

    /**
     * Checks if any focused element matches the given predicate.
     *
     * @param traversal The traversal to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if any focused element matches
     */
    public &lt;A&gt; boolean anyMatch(Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1231">      return traversalToFold(traversal).exists(predicate, source);</span>
    }

    /**
     * Checks if all focused elements match the given predicate.
     *
     * @param fold The optic to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if all focused elements match
     */
    public &lt;A&gt; boolean allMatch(Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1243">      return fold.all(predicate, source);</span>
    }

    /**
     * Checks if all focused elements match the given predicate.
     *
     * @param traversal The traversal to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if all focused elements match
     */
    public &lt;A&gt; boolean allMatch(Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1255">      return traversalToFold(traversal).all(predicate, source);</span>
    }

    /**
     * Finds the first focused element that matches the given predicate.
     *
     * @param fold The optic to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return An {@link Optional} containing the first matching element, or empty if none match
     */
    public &lt;A&gt; Optional&lt;A&gt; findFirst(Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1267">      return fold.find(predicate, source);</span>
    }

    /**
     * Finds the first focused element that matches the given predicate.
     *
     * @param traversal The traversal to focus with
     * @param predicate The predicate to test
     * @param &lt;A&gt; The focused value type
     * @return An {@link Optional} containing the first matching element, or empty if none match
     */
    public &lt;A&gt; Optional&lt;A&gt; findFirst(Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L1279">      return traversalToFold(traversal).find(predicate, source);</span>
    }

    /**
     * Counts the number of focused elements.
     *
     * @param fold The optic to focus with
     * @param &lt;A&gt; The focused value type
     * @return The number of focused elements
     */
    public &lt;A&gt; int count(Fold&lt;S, A&gt; fold) {
<span class="fc" id="L1290">      return fold.length(source);</span>
    }

    /**
     * Counts the number of focused elements.
     *
     * @param traversal The traversal to focus with
     * @param &lt;A&gt; The focused value type
     * @return The number of focused elements
     */
    public &lt;A&gt; int count(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L1301">      return traversalToFold(traversal).length(source);</span>
    }

    /**
     * Checks if there are no focused elements.
     *
     * @param fold The optic to focus with
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if there are no focused elements
     */
    public &lt;A&gt; boolean isEmpty(Fold&lt;S, A&gt; fold) {
<span class="fc" id="L1312">      return fold.isEmpty(source);</span>
    }

    /**
     * Checks if there are no focused elements.
     *
     * @param traversal The traversal to focus with
     * @param &lt;A&gt; The focused value type
     * @return {@code true} if there are no focused elements
     */
    public &lt;A&gt; boolean isEmpty(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L1323">      return traversalToFold(traversal).isEmpty(source);</span>
    }
  }

  /**
   * Builder for fluent validation-aware modify operations.
   *
   * &lt;p&gt;This builder provides methods for modifying values with validation that can fail, returning
   * {@link org.higherkindedj.hkt.either.Either}, {@link org.higherkindedj.hkt.maybe.Maybe}, or
   * {@link org.higherkindedj.hkt.validated.Validated} to represent success or failure.
   *
   * &lt;h2&gt;When to Use Each Method&lt;/h2&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;&lt;b&gt;throughEither&lt;/b&gt;: Single field validation with error short-circuiting
   *   &lt;li&gt;&lt;b&gt;throughMaybe&lt;/b&gt;: Single field optional validation (success/nothing)
   *   &lt;li&gt;&lt;b&gt;allThroughValidated&lt;/b&gt;: Multiple field validation with error accumulation
   *   &lt;li&gt;&lt;b&gt;allThroughEither&lt;/b&gt;: Multiple field validation with error short-circuiting
   * &lt;/ul&gt;
   *
   * @param &lt;S&gt; The source type
   */
  public static final class ModifyingWithValidation&lt;S&gt; {
    private final S source;

<span class="fc" id="L1348">    ModifyingWithValidation(S source) {</span>
<span class="fc" id="L1349">      this.source = source;</span>
<span class="fc" id="L1350">    }</span>

    /**
     * Modifies through a {@link Lens} with Either-based validation.
     *
     * &lt;p&gt;Example:
     *
     * &lt;pre&gt;{@code
     * Either&lt;String, User&gt; result = OpticOps.modifyingWithValidation(user)
     *     .throughEither(emailLens, email -&gt;
     *         email.contains(&quot;@&quot;)
     *             ? Either.right(email.toLowerCase())
     *             : Either.left(&quot;Invalid email format&quot;)
     *     );
     * }&lt;/pre&gt;
     *
     * @param lens The lens to focus with
     * @param validator Function returning Either.right(valid) or Either.left(error)
     * @param &lt;E&gt; The error type
     * @param &lt;A&gt; The focused value type
     * @return Either containing the updated structure or an error
     */
    public &lt;E, A&gt; Either&lt;E, S&gt; throughEither(Lens&lt;S, A&gt; lens, Function&lt;A, Either&lt;E, A&gt;&gt; validator) {
<span class="fc" id="L1373">      return modifyEither(source, lens, validator);</span>
    }

    /**
     * Modifies through a {@link Lens} with Maybe-based validation.
     *
     * &lt;p&gt;Example:
     *
     * &lt;pre&gt;{@code
     * Maybe&lt;Person&gt; result = OpticOps.modifyingWithValidation(person)
     *     .throughMaybe(ageLens, age -&gt;
     *         (age &gt;= 0 &amp;&amp; age &lt;= 150)
     *             ? Maybe.just(age)
     *             : Maybe.nothing()
     *     );
     * }&lt;/pre&gt;
     *
     * @param lens The lens to focus with
     * @param validator Function returning Maybe.just(valid) or Maybe.nothing()
     * @param &lt;A&gt; The focused value type
     * @return Maybe containing the updated structure or nothing
     */
    public &lt;A&gt; Maybe&lt;S&gt; throughMaybe(Lens&lt;S, A&gt; lens, Function&lt;A, Maybe&lt;A&gt;&gt; validator) {
<span class="fc" id="L1396">      return modifyMaybe(source, lens, validator);</span>
    }

    /**
     * Modifies all focused values with Validated accumulation.
     *
     * &lt;p&gt;All validation errors are accumulated rather than short-circuiting on the first error.
     *
     * &lt;p&gt;Example:
     *
     * &lt;pre&gt;{@code
     * Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyingWithValidation(order)
     *     .allThroughValidated(itemPrices, price -&gt; {
     *         if (price &lt; 0) {
     *             return Validated.invalid(&quot;Negative price&quot;);
     *         } else if (price &gt; 10000) {
     *             return Validated.invalid(&quot;Price too high&quot;);
     *         } else {
     *             return Validated.valid(price);
     *         }
     *     });
     * }&lt;/pre&gt;
     *
     * @param traversal The traversal to focus with
     * @param validator Function returning Validated.valid or Validated.invalid
     * @param &lt;E&gt; The error type
     * @param &lt;A&gt; The focused value type
     * @return Validated containing the updated structure or accumulated errors
     */
    public &lt;E, A&gt; Validated&lt;List&lt;E&gt;, S&gt; allThroughValidated(
        Traversal&lt;S, A&gt; traversal, Function&lt;A, Validated&lt;E, A&gt;&gt; validator) {
<span class="fc" id="L1427">      return modifyAllValidated(source, traversal, validator);</span>
    }

    /**
     * Modifies all focused values with Either short-circuiting.
     *
     * &lt;p&gt;Stops at the first validation error (short-circuits).
     *
     * &lt;p&gt;Example:
     *
     * &lt;pre&gt;{@code
     * Either&lt;String, Team&gt; result = OpticOps.modifyingWithValidation(team)
     *     .allThroughEither(playerNames, name -&gt;
     *         name.length() &gt;= 3
     *             ? Either.right(name.trim())
     *             : Either.left(&quot;Name too short: &quot; + name)
     *     );
     * }&lt;/pre&gt;
     *
     * @param traversal The traversal to focus with
     * @param validator Function returning Either.right or Either.left
     * @param &lt;E&gt; The error type
     * @param &lt;A&gt; The focused value type
     * @return Either containing the updated structure or first error
     */
    public &lt;E, A&gt; Either&lt;E, S&gt; allThroughEither(
        Traversal&lt;S, A&gt; traversal, Function&lt;A, Either&lt;E, A&gt;&gt; validator) {
<span class="fc" id="L1454">      return modifyAllEither(source, traversal, validator);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>