<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.context</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.context;

import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.vtask.VTask;
import org.jspecify.annotations.Nullable;

/**
 * Represents a computation that reads a value of type {@code R} from a {@link ScopedValue
 * ScopedValue&lt;R&gt;} and produces a result of type {@code A}.
 *
 * &lt;p&gt;{@code Context&lt;R, A&gt;} is the functional interface for working with Java's {@link ScopedValue}
 * API in a composable way. It enables context propagation patterns that work correctly with virtual
 * threads and structured concurrency, where child threads automatically inherit scoped value
 * bindings from their parent.
 *
 * &lt;p&gt;&lt;b&gt;Key Characteristics:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Scoped Value Access:&lt;/b&gt; Reads from thread-scoped {@link ScopedValue} containers rather
 *       than requiring explicit parameter passing.
 *   &lt;li&gt;&lt;b&gt;Thread Inheritance:&lt;/b&gt; Values bound in a parent thread are automatically visible to
 *       child virtual threads forked within the same scope.
 *   &lt;li&gt;&lt;b&gt;Composability:&lt;/b&gt; Supports {@link #map(Function)}, {@link #flatMap(Function)}, and
 *       other functional composition methods.
 *   &lt;li&gt;&lt;b&gt;HKT Integration:&lt;/b&gt; Implements {@link ContextKind} for use with Higher-Kinded-J type
 *       classes like {@link org.higherkindedj.hkt.Functor Functor} and {@link
 *       org.higherkindedj.hkt.Monad Monad}.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * // Define a scoped value
 * static final ScopedValue&lt;String&gt; TRACE_ID = ScopedValue.newInstance();
 *
 * // Create a context that reads it
 * Context&lt;String, String&gt; getTraceId = Context.ask(TRACE_ID);
 *
 * // Transform the result
 * Context&lt;String, String&gt; formatTrace = getTraceId.map(id -&gt; &quot;[&quot; + id + &quot;]&quot;);
 *
 * // Run within a scoped binding
 * String result = ScopedValue
 *     .where(TRACE_ID, &quot;abc-123&quot;)
 *     .call(() -&gt; formatTrace.run());
 * // result = &quot;[abc-123]&quot;
 * }&lt;/pre&gt;
 *
 * @param &lt;R&gt; The type of the value read from the {@link ScopedValue}.
 * @param &lt;A&gt; The type of the result produced by this context computation.
 * @see ScopedValue
 * @see ContextKind
 * @see ContextMonad
 */
public sealed interface Context&lt;R, A&gt; extends ContextKind&lt;R, A&gt;
    permits Context.Ask,
        Context.Pure,
        Context.FlatMapped,
        Context.Failed,
        Context.Recovered,
        Context.RecoveredWith,
        Context.ErrorMapped {

  /**
   * Executes this context computation, reading from any required {@link ScopedValue} bindings and
   * producing a result.
   *
   * &lt;p&gt;This method should be called within a scope where all required {@link ScopedValue}s are
   * bound. If a required scoped value is not bound, a {@link NoSuchElementException} will be
   * thrown.
   *
   * @return The result of the computation.
   * @throws NoSuchElementException if a required {@link ScopedValue} is not bound.
   * @throws RuntimeException if the computation fails.
   */
  @Nullable A run();

  // ===== FACTORY METHODS =====

  /**
   * Creates a {@code Context} that reads from the specified {@link ScopedValue} and returns the
   * value unchanged.
   *
   * &lt;p&gt;This is the fundamental operation for accessing scoped values. The returned context, when
   * run, will call {@link ScopedValue#get()} on the provided key.
   *
   * @param key The {@link ScopedValue} to read from. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @return A {@code Context&lt;R, R&gt;} that reads and returns the scoped value.
   * @throws NullPointerException if {@code key} is null.
   */
  static &lt;R&gt; Context&lt;R, R&gt; ask(ScopedValue&lt;R&gt; key) {
<span class="fc" id="L101">    Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L102">    return new Ask&lt;&gt;(key, Function.identity());</span>
  }

  /**
   * Creates a {@code Context} that reads from the specified {@link ScopedValue} and transforms the
   * value using the provided function.
   *
   * &lt;p&gt;This is a convenience method combining {@link #ask(ScopedValue)} and {@link #map(Function)}.
   *
   * @param key The {@link ScopedValue} to read from. Must not be null.
   * @param f The function to apply to the scoped value. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the transformed result.
   * @return A {@code Context&lt;R, A&gt;} that reads the scoped value and applies the function.
   * @throws NullPointerException if {@code key} or {@code f} is null.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; asks(ScopedValue&lt;R&gt; key, Function&lt;? super R, ? extends A&gt; f) {
<span class="fc" id="L119">    Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L120">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L121">    return new Ask&lt;&gt;(key, f);</span>
  }

  /**
   * Creates a {@code Context} that succeeds immediately with the given value, without reading from
   * any {@link ScopedValue}.
   *
   * &lt;p&gt;This is the &quot;pure&quot; or &quot;return&quot; operation for the Context monad.
   *
   * @param value The value to wrap. May be null.
   * @param &lt;R&gt; The phantom type parameter for the scoped value (not used).
   * @param &lt;A&gt; The type of the value.
   * @return A {@code Context&lt;R, A&gt;} that succeeds with the given value.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; succeed(@Nullable A value) {
<span class="fc" id="L136">    return new Pure&lt;&gt;(value);</span>
  }

  /**
   * Creates a {@code Context} that fails immediately with the given error when run.
   *
   * @param error The error to fail with. Must not be null.
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The phantom type parameter for the result.
   * @return A {@code Context&lt;R, A&gt;} that fails with the given error.
   * @throws NullPointerException if {@code error} is null.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; fail(Throwable error) {
<span class="fc" id="L149">    Objects.requireNonNull(error, &quot;error cannot be null&quot;);</span>
<span class="fc" id="L150">    return new Failed&lt;&gt;(error);</span>
  }

  // ===== COMBINATOR METHODS =====

  /**
   * Combines two {@code Context} values using a combining function.
   *
   * &lt;p&gt;This is a convenience method that avoids nested {@code flatMap} calls when combining two
   * context computations.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Context&lt;String, Integer&gt; getAge = Context.asks(USER_KEY, User::age);
   * Context&lt;String, String&gt; getName = Context.asks(USER_KEY, User::name);
   *
   * Context&lt;String, String&gt; greeting = Context.map2(
   *     getAge,
   *     getName,
   *     (age, name) -&gt; name + &quot; is &quot; + age + &quot; years old&quot;
   * );
   * }&lt;/pre&gt;
   *
   * @param ca The first context. Must not be null.
   * @param cb The second context. Must not be null.
   * @param f The combining function. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the first context's result.
   * @param &lt;B&gt; The type of the second context's result.
   * @param &lt;C&gt; The type of the combined result.
   * @return A {@code Context&lt;R, C&gt;} that combines both results.
   * @throws NullPointerException if any argument is null.
   */
  static &lt;R, A, B, C&gt; Context&lt;R, C&gt; map2(
      Context&lt;R, A&gt; ca, Context&lt;R, B&gt; cb, BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {
<span class="fc" id="L186">    Objects.requireNonNull(ca, &quot;ca cannot be null&quot;);</span>
<span class="fc" id="L187">    Objects.requireNonNull(cb, &quot;cb cannot be null&quot;);</span>
<span class="fc" id="L188">    Objects.requireNonNull(f, &quot;f cannot be null&quot;);</span>
<span class="fc" id="L189">    return ca.flatMap(a -&gt; cb.map(b -&gt; f.apply(a, b)));</span>
  }

  /**
   * Combines three {@code Context} values using a combining function.
   *
   * &lt;p&gt;This is a convenience method that avoids deeply nested {@code flatMap} calls when combining
   * three context computations.
   *
   * @param ca The first context. Must not be null.
   * @param cb The second context. Must not be null.
   * @param cc The third context. Must not be null.
   * @param f The combining function. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the first context's result.
   * @param &lt;B&gt; The type of the second context's result.
   * @param &lt;C&gt; The type of the third context's result.
   * @param &lt;D&gt; The type of the combined result.
   * @return A {@code Context&lt;R, D&gt;} that combines all results.
   * @throws NullPointerException if any argument is null.
   */
  static &lt;R, A, B, C, D&gt; Context&lt;R, D&gt; map3(
      Context&lt;R, A&gt; ca,
      Context&lt;R, B&gt; cb,
      Context&lt;R, C&gt; cc,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; f) {
<span class="fc" id="L215">    Objects.requireNonNull(ca, &quot;ca cannot be null&quot;);</span>
<span class="fc" id="L216">    Objects.requireNonNull(cb, &quot;cb cannot be null&quot;);</span>
<span class="fc" id="L217">    Objects.requireNonNull(cc, &quot;cc cannot be null&quot;);</span>
<span class="fc" id="L218">    Objects.requireNonNull(f, &quot;f cannot be null&quot;);</span>
<span class="fc" id="L219">    return ca.flatMap(a -&gt; cb.flatMap(b -&gt; cc.map(c -&gt; f.apply(a, b, c))));</span>
  }

  // ===== COMPOSITION METHODS =====

  /**
   * Transforms the result of this context using the provided function.
   *
   * &lt;p&gt;This is the Functor {@code map} operation for Context.
   *
   * @param f The function to apply to the result. Must not be null.
   * @param &lt;B&gt; The type of the transformed result.
   * @return A new {@code Context&lt;R, B&gt;} with the transformed result.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; Context&lt;R, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L235">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L236">    return flatMap(a -&gt; succeed(f.apply(a)));</span>
  }

  /**
   * Composes this context with a function that produces another context.
   *
   * &lt;p&gt;This is the Monad {@code flatMap} (or {@code bind}) operation for Context. It allows
   * sequencing context computations where each step can depend on the result of the previous.
   *
   * @param f A function that takes the result and returns a new context. Must not be null.
   * @param &lt;B&gt; The type of the result produced by the new context.
   * @return A new {@code Context&lt;R, B&gt;} representing the composed computation.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; Context&lt;R, B&gt; flatMap(Function&lt;? super A, ? extends Context&lt;R, ? extends B&gt;&gt; f) {
<span class="fc" id="L251">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L252">    return new FlatMapped&lt;&gt;(this, f);</span>
  }

  /**
   * Recovers from a failure by applying the given function to produce a recovery value.
   *
   * @param recoveryFunction A function that takes the error and returns a recovery value. Must not
   *     be null.
   * @return A new {@code Context&lt;R, A&gt;} that recovers from failures.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default Context&lt;R, A&gt; recover(Function&lt;? super Throwable, ? extends A&gt; recoveryFunction) {
<span class="fc" id="L264">    Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L265">    return new Recovered&lt;&gt;(this, recoveryFunction);</span>
  }

  /**
   * Recovers from a failure by applying the given function to produce a recovery context.
   *
   * @param recoveryFunction A function that takes the error and returns a recovery context. Must
   *     not be null.
   * @return A new {@code Context&lt;R, A&gt;} that recovers from failures.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default Context&lt;R, A&gt; recoverWith(
      Function&lt;? super Throwable, ? extends Context&lt;R, ? extends A&gt;&gt; recoveryFunction) {
<span class="fc" id="L278">    Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L279">    return new RecoveredWith&lt;&gt;(this, recoveryFunction);</span>
  }

  /**
   * Transforms the error if this context fails.
   *
   * @param f A function that transforms the error. Must not be null.
   * @return A new {@code Context&lt;R, A&gt;} with the transformed error.
   * @throws NullPointerException if {@code f} is null.
   */
  default Context&lt;R, A&gt; mapError(Function&lt;? super Throwable, ? extends Throwable&gt; f) {
<span class="fc" id="L290">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L291">    return new ErrorMapped&lt;&gt;(this, f);</span>
  }

  // ===== CONVERSION METHODS =====

  /**
   * Converts this context to a {@link VTask} that reads from the currently bound scoped values.
   *
   * &lt;p&gt;The returned VTask, when executed, will run this context computation. The scoped values must
   * be bound in the scope where the VTask is executed.
   *
   * @return A {@link VTask} that executes this context computation.
   */
  default VTask&lt;A&gt; toVTask() {
<span class="fc" id="L305">    return VTask.delay(this::run);</span>
  }

  /**
   * Converts this context to a {@link Maybe}, returning {@link Maybe#nothing()} if the computation
   * fails.
   *
   * @return A {@link Maybe} containing the result or nothing if failed.
   */
  default Maybe&lt;A&gt; toMaybe() {
    try {
<span class="fc" id="L316">      A result = run();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">      return result != null ? Maybe.just(result) : Maybe.nothing();</span>
<span class="fc" id="L318">    } catch (Throwable t) {</span>
<span class="fc" id="L319">      return Maybe.nothing();</span>
    }
  }

  /**
   * Discards the result, returning {@link Unit}.
   *
   * @return A {@code Context&lt;R, Unit&gt;} that performs the same computation but returns Unit.
   */
  default Context&lt;R, Unit&gt; asUnit() {
<span class="fc" id="L329">    return map(_ -&gt; Unit.INSTANCE);</span>
  }

  // ===== IMPLEMENTATION CLASSES =====

  /**
   * Implementation that reads from a {@link ScopedValue} and applies a transformation.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result after transformation.
   */
  record Ask&lt;R, A&gt;(ScopedValue&lt;R&gt; key, Function&lt;? super R, ? extends A&gt; transform)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L344">    public Ask {</span>
<span class="fc" id="L345">      Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L346">      Objects.requireNonNull(transform, &quot;transform cannot be null&quot;);</span>
<span class="fc" id="L347">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable A run() {
<span class="fc" id="L352">      R value = key.get();</span>
<span class="fc" id="L353">      return (A) transform.apply(value);</span>
    }
  }

  /**
   * Implementation that succeeds with a pure value.
   *
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The type of the value.
   */
<span class="fc" id="L363">  record Pure&lt;R, A&gt;(@Nullable A value) implements Context&lt;R, A&gt; {</span>

    @Override
    public @Nullable A run() {
<span class="fc" id="L367">      return value;</span>
    }
  }

  /**
   * Implementation that composes two context computations.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The intermediate type.
   * @param &lt;B&gt; The final result type.
   */
  record FlatMapped&lt;R, A, B&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super A, ? extends Context&lt;R, ? extends B&gt;&gt; f)
      implements Context&lt;R, B&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L383">    public FlatMapped {</span>
<span class="fc" id="L384">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L385">      Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L386">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable B run() {
<span class="fc" id="L391">      A a = source.run();</span>
<span class="fc" id="L392">      Context&lt;R, ? extends B&gt; next = f.apply(a);</span>
<span class="fc" id="L393">      Objects.requireNonNull(next, &quot;flatMap function returned null context&quot;);</span>
<span class="fc" id="L394">      return (B) next.run();</span>
    }
  }

  /**
   * Implementation that fails with an error.
   *
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The phantom type parameter for the result.
   */
  record Failed&lt;R, A&gt;(Throwable error) implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L407">    public Failed {</span>
<span class="fc" id="L408">      Objects.requireNonNull(error, &quot;error cannot be null&quot;);</span>
<span class="fc" id="L409">    }</span>

    @Override
    public @Nullable A run() {
<span class="nc" id="L413">      throw sneakyThrow(error);</span>
    }
  }

  /**
   * Implementation that recovers from failures with a recovery value.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record Recovered&lt;R, A&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super Throwable, ? extends A&gt; recoveryFunction)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L428">    public Recovered {</span>
<span class="fc" id="L429">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L430">      Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L431">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable A run() {
      try {
<span class="fc" id="L437">        return source.run();</span>
<span class="fc" id="L438">      } catch (Throwable t) {</span>
<span class="fc" id="L439">        return (A) recoveryFunction.apply(t);</span>
      }
    }
  }

  /**
   * Implementation that recovers from failures with a recovery context.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record RecoveredWith&lt;R, A&gt;(
      Context&lt;R, A&gt; source,
      Function&lt;? super Throwable, ? extends Context&lt;R, ? extends A&gt;&gt; recoveryFunction)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L456">    public RecoveredWith {</span>
<span class="fc" id="L457">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L458">      Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L459">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable A run() {
      try {
<span class="fc" id="L465">        return source.run();</span>
<span class="fc" id="L466">      } catch (Throwable t) {</span>
<span class="fc" id="L467">        Context&lt;R, ? extends A&gt; recovery = recoveryFunction.apply(t);</span>
<span class="fc" id="L468">        Objects.requireNonNull(recovery, &quot;recovery context cannot be null&quot;);</span>
<span class="fc" id="L469">        return (A) recovery.run();</span>
      }
    }
  }

  /**
   * Implementation that transforms errors.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record ErrorMapped&lt;R, A&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super Throwable, ? extends Throwable&gt; errorMapper)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L485">    public ErrorMapped {</span>
<span class="fc" id="L486">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L487">      Objects.requireNonNull(errorMapper, &quot;errorMapper cannot be null&quot;);</span>
<span class="fc" id="L488">    }</span>

    @Override
    public @Nullable A run() {
      try {
<span class="fc" id="L493">        return source.run();</span>
<span class="fc" id="L494">      } catch (Throwable t) {</span>
<span class="nc" id="L495">        throw sneakyThrow(errorMapper.apply(t));</span>
      }
    }
  }

  // ===== UTILITY METHODS =====

  /**
   * Utility method to throw checked exceptions without declaring them.
   *
   * @param t The throwable to throw.
   * @return Never returns; always throws.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;T extends Throwable&gt; RuntimeException sneakyThrow(Throwable t) throws T {
<span class="fc" id="L510">    throw (T) t;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>