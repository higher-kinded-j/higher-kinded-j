<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.context</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.context;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.vtask.VTask;
import org.jspecify.annotations.Nullable;

/**
 * Represents a computation that reads a value of type {@code R} from a {@link ScopedValue
 * ScopedValue&lt;R&gt;} and produces a result of type {@code A}.
 *
 * &lt;p&gt;{@code Context&lt;R, A&gt;} is the functional interface for working with Java's {@link ScopedValue}
 * API in a composable way. It enables context propagation patterns that work correctly with virtual
 * threads and structured concurrency, where child threads automatically inherit scoped value
 * bindings from their parent.
 *
 * &lt;p&gt;&lt;b&gt;Key Characteristics:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Scoped Value Access:&lt;/b&gt; Reads from thread-scoped {@link ScopedValue} containers rather
 *       than requiring explicit parameter passing.
 *   &lt;li&gt;&lt;b&gt;Thread Inheritance:&lt;/b&gt; Values bound in a parent thread are automatically visible to
 *       child virtual threads forked within the same scope.
 *   &lt;li&gt;&lt;b&gt;Composability:&lt;/b&gt; Supports {@link #map(Function)}, {@link #flatMap(Function)}, and
 *       other functional composition methods.
 *   &lt;li&gt;&lt;b&gt;HKT Integration:&lt;/b&gt; Implements {@link ContextKind} for use with Higher-Kinded-J type
 *       classes like {@link org.higherkindedj.hkt.Functor Functor} and {@link
 *       org.higherkindedj.hkt.Monad Monad}.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * // Define a scoped value
 * static final ScopedValue&lt;String&gt; TRACE_ID = ScopedValue.newInstance();
 *
 * // Create a context that reads it
 * Context&lt;String, String&gt; getTraceId = Context.ask(TRACE_ID);
 *
 * // Transform the result
 * Context&lt;String, String&gt; formatTrace = getTraceId.map(id -&gt; &quot;[&quot; + id + &quot;]&quot;);
 *
 * // Run within a scoped binding
 * String result = ScopedValue
 *     .where(TRACE_ID, &quot;abc-123&quot;)
 *     .call(() -&gt; formatTrace.run());
 * // result = &quot;[abc-123]&quot;
 * }&lt;/pre&gt;
 *
 * @param &lt;R&gt; The type of the value read from the {@link ScopedValue}.
 * @param &lt;A&gt; The type of the result produced by this context computation.
 * @see ScopedValue
 * @see ContextKind
 * @see ContextMonad
 */
public sealed interface Context&lt;R, A&gt; extends ContextKind&lt;R, A&gt;
    permits Context.Ask,
        Context.Pure,
        Context.FlatMapped,
        Context.Failed,
        Context.Recovered,
        Context.RecoveredWith,
        Context.ErrorMapped {

  /**
   * Executes this context computation, reading from any required {@link ScopedValue} bindings and
   * producing a result.
   *
   * &lt;p&gt;This method should be called within a scope where all required {@link ScopedValue}s are
   * bound. If a required scoped value is not bound, a {@link NoSuchElementException} will be
   * thrown.
   *
   * @return The result of the computation.
   * @throws NoSuchElementException if a required {@link ScopedValue} is not bound.
   * @throws RuntimeException if the computation fails.
   */
  @Nullable A run();

  // ===== FACTORY METHODS =====

  /**
   * Creates a {@code Context} that reads from the specified {@link ScopedValue} and returns the
   * value unchanged.
   *
   * &lt;p&gt;This is the fundamental operation for accessing scoped values. The returned context, when
   * run, will call {@link ScopedValue#get()} on the provided key.
   *
   * @param key The {@link ScopedValue} to read from. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @return A {@code Context&lt;R, R&gt;} that reads and returns the scoped value.
   * @throws NullPointerException if {@code key} is null.
   */
  static &lt;R&gt; Context&lt;R, R&gt; ask(ScopedValue&lt;R&gt; key) {
<span class="fc" id="L103">    Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L104">    return new Ask&lt;&gt;(key, Function.identity());</span>
  }

  /**
   * Creates a {@code Context} that reads from the specified {@link ScopedValue} and transforms the
   * value using the provided function.
   *
   * &lt;p&gt;This is a convenience method combining {@link #ask(ScopedValue)} and {@link #map(Function)}.
   *
   * @param key The {@link ScopedValue} to read from. Must not be null.
   * @param f The function to apply to the scoped value. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the transformed result.
   * @return A {@code Context&lt;R, A&gt;} that reads the scoped value and applies the function.
   * @throws NullPointerException if {@code key} or {@code f} is null.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; asks(ScopedValue&lt;R&gt; key, Function&lt;? super R, ? extends A&gt; f) {
<span class="fc" id="L121">    Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L122">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L123">    return new Ask&lt;&gt;(key, f);</span>
  }

  /**
   * Creates a {@code Context} that succeeds immediately with the given value, without reading from
   * any {@link ScopedValue}.
   *
   * &lt;p&gt;This is the &quot;pure&quot; or &quot;return&quot; operation for the Context monad.
   *
   * @param value The value to wrap. May be null.
   * @param &lt;R&gt; The phantom type parameter for the scoped value (not used).
   * @param &lt;A&gt; The type of the value.
   * @return A {@code Context&lt;R, A&gt;} that succeeds with the given value.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; succeed(@Nullable A value) {
<span class="fc" id="L138">    return new Pure&lt;&gt;(value);</span>
  }

  /**
   * Creates a {@code Context} that fails immediately with the given error when run.
   *
   * @param error The error to fail with. Must not be null.
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The phantom type parameter for the result.
   * @return A {@code Context&lt;R, A&gt;} that fails with the given error.
   * @throws NullPointerException if {@code error} is null.
   */
  static &lt;R, A&gt; Context&lt;R, A&gt; fail(Throwable error) {
<span class="fc" id="L151">    Objects.requireNonNull(error, &quot;error cannot be null&quot;);</span>
<span class="fc" id="L152">    return new Failed&lt;&gt;(error);</span>
  }

  // ===== COMBINATOR METHODS =====

  /**
   * Combines two {@code Context} values using a combining function.
   *
   * &lt;p&gt;This is a convenience method that avoids nested {@code flatMap} calls when combining two
   * context computations.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Context&lt;String, Integer&gt; getAge = Context.asks(USER_KEY, User::age);
   * Context&lt;String, String&gt; getName = Context.asks(USER_KEY, User::name);
   *
   * Context&lt;String, String&gt; greeting = Context.map2(
   *     getAge,
   *     getName,
   *     (age, name) -&gt; name + &quot; is &quot; + age + &quot; years old&quot;
   * );
   * }&lt;/pre&gt;
   *
   * @param ca The first context. Must not be null.
   * @param cb The second context. Must not be null.
   * @param f The combining function. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the first context's result.
   * @param &lt;B&gt; The type of the second context's result.
   * @param &lt;C&gt; The type of the combined result.
   * @return A {@code Context&lt;R, C&gt;} that combines both results.
   * @throws NullPointerException if any argument is null.
   */
  static &lt;R, A, B, C&gt; Context&lt;R, C&gt; map2(
      Context&lt;R, A&gt; ca, Context&lt;R, B&gt; cb, BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {
<span class="fc" id="L188">    Objects.requireNonNull(ca, &quot;ca cannot be null&quot;);</span>
<span class="fc" id="L189">    Objects.requireNonNull(cb, &quot;cb cannot be null&quot;);</span>
<span class="fc" id="L190">    Objects.requireNonNull(f, &quot;f cannot be null&quot;);</span>
<span class="fc" id="L191">    return ca.flatMap(a -&gt; cb.map(b -&gt; f.apply(a, b)));</span>
  }

  /**
   * Combines three {@code Context} values using a combining function.
   *
   * &lt;p&gt;This is a convenience method that avoids deeply nested {@code flatMap} calls when combining
   * three context computations.
   *
   * @param ca The first context. Must not be null.
   * @param cb The second context. Must not be null.
   * @param cc The third context. Must not be null.
   * @param f The combining function. Must not be null.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the first context's result.
   * @param &lt;B&gt; The type of the second context's result.
   * @param &lt;C&gt; The type of the third context's result.
   * @param &lt;D&gt; The type of the combined result.
   * @return A {@code Context&lt;R, D&gt;} that combines all results.
   * @throws NullPointerException if any argument is null.
   */
  static &lt;R, A, B, C, D&gt; Context&lt;R, D&gt; map3(
      Context&lt;R, A&gt; ca,
      Context&lt;R, B&gt; cb,
      Context&lt;R, C&gt; cc,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; f) {
<span class="fc" id="L217">    Objects.requireNonNull(ca, &quot;ca cannot be null&quot;);</span>
<span class="fc" id="L218">    Objects.requireNonNull(cb, &quot;cb cannot be null&quot;);</span>
<span class="fc" id="L219">    Objects.requireNonNull(cc, &quot;cc cannot be null&quot;);</span>
<span class="fc" id="L220">    Objects.requireNonNull(f, &quot;f cannot be null&quot;);</span>
<span class="fc" id="L221">    return ca.flatMap(a -&gt; cb.flatMap(b -&gt; cc.map(c -&gt; f.apply(a, b, c))));</span>
  }

  // ===== COMPOSITION METHODS =====

  /**
   * Transforms the result of this context using the provided function.
   *
   * &lt;p&gt;This is the Functor {@code map} operation for Context.
   *
   * @param f The function to apply to the result. Must not be null.
   * @param &lt;B&gt; The type of the transformed result.
   * @return A new {@code Context&lt;R, B&gt;} with the transformed result.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; Context&lt;R, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L237">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L238">    return flatMap(a -&gt; succeed(f.apply(a)));</span>
  }

  /**
   * Composes this context with a function that produces another context.
   *
   * &lt;p&gt;This is the Monad {@code flatMap} (or {@code bind}) operation for Context. It allows
   * sequencing context computations where each step can depend on the result of the previous.
   *
   * @param f A function that takes the result and returns a new context. Must not be null.
   * @param &lt;B&gt; The type of the result produced by the new context.
   * @return A new {@code Context&lt;R, B&gt;} representing the composed computation.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; Context&lt;R, B&gt; flatMap(Function&lt;? super A, ? extends Context&lt;R, ? extends B&gt;&gt; f) {
<span class="fc" id="L253">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L254">    return new FlatMapped&lt;&gt;(this, f);</span>
  }

  /**
   * Recovers from a failure by applying the given function to produce a recovery value.
   *
   * @param recoveryFunction A function that takes the error and returns a recovery value. Must not
   *     be null.
   * @return A new {@code Context&lt;R, A&gt;} that recovers from failures.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default Context&lt;R, A&gt; recover(Function&lt;? super Throwable, ? extends A&gt; recoveryFunction) {
<span class="fc" id="L266">    Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L267">    return new Recovered&lt;&gt;(this, recoveryFunction);</span>
  }

  /**
   * Recovers from a failure by applying the given function to produce a recovery context.
   *
   * @param recoveryFunction A function that takes the error and returns a recovery context. Must
   *     not be null.
   * @return A new {@code Context&lt;R, A&gt;} that recovers from failures.
   * @throws NullPointerException if {@code recoveryFunction} is null.
   */
  default Context&lt;R, A&gt; recoverWith(
      Function&lt;? super Throwable, ? extends Context&lt;R, ? extends A&gt;&gt; recoveryFunction) {
<span class="fc" id="L280">    Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L281">    return new RecoveredWith&lt;&gt;(this, recoveryFunction);</span>
  }

  /**
   * Transforms the error if this context fails.
   *
   * @param f A function that transforms the error. Must not be null.
   * @return A new {@code Context&lt;R, A&gt;} with the transformed error.
   * @throws NullPointerException if {@code f} is null.
   */
  default Context&lt;R, A&gt; mapError(Function&lt;? super Throwable, ? extends Throwable&gt; f) {
<span class="fc" id="L292">    Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L293">    return new ErrorMapped&lt;&gt;(this, f);</span>
  }

  // ===== CONVERSION METHODS =====

  /**
   * Converts this context to a {@link VTask} that reads from the currently bound scoped values.
   *
   * &lt;p&gt;The returned VTask, when executed, will run this context computation. The scoped values must
   * be bound in the scope where the VTask is executed.
   *
   * @return A {@link VTask} that executes this context computation.
   */
  default VTask&lt;A&gt; toVTask() {
<span class="fc" id="L307">    return VTask.delay(this::run);</span>
  }

  /**
   * Converts this context to a {@link Maybe}, returning {@link Maybe#nothing()} if the computation
   * fails.
   *
   * @return A {@link Maybe} containing the result or nothing if failed.
   */
  default Maybe&lt;A&gt; toMaybe() {
    try {
<span class="fc" id="L318">      A result = run();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">      return result != null ? Maybe.just(result) : Maybe.nothing();</span>
<span class="fc" id="L320">    } catch (Throwable t) {</span>
<span class="fc" id="L321">      return Maybe.nothing();</span>
    }
  }

  /**
   * Discards the result, returning {@link Unit}.
   *
   * @return A {@code Context&lt;R, Unit&gt;} that performs the same computation but returns Unit.
   */
  default Context&lt;R, Unit&gt; asUnit() {
<span class="fc" id="L331">    return map(_ -&gt; Unit.INSTANCE);</span>
  }

  // ===== IMPLEMENTATION CLASSES =====

  /**
   * Implementation that reads from a {@link ScopedValue} and applies a transformation.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result after transformation.
   */
  record Ask&lt;R, A&gt;(ScopedValue&lt;R&gt; key, Function&lt;? super R, ? extends A&gt; transform)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L346">    public Ask {</span>
<span class="fc" id="L347">      Objects.requireNonNull(key, &quot;key cannot be null&quot;);</span>
<span class="fc" id="L348">      Objects.requireNonNull(transform, &quot;transform cannot be null&quot;);</span>
<span class="fc" id="L349">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable A run() {
<span class="fc" id="L354">      R value = key.get();</span>
<span class="fc" id="L355">      return (A) transform.apply(value);</span>
    }
  }

  /**
   * Implementation that succeeds with a pure value.
   *
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The type of the value.
   */
<span class="fc" id="L365">  record Pure&lt;R, A&gt;(@Nullable A value) implements Context&lt;R, A&gt; {</span>

    @Override
    public @Nullable A run() {
<span class="fc" id="L369">      return value;</span>
    }
  }

  /**
   * Implementation that composes two context computations.
   *
   * &lt;p&gt;This implementation uses trampolined evaluation to ensure stack safety for deeply nested
   * flatMap chains. Instead of recursively calling {@code run()}, it delegates to the static
   * {@link #evaluate(Context)} method which iteratively unwinds the chain.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The intermediate type.
   * @param &lt;B&gt; The final result type.
   */
  record FlatMapped&lt;R, A, B&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super A, ? extends Context&lt;R, ? extends B&gt;&gt; f)
      implements Context&lt;R, B&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L389">    public FlatMapped {</span>
<span class="fc" id="L390">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L391">      Objects.requireNonNull(f, &quot;function cannot be null&quot;);</span>
<span class="fc" id="L392">    }</span>

    @Override
    public @Nullable B run() {
      // Delegate to trampolined evaluation for stack safety
<span class="fc" id="L397">      return evaluate(this);</span>
    }
  }

  /**
   * Implementation that fails with an error.
   *
   * @param &lt;R&gt; The phantom type parameter for the scoped value.
   * @param &lt;A&gt; The phantom type parameter for the result.
   */
  record Failed&lt;R, A&gt;(Throwable error) implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L410">    public Failed {</span>
<span class="fc" id="L411">      Objects.requireNonNull(error, &quot;error cannot be null&quot;);</span>
<span class="fc" id="L412">    }</span>

    @Override
    public @Nullable A run() {
<span class="nc" id="L416">      throw sneakyThrow(error);</span>
    }
  }

  /**
   * Implementation that recovers from failures with a recovery value.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record Recovered&lt;R, A&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super Throwable, ? extends A&gt; recoveryFunction)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L431">    public Recovered {</span>
<span class="fc" id="L432">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L433">      Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L434">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public @Nullable A run() {
      try {
<span class="fc" id="L440">        return source.run();</span>
<span class="fc" id="L441">      } catch (Throwable t) {</span>
<span class="fc" id="L442">        return (A) recoveryFunction.apply(t);</span>
      }
    }
  }

  /**
   * Implementation that recovers from failures with a recovery context.
   *
   * &lt;p&gt;This implementation uses trampolined evaluation to ensure stack safety when the recovery
   * context itself contains nested flatMap chains.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record RecoveredWith&lt;R, A&gt;(
      Context&lt;R, A&gt; source,
      Function&lt;? super Throwable, ? extends Context&lt;R, ? extends A&gt;&gt; recoveryFunction)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L462">    public RecoveredWith {</span>
<span class="fc" id="L463">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L464">      Objects.requireNonNull(recoveryFunction, &quot;recoveryFunction cannot be null&quot;);</span>
<span class="fc" id="L465">    }</span>

    @Override
    public @Nullable A run() {
      // Delegate to trampolined evaluation for stack safety
<span class="fc" id="L470">      return evaluate(this);</span>
    }
  }

  /**
   * Implementation that transforms errors.
   *
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   */
  record ErrorMapped&lt;R, A&gt;(
      Context&lt;R, A&gt; source, Function&lt;? super Throwable, ? extends Throwable&gt; errorMapper)
      implements Context&lt;R, A&gt; {

    /** Compact constructor for validation. */
<span class="fc" id="L485">    public ErrorMapped {</span>
<span class="fc" id="L486">      Objects.requireNonNull(source, &quot;source cannot be null&quot;);</span>
<span class="fc" id="L487">      Objects.requireNonNull(errorMapper, &quot;errorMapper cannot be null&quot;);</span>
<span class="fc" id="L488">    }</span>

    @Override
    public @Nullable A run() {
      try {
<span class="fc" id="L493">        return source.run();</span>
<span class="fc" id="L494">      } catch (Throwable t) {</span>
<span class="nc" id="L495">        throw sneakyThrow(errorMapper.apply(t));</span>
      }
    }
  }

  // ===== UTILITY METHODS =====

  /**
   * Evaluates a Context in a stack-safe manner using trampolined iteration.
   *
   * &lt;p&gt;This method handles deeply nested flatMap chains without stack overflow by using an explicit
   * stack of continuations instead of recursive calls. It iteratively unwinds FlatMapped chains,
   * pushing continuations onto the stack, then applies them in reverse order.
   *
   * @param context The context to evaluate.
   * @param &lt;R&gt; The type of the scoped value.
   * @param &lt;A&gt; The type of the result.
   * @return The result of evaluating the context.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
  private static &lt;R, A&gt; @Nullable A evaluate(Context&lt;R, A&gt; context) {
    // Local record to mark recovery handlers on the stack (distinguishes from continuations)
<span class="fc" id="L517">    record RecoveryHandler(Function recoveryFunction) {}</span>
    // Stack holds either Function (continuation) or RecoveryHandler (error handler)
<span class="fc" id="L519">    Deque&lt;Object&gt; stack = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L520">    Context&lt;R, ?&gt; current = context;</span>

    outer:
    while (true) {
      // Phase 1: Unwrap left-associated FlatMapped and RecoveredWith chains
      while (true) {
<span class="fc bfc" id="L526" title="All 2 branches covered.">        if (current instanceof FlatMapped&lt;R, ?, ?&gt; flatMapped) {</span>
<span class="fc" id="L527">          stack.push(flatMapped.f());</span>
<span class="fc" id="L528">          current = flatMapped.source();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        } else if (current instanceof RecoveredWith&lt;R, ?&gt; recoveredWith) {</span>
<span class="fc" id="L530">          stack.push(new RecoveryHandler(recoveredWith.recoveryFunction()));</span>
<span class="fc" id="L531">          current = recoveredWith.source();</span>
        } else {
          break;
        }
<span class="fc" id="L535">      }</span>

      // Phase 2: Evaluate the terminal node
      Object result;
      try {
<span class="fc" id="L540">        result = current.run();</span>
<span class="fc" id="L541">      } catch (Throwable error) {</span>
        // Phase 3a: Error path - find a recovery handler
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        while (!stack.isEmpty()) {</span>
<span class="fc" id="L544">          Object item = stack.pop();</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">          if (item instanceof RecoveryHandler handler) {</span>
<span class="fc" id="L546">            Context&lt;R, ?&gt; recovery =</span>
<span class="fc" id="L547">                (Context&lt;R, ?&gt;) handler.recoveryFunction().apply(error);</span>
<span class="fc" id="L548">            Objects.requireNonNull(recovery, &quot;recovery context cannot be null&quot;);</span>
<span class="fc" id="L549">            current = recovery;</span>
<span class="fc" id="L550">            continue outer;</span>
          }
          // Skip continuations when propagating errors
<span class="fc" id="L553">        }</span>
        // No handler found, rethrow
<span class="nc" id="L555">        throw sneakyThrow(error);</span>
<span class="fc" id="L556">      }</span>

      // Phase 3b: Success path - apply continuations
<span class="fc bfc" id="L559" title="All 2 branches covered.">      while (!stack.isEmpty()) {</span>
<span class="fc" id="L560">        Object item = stack.pop();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (item instanceof RecoveryHandler) {</span>
          // Skip recovery handlers on success path
<span class="fc" id="L563">          continue;</span>
        }
        // Apply the continuation
<span class="fc" id="L566">        Function&lt;Object, Context&lt;R, ?&gt;&gt; f = (Function) item;</span>
<span class="fc" id="L567">        Context&lt;R, ?&gt; next = f.apply(result);</span>
<span class="fc" id="L568">        Objects.requireNonNull(next, &quot;flatMap function returned null context&quot;);</span>
<span class="fc" id="L569">        current = next;</span>
<span class="fc" id="L570">        continue outer;</span>
      }

      // Stack is empty, we have the final result
<span class="fc" id="L574">      return (A) result;</span>
    }
  }

  /**
   * Utility method to throw checked exceptions without declaring them.
   *
   * @param t The throwable to throw.
   * @return Never returns; always throws.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;T extends Throwable&gt; RuntimeException sneakyThrow(Throwable t) throws T {
<span class="fc" id="L586">    throw (T) t;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>