<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.util.validation</a> &gt; <span class="el_source">FunctionValidator.java</span></div><h1>FunctionValidator.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.util.validation;

import static java.util.Objects.isNull;
import static org.higherkindedj.hkt.util.validation.Operation.FLAT_MAP;
import static org.higherkindedj.hkt.util.validation.Operation.FOLD_MAP;
import static org.higherkindedj.hkt.util.validation.Operation.HANDLE_ERROR_WITH;
import static org.higherkindedj.hkt.util.validation.Operation.TRAVERSE;

import java.util.Objects;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.Nullable;

/**
 * Handles function parameter validations in monad operations.
 *
 * &lt;p&gt;This validator ensures consistent error messaging for function parameters across all monad
 * operations, preventing confusion about which operation failed and why.
 */
<span class="fc" id="L25">public enum FunctionValidator {</span>
<span class="fc" id="L26">  FUNCTION_VALIDATOR;</span>

  /**
   * Validates mapping function with class-based operation context.
   *
   * @param function The mapping function to validate
   * @param contextClass The class providing context (e.g., StateTMonad.class, OptionalT.class)
   * @param operation The operation name (e.g., &quot;map&quot;, &quot;traverse&quot;)
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null
   *     &lt;p&gt;Example usage:
   *     &lt;pre&gt;
   * Validation.functionValidator().requireMapper(f, StateTMonad.class, &quot;map&quot;);
   * // Error: &quot;function f for StateTMonad.map cannot be null&quot;
   * &lt;/pre&gt;
   */
  public &lt;T&gt; T requireMapper(
      T function, String functionName, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L45">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L46">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>
<span class="fc" id="L47">    Objects.requireNonNull(functionName, &quot;functionName cannot be null&quot;);</span>

<span class="fc" id="L49">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L50">    return requireMapper(function, functionName, fullOperation);</span>
  }

  /**
   * Validates mapping function with operation context.
   *
   * @param function The mapping function to validate
   * @param operation The operation name (e.g., &quot;map&quot;, &quot;traverse&quot;)
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null
   */
  public &lt;T&gt; T requireMapper(T function, String functionName, String operation) {
<span class="fc" id="L63">    var context = FunctionContext.mapper(functionName, operation);</span>
<span class="fc" id="L64">    return Objects.requireNonNull(function, context.nullParameterMessage());</span>
  }

  /**
   * Validates flat mapping function with class-based operation context.
   *
   * @param function The flat mapping function to validate
   * @param contextClass The class providing context (e.g., StateTMonad.class)
   * @param operation The operation name (e.g., &quot;FLAT_MAP, OF)
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null
   *     &lt;p&gt;Example usage:
   *     &lt;pre&gt;
   * Validation.functionValidator().requireFlatMapper(f, StateTMonad.class, FLAT_MAP);
   * // Error: &quot;function f for StateTMonad.flatMap cannot be null&quot;
   * &lt;/pre&gt;
   */
  public &lt;T&gt; T requireFlatMapper(
      T function, String functionName, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L84">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L85">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>
<span class="fc" id="L86">    Objects.requireNonNull(functionName, &quot;functionName cannot be null&quot;);</span>

<span class="fc" id="L88">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L89">    return requireFlatMapper(function, functionName, fullOperation);</span>
  }

  /**
   * Validates flat mapping function with operation context.
   *
   * @param function The flat mapping function to validate
   * @param operation The operation name (e.g., &quot;flatMap&quot;, &quot;bind&quot;)
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null
   */
  public &lt;T&gt; T requireFlatMapper(T function, String functionName, String operation) {
<span class="fc" id="L102">    var context = FunctionContext.flatMapper(functionName, operation);</span>
<span class="fc" id="L103">    return Objects.requireNonNull(function, context.nullParameterMessage());</span>
  }

  /**
   * Validates applicative instance with class-based operation context.
   *
   * @param applicative The applicative instance to validate
   * @param contextClass The class providing context
   * @param operation The operation name (e.g., &quot;traverse&quot;, &quot;sequence&quot;)
   * @param &lt;T&gt; The applicative type
   * @return The validated applicative
   * @throws NullPointerException with context-specific message if applicative is null
   */
  public &lt;T&gt; T requireApplicative(
      T applicative, String applicativeName, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L118">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L119">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>
<span class="fc" id="L120">    Objects.requireNonNull(applicativeName, &quot;applicativeName cannot be null&quot;);</span>

<span class="fc" id="L122">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L123">    return requireApplicative(applicative, applicativeName, fullOperation);</span>
  }

  /**
   * Validates applicative instance with operation context.
   *
   * @param applicative The applicative instance to validate
   * @param operation The operation name (e.g., &quot;traverse&quot;, &quot;sequence&quot;)
   * @param &lt;T&gt; The applicative type
   * @return The validated applicative
   * @throws NullPointerException with context-specific message if applicative is null
   */
  public &lt;T&gt; T requireApplicative(T applicative, String applicativeName, String operation) {
<span class="fc" id="L136">    var context = FunctionContext.applicative(applicativeName, operation);</span>
<span class="fc" id="L137">    return Objects.requireNonNull(applicative, context.nullParameterMessage());</span>
  }

  /**
   * Validates monoid instance with class-based operation context.
   *
   * @param monoid The monoid instance to validate
   * @param monoidName The name of the monoid parameter
   * @param contextClass The class providing context
   * @param operation The operation name (e.g., &quot;foldMap&quot;)
   * @param &lt;T&gt; The monoid type
   * @return The validated monoid
   * @throws NullPointerException with context-specific message if monoid is null
   */
  public &lt;T&gt; T requireMonoid(
      T monoid, String monoidName, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L153">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L154">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>

<span class="fc" id="L156">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L157">    return requireMonoid(monoid, monoidName, fullOperation);</span>
  }

  /**
   * Validates monoid instance with operation context.
   *
   * @param monoid The monoid instance to validate
   * @param operation The operation name (e.g., &quot;foldMap&quot;)
   * @param &lt;T&gt; The monoid type
   * @return The validated monoid
   * @throws NullPointerException with context-specific message if monoid is null
   */
  public &lt;T&gt; T requireMonoid(T monoid, String monoidName, String operation) {
<span class="fc" id="L170">    var context = new FunctionContext(monoidName, operation);</span>
<span class="fc" id="L171">    return Objects.requireNonNull(monoid, context.nullParameterMessage());</span>
  }

  /**
   * Generic function validation with class-based context.
   *
   * @param function The function to validate
   * @param functionName The name of the function parameter
   * @param contextClass The class providing context
   * @param operation The operation name
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null Example usage:
   *     &lt;pre&gt;
   * Validation.functionValidator().requireFunction(fn, &quot;runStateTFn&quot;, StateT.class, &quot;construction&quot;);
   * // Error: &quot;runStateTFn for StateT construction cannot be null&quot;
   *  &lt;/pre&gt;
   */
  public &lt;T&gt; T requireFunction(
      T function, String functionName, Class&lt;?&gt; contextClass, Operation operation) {

<span class="fc" id="L192">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L193">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>

<span class="fc" id="L195">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L196">    return requireFunction(function, functionName, fullOperation);</span>
  }

  /**
   * Generic function validation with custom name and operation context.
   *
   * @param function The function to validate
   * @param functionName The name of the function parameter
   * @param operation The operation name
   * @param &lt;T&gt; The function type
   * @return The validated function
   * @throws NullPointerException with context-specific message if function is null
   */
  public &lt;T&gt; T requireFunction(T function, String functionName, String operation) {
<span class="fc" id="L210">    var context = new FunctionContext(functionName, operation);</span>
<span class="fc" id="L211">    return Objects.requireNonNull(function, context.nullParameterMessage());</span>
  }

  /**
   * Validates that a function result is not null (for flatMap scenarios) with class-based context.
   *
   * @param result The result returned by a function
   * @param contextClass The class providing context
   * @param operation The operation that produced this result
   * @param &lt;T&gt; The result type
   * @return The validated result
   * @throws KindUnwrapException if result is null
   *     &lt;p&gt;Example usage:
   *     &lt;pre&gt;
   * Validation.functionValidator().requireNonNullResult(kindB, StateTMonad.class, &quot;flatMap&quot;);
   * // Error: &quot;Function in StateTMonad.flatMap returned null, which is not allowed&quot;
   * &lt;/pre&gt;
   */
  public &lt;T&gt; T requireNonNullResult(
      T result, String functionName, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L231">    return requireNonNullResult(result, functionName, contextClass, operation, null);</span>
  }

  /**
   * Validates that a function result is not null (for flatMap scenarios).
   *
   * @param result The result returned by a function
   * @param operation The operation that produced this result
   * @param targetType The expected type for error messaging
   * @param &lt;T&gt; The result type
   * @return The validated result
   * @throws KindUnwrapException if result is null
   */
  public &lt;T&gt; T requireNonNullResult(
      T result,
      String functionName,
      Class&lt;?&gt; contextClass,
      Operation operation,
      @Nullable Class&lt;?&gt; targetType) {
<span class="fc" id="L250">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L251">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>
<span class="fc" id="L252">    Objects.requireNonNull(functionName, &quot;functionName cannot be null&quot;);</span>

<span class="fc" id="L254">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (isNull(result)) {</span>
      String msg =
<span class="fc bfc" id="L257" title="All 2 branches covered.">          (targetType == null)</span>
              ? &quot;Function %s in %s returned null, which is not allowed&quot;
<span class="fc" id="L259">                  .formatted(functionName, fullOperation)</span>
              : &quot;Function %s in %s returned null when %s expected, which is not allowed&quot;
<span class="fc" id="L261">                  .formatted(functionName, fullOperation, targetType.getSimpleName());</span>

<span class="fc" id="L263">      throw new KindUnwrapException(msg);</span>
    }
<span class="fc" id="L265">    return result;</span>
  }

  // Add validation for handlers (used in error handling)
  public &lt;T&gt; T requireHandler(T handler, Class&lt;?&gt; contextClass, Operation operation) {
<span class="fc" id="L270">    Objects.requireNonNull(contextClass, &quot;contextClass cannot be null&quot;);</span>
<span class="fc" id="L271">    Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>

<span class="fc" id="L273">    String fullOperation = contextClass.getSimpleName() + &quot;.&quot; + operation;</span>
<span class="fc" id="L274">    var context = new FunctionContext(&quot;handler&quot;, fullOperation);</span>
<span class="fc" id="L275">    return Objects.requireNonNull(handler, context.nullParameterMessage());</span>
  }

  // ==================== Bulk Validation Helpers ====================
  // These methods reduce boilerplate by combining multiple validations into single calls.

  /**
   * Validates all parameters for a flatMap operation in a single call.
   *
   * &lt;p&gt;This combines function and Kind validation, reducing boilerplate in Monad implementations.
   *
   * @param f the flatMap function (must be non-null)
   * @param ma the input Kind (must be non-null)
   * @param contextClass the class performing the operation (for error messages)
   * @param &lt;F&gt; the functor type constructor
   * @param &lt;A&gt; input type
   * @param &lt;B&gt; output type
   * @throws NullPointerException if f or ma is null
   */
  public &lt;F, A, B&gt; void validateFlatMap(
      Function&lt;? super A, ? extends Kind&lt;F, B&gt;&gt; f, Kind&lt;F, A&gt; ma, Class&lt;?&gt; contextClass) {
<span class="fc" id="L296">    requireFlatMapper(f, &quot;f&quot;, contextClass, FLAT_MAP);</span>
<span class="fc" id="L297">    Validation.kind().requireNonNull(ma, contextClass, FLAT_MAP);</span>
<span class="fc" id="L298">  }</span>

  /**
   * Validates all parameters for a traverse operation in a single call.
   *
   * &lt;p&gt;This combines applicative, function, and Kind validation, reducing boilerplate in Traverse
   * implementations.
   *
   * @param applicative the target Applicative (must be non-null)
   * @param f the transformation function (must be non-null)
   * @param ta the traversable Kind (must be non-null)
   * @param contextClass the class performing the operation (for error messages)
   * @param &lt;G&gt; the applicative type constructor
   * @param &lt;A&gt; input element type
   * @param &lt;B&gt; output element type
   * @throws NullPointerException if any parameter is null
   */
  public &lt;G, A, B&gt; void validateTraverse(
      Applicative&lt;G&gt; applicative,
      Function&lt;? super A, ? extends Kind&lt;G, ? extends B&gt;&gt; f,
      Kind&lt;?, A&gt; ta,
      Class&lt;?&gt; contextClass) {
<span class="fc" id="L320">    requireApplicative(applicative, &quot;applicative&quot;, contextClass, TRAVERSE);</span>
<span class="fc" id="L321">    requireMapper(f, &quot;f&quot;, contextClass, TRAVERSE);</span>
<span class="fc" id="L322">    Validation.kind().requireNonNull(ta, contextClass, TRAVERSE);</span>
<span class="fc" id="L323">  }</span>

  /**
   * Validates all parameters for a foldMap operation in a single call.
   *
   * &lt;p&gt;This combines monoid, function, and Kind validation, reducing boilerplate in
   * Foldable/Traverse implementations.
   *
   * @param monoid the combining Monoid (must be non-null)
   * @param f the transformation function (must be non-null)
   * @param fa the foldable Kind (must be non-null)
   * @param contextClass the class performing the operation (for error messages)
   * @param &lt;M&gt; the monoid type
   * @param &lt;A&gt; input element type
   * @throws NullPointerException if any parameter is null
   */
  public &lt;M, A&gt; void validateFoldMap(
      Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, Kind&lt;?, A&gt; fa, Class&lt;?&gt; contextClass) {
<span class="fc" id="L341">    requireMonoid(monoid, &quot;monoid&quot;, contextClass, FOLD_MAP);</span>
<span class="fc" id="L342">    requireMapper(f, &quot;f&quot;, contextClass, FOLD_MAP);</span>
<span class="fc" id="L343">    Validation.kind().requireNonNull(fa, contextClass, FOLD_MAP);</span>
<span class="fc" id="L344">  }</span>

  /**
   * Validates all parameters for a handleErrorWith operation in a single call.
   *
   * &lt;p&gt;This combines Kind and handler function validation, reducing boilerplate in MonadError
   * implementations.
   *
   * @param ma the source Kind (must be non-null)
   * @param handler the error recovery function (must be non-null)
   * @param contextClass the class performing the operation (for error messages)
   * @param &lt;F&gt; the functor type constructor
   * @param &lt;A&gt; the value type
   * @param &lt;E&gt; the error type
   * @throws NullPointerException if ma or handler is null
   */
  public &lt;F, A, E&gt; void validateHandleErrorWith(
      Kind&lt;F, A&gt; ma, Function&lt;? super E, ? extends Kind&lt;F, A&gt;&gt; handler, Class&lt;?&gt; contextClass) {
<span class="fc" id="L362">    Validation.kind().requireNonNull(ma, contextClass, HANDLE_ERROR_WITH, &quot;source&quot;);</span>
<span class="fc" id="L363">    requireFunction(handler, &quot;handler&quot;, contextClass, HANDLE_ERROR_WITH);</span>
<span class="fc" id="L364">  }</span>

  public record FunctionContext(String functionName, String operation) {

<span class="fc" id="L368">    public FunctionContext {</span>
<span class="fc" id="L369">      Objects.requireNonNull(functionName, &quot;functionName cannot be null&quot;);</span>
<span class="fc" id="L370">      Objects.requireNonNull(operation, &quot;operation cannot be null&quot;);</span>
<span class="fc" id="L371">    }</span>

    public static FunctionContext mapper(String functionName, String operation) {
<span class="fc" id="L374">      return new FunctionContext(functionName, operation);</span>
    }

    public static FunctionContext flatMapper(String functionName, String operation) {
<span class="fc" id="L378">      return new FunctionContext(functionName, operation);</span>
    }

    public static FunctionContext applicative(String applicativeName, String operation) {
<span class="fc" id="L382">      return new FunctionContext(applicativeName, operation);</span>
    }

    public String nullParameterMessage() {
<span class="fc" id="L386">      return String.format(&quot;Function %s for %s cannot be null&quot;, functionName, operation);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>