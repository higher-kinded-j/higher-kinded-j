<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LazyPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">LazyPath.java</span></div><h1>LazyPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.id.Id;
import org.higherkindedj.hkt.lazy.Lazy;
import org.higherkindedj.hkt.lazy.ThrowableSupplier;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;

/**
 * A fluent path wrapper for {@link Lazy} computations.
 *
 * &lt;p&gt;{@code LazyPath} represents deferred computations that are evaluated at most once. Once
 * evaluated, the result is cached and reused on subsequent accesses.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Expensive computations that may not be needed
 *   &lt;li&gt;Breaking circular dependencies
 *   &lt;li&gt;Infinite data structures
 *   &lt;li&gt;Memoisation
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating LazyPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Deferred computation
 * LazyPath&lt;BigInteger&gt; expensiveCalc = LazyPath.defer(() -&gt; computeFibonacci(1000));
 *
 * // Already-evaluated value
 * LazyPath&lt;String&gt; eager = LazyPath.now(&quot;hello&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * LazyPath&lt;BigInteger&gt; fibonacci1000 = LazyPath.defer(() -&gt; computeFib(1000));
 *
 * // Transformations are also lazy
 * LazyPath&lt;String&gt; asString = fibonacci1000.map(BigInteger::toString);
 *
 * // Not computed yet
 * System.out.println(&quot;About to force...&quot;);
 *
 * // Now it's computed (and cached)
 * String result = asString.get();
 *
 * // Second call returns cached value (no recomputation)
 * String result2 = asString.get();
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Exception Handling&lt;/h2&gt;
 *
 * &lt;p&gt;Unlike most path types, {@code LazyPath} can throw exceptions when evaluated. The {@link
 * #get()} method wraps checked exceptions in {@link RuntimeException}, while {@link #force()}
 * throws them directly.
 *
 * @param &lt;A&gt; the type of the computed value
 */
public final class LazyPath&lt;A&gt; implements Chainable&lt;A&gt; {

  private final Lazy&lt;A&gt; lazy;

  /**
   * Creates a new LazyPath wrapping the given Lazy.
   *
   * @param lazy the Lazy to wrap; must not be null
   */
<span class="fc" id="L79">  LazyPath(Lazy&lt;A&gt; lazy) {</span>
<span class="fc" id="L80">    this.lazy = Objects.requireNonNull(lazy, &quot;lazy must not be null&quot;);</span>
<span class="fc" id="L81">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a LazyPath from a Lazy.
   *
   * @param lazy the Lazy to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a LazyPath wrapping the given Lazy
   * @throws NullPointerException if lazy is null
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; of(Lazy&lt;A&gt; lazy) {
<span class="fc" id="L94">    return new LazyPath&lt;&gt;(lazy);</span>
  }

  /**
   * Creates an already-evaluated LazyPath.
   *
   * &lt;p&gt;The value is immediately available without any computation.
   *
   * @param value the already-computed value
   * @param &lt;A&gt; the value type
   * @return a LazyPath holding the pre-computed value
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; now(A value) {
<span class="fc" id="L107">    return new LazyPath&lt;&gt;(Lazy.now(value));</span>
  }

  /**
   * Creates a LazyPath that defers computation until first access.
   *
   * &lt;p&gt;The supplier will be called at most once when the value is first requested.
   *
   * @param supplier the supplier for the value; must not be null
   * @param &lt;A&gt; the value type
   * @return a LazyPath that defers computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; defer(Supplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L121">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L122">    return new LazyPath&lt;&gt;(Lazy.defer(() -&gt; supplier.get()));</span>
  }

  /**
   * Creates a LazyPath that defers computation which may throw.
   *
   * &lt;p&gt;The supplier will be called at most once when the value is first requested.
   *
   * @param supplier the supplier for the value; must not be null
   * @param &lt;A&gt; the value type
   * @return a LazyPath that defers computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; deferThrowable(ThrowableSupplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L136">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L137">    return new LazyPath&lt;&gt;(Lazy.defer(supplier));</span>
  }

  // ===== Terminal Operations =====

  /**
   * Forces evaluation and returns the result.
   *
   * &lt;p&gt;Subsequent calls return the cached value without recomputation. If the computation throws an
   * exception, it will be cached and re-thrown on subsequent calls.
   *
   * @return the computed value
   * @throws RuntimeException wrapping any exception thrown by the computation
   */
  public A get() {
    try {
<span class="fc" id="L153">      return lazy.force();</span>
<span class="fc" id="L154">    } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L155">      throw e;</span>
<span class="fc" id="L156">    } catch (Throwable t) {</span>
<span class="fc" id="L157">      throw new RuntimeException(&quot;LazyPath computation failed&quot;, t);</span>
    }
  }

  /**
   * Forces evaluation and returns the result, allowing checked exceptions.
   *
   * &lt;p&gt;This method provides direct access to exceptions thrown by the computation.
   *
   * @return the computed value
   * @throws Throwable if the computation throws
   */
  public A force() throws Throwable {
<span class="fc" id="L170">    return lazy.force();</span>
  }

  /**
   * Returns whether this lazy value has been evaluated.
   *
   * @return true if already evaluated, false if still deferred
   */
  public boolean isEvaluated() {
<span class="fc" id="L179">    return lazy.isEvaluated();</span>
  }

  /**
   * Returns the underlying Lazy.
   *
   * @return the wrapped Lazy
   */
  public Lazy&lt;A&gt; toLazy() {
<span class="fc" id="L188">    return lazy;</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; LazyPath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L195">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L196">    return new LazyPath&lt;&gt;(lazy.map(mapper));</span>
  }

  @Override
  public LazyPath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L201">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L202">    return new LazyPath&lt;&gt;(</span>
<span class="fc" id="L203">        lazy.map(</span>
            a -&gt; {
<span class="fc" id="L205">              consumer.accept(a);</span>
<span class="fc" id="L206">              return a;</span>
            }));
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; LazyPath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L215">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L216">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (!(other instanceof LazyPath&lt;?&gt; otherLazy)) {</span>
<span class="fc" id="L219">      throw new IllegalArgumentException(&quot;Cannot zipWith non-LazyPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L223">    LazyPath&lt;B&gt; typedOther = (LazyPath&lt;B&gt;) otherLazy;</span>

<span class="fc" id="L225">    return new LazyPath&lt;&gt;(</span>
<span class="fc" id="L226">        Lazy.defer(</span>
            () -&gt; {
<span class="fc" id="L228">              A a = this.lazy.force();</span>
<span class="fc" id="L229">              B b = typedOther.lazy.force();</span>
<span class="fc" id="L230">              return combiner.apply(a, b);</span>
            }));
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * &lt;p&gt;All three lazy values are evaluated when the result is forced.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new lazy path containing the combined result
   */
  public &lt;B, C, D&gt; LazyPath&lt;D&gt; zipWith3(
      LazyPath&lt;B&gt; second,
      LazyPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L251">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L252">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L253">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L255">    return new LazyPath&lt;&gt;(</span>
<span class="fc" id="L256">        Lazy.defer(</span>
            () -&gt; {
<span class="fc" id="L258">              A a = this.lazy.force();</span>
<span class="fc" id="L259">              B b = second.lazy.force();</span>
<span class="fc" id="L260">              C c = third.lazy.force();</span>
<span class="fc" id="L261">              return combiner.apply(a, b, c);</span>
            }));
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; LazyPath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L269">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L271">    return new LazyPath&lt;&gt;(</span>
<span class="fc" id="L272">        lazy.flatMap(</span>
            a -&gt; {
<span class="fc" id="L274">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L275">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">              if (!(result instanceof LazyPath&lt;?&gt; lazyPath)) {</span>
<span class="fc" id="L278">                throw new IllegalArgumentException(</span>
<span class="fc" id="L279">                    &quot;via mapper must return LazyPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L283">              LazyPath&lt;B&gt; typedResult = (LazyPath&lt;B&gt;) lazyPath;</span>
<span class="fc" id="L284">              return typedResult.lazy;</span>
            }));
  }

  @Override
  public &lt;B&gt; LazyPath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L290">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc" id="L292">    return new LazyPath&lt;&gt;(</span>
<span class="fc" id="L293">        Lazy.defer(</span>
            () -&gt; {
              // Force this lazy for sequencing
<span class="fc" id="L296">              this.lazy.force();</span>

<span class="fc" id="L298">              Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L299">              Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">              if (!(result instanceof LazyPath&lt;?&gt; lazyPath)) {</span>
<span class="fc" id="L302">                throw new IllegalArgumentException(</span>
<span class="fc" id="L303">                    &quot;then supplier must return LazyPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L307">              LazyPath&lt;B&gt; typedResult = (LazyPath&lt;B&gt;) lazyPath;</span>
<span class="fc" id="L308">              return typedResult.lazy.force();</span>
            }));
  }

  // ===== Conversions =====

  /**
   * Converts to an IOPath.
   *
   * &lt;p&gt;The IO will force evaluation when run.
   *
   * @return an IOPath that produces the same value
   */
  public IOPath&lt;A&gt; toIOPath() {
<span class="fc" id="L322">    return new IOPath&lt;&gt;(this::get);</span>
  }

  /**
   * Converts to a MaybePath.
   *
   * &lt;p&gt;Forces evaluation. If the value is null, returns an empty MaybePath.
   *
   * @return a MaybePath containing the value if non-null
   */
  public MaybePath&lt;A&gt; toMaybePath() {
<span class="fc" id="L333">    A val = get();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">    return val != null ? new MaybePath&lt;&gt;(Maybe.just(val)) : new MaybePath&lt;&gt;(Maybe.nothing());</span>
  }

  /**
   * Converts to a TryPath.
   *
   * &lt;p&gt;Forces evaluation. If the computation throws, the exception is captured in the TryPath.
   *
   * @return a TryPath containing Success if computation succeeds, Failure otherwise
   */
  public TryPath&lt;A&gt; toTryPath() {
    try {
<span class="fc" id="L346">      return new TryPath&lt;&gt;(Try.success(lazy.force()));</span>
<span class="fc" id="L347">    } catch (Throwable t) {</span>
<span class="fc" id="L348">      return new TryPath&lt;&gt;(Try.failure(t));</span>
    }
  }

  /**
   * Converts to an IdPath.
   *
   * &lt;p&gt;Forces evaluation.
   *
   * @return an IdPath containing the value
   */
  public IdPath&lt;A&gt; toIdPath() {
<span class="fc" id="L360">    return new IdPath&lt;&gt;(Id.of(get()));</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">    if (!(obj instanceof LazyPath&lt;?&gt; other)) return false;</span>
<span class="fc" id="L369">    return lazy.equals(other.lazy);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L374">    return lazy.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L379">    return &quot;LazyPath(&quot; + lazy + &quot;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>