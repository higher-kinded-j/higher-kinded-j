<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TryPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">TryPath.java</span></div><h1>TryPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.effect.capability.Recoverable;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPath;

/**
 * A fluent path wrapper for {@link Try} values.
 *
 * &lt;p&gt;{@code TryPath} provides a chainable API for composing operations that may throw exceptions.
 * It implements {@link Recoverable} with {@link Throwable} as the error type.
 *
 * &lt;h2&gt;Creating TryPath instances&lt;/h2&gt;
 *
 * &lt;p&gt;Use the {@link Path} factory class to create instances:
 *
 * &lt;pre&gt;{@code
 * TryPath&lt;String&gt; path = Path.tryOf(() -&gt; Files.readString(file));
 * TryPath&lt;Integer&gt; success = Path.success(42);
 * TryPath&lt;Integer&gt; failure = Path.failure(new IOException(&quot;File not found&quot;));
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * TryPath&lt;Config&gt; config = Path.tryOf(() -&gt; readConfigFile())
 *     .map(Config::parse)
 *     .via(c -&gt; Path.tryOf(() -&gt; validate(c)));
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Exception handling&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * String content = Path.tryOf(() -&gt; Files.readString(path))
 *     .recover(ex -&gt; &quot;default content&quot;)
 *     .run()
 *     .get();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the type of the success value
 */
public final class TryPath&lt;A&gt; implements Recoverable&lt;Throwable, A&gt; {

  private final Try&lt;A&gt; value;

  /**
   * Creates a new TryPath wrapping the given Try.
   *
   * @param value the Try to wrap; must not be null
   */
<span class="fc" id="L67">  TryPath(Try&lt;A&gt; value) {</span>
<span class="fc" id="L68">    this.value = Objects.requireNonNull(value, &quot;value must not be null&quot;);</span>
<span class="fc" id="L69">  }</span>

  /**
   * Returns the underlying Try value.
   *
   * @return the wrapped Try
   */
  public Try&lt;A&gt; run() {
<span class="fc" id="L77">    return value;</span>
  }

  /**
   * Returns the success value if present, otherwise returns the provided default.
   *
   * @param defaultValue the value to return if this path contains a failure
   * @return the success value or the default
   */
  public A getOrElse(A defaultValue) {
<span class="fc" id="L87">    return value.orElse(defaultValue);</span>
  }

  /**
   * Returns the success value if present, otherwise invokes the supplier.
   *
   * @param supplier provides the default value; must not be null
   * @return the success value or the supplier's result
   * @throws NullPointerException if supplier is null
   */
  public A getOrElseGet(Supplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L98">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L99">    return value.orElseGet(supplier);</span>
  }

  /**
   * Folds both cases of this path into a single value.
   *
   * @param successMapper the function to apply if this path contains a value; must not be null
   * @param failureMapper the function to apply if this path contains an exception; must not be null
   * @param &lt;B&gt; the result type
   * @return the result of applying the appropriate function
   * @throws NullPointerException if either mapper is null
   */
  public &lt;B&gt; B fold(
      Function&lt;? super A, ? extends B&gt; successMapper,
      Function&lt;? super Throwable, ? extends B&gt; failureMapper) {
<span class="fc" id="L114">    Objects.requireNonNull(successMapper, &quot;successMapper must not be null&quot;);</span>
<span class="fc" id="L115">    Objects.requireNonNull(failureMapper, &quot;failureMapper must not be null&quot;);</span>
<span class="fc" id="L116">    return value.fold(successMapper, failureMapper);</span>
  }

  /**
   * Converts this TryPath to a MaybePath, discarding the exception.
   *
   * @return a MaybePath containing the value, or empty if this contains an exception
   */
  public MaybePath&lt;A&gt; toMaybePath() {
<span class="fc" id="L125">    return value.fold(a -&gt; new MaybePath&lt;&gt;(Maybe.just(a)), ex -&gt; new MaybePath&lt;&gt;(Maybe.nothing()));</span>
  }

  /**
   * Converts this TryPath to an EitherPath.
   *
   * &lt;p&gt;The exception is transformed using the provided function to create the error type.
   *
   * @param exceptionToError converts the exception to an error; must not be null
   * @param &lt;E&gt; the error type
   * @return an EitherPath representing this path's value or the transformed error
   * @throws NullPointerException if exceptionToError is null
   */
  public &lt;E&gt; EitherPath&lt;E, A&gt; toEitherPath(
      Function&lt;? super Throwable, ? extends E&gt; exceptionToError) {
<span class="fc" id="L140">    Objects.requireNonNull(exceptionToError, &quot;exceptionToError must not be null&quot;);</span>
<span class="fc" id="L141">    return value.fold(</span>
<span class="fc" id="L142">        a -&gt; new EitherPath&lt;&gt;(Either.right(a)),</span>
<span class="fc" id="L143">        ex -&gt; new EitherPath&lt;&gt;(Either.left(exceptionToError.apply(ex))));</span>
  }

  /**
   * Converts this TryPath to a ValidationPath.
   *
   * &lt;p&gt;The exception is transformed using the provided function to create the error type.
   *
   * @param exceptionToError converts the exception to an error; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @return a ValidationPath representing this path's value or the transformed error
   * @throws NullPointerException if either argument is null
   */
  public &lt;E&gt; ValidationPath&lt;E, A&gt; toValidationPath(
      Function&lt;? super Throwable, ? extends E&gt; exceptionToError, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L159">    Objects.requireNonNull(exceptionToError, &quot;exceptionToError must not be null&quot;);</span>
<span class="fc" id="L160">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>
<span class="fc" id="L161">    return value.fold(</span>
<span class="fc" id="L162">        a -&gt; new ValidationPath&lt;&gt;(Validated.valid(a), semigroup),</span>
<span class="fc" id="L163">        ex -&gt; new ValidationPath&lt;&gt;(Validated.invalid(exceptionToError.apply(ex)), semigroup));</span>
  }

  /**
   * Converts this TryPath to an OptionalPath, discarding the exception.
   *
   * @return an OptionalPath containing the value if Success, or empty if Failure
   */
  public OptionalPath&lt;A&gt; toOptionalPath() {
<span class="fc" id="L172">    return value.fold(</span>
<span class="fc" id="L173">        a -&gt; new OptionalPath&lt;&gt;(Optional.of(a)), _ -&gt; new OptionalPath&lt;&gt;(Optional.empty()));</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; TryPath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L180">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L181">    return new TryPath&lt;&gt;(value.map(mapper));</span>
  }

  @Override
  public TryPath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L186">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (value.isSuccess()) {</span>
      try {
<span class="fc" id="L189">        consumer.accept(value.get());</span>
<span class="fc" id="L190">      } catch (Throwable ignored) {</span>
        // peek should not modify the path even if consumer throws
<span class="fc" id="L192">      }</span>
    }
<span class="fc" id="L194">    return this;</span>
  }

  /**
   * Observes the failure without modifying it (for debugging).
   *
   * @param consumer the action to perform on the exception; must not be null
   * @return this path unchanged
   * @throws NullPointerException if consumer is null
   */
  public TryPath&lt;A&gt; peekFailure(Consumer&lt;? super Throwable&gt; consumer) {
<span class="fc" id="L205">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L206">    value.fold(</span>
<span class="fc" id="L207">        a -&gt; null, // Success case - do nothing</span>
        ex -&gt; {
<span class="fc" id="L209">          consumer.accept(ex);</span>
<span class="fc" id="L210">          return null;</span>
        });
<span class="fc" id="L212">    return this;</span>
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; TryPath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L220">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L221">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (!(other instanceof TryPath&lt;?&gt; otherTry)) {</span>
<span class="fc" id="L224">      throw new IllegalArgumentException(&quot;Cannot zipWith non-TryPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L228">    TryPath&lt;B&gt; typedOther = (TryPath&lt;B&gt;) otherTry;</span>

<span class="fc" id="L230">    return this.value.fold(</span>
        a -&gt;
<span class="fc" id="L232">            typedOther.value.fold(</span>
<span class="fc" id="L233">                b -&gt; new TryPath&lt;&gt;(Try.of(() -&gt; combiner.apply(a, b))),</span>
<span class="fc" id="L234">                ex -&gt; new TryPath&lt;&gt;(Try.failure(ex))),</span>
<span class="fc" id="L235">        ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result, or the first failure encountered
   */
  public &lt;B, C, D&gt; TryPath&lt;D&gt; zipWith3(
      TryPath&lt;B&gt; second,
      TryPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L253">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L254">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L255">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L257">    return this.value.fold(</span>
        a -&gt;
<span class="fc" id="L259">            second.value.fold(</span>
                b -&gt;
<span class="fc" id="L261">                    third.value.fold(</span>
<span class="fc" id="L262">                        c -&gt; new TryPath&lt;&gt;(Try.of(() -&gt; combiner.apply(a, b, c))),</span>
<span class="fc" id="L263">                        ex -&gt; new TryPath&lt;&gt;(Try.failure(ex))),</span>
<span class="fc" id="L264">                ex -&gt; new TryPath&lt;&gt;(Try.failure(ex))),</span>
<span class="fc" id="L265">        ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; TryPath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L272">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">    if (value.isFailure()) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L276">      TryPath&lt;B&gt; result = (TryPath&lt;B&gt;) this;</span>
<span class="fc" id="L277">      return result;</span>
    }

    try {
<span class="fc" id="L281">      A successValue = value.get();</span>
<span class="fc" id="L282">      Chainable&lt;B&gt; result = mapper.apply(successValue);</span>
<span class="fc" id="L283">      Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">      if (!(result instanceof TryPath&lt;?&gt; tryPath)) {</span>
<span class="fc" id="L286">        throw new IllegalArgumentException(</span>
<span class="fc" id="L287">            &quot;via mapper must return TryPath, got: &quot; + result.getClass());</span>
      }

      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L291">      TryPath&lt;B&gt; typedResult = (TryPath&lt;B&gt;) tryPath;</span>
<span class="fc" id="L292">      return typedResult;</span>
<span class="fc" id="L293">    } catch (Throwable ex) {</span>
<span class="fc" id="L294">      return new TryPath&lt;&gt;(Try.failure(ex));</span>
    }
  }

  @Override
  public &lt;B&gt; TryPath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L300">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">    if (value.isFailure()) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L304">      TryPath&lt;B&gt; result = (TryPath&lt;B&gt;) this;</span>
<span class="fc" id="L305">      return result;</span>
    }

    try {
<span class="fc" id="L309">      Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L310">      Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">      if (!(result instanceof TryPath&lt;?&gt; tryPath)) {</span>
<span class="fc" id="L313">        throw new IllegalArgumentException(</span>
<span class="fc" id="L314">            &quot;then supplier must return TryPath, got: &quot; + result.getClass());</span>
      }

      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L318">      TryPath&lt;B&gt; typedResult = (TryPath&lt;B&gt;) tryPath;</span>
<span class="fc" id="L319">      return typedResult;</span>
<span class="fc" id="L320">    } catch (Throwable ex) {</span>
<span class="fc" id="L321">      return new TryPath&lt;&gt;(Try.failure(ex));</span>
    }
  }

  // ===== Recoverable implementation =====

  @Override
  public TryPath&lt;A&gt; recover(Function&lt;? super Throwable, ? extends A&gt; recovery) {
<span class="fc" id="L329">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L330">    return new TryPath&lt;&gt;(value.recover(recovery));</span>
  }

  @Override
  public TryPath&lt;A&gt; recoverWith(
      Function&lt;? super Throwable, ? extends Recoverable&lt;Throwable, A&gt;&gt; recovery) {
<span class="fc" id="L336">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L337">    return value.fold(</span>
<span class="fc" id="L338">        a -&gt; this,</span>
        ex -&gt; {
<span class="fc" id="L340">          Recoverable&lt;Throwable, A&gt; result = recovery.apply(ex);</span>
<span class="fc" id="L341">          Objects.requireNonNull(result, &quot;recovery must not return null&quot;);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">          if (!(result instanceof TryPath&lt;?&gt; tryPath)) {</span>
<span class="fc" id="L343">            throw new IllegalArgumentException(</span>
<span class="fc" id="L344">                &quot;recovery must return TryPath, got: &quot; + result.getClass());</span>
          }
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L347">          TryPath&lt;A&gt; typedResult = (TryPath&lt;A&gt;) tryPath;</span>
<span class="fc" id="L348">          return typedResult;</span>
        });
  }

  @Override
  public TryPath&lt;A&gt; orElse(Supplier&lt;? extends Recoverable&lt;Throwable, A&gt;&gt; alternative) {
<span class="fc" id="L354">    Objects.requireNonNull(alternative, &quot;alternative must not be null&quot;);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (value.isSuccess()) {</span>
<span class="fc" id="L356">      return this;</span>
    }
<span class="fc" id="L358">    Recoverable&lt;Throwable, A&gt; result = alternative.get();</span>
<span class="fc" id="L359">    Objects.requireNonNull(result, &quot;alternative must not return null&quot;);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    if (!(result instanceof TryPath&lt;?&gt; tryPath)) {</span>
<span class="fc" id="L361">      throw new IllegalArgumentException(</span>
<span class="fc" id="L362">          &quot;alternative must return TryPath, got: &quot; + result.getClass());</span>
    }
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L365">    TryPath&lt;A&gt; typedResult = (TryPath&lt;A&gt;) tryPath;</span>
<span class="fc" id="L366">    return typedResult;</span>
  }

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;E2&gt; Recoverable&lt;E2, A&gt; mapError(Function&lt;? super Throwable, ? extends E2&gt; mapper) {
    // TryPath uses Throwable as a fixed error type. mapError transforms the error type,
    // but for TryPath we can't actually change the underlying Throwable.
    // We return this cast to the new error type, which is a limitation of the type system.
<span class="fc" id="L375">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L376">    return (Recoverable&lt;E2, A&gt;) this;</span>
  }

  /**
   * Transforms the exception in a failure.
   *
   * &lt;p&gt;If this path is a failure, applies the function to transform the exception into a new
   * exception. If this path is a success, returns unchanged.
   *
   * @param mapper the function to transform the exception; must not be null
   * @return a TryPath with the transformed exception
   * @throws NullPointerException if mapper is null
   */
  public TryPath&lt;A&gt; mapException(Function&lt;? super Throwable, ? extends Throwable&gt; mapper) {
<span class="fc" id="L390">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L391">    return value.fold(a -&gt; this, ex -&gt; new TryPath&lt;&gt;(Try.failure(mapper.apply(ex))));</span>
  }

  // ===== FocusPath Bridge Methods =====

  /**
   * Applies a {@link FocusPath} to navigate within the Success value.
   *
   * &lt;p&gt;This bridges from the effect domain to the optics domain, allowing structural navigation
   * inside an effect context. Since FocusPath always focuses on exactly one element, the result is
   * always a successful navigation if this TryPath is a Success.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;Config, String&gt; apiKeyPath = ConfigFocus.apiKey();
   *
   * TryPath&lt;Config&gt; configPath = Path.tryOf(() -&gt; loadConfig());
   * TryPath&lt;String&gt; apiKey = configPath.focus(apiKeyPath);
   * // Equivalent to: configPath.map(apiKeyPath::get)
   * }&lt;/pre&gt;
   *
   * @param path the FocusPath to apply
   * @param &lt;B&gt; the focused type
   * @return a new TryPath containing the focused value
   */
  public &lt;B&gt; TryPath&lt;B&gt; focus(FocusPath&lt;A, B&gt; path) {
<span class="fc" id="L418">    Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L419">    return map(path::get);</span>
  }

  /**
   * Applies an {@link AffinePath} to navigate within the Success value.
   *
   * &lt;p&gt;This bridges from the effect domain to the optics domain. If the AffinePath doesn't match, a
   * Failure is returned with the exception provided by the supplier. This allows converting partial
   * optics failures to exceptions.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * AffinePath&lt;Config, String&gt; optionalKeyPath = ConfigFocus.optionalApiKey();
   *
   * TryPath&lt;Config&gt; configPath = Path.tryOf(() -&gt; loadConfig());
   * TryPath&lt;String&gt; apiKey = configPath.focus(
   *     optionalKeyPath,
   *     () -&gt; new IllegalStateException(&quot;API key not configured&quot;));
   * // Returns Failure if config has no API key
   * }&lt;/pre&gt;
   *
   * @param path the AffinePath to apply
   * @param exceptionIfAbsent supplies the exception if the path doesn't match
   * @param &lt;B&gt; the focused type
   * @return a new TryPath containing the focused value or a Failure
   */
  public &lt;B&gt; TryPath&lt;B&gt; focus(
      AffinePath&lt;A, B&gt; path, Supplier&lt;? extends Throwable&gt; exceptionIfAbsent) {
<span class="fc" id="L448">    Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L449">    Objects.requireNonNull(exceptionIfAbsent, &quot;exceptionIfAbsent must not be null&quot;);</span>
<span class="fc" id="L450">    return via(</span>
        a -&gt;
<span class="fc" id="L452">            path.getOptional(a)</span>
<span class="fc" id="L453">                .map(Path::success)</span>
<span class="fc" id="L454">                .orElseGet(() -&gt; Path.failure(exceptionIfAbsent.get())));</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">    if (!(obj instanceof TryPath&lt;?&gt; other)) return false;</span>
<span class="fc" id="L463">    return value.equals(other.value);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L468">    return value.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L473">    return &quot;TryPath(&quot; + value + &quot;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>