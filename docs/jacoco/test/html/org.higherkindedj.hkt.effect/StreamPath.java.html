<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">StreamPath.java</span></div><h1>StreamPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.maybe.Maybe;

/**
 * A fluent path wrapper for {@link Stream} representing lazy sequence computations.
 *
 * &lt;p&gt;{@code StreamPath} provides lazy evaluation of sequences. Operations are not executed until a
 * terminal operation is called. Unlike raw Streams, StreamPath uses a supplier to allow multiple
 * terminal operations.
 *
 * &lt;h2&gt;Important&lt;/h2&gt;
 *
 * &lt;p&gt;StreamPath materializes the stream supplier into a list for reusability. For very large or
 * infinite streams, use terminal operations carefully or use {@link #take(long)} first.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Large data processing
 *   &lt;li&gt;Infinite sequences (with limit)
 *   &lt;li&gt;Pipeline transformations
 *   &lt;li&gt;Memory-efficient processing
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating StreamPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // From a stream
 * StreamPath&lt;Integer&gt; numbers = StreamPath.of(Stream.of(1, 2, 3));
 *
 * // From a list
 * StreamPath&lt;String&gt; fromList = StreamPath.fromList(myList);
 *
 * // Infinite sequence
 * StreamPath&lt;Integer&gt; naturals = StreamPath.iterate(1, n -&gt; n + 1);
 *
 * // Generate values
 * StreamPath&lt;Double&gt; randoms = StreamPath.generate(Math::random);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * List&lt;Integer&gt; firstTenSquares = StreamPath.iterate(1, n -&gt; n + 1)
 *     .map(n -&gt; n * n)
 *     .take(10)
 *     .toList();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the element type
 */
public final class StreamPath&lt;A&gt; implements Chainable&lt;A&gt; {

  private final Supplier&lt;Stream&lt;A&gt;&gt; streamSupplier;

  /**
   * Creates a new StreamPath with the given stream supplier.
   *
   * @param streamSupplier the supplier for streams; must not be null
   */
<span class="fc" id="L80">  StreamPath(Supplier&lt;Stream&lt;A&gt;&gt; streamSupplier) {</span>
<span class="fc" id="L81">    this.streamSupplier = Objects.requireNonNull(streamSupplier, &quot;streamSupplier must not be null&quot;);</span>
<span class="fc" id="L82">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a StreamPath from a stream.
   *
   * &lt;p&gt;Note: The stream is materialized to a list to allow multiple terminal operations.
   *
   * @param stream the stream to wrap; must not be null
   * @param &lt;A&gt; the element type
   * @return a StreamPath wrapping the stream
   * @throws NullPointerException if stream is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; of(Stream&lt;A&gt; stream) {
<span class="fc" id="L97">    Objects.requireNonNull(stream, &quot;stream must not be null&quot;);</span>
    // Materialize to allow multiple uses
<span class="fc" id="L99">    List&lt;A&gt; materialized = stream.collect(Collectors.toList());</span>
<span class="fc" id="L100">    return new StreamPath&lt;&gt;(materialized::stream);</span>
  }

  /**
   * Creates a StreamPath from a supplier that produces streams.
   *
   * &lt;p&gt;The supplier is called fresh each time a terminal operation is performed.
   *
   * @param supplier the stream supplier; must not be null
   * @param &lt;A&gt; the element type
   * @return a StreamPath using the supplier
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; fromSupplier(Supplier&lt;Stream&lt;A&gt;&gt; supplier) {
<span class="fc" id="L114">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L115">    return new StreamPath&lt;&gt;(supplier);</span>
  }

  /**
   * Creates a StreamPath from a list.
   *
   * @param list the list to wrap; must not be null
   * @param &lt;A&gt; the element type
   * @return a StreamPath streaming the list
   * @throws NullPointerException if list is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; fromList(List&lt;A&gt; list) {
<span class="fc" id="L127">    Objects.requireNonNull(list, &quot;list must not be null&quot;);</span>
<span class="fc" id="L128">    return new StreamPath&lt;&gt;(list::stream);</span>
  }

  /**
   * Creates a StreamPath from varargs.
   *
   * @param elements the elements
   * @param &lt;A&gt; the element type
   * @return a StreamPath containing the elements
   */
  @SafeVarargs
  public static &lt;A&gt; StreamPath&lt;A&gt; of(A... elements) {
<span class="fc" id="L140">    List&lt;A&gt; list = Arrays.asList(elements);</span>
<span class="fc" id="L141">    return new StreamPath&lt;&gt;(list::stream);</span>
  }

  /**
   * Creates a StreamPath with a single element.
   *
   * @param value the single element
   * @param &lt;A&gt; the element type
   * @return a StreamPath containing one element
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; pure(A value) {
<span class="fc" id="L152">    return new StreamPath&lt;&gt;(() -&gt; Stream.of(value));</span>
  }

  /**
   * Creates an empty StreamPath.
   *
   * @param &lt;A&gt; the element type
   * @return an empty StreamPath
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; empty() {
<span class="fc" id="L162">    return new StreamPath&lt;&gt;(Stream::empty);</span>
  }

  /**
   * Creates an infinite StreamPath by iterating a function.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This creates an infinite stream. Use {@link #take(long)} to limit.
   *
   * @param seed the initial value
   * @param f the function to generate next values; must not be null
   * @param &lt;A&gt; the element type
   * @return an infinite StreamPath
   * @throws NullPointerException if f is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; iterate(A seed, UnaryOperator&lt;A&gt; f) {
<span class="fc" id="L177">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L178">    return new StreamPath&lt;&gt;(() -&gt; Stream.iterate(seed, f));</span>
  }

  /**
   * Creates an infinite StreamPath from a supplier.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This creates an infinite stream. Use {@link #take(long)} to limit.
   *
   * @param supplier the element supplier; must not be null
   * @param &lt;A&gt; the element type
   * @return an infinite StreamPath
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; generate(Supplier&lt;A&gt; supplier) {
<span class="fc" id="L192">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L193">    return new StreamPath&lt;&gt;(() -&gt; Stream.generate(supplier));</span>
  }

  // ===== Terminal Operations =====

  /**
   * Returns a fresh stream for consumption.
   *
   * @return a new stream from the supplier
   */
  public Stream&lt;A&gt; run() {
<span class="fc" id="L204">    return streamSupplier.get();</span>
  }

  /**
   * Collects to a list.
   *
   * @return a list containing all elements
   */
  public List&lt;A&gt; toList() {
<span class="fc" id="L213">    return run().collect(Collectors.toList());</span>
  }

  /**
   * Returns the first element, or empty if the stream is empty.
   *
   * @return an Optional containing the first element if present
   */
  public Optional&lt;A&gt; headOption() {
<span class="fc" id="L222">    return run().findFirst();</span>
  }

  /**
   * Counts elements.
   *
   * @return the number of elements
   */
  public long count() {
<span class="fc" id="L231">    return run().count();</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; StreamPath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L238">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L239">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().map(mapper));</span>
  }

  @Override
  public StreamPath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L244">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L245">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().peek(consumer));</span>
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; StreamPath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L253">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L254">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">    if (!(other instanceof StreamPath&lt;?&gt; otherStream)) {</span>
<span class="fc" id="L257">      throw new IllegalArgumentException(&quot;Cannot zipWith non-StreamPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L261">    StreamPath&lt;B&gt; typedOther = (StreamPath&lt;B&gt;) otherStream;</span>

    // Cartesian product - all combinations (materializes streams)
<span class="fc" id="L264">    return new StreamPath&lt;&gt;(</span>
        () -&gt; {
<span class="fc" id="L266">          List&lt;A&gt; thisElements = this.toList();</span>
<span class="fc" id="L267">          List&lt;B&gt; otherElements = typedOther.toList();</span>
<span class="fc" id="L268">          return thisElements.stream()</span>
<span class="fc" id="L269">              .flatMap(a -&gt; otherElements.stream().map(b -&gt; combiner.apply(a, b)));</span>
        });
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; StreamPath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L277">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L279">    return new StreamPath&lt;&gt;(</span>
        () -&gt;
            streamSupplier
<span class="fc" id="L282">                .get()</span>
<span class="fc" id="L283">                .flatMap(</span>
                    a -&gt; {
<span class="fc" id="L285">                      Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L286">                      Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">                      if (!(result instanceof StreamPath&lt;?&gt; streamPath)) {</span>
<span class="fc" id="L289">                        throw new IllegalArgumentException(</span>
<span class="fc" id="L290">                            &quot;via mapper must return StreamPath, got: &quot; + result.getClass());</span>
                      }

                      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L294">                      StreamPath&lt;B&gt; typedResult = (StreamPath&lt;B&gt;) streamPath;</span>
<span class="fc" id="L295">                      return typedResult.run();</span>
                    }));
  }

  @Override
  public &lt;B&gt; StreamPath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L301">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L302">    return via(ignored -&gt; supplier.get());</span>
  }

  // ===== Stream-Specific Operations =====

  /**
   * Filters elements based on a predicate.
   *
   * @param predicate the condition to test; must not be null
   * @return a new StreamPath with only matching elements
   * @throws NullPointerException if predicate is null
   */
  public StreamPath&lt;A&gt; filter(Predicate&lt;? super A&gt; predicate) {
<span class="fc" id="L315">    Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L316">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().filter(predicate));</span>
  }

  /**
   * Takes the first n elements.
   *
   * @param n the number of elements to take
   * @return a new StreamPath with at most n elements
   */
  public StreamPath&lt;A&gt; take(long n) {
<span class="fc" id="L326">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().limit(n));</span>
  }

  /**
   * Drops the first n elements.
   *
   * @param n the number of elements to skip
   * @return a new StreamPath without the first n elements
   */
  public StreamPath&lt;A&gt; drop(long n) {
<span class="fc" id="L336">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().skip(n));</span>
  }

  /**
   * Takes elements while predicate is true.
   *
   * @param predicate the condition; must not be null
   * @return a new StreamPath with elements taken while predicate holds
   * @throws NullPointerException if predicate is null
   */
  public StreamPath&lt;A&gt; takeWhile(Predicate&lt;? super A&gt; predicate) {
<span class="fc" id="L347">    Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L348">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().takeWhile(predicate));</span>
  }

  /**
   * Drops elements while predicate is true.
   *
   * @param predicate the condition; must not be null
   * @return a new StreamPath with elements after predicate stops holding
   * @throws NullPointerException if predicate is null
   */
  public StreamPath&lt;A&gt; dropWhile(Predicate&lt;? super A&gt; predicate) {
<span class="fc" id="L359">    Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L360">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().dropWhile(predicate));</span>
  }

  /**
   * Returns distinct elements.
   *
   * @return a new StreamPath with duplicates removed
   */
  public StreamPath&lt;A&gt; distinct() {
<span class="fc" id="L369">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().distinct());</span>
  }

  /**
   * Sorts elements (natural ordering).
   *
   * @return a new StreamPath with sorted elements
   */
  public StreamPath&lt;A&gt; sorted() {
<span class="fc" id="L378">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().sorted());</span>
  }

  /**
   * Sorts elements using a comparator.
   *
   * @param comparator the comparator to use; must not be null
   * @return a new StreamPath with sorted elements
   * @throws NullPointerException if comparator is null
   */
  public StreamPath&lt;A&gt; sorted(Comparator&lt;? super A&gt; comparator) {
<span class="fc" id="L389">    Objects.requireNonNull(comparator, &quot;comparator must not be null&quot;);</span>
<span class="fc" id="L390">    return new StreamPath&lt;&gt;(() -&gt; streamSupplier.get().sorted(comparator));</span>
  }

  /**
   * Concatenates with another StreamPath.
   *
   * @param other the other StreamPath; must not be null
   * @return a new StreamPath containing elements from both
   * @throws NullPointerException if other is null
   */
  public StreamPath&lt;A&gt; concat(StreamPath&lt;A&gt; other) {
<span class="fc" id="L401">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L402">    return new StreamPath&lt;&gt;(() -&gt; Stream.concat(streamSupplier.get(), other.run()));</span>
  }

  /**
   * Folds the stream from the left.
   *
   * @param initial the initial accumulator value
   * @param f the folding function; must not be null
   * @param &lt;B&gt; the accumulator and result type
   * @return the folded result
   * @throws NullPointerException if f is null
   */
  public &lt;B&gt; B foldLeft(B initial, BiFunction&lt;B, A, B&gt; f) {
<span class="fc" id="L415">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L416">    B result = initial;</span>
<span class="fc" id="L417">    Iterator&lt;A&gt; iter = run().iterator();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L419">      result = f.apply(result, iter.next());</span>
    }
<span class="fc" id="L421">    return result;</span>
  }

  // ===== Conversions =====

  /**
   * Converts to NonDetPath (materializes the stream).
   *
   * @return a NonDetPath containing the same elements
   */
  public NonDetPath&lt;A&gt; toNonDetPath() {
<span class="fc" id="L432">    return NonDetPath.of(toList());</span>
  }

  /**
   * Converts to MaybePath with the first element.
   *
   * @return a MaybePath containing the first element if present
   */
  public MaybePath&lt;A&gt; toMaybePath() {
<span class="fc" id="L441">    return headOption()</span>
<span class="fc" id="L442">        .map(a -&gt; new MaybePath&lt;&gt;(Maybe.just(a)))</span>
<span class="fc" id="L443">        .orElse(new MaybePath&lt;&gt;(Maybe.nothing()));</span>
  }

  /**
   * Converts to an IOPath that returns this stream's list.
   *
   * @return an IOPath that produces this stream as a list
   */
  public IOPath&lt;List&lt;A&gt;&gt; toIOPath() {
<span class="fc" id="L452">    return new IOPath&lt;&gt;(this::toList);</span>
  }

  // ===== Object methods =====

  @Override
  public String toString() {
<span class="fc" id="L459">    return &quot;StreamPath(&lt;stream&gt;)&quot;;</span>
  }

  // Note: equals and hashCode not implemented because streams are not comparable
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>