<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Path.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">Path.java</span></div><h1>Path.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.spi.PathRegistry;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.free.Free;
import org.higherkindedj.hkt.free_ap.FreeAp;
import org.higherkindedj.hkt.id.Id;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.lazy.Lazy;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.reader.Reader;
import org.higherkindedj.hkt.state.State;
import org.higherkindedj.hkt.trampoline.Trampoline;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.writer.Writer;
import org.jspecify.annotations.Nullable;

/**
 * Factory class for creating Effect Path instances.
 *
 * &lt;p&gt;This is the primary entry point for the Effect Path API. It provides static factory methods
 * for creating path instances from raw values, existing effect types, or deferred computations.
 *
 * &lt;h2&gt;Creating MaybePath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * MaybePath&lt;String&gt; fromValue = Path.just(&quot;hello&quot;);
 * MaybePath&lt;String&gt; empty = Path.nothing();
 * MaybePath&lt;String&gt; fromNullable = Path.maybe(nullableValue);
 * MaybePath&lt;User&gt; fromMaybe = Path.maybe(userRepo.findById(id));
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating EitherPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * EitherPath&lt;Error, User&gt; success = Path.right(user);
 * EitherPath&lt;Error, User&gt; failure = Path.left(Error.notFound());
 * EitherPath&lt;Error, User&gt; fromEither = Path.either(someEither);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating TryPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * TryPath&lt;String&gt; fromSupplier = Path.tryOf(() -&gt; Files.readString(path));
 * TryPath&lt;Integer&gt; success = Path.success(42);
 * TryPath&lt;Integer&gt; failure = Path.failure(new IOException(&quot;Not found&quot;));
 * TryPath&lt;Config&gt; fromTry = Path.tryPath(someTry);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating IOPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * IOPath&lt;String&gt; deferred = Path.io(() -&gt; Files.readString(path));
 * IOPath&lt;Unit&gt; action = Path.ioRunnable(() -&gt; System.out.println(&quot;Hello&quot;));
 * IOPath&lt;Integer&gt; pure = Path.ioPure(42);
 * IOPath&lt;Config&gt; fromIO = Path.ioPath(someIO);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating ValidationPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; success = Path.valid(user, Semigroups.list());
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; failure = Path.invalid(errors, Semigroups.list());
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; fromValidated = Path.validated(v, Semigroups.list());
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating IdPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * IdPath&lt;User&gt; path = Path.id(user);
 * IdPath&lt;User&gt; fromId = Path.idPath(Id.of(user));
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating OptionalPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * OptionalPath&lt;User&gt; path = Path.optional(Optional.of(user));
 * OptionalPath&lt;User&gt; present = Path.present(user);
 * OptionalPath&lt;User&gt; absent = Path.absent();
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Creating GenericPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * GenericPath&lt;CustomKind.Witness, User&gt; path = Path.generic(kindValue, customMonad);
 * GenericPath&lt;CustomKind.Witness, User&gt; pure = Path.genericPure(user, customMonad);
 * }&lt;/pre&gt;
 *
 * @see MaybePath
 * @see EitherPath
 * @see TryPath
 * @see IOPath
 * @see ValidationPath
 * @see IdPath
 * @see OptionalPath
 * @see GenericPath
 * @see ReaderPath
 * @see WithStatePath
 * @see WriterPath
 * @see LazyPath
 * @see CompletableFuturePath
 * @see NonDetPath
 * @see StreamPath
 * @see TrampolinePath
 * @see FreePath
 * @see FreeApPath
 */
public final class Path {

  private Path() {
    // Utility class - no instantiation
  }

  // ===== MaybePath factory methods =====

  /**
   * Creates a MaybePath containing the given non-null value.
   *
   * @param value the value to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return a MaybePath containing the value
   * @throws NullPointerException if value is null
   */
  public static &lt;A&gt; MaybePath&lt;A&gt; just(A value) {
<span class="fc" id="L143">    return new MaybePath&lt;&gt;(Maybe.just(value));</span>
  }

  /**
   * Creates an empty MaybePath.
   *
   * @param &lt;A&gt; the phantom type of the absent value
   * @return an empty MaybePath
   */
  public static &lt;A&gt; MaybePath&lt;A&gt; nothing() {
<span class="fc" id="L153">    return new MaybePath&lt;&gt;(Maybe.nothing());</span>
  }

  /**
   * Creates a MaybePath from a nullable value.
   *
   * &lt;p&gt;If the value is non-null, returns a MaybePath containing it. If the value is null, returns
   * an empty MaybePath.
   *
   * @param value the possibly-null value
   * @param &lt;A&gt; the type of the value
   * @return a MaybePath that is Just if value is non-null, Nothing otherwise
   */
  public static &lt;A&gt; MaybePath&lt;A&gt; maybe(@Nullable A value) {
<span class="fc" id="L167">    return new MaybePath&lt;&gt;(Maybe.fromNullable(value));</span>
  }

  /**
   * Creates a MaybePath from an existing Maybe.
   *
   * @param maybe the Maybe to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return a MaybePath wrapping the Maybe
   * @throws NullPointerException if maybe is null
   */
  public static &lt;A&gt; MaybePath&lt;A&gt; maybe(Maybe&lt;A&gt; maybe) {
<span class="fc" id="L179">    Objects.requireNonNull(maybe, &quot;maybe must not be null&quot;);</span>
<span class="fc" id="L180">    return new MaybePath&lt;&gt;(maybe);</span>
  }

  // ===== EitherPath factory methods =====

  /**
   * Creates an EitherPath containing a Right (success) value.
   *
   * @param value the success value
   * @param &lt;E&gt; the error type (phantom)
   * @param &lt;A&gt; the success type
   * @return an EitherPath containing Right
   */
  public static &lt;E, A&gt; EitherPath&lt;E, A&gt; right(@Nullable A value) {
<span class="fc" id="L194">    return new EitherPath&lt;&gt;(Either.right(value));</span>
  }

  /**
   * Creates an EitherPath containing a Left (error) value.
   *
   * @param error the error value
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the success type (phantom)
   * @return an EitherPath containing Left
   */
  public static &lt;E, A&gt; EitherPath&lt;E, A&gt; left(@Nullable E error) {
<span class="fc" id="L206">    return new EitherPath&lt;&gt;(Either.left(error));</span>
  }

  /**
   * Creates an EitherPath from an existing Either.
   *
   * @param either the Either to wrap; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the success type
   * @return an EitherPath wrapping the Either
   * @throws NullPointerException if either is null
   */
  public static &lt;E, A&gt; EitherPath&lt;E, A&gt; either(Either&lt;E, A&gt; either) {
<span class="fc" id="L219">    Objects.requireNonNull(either, &quot;either must not be null&quot;);</span>
<span class="fc" id="L220">    return new EitherPath&lt;&gt;(either);</span>
  }

  // ===== TryPath factory methods =====

  /**
   * Creates a TryPath by executing the given supplier.
   *
   * &lt;p&gt;If the supplier completes normally, returns a success TryPath. If the supplier throws, the
   * exception is captured in a failure TryPath.
   *
   * @param supplier the computation to execute; must not be null
   * @param &lt;A&gt; the type of the result
   * @return a TryPath containing the result or exception
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; TryPath&lt;A&gt; tryOf(Supplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L237">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L238">    return new TryPath&lt;&gt;(Try.of(supplier));</span>
  }

  /**
   * Creates a successful TryPath containing the given value.
   *
   * @param value the success value
   * @param &lt;A&gt; the type of the value
   * @return a success TryPath
   */
  public static &lt;A&gt; TryPath&lt;A&gt; success(@Nullable A value) {
<span class="fc" id="L249">    return new TryPath&lt;&gt;(Try.success(value));</span>
  }

  /**
   * Creates a failure TryPath containing the given exception.
   *
   * @param exception the exception; must not be null
   * @param &lt;A&gt; the phantom type of the success value
   * @return a failure TryPath
   * @throws NullPointerException if exception is null
   */
  public static &lt;A&gt; TryPath&lt;A&gt; failure(Throwable exception) {
<span class="fc" id="L261">    Objects.requireNonNull(exception, &quot;exception must not be null&quot;);</span>
<span class="fc" id="L262">    return new TryPath&lt;&gt;(Try.failure(exception));</span>
  }

  /**
   * Creates a TryPath from an existing Try.
   *
   * @param tryValue the Try to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return a TryPath wrapping the Try
   * @throws NullPointerException if tryValue is null
   */
  public static &lt;A&gt; TryPath&lt;A&gt; tryPath(Try&lt;A&gt; tryValue) {
<span class="fc" id="L274">    Objects.requireNonNull(tryValue, &quot;tryValue must not be null&quot;);</span>
<span class="fc" id="L275">    return new TryPath&lt;&gt;(tryValue);</span>
  }

  // ===== IOPath factory methods =====

  /**
   * Creates an IOPath with a deferred computation.
   *
   * &lt;p&gt;The supplier is not executed until {@link IOPath#unsafeRun()} or {@link IOPath#runSafe()} is
   * called.
   *
   * @param supplier the computation to defer; must not be null
   * @param &lt;A&gt; the type of the result
   * @return an IOPath representing the deferred computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; IOPath&lt;A&gt; io(Supplier&lt;A&gt; supplier) {
<span class="fc" id="L292">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L293">    return new IOPath&lt;&gt;(IO.delay(supplier));</span>
  }

  /**
   * Creates an IOPath that executes a side-effecting runnable.
   *
   * &lt;p&gt;The runnable is not executed until {@link IOPath#unsafeRun()} or {@link IOPath#runSafe()} is
   * called.
   *
   * @param runnable the side effect to defer; must not be null
   * @return an IOPath that produces Unit when run
   * @throws NullPointerException if runnable is null
   */
  public static IOPath&lt;Unit&gt; ioRunnable(Runnable runnable) {
<span class="fc" id="L307">    Objects.requireNonNull(runnable, &quot;runnable must not be null&quot;);</span>
<span class="fc" id="L308">    return new IOPath&lt;&gt;(IO.fromRunnable(runnable));</span>
  }

  /**
   * Creates an IOPath containing a pure value.
   *
   * &lt;p&gt;The value is already computed; no side effects occur when this IOPath is run.
   *
   * @param value the value to wrap
   * @param &lt;A&gt; the type of the value
   * @return an IOPath that immediately produces the value when run
   */
  public static &lt;A&gt; IOPath&lt;A&gt; ioPure(A value) {
<span class="fc" id="L321">    return new IOPath&lt;&gt;(IO.delay(() -&gt; value));</span>
  }

  /**
   * Creates an IOPath from an existing IO.
   *
   * @param io the IO to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return an IOPath wrapping the IO
   * @throws NullPointerException if io is null
   */
  public static &lt;A&gt; IOPath&lt;A&gt; ioPath(IO&lt;A&gt; io) {
<span class="fc" id="L333">    Objects.requireNonNull(io, &quot;io must not be null&quot;);</span>
<span class="fc" id="L334">    return new IOPath&lt;&gt;(io);</span>
  }

  // ===== ValidationPath factory methods =====

  /**
   * Creates a valid ValidationPath containing the given value.
   *
   * @param value the success value
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the value type
   * @return a valid ValidationPath
   * @throws NullPointerException if semigroup is null
   */
  public static &lt;E, A&gt; ValidationPath&lt;E, A&gt; valid(A value, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L350">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>
<span class="fc" id="L351">    return new ValidationPath&lt;&gt;(Validated.valid(value), semigroup);</span>
  }

  /**
   * Creates an invalid ValidationPath containing the given error.
   *
   * @param error the error value; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the phantom type of the success value
   * @return an invalid ValidationPath
   * @throws NullPointerException if error or semigroup is null
   */
  public static &lt;E, A&gt; ValidationPath&lt;E, A&gt; invalid(E error, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L365">    Objects.requireNonNull(error, &quot;error must not be null&quot;);</span>
<span class="fc" id="L366">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>
<span class="fc" id="L367">    return new ValidationPath&lt;&gt;(Validated.invalid(error), semigroup);</span>
  }

  /**
   * Creates a ValidationPath from an existing Validated.
   *
   * @param validated the Validated to wrap; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the value type
   * @return a ValidationPath wrapping the Validated
   * @throws NullPointerException if validated or semigroup is null
   */
  public static &lt;E, A&gt; ValidationPath&lt;E, A&gt; validated(
      Validated&lt;E, A&gt; validated, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L382">    Objects.requireNonNull(validated, &quot;validated must not be null&quot;);</span>
<span class="fc" id="L383">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>
<span class="fc" id="L384">    return new ValidationPath&lt;&gt;(validated, semigroup);</span>
  }

  // ===== IdPath factory methods =====

  /**
   * Creates an IdPath containing the given value.
   *
   * @param value the value to wrap
   * @param &lt;A&gt; the type of the value
   * @return an IdPath containing the value
   */
  public static &lt;A&gt; IdPath&lt;A&gt; id(@Nullable A value) {
<span class="fc" id="L397">    return new IdPath&lt;&gt;(Id.of(value));</span>
  }

  /**
   * Creates an IdPath from an existing Id.
   *
   * @param id the Id to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return an IdPath wrapping the Id
   * @throws NullPointerException if id is null
   */
  public static &lt;A&gt; IdPath&lt;A&gt; idPath(Id&lt;A&gt; id) {
<span class="fc" id="L409">    Objects.requireNonNull(id, &quot;id must not be null&quot;);</span>
<span class="fc" id="L410">    return new IdPath&lt;&gt;(id);</span>
  }

  // ===== OptionalPath factory methods =====

  /**
   * Creates an OptionalPath from a java.util.Optional.
   *
   * @param optional the Optional to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return an OptionalPath wrapping the Optional
   * @throws NullPointerException if optional is null
   */
  public static &lt;A&gt; OptionalPath&lt;A&gt; optional(Optional&lt;A&gt; optional) {
<span class="fc" id="L424">    Objects.requireNonNull(optional, &quot;optional must not be null&quot;);</span>
<span class="fc" id="L425">    return new OptionalPath&lt;&gt;(optional);</span>
  }

  /**
   * Creates an OptionalPath containing the given non-null value.
   *
   * @param value the value to wrap; must not be null
   * @param &lt;A&gt; the type of the value
   * @return an OptionalPath containing the value
   * @throws NullPointerException if value is null
   */
  public static &lt;A&gt; OptionalPath&lt;A&gt; present(A value) {
<span class="fc" id="L437">    Objects.requireNonNull(value, &quot;value must not be null&quot;);</span>
<span class="fc" id="L438">    return new OptionalPath&lt;&gt;(Optional.of(value));</span>
  }

  /**
   * Creates an empty OptionalPath.
   *
   * @param &lt;A&gt; the phantom type of the absent value
   * @return an empty OptionalPath
   */
  public static &lt;A&gt; OptionalPath&lt;A&gt; absent() {
<span class="fc" id="L448">    return new OptionalPath&lt;&gt;(Optional.empty());</span>
  }

  // ===== GenericPath factory methods =====

  /**
   * Creates a GenericPath from a Kind and Monad instance.
   *
   * &lt;p&gt;This is the escape hatch for using custom monads in Path composition.
   *
   * @param value the Kind to wrap; must not be null
   * @param monad the Monad instance; must not be null
   * @param &lt;F&gt; the witness type
   * @param &lt;A&gt; the value type
   * @return a GenericPath wrapping the Kind
   * @throws NullPointerException if value or monad is null
   */
  public static &lt;F, A&gt; GenericPath&lt;F, A&gt; generic(Kind&lt;F, A&gt; value, Monad&lt;F&gt; monad) {
<span class="fc" id="L466">    return GenericPath.of(value, monad);</span>
  }

  /**
   * Creates a GenericPath by lifting a pure value using the Monad's {@code of} method.
   *
   * @param value the value to lift
   * @param monad the Monad instance; must not be null
   * @param &lt;F&gt; the witness type
   * @param &lt;A&gt; the value type
   * @return a GenericPath containing the lifted value
   * @throws NullPointerException if monad is null
   */
  public static &lt;F, A&gt; GenericPath&lt;F, A&gt; genericPure(A value, Monad&lt;F&gt; monad) {
<span class="fc" id="L480">    return GenericPath.pure(value, monad);</span>
  }

  // ===== ReaderPath factory methods =====

  /**
   * Creates a ReaderPath from an existing Reader.
   *
   * @param reader the Reader to wrap; must not be null
   * @param &lt;R&gt; the environment type
   * @param &lt;A&gt; the value type
   * @return a ReaderPath wrapping the Reader
   * @throws NullPointerException if reader is null
   */
  public static &lt;R, A&gt; ReaderPath&lt;R, A&gt; reader(Reader&lt;R, A&gt; reader) {
<span class="fc" id="L495">    Objects.requireNonNull(reader, &quot;reader must not be null&quot;);</span>
<span class="fc" id="L496">    return new ReaderPath&lt;&gt;(reader);</span>
  }

  /**
   * Creates a ReaderPath that returns a pure value, ignoring the environment.
   *
   * @param value the value to return
   * @param &lt;R&gt; the environment type (phantom)
   * @param &lt;A&gt; the value type
   * @return a ReaderPath that always returns the given value
   */
  public static &lt;R, A&gt; ReaderPath&lt;R, A&gt; readerPure(A value) {
<span class="fc" id="L508">    return ReaderPath.pure(value);</span>
  }

  /**
   * Creates a ReaderPath that returns the entire environment.
   *
   * @param &lt;R&gt; the environment type
   * @return a ReaderPath that returns the environment
   */
  public static &lt;R&gt; ReaderPath&lt;R, R&gt; ask() {
<span class="fc" id="L518">    return ReaderPath.ask();</span>
  }

  /**
   * Creates a ReaderPath that extracts a value from the environment.
   *
   * @param f the function to extract from the environment; must not be null
   * @param &lt;R&gt; the environment type
   * @param &lt;A&gt; the extracted value type
   * @return a ReaderPath that extracts from the environment
   * @throws NullPointerException if f is null
   */
  public static &lt;R, A&gt; ReaderPath&lt;R, A&gt; asks(Function&lt;? super R, ? extends A&gt; f) {
<span class="fc" id="L531">    return ReaderPath.asks(f);</span>
  }

  // ===== WithStatePath factory methods =====

  /**
   * Creates a WithStatePath from an existing State.
   *
   * @param state the State to wrap; must not be null
   * @param &lt;S&gt; the state type
   * @param &lt;A&gt; the value type
   * @return a WithStatePath wrapping the State
   * @throws NullPointerException if state is null
   */
  public static &lt;S, A&gt; WithStatePath&lt;S, A&gt; state(State&lt;S, A&gt; state) {
<span class="fc" id="L546">    Objects.requireNonNull(state, &quot;state must not be null&quot;);</span>
<span class="fc" id="L547">    return new WithStatePath&lt;&gt;(state);</span>
  }

  /**
   * Creates a WithStatePath that returns a pure value without modifying state.
   *
   * @param value the value to return
   * @param &lt;S&gt; the state type
   * @param &lt;A&gt; the value type
   * @return a WithStatePath that always returns the given value
   */
  public static &lt;S, A&gt; WithStatePath&lt;S, A&gt; statePure(A value) {
<span class="fc" id="L559">    return WithStatePath.pure(value);</span>
  }

  /**
   * Creates a WithStatePath that returns the current state.
   *
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that returns the state
   */
  public static &lt;S&gt; WithStatePath&lt;S, S&gt; getState() {
<span class="fc" id="L569">    return WithStatePath.get();</span>
  }

  /**
   * Creates a WithStatePath that sets the state.
   *
   * @param newState the new state; must not be null
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that sets the state and returns Unit
   * @throws NullPointerException if newState is null
   */
  public static &lt;S&gt; WithStatePath&lt;S, Unit&gt; setState(S newState) {
<span class="fc" id="L581">    return WithStatePath.set(newState);</span>
  }

  /**
   * Creates a WithStatePath that modifies the state.
   *
   * @param f the function to modify state; must not be null
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that modifies state and returns Unit
   * @throws NullPointerException if f is null
   */
  public static &lt;S&gt; WithStatePath&lt;S, Unit&gt; modifyState(UnaryOperator&lt;S&gt; f) {
<span class="fc" id="L593">    return WithStatePath.modify(f);</span>
  }

  // ===== WriterPath factory methods =====

  /**
   * Creates a WriterPath from an existing Writer.
   *
   * @param writer the Writer to wrap; must not be null
   * @param monoid the Monoid for log accumulation; must not be null
   * @param &lt;W&gt; the log type
   * @param &lt;A&gt; the value type
   * @return a WriterPath wrapping the Writer
   * @throws NullPointerException if writer or monoid is null
   */
  public static &lt;W, A&gt; WriterPath&lt;W, A&gt; writer(Writer&lt;W, A&gt; writer, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L609">    Objects.requireNonNull(writer, &quot;writer must not be null&quot;);</span>
<span class="fc" id="L610">    Objects.requireNonNull(monoid, &quot;monoid must not be null&quot;);</span>
<span class="fc" id="L611">    return new WriterPath&lt;&gt;(writer, monoid);</span>
  }

  /**
   * Creates a WriterPath with a pure value and empty log.
   *
   * @param value the value to return
   * @param monoid the Monoid for log accumulation; must not be null
   * @param &lt;W&gt; the log type
   * @param &lt;A&gt; the value type
   * @return a WriterPath with empty log
   * @throws NullPointerException if monoid is null
   */
  public static &lt;W, A&gt; WriterPath&lt;W, A&gt; writerPure(A value, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L625">    return WriterPath.pure(value, monoid);</span>
  }

  /**
   * Creates a WriterPath that only produces log output.
   *
   * @param log the log to produce; must not be null
   * @param monoid the Monoid for log accumulation; must not be null
   * @param &lt;W&gt; the log type
   * @return a WriterPath that produces log and returns Unit
   * @throws NullPointerException if log or monoid is null
   */
  public static &lt;W&gt; WriterPath&lt;W, Unit&gt; tell(W log, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L638">    return WriterPath.tell(log, monoid);</span>
  }

  // ===== LazyPath factory methods =====

  /**
   * Creates a LazyPath from an existing Lazy.
   *
   * @param lazy the Lazy to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a LazyPath wrapping the Lazy
   * @throws NullPointerException if lazy is null
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; lazy(Lazy&lt;A&gt; lazy) {
<span class="fc" id="L652">    Objects.requireNonNull(lazy, &quot;lazy must not be null&quot;);</span>
<span class="fc" id="L653">    return new LazyPath&lt;&gt;(lazy);</span>
  }

  /**
   * Creates an already-evaluated LazyPath.
   *
   * @param value the value
   * @param &lt;A&gt; the value type
   * @return a LazyPath holding the value
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; lazyNow(A value) {
<span class="fc" id="L664">    return LazyPath.now(value);</span>
  }

  /**
   * Creates a LazyPath that defers computation.
   *
   * @param supplier the computation to defer; must not be null
   * @param &lt;A&gt; the value type
   * @return a LazyPath that defers computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; LazyPath&lt;A&gt; lazyDefer(Supplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L676">    return LazyPath.defer(supplier);</span>
  }

  // ===== CompletableFuturePath factory methods =====

  /**
   * Creates a CompletableFuturePath from an existing CompletableFuture.
   *
   * @param future the CompletableFuture to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a CompletableFuturePath wrapping the future
   * @throws NullPointerException if future is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; future(CompletableFuture&lt;A&gt; future) {
<span class="fc" id="L690">    return CompletableFuturePath.fromFuture(future);</span>
  }

  /**
   * Creates an already-completed CompletableFuturePath.
   *
   * @param value the completed value
   * @param &lt;A&gt; the value type
   * @return a completed CompletableFuturePath
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; futureCompleted(A value) {
<span class="fc" id="L701">    return CompletableFuturePath.completed(value);</span>
  }

  /**
   * Creates a failed CompletableFuturePath.
   *
   * @param exception the exception; must not be null
   * @param &lt;A&gt; the value type
   * @return a failed CompletableFuturePath
   * @throws NullPointerException if exception is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; futureFailed(Exception exception) {
<span class="fc" id="L713">    return CompletableFuturePath.failed(exception);</span>
  }

  /**
   * Creates a CompletableFuturePath from an async computation.
   *
   * @param supplier the async computation; must not be null
   * @param &lt;A&gt; the value type
   * @return a CompletableFuturePath running asynchronously
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; futureAsync(Supplier&lt;A&gt; supplier) {
<span class="fc" id="L725">    return CompletableFuturePath.supplyAsync(supplier);</span>
  }

  // ===== NonDetPath factory methods =====

  /**
   * Creates a NonDetPath from an existing List.
   *
   * @param list the list to wrap; must not be null
   * @param &lt;A&gt; the element type
   * @return a NonDetPath wrapping the list
   * @throws NullPointerException if list is null
   */
  public static &lt;A&gt; NonDetPath&lt;A&gt; list(List&lt;A&gt; list) {
<span class="fc" id="L739">    return NonDetPath.of(list);</span>
  }

  /**
   * Creates a NonDetPath from varargs.
   *
   * @param elements the elements
   * @param &lt;A&gt; the element type
   * @return a NonDetPath containing the elements
   */
  @SafeVarargs
  public static &lt;A&gt; NonDetPath&lt;A&gt; list(A... elements) {
<span class="fc" id="L751">    return NonDetPath.of(elements);</span>
  }

  /**
   * Creates a NonDetPath with a single element.
   *
   * @param value the single element
   * @param &lt;A&gt; the element type
   * @return a NonDetPath containing one element
   */
  public static &lt;A&gt; NonDetPath&lt;A&gt; listPure(A value) {
<span class="fc" id="L762">    return NonDetPath.pure(value);</span>
  }

  /**
   * Creates an empty NonDetPath.
   *
   * @param &lt;A&gt; the element type
   * @return an empty NonDetPath
   */
  public static &lt;A&gt; NonDetPath&lt;A&gt; listEmpty() {
<span class="fc" id="L772">    return NonDetPath.empty();</span>
  }

  // ===== ListPath factory methods =====

  /**
   * Creates a ListPath from a List.
   *
   * &lt;p&gt;ListPath uses positional zipWith semantics (pairs corresponding elements), unlike NonDetPath
   * which uses Cartesian product semantics.
   *
   * @param list the list to wrap; must not be null
   * @param &lt;A&gt; the element type
   * @return a ListPath wrapping the list
   * @throws NullPointerException if list is null
   */
  public static &lt;A&gt; ListPath&lt;A&gt; listPath(List&lt;A&gt; list) {
<span class="fc" id="L789">    return ListPath.of(list);</span>
  }

  /**
   * Creates a ListPath from varargs.
   *
   * @param elements the elements
   * @param &lt;A&gt; the element type
   * @return a ListPath containing the elements
   */
  @SafeVarargs
  public static &lt;A&gt; ListPath&lt;A&gt; listPath(A... elements) {
<span class="fc" id="L801">    return ListPath.of(elements);</span>
  }

  /**
   * Creates a ListPath with a single element.
   *
   * @param value the single element
   * @param &lt;A&gt; the element type
   * @return a ListPath containing one element
   */
  public static &lt;A&gt; ListPath&lt;A&gt; listPathPure(A value) {
<span class="fc" id="L812">    return ListPath.pure(value);</span>
  }

  /**
   * Creates an empty ListPath.
   *
   * @param &lt;A&gt; the element type
   * @return an empty ListPath
   */
  public static &lt;A&gt; ListPath&lt;A&gt; listPathEmpty() {
<span class="fc" id="L822">    return ListPath.empty();</span>
  }

  /**
   * Creates a ListPath from a range of integers.
   *
   * @param startInclusive the start value (inclusive)
   * @param endExclusive the end value (exclusive)
   * @return a ListPath containing integers in the range
   */
  public static ListPath&lt;Integer&gt; listPathRange(int startInclusive, int endExclusive) {
<span class="fc" id="L833">    return ListPath.range(startInclusive, endExclusive);</span>
  }

  // ===== StreamPath factory methods =====

  /**
   * Creates a StreamPath from an existing Stream.
   *
   * &lt;p&gt;Note: The stream is materialized for reusability.
   *
   * @param stream the stream to wrap; must not be null
   * @param &lt;A&gt; the element type
   * @return a StreamPath wrapping the stream
   * @throws NullPointerException if stream is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; stream(Stream&lt;A&gt; stream) {
<span class="fc" id="L849">    return StreamPath.of(stream);</span>
  }

  /**
   * Creates a StreamPath from a List.
   *
   * @param list the list to stream; must not be null
   * @param &lt;A&gt; the element type
   * @return a StreamPath streaming the list
   * @throws NullPointerException if list is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; streamFromList(List&lt;A&gt; list) {
<span class="fc" id="L861">    return StreamPath.fromList(list);</span>
  }

  /**
   * Creates a StreamPath with a single element.
   *
   * @param value the single element
   * @param &lt;A&gt; the element type
   * @return a StreamPath containing one element
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; streamPure(A value) {
<span class="fc" id="L872">    return StreamPath.pure(value);</span>
  }

  /**
   * Creates an empty StreamPath.
   *
   * @param &lt;A&gt; the element type
   * @return an empty StreamPath
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; streamEmpty() {
<span class="fc" id="L882">    return StreamPath.empty();</span>
  }

  /**
   * Creates an infinite StreamPath by iteration.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Use {@code take()} to limit infinite streams.
   *
   * @param seed the initial value
   * @param f the iteration function; must not be null
   * @param &lt;A&gt; the element type
   * @return an infinite StreamPath
   * @throws NullPointerException if f is null
   */
  public static &lt;A&gt; StreamPath&lt;A&gt; streamIterate(A seed, UnaryOperator&lt;A&gt; f) {
<span class="fc" id="L897">    return StreamPath.iterate(seed, f);</span>
  }

  // ===== PathRegistry integration =====

  /**
   * Creates a Path from any registered Kind type using the PathRegistry.
   *
   * &lt;p&gt;This method looks up a {@link org.higherkindedj.hkt.effect.spi.PathProvider} for the given
   * witness type and uses it to create an appropriate Path wrapper.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // With a registered custom effect type
   * Kind&lt;ApiResultKind.Witness, User&gt; kind = apiService.getUser(id);
   * Optional&lt;Chainable&lt;User&gt;&gt; path = Path.from(kind, ApiResultKind.Witness.class);
   * }&lt;/pre&gt;
   *
   * @param kind the Kind value to wrap; must not be null
   * @param witnessType the witness type class
   * @param &lt;F&gt; the witness type
   * @param &lt;A&gt; the value type
   * @return an Optional containing the path if a provider is registered
   * @throws NullPointerException if kind or witnessType is null
   * @see org.higherkindedj.hkt.effect.spi.PathRegistry
   * @see org.higherkindedj.hkt.effect.spi.PathProvider
   */
  public static &lt;F, A&gt; Optional&lt;Chainable&lt;A&gt;&gt; from(Kind&lt;F, A&gt; kind, Class&lt;?&gt; witnessType) {
<span class="fc" id="L926">    Objects.requireNonNull(kind, &quot;kind must not be null&quot;);</span>
<span class="fc" id="L927">    Objects.requireNonNull(witnessType, &quot;witnessType must not be null&quot;);</span>
<span class="fc" id="L928">    return PathRegistry.createPath(kind, witnessType);</span>
  }

  // ===== TrampolinePath factory methods =====

  /**
   * Creates a TrampolinePath with an immediate value.
   *
   * @param value the completed value
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath containing the value
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; trampolineDone(A value) {
<span class="fc" id="L941">    return TrampolinePath.done(value);</span>
  }

  /**
   * Creates a TrampolinePath with a deferred computation.
   *
   * &lt;p&gt;This is the key method for achieving stack safety. Instead of making a recursive call
   * directly, wrap the call in {@code trampolineDefer}.
   *
   * @param supplier supplies the next TrampolinePath step; must not be null
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath representing the deferred computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; trampolineDefer(Supplier&lt;TrampolinePath&lt;A&gt;&gt; supplier) {
<span class="fc" id="L956">    return TrampolinePath.defer(supplier);</span>
  }

  /**
   * Creates a TrampolinePath from an existing Trampoline.
   *
   * @param trampoline the Trampoline to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath wrapping the Trampoline
   * @throws NullPointerException if trampoline is null
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; trampoline(Trampoline&lt;A&gt; trampoline) {
<span class="fc" id="L968">    return TrampolinePath.of(trampoline);</span>
  }

  // ===== FreePath factory methods =====

  /**
   * Creates a FreePath containing a pure value.
   *
   * @param value the value to wrap
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreePath containing the value
   * @throws NullPointerException if functor is null
   */
  public static &lt;F, A&gt; FreePath&lt;F, A&gt; freePure(A value, Functor&lt;F&gt; functor) {
<span class="fc" id="L984">    return FreePath.pure(value, functor);</span>
  }

  /**
   * Lifts a functor value into FreePath.
   *
   * @param fa the functor value to lift; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the result type
   * @return a FreePath containing the lifted instruction
   * @throws NullPointerException if fa or functor is null
   */
  public static &lt;F, A&gt; FreePath&lt;F, A&gt; freeLift(Kind&lt;F, A&gt; fa, Functor&lt;F&gt; functor) {
<span class="fc" id="L998">    return FreePath.liftF(fa, functor);</span>
  }

  /**
   * Creates a FreePath from an existing Free monad.
   *
   * @param free the Free monad to wrap; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreePath wrapping the Free monad
   * @throws NullPointerException if free or functor is null
   */
  public static &lt;F, A&gt; FreePath&lt;F, A&gt; free(Free&lt;F, A&gt; free, Functor&lt;F&gt; functor) {
<span class="fc" id="L1012">    return FreePath.of(free, functor);</span>
  }

  // ===== FreeApPath factory methods =====

  /**
   * Creates a FreeApPath containing a pure value.
   *
   * @param value the value to wrap
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreeApPath containing the value
   * @throws NullPointerException if functor is null
   */
  public static &lt;F, A&gt; FreeApPath&lt;F, A&gt; freeApPure(A value, Functor&lt;F&gt; functor) {
<span class="fc" id="L1028">    return FreeApPath.pure(value, functor);</span>
  }

  /**
   * Lifts a functor value into FreeApPath.
   *
   * @param fa the functor value to lift; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the result type
   * @return a FreeApPath containing the lifted instruction
   * @throws NullPointerException if fa or functor is null
   */
  public static &lt;F, A&gt; FreeApPath&lt;F, A&gt; freeApLift(Kind&lt;F, A&gt; fa, Functor&lt;F&gt; functor) {
<span class="fc" id="L1042">    return FreeApPath.liftF(fa, functor);</span>
  }

  /**
   * Creates a FreeApPath from an existing FreeAp.
   *
   * @param freeAp the FreeAp to wrap; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreeApPath wrapping the FreeAp
   * @throws NullPointerException if freeAp or functor is null
   */
  public static &lt;F, A&gt; FreeApPath&lt;F, A&gt; freeAp(FreeAp&lt;F, A&gt; freeAp, Functor&lt;F&gt; functor) {
<span class="fc" id="L1056">    return FreeApPath.of(freeAp, functor);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>