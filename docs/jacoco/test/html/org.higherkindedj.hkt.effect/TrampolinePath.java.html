<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrampolinePath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">TrampolinePath.java</span></div><h1>TrampolinePath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.trampoline.Trampoline;

/**
 * A fluent path wrapper for {@link Trampoline} computations.
 *
 * &lt;p&gt;{@code TrampolinePath} represents stack-safe recursive computations that are trampolined to
 * avoid stack overflow. This is essential for deeply recursive algorithms or processing deeply
 * nested data structures.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Deeply recursive algorithms (factorial, fibonacci)
 *   &lt;li&gt;Processing deeply nested trees
 *   &lt;li&gt;Mutual recursion without stack overflow
 *   &lt;li&gt;Interpreter/evaluator implementations
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Stack-safe factorial
 * TrampolinePath&lt;BigInteger&gt; factorial(BigInteger n, BigInteger acc) {
 *     if (n.compareTo(BigInteger.ONE) &lt;= 0) {
 *         return TrampolinePath.done(acc);
 *     }
 *     return TrampolinePath.defer(() -&gt;
 *         factorial(n.subtract(BigInteger.ONE), n.multiply(acc)));
 * }
 *
 * BigInteger result = factorial(BigInteger.valueOf(100000), BigInteger.ONE).run();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the result type
 */
public final class TrampolinePath&lt;A&gt; implements Chainable&lt;A&gt; {

  private final Trampoline&lt;A&gt; trampoline;

<span class="fc" id="L52">  private TrampolinePath(Trampoline&lt;A&gt; trampoline) {</span>
<span class="fc" id="L53">    this.trampoline = Objects.requireNonNull(trampoline, &quot;trampoline must not be null&quot;);</span>
<span class="fc" id="L54">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a TrampolinePath with an immediate value.
   *
   * @param value the completed value
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath containing the value
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; done(A value) {
<span class="fc" id="L66">    return new TrampolinePath&lt;&gt;(Trampoline.done(value));</span>
  }

  /**
   * Creates a TrampolinePath with a deferred computation.
   *
   * &lt;p&gt;This is the key method for achieving stack safety. Instead of making a recursive call
   * directly, wrap the call in {@code defer}.
   *
   * @param supplier supplies the next TrampolinePath step; must not be null
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath representing the deferred computation
   * @throws NullPointerException if supplier is null
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; defer(Supplier&lt;TrampolinePath&lt;A&gt;&gt; supplier) {
<span class="fc" id="L81">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L82">    return new TrampolinePath&lt;&gt;(Trampoline.defer(() -&gt; supplier.get().trampoline));</span>
  }

  /**
   * Creates a TrampolinePath from an existing Trampoline.
   *
   * @param trampoline the Trampoline to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath wrapping the Trampoline
   * @throws NullPointerException if trampoline is null
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; of(Trampoline&lt;A&gt; trampoline) {
<span class="fc" id="L94">    return new TrampolinePath&lt;&gt;(trampoline);</span>
  }

  /**
   * Creates a pure TrampolinePath containing the given value.
   *
   * &lt;p&gt;Alias for {@link #done(Object)} for consistency with other path types.
   *
   * @param value the value
   * @param &lt;A&gt; the value type
   * @return a TrampolinePath containing the value
   */
  public static &lt;A&gt; TrampolinePath&lt;A&gt; pure(A value) {
<span class="fc" id="L107">    return done(value);</span>
  }

  // ===== Terminal Operations =====

  /**
   * Runs the trampolined computation to completion.
   *
   * &lt;p&gt;This is stack-safe regardless of recursion depth.
   *
   * @return the computed value
   */
  public A run() {
<span class="fc" id="L120">    return trampoline.run();</span>
  }

  /**
   * Returns the underlying Trampoline.
   *
   * @return the wrapped Trampoline
   */
  public Trampoline&lt;A&gt; toTrampoline() {
<span class="fc" id="L129">    return trampoline;</span>
  }

  // ===== Composable Implementation =====

  @Override
  public &lt;B&gt; TrampolinePath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L136">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L137">    return new TrampolinePath&lt;&gt;(trampoline.map(mapper));</span>
  }

  @Override
  public TrampolinePath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L142">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L143">    return map(</span>
        a -&gt; {
<span class="fc" id="L145">          consumer.accept(a);</span>
<span class="fc" id="L146">          return a;</span>
        });
  }

  // ===== Combinable Implementation =====

  /**
   * Combines this TrampolinePath with another using a combining function.
   *
   * @param other the other Combinable; must be a TrampolinePath
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the other value
   * @param &lt;C&gt; the type of the combined result
   * @return a TrampolinePath containing the combined result
   * @throws NullPointerException if other or combiner is null
   * @throws IllegalArgumentException if other is not a TrampolinePath
   */
  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;B, C&gt; TrampolinePath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L167">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L168">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">    if (!(other instanceof TrampolinePath&lt;?&gt; otherTrampoline)) {</span>
<span class="fc" id="L171">      throw new IllegalArgumentException(&quot;Cannot zipWith non-TrampolinePath: &quot; + other.getClass());</span>
    }

<span class="fc" id="L174">    TrampolinePath&lt;B&gt; typedOther = (TrampolinePath&lt;B&gt;) otherTrampoline;</span>
<span class="fc" id="L175">    return via(a -&gt; typedOther.map(b -&gt; combiner.apply(a, b)));</span>
  }

  // ===== Chainable Implementation =====

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;B&gt; TrampolinePath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L183">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L184">    Trampoline&lt;B&gt; flatMapped =</span>
<span class="fc" id="L185">        trampoline.flatMap(</span>
            a -&gt; {
<span class="fc" id="L187">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L188">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">              if (!(result instanceof TrampolinePath&lt;?&gt; tp)) {</span>
<span class="fc" id="L191">                throw new IllegalArgumentException(</span>
<span class="fc" id="L192">                    &quot;TrampolinePath.via must return TrampolinePath. Got: &quot; + result.getClass());</span>
              }
<span class="fc" id="L194">              return ((TrampolinePath&lt;B&gt;) tp).trampoline;</span>
            });
<span class="fc" id="L196">    return new TrampolinePath&lt;&gt;(flatMapped);</span>
  }

  @Override
  public &lt;B&gt; TrampolinePath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L201">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L202">    return via(_ -&gt; supplier.get());</span>
  }

  // ===== Conversions =====

  /**
   * Converts to IOPath by running the trampoline.
   *
   * &lt;p&gt;The IOPath will execute the trampoline when run.
   *
   * @return an IOPath that runs this trampoline
   */
  public IOPath&lt;A&gt; toIOPath() {
<span class="fc" id="L215">    return new IOPath&lt;&gt;(IO.delay(this::run));</span>
  }

  /**
   * Converts to LazyPath.
   *
   * &lt;p&gt;The LazyPath will execute the trampoline when evaluated.
   *
   * @return a LazyPath that runs this trampoline
   */
  public LazyPath&lt;A&gt; toLazyPath() {
<span class="fc" id="L226">    return LazyPath.defer(this::run);</span>
  }

  // ===== Object Methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">    if (!(obj instanceof TrampolinePath&lt;?&gt; other)) return false;</span>
<span class="fc" id="L235">    return trampoline.equals(other.trampoline);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L240">    return trampoline.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L245">    return &quot;TrampolinePath(...)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>