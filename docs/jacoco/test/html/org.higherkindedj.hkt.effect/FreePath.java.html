<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FreePath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">FreePath.java</span></div><h1>FreePath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.Natural;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.free.Free;

/**
 * A fluent path wrapper for {@link Free} monad computations.
 *
 * &lt;p&gt;{@code FreePath} represents computations built from a functor {@code F} that can be
 * interpreted into any monad. This is the foundation for building domain-specific languages (DSLs)
 * with deferred interpretation.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Building embedded DSLs
 *   &lt;li&gt;Separating program description from execution
 *   &lt;li&gt;Testing with mock interpreters
 *   &lt;li&gt;Multiple interpretation strategies
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Define a simple Console DSL
 * sealed interface ConsoleF&lt;A&gt; {
 *     record PrintLine&lt;A&gt;(String line, A next) implements ConsoleF&lt;A&gt; {}
 *     record ReadLine&lt;A&gt;(Function&lt;String, A&gt; cont) implements ConsoleF&lt;A&gt; {}
 * }
 *
 * // Build a program
 * FreePath&lt;ConsoleF.Witness, String&gt; program =
 *     FreePath.liftF(new PrintLine&lt;&gt;(&quot;Enter name:&quot;, ()), consoleFunctor)
 *         .then(() -&gt; FreePath.liftF(new ReadLine&lt;&gt;(name -&gt; name), consoleFunctor))
 *         .via(name -&gt; FreePath.liftF(new PrintLine&lt;&gt;(&quot;Hello &quot; + name, name), consoleFunctor));
 *
 * // Interpret to IO using a natural transformation
 * GenericPath&lt;IO.Witness, String&gt; result = program.foldMap(consoleInterpreter, IOMonad.INSTANCE);
 * }&lt;/pre&gt;
 *
 * @param &lt;F&gt; the functor witness type for the DSL
 * @param &lt;A&gt; the result type
 */
public final class FreePath&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; implements Chainable&lt;A&gt; {

  private final Free&lt;F, A&gt; free;
  private final Functor&lt;F&gt; functor;

<span class="fc" id="L63">  private FreePath(Free&lt;F, A&gt; free, Functor&lt;F&gt; functor) {</span>
<span class="fc" id="L64">    this.free = Objects.requireNonNull(free, &quot;free must not be null&quot;);</span>
<span class="fc" id="L65">    this.functor = Objects.requireNonNull(functor, &quot;functor must not be null&quot;);</span>
<span class="fc" id="L66">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a FreePath containing a pure value.
   *
   * @param value the value to wrap
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreePath containing the value
   * @throws NullPointerException if functor is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FreePath&lt;F, A&gt; pure(
      A value, Functor&lt;F&gt; functor) {
<span class="fc" id="L82">    Objects.requireNonNull(functor, &quot;functor must not be null&quot;);</span>
<span class="fc" id="L83">    return new FreePath&lt;&gt;(Free.pure(value), functor);</span>
  }

  /**
   * Lifts a functor value into FreePath.
   *
   * &lt;p&gt;This is the primary way to create DSL instructions. The functor value represents a single
   * operation in your DSL.
   *
   * @param fa the functor value to lift; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the result type
   * @return a FreePath containing the lifted instruction
   * @throws NullPointerException if fa or functor is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FreePath&lt;F, A&gt; liftF(
      Kind&lt;F, A&gt; fa, Functor&lt;F&gt; functor) {
<span class="fc" id="L101">    Objects.requireNonNull(fa, &quot;fa must not be null&quot;);</span>
<span class="fc" id="L102">    Objects.requireNonNull(functor, &quot;functor must not be null&quot;);</span>
<span class="fc" id="L103">    return new FreePath&lt;&gt;(Free.liftF(fa, functor), functor);</span>
  }

  /**
   * Creates a FreePath from an existing Free monad.
   *
   * @param free the Free monad to wrap; must not be null
   * @param functor the Functor instance for F; must not be null
   * @param &lt;F&gt; the functor witness type
   * @param &lt;A&gt; the value type
   * @return a FreePath wrapping the Free monad
   * @throws NullPointerException if free or functor is null
   */
  public static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; FreePath&lt;F, A&gt; of(
      Free&lt;F, A&gt; free, Functor&lt;F&gt; functor) {
<span class="fc" id="L118">    return new FreePath&lt;&gt;(free, functor);</span>
  }

  // ===== Interpretation =====

  /**
   * Interprets this FreePath into a target monad using a natural transformation.
   *
   * &lt;p&gt;The natural transformation converts each instruction in F to the target monad G. This is
   * stack-safe and uses trampolining internally.
   *
   * @param interpreter natural transformation from F to G; must not be null
   * @param targetMonad the target monad instance; must not be null
   * @param &lt;G&gt; the target monad witness type
   * @return a GenericPath containing the interpreted result
   * @throws NullPointerException if interpreter or targetMonad is null
   */
  public &lt;G extends WitnessArity&lt;TypeArity.Unary&gt;&gt; GenericPath&lt;G, A&gt; foldMap(
      Natural&lt;F, G&gt; interpreter, Monad&lt;G&gt; targetMonad) {
<span class="fc" id="L137">    Objects.requireNonNull(interpreter, &quot;interpreter must not be null&quot;);</span>
<span class="fc" id="L138">    Objects.requireNonNull(targetMonad, &quot;targetMonad must not be null&quot;);</span>
<span class="fc" id="L139">    Kind&lt;G, A&gt; result = free.foldMap(interpreter, targetMonad);</span>
<span class="fc" id="L140">    return GenericPath.of(result, targetMonad);</span>
  }

  /**
   * Interprets this FreePath using the effect package's NaturalTransformation.
   *
   * &lt;p&gt;This method adapts the effect package's NaturalTransformation to work with Free's foldMap.
   *
   * @param interpreter natural transformation from F to G; must not be null
   * @param targetMonad the target monad instance; must not be null
   * @param &lt;G&gt; the target monad witness type
   * @return a GenericPath containing the interpreted result
   * @throws NullPointerException if interpreter or targetMonad is null
   */
  public &lt;G extends WitnessArity&lt;TypeArity.Unary&gt;&gt; GenericPath&lt;G, A&gt; foldMapWith(
      NaturalTransformation&lt;F, G&gt; interpreter, Monad&lt;G&gt; targetMonad) {
<span class="fc" id="L156">    Objects.requireNonNull(interpreter, &quot;interpreter must not be null&quot;);</span>
<span class="fc" id="L157">    Objects.requireNonNull(targetMonad, &quot;targetMonad must not be null&quot;);</span>

    // Adapt NaturalTransformation to Natural
<span class="fc" id="L160">    Natural&lt;F, G&gt; adapted = interpreter::apply;</span>
<span class="fc" id="L161">    Kind&lt;G, A&gt; result = free.foldMap(adapted, targetMonad);</span>
<span class="fc" id="L162">    return GenericPath.of(result, targetMonad);</span>
  }

  /**
   * Returns the underlying Free monad.
   *
   * @return the wrapped Free monad
   */
  public Free&lt;F, A&gt; toFree() {
<span class="fc" id="L171">    return free;</span>
  }

  /**
   * Returns the Functor instance for this FreePath.
   *
   * @return the Functor instance
   */
  public Functor&lt;F&gt; functor() {
<span class="fc" id="L180">    return functor;</span>
  }

  // ===== Composable Implementation =====

  @Override
  public &lt;B&gt; FreePath&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L187">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L188">    return new FreePath&lt;&gt;(free.map(mapper), functor);</span>
  }

  @Override
  public FreePath&lt;F, A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L193">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L194">    return map(</span>
        a -&gt; {
<span class="fc" id="L196">          consumer.accept(a);</span>
<span class="fc" id="L197">          return a;</span>
        });
  }

  // ===== Combinable Implementation =====

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;B, C&gt; FreePath&lt;F, C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L207">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L208">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (!(other instanceof FreePath&lt;?, ?&gt; otherFree)) {</span>
<span class="fc" id="L211">      throw new IllegalArgumentException(&quot;Cannot zipWith non-FreePath: &quot; + other.getClass());</span>
    }

<span class="fc" id="L214">    FreePath&lt;F, B&gt; typedOther = (FreePath&lt;F, B&gt;) otherFree;</span>
<span class="fc" id="L215">    return via(a -&gt; typedOther.map(b -&gt; combiner.apply(a, b)));</span>
  }

  // ===== Chainable Implementation =====

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;B&gt; FreePath&lt;F, B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L223">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L224">    Free&lt;F, B&gt; flatMapped =</span>
<span class="fc" id="L225">        free.flatMap(</span>
            a -&gt; {
<span class="fc" id="L227">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L228">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">              if (!(result instanceof FreePath&lt;?, ?&gt; fp)) {</span>
<span class="fc" id="L231">                throw new IllegalArgumentException(</span>
<span class="fc" id="L232">                    &quot;FreePath.via must return FreePath. Got: &quot; + result.getClass());</span>
              }
<span class="fc" id="L234">              return ((FreePath&lt;F, B&gt;) fp).free;</span>
            });
<span class="fc" id="L236">    return new FreePath&lt;&gt;(flatMapped, functor);</span>
  }

  @Override
  public &lt;B&gt; FreePath&lt;F, B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L241">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L242">    return via(_ -&gt; supplier.get());</span>
  }

  // ===== Object Methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (!(obj instanceof FreePath&lt;?, ?&gt; other)) return false;</span>
<span class="fc" id="L251">    return free.equals(other.free);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L256">    return free.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L261">    return &quot;FreePath(&quot; + free + &quot;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>