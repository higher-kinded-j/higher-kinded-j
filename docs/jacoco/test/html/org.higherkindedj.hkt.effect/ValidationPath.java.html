<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValidationPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">ValidationPath.java</span></div><h1>ValidationPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.annotation.Generated;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.effect.capability.Accumulating;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.effect.capability.Recoverable;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Invalid;
import org.higherkindedj.hkt.validated.Valid;
import org.higherkindedj.hkt.validated.Validated;

/**
 * A fluent path wrapper for {@link Validated} values with error accumulation support.
 *
 * &lt;p&gt;{@code ValidationPath} provides a chainable API for composing validation operations. It
 * uniquely implements both {@link Chainable} (for sequential operations that short-circuit) and
 * {@link Accumulating} (for parallel validations that accumulate errors).
 *
 * &lt;h2&gt;Dual Nature: Short-Circuit vs Accumulating&lt;/h2&gt;
 *
 * &lt;p&gt;ValidationPath supports two modes of composition:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Short-circuit&lt;/b&gt; ({@link #via}, {@link #zipWith}): Stops at first error, like
 *       EitherPath
 *   &lt;li&gt;&lt;b&gt;Accumulating&lt;/b&gt; ({@link #zipWithAccum}, {@link #andAlso}): Collects all errors using
 *       Semigroup
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating ValidationPath instances&lt;/h2&gt;
 *
 * &lt;p&gt;Use the {@link Path} factory class to create instances:
 *
 * &lt;pre&gt;{@code
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; valid = Path.valid(user, Semigroups.list());
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; invalid = Path.invalid(List.of(error), Semigroups.list());
 * ValidationPath&lt;List&lt;Error&gt;, User&gt; fromValidated = Path.validated(validated, Semigroups.list());
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Short-circuit composition (via)&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * ValidationPath&lt;List&lt;Error&gt;, Order&gt; result = Path.valid(userId, Semigroups.list())
 *     .via(id -&gt; userService.findById(id))   // Stops if user not found
 *     .via(user -&gt; createOrder(user));       // Only runs if user found
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Accumulating composition (zipWithAccum)&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * ValidationPath&lt;List&lt;Error&gt;, Registration&gt; result = validateName(input.name())
 *     .zipWithAccum(validateEmail(input.email()), (name, email) -&gt;
 *         new Registration(name, email));
 * // Collects errors from both validations
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Error handling&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * User user = Path.valid(userData, Semigroups.list())
 *     .via(data -&gt; validateUser(data))
 *     .recover(errors -&gt; User.guest())
 *     .run()
 *     .fold(e -&gt; null, u -&gt; u);
 * }&lt;/pre&gt;
 *
 * @param &lt;E&gt; the type of the error (typically a collection type like {@code List&lt;Error&gt;})
 * @param &lt;A&gt; the type of the success value
 */
public final class ValidationPath&lt;E, A&gt;
    implements Chainable&lt;A&gt;, Accumulating&lt;E, A&gt;, Recoverable&lt;E, A&gt; {

  private final Validated&lt;E, A&gt; value;
  private final Semigroup&lt;E&gt; semigroup;

  /**
   * Creates a new ValidationPath wrapping the given Validated with the specified Semigroup.
   *
   * @param value the Validated to wrap; must not be null
   * @param semigroup the Semigroup for combining errors; must not be null
   */
<span class="fc" id="L95">  ValidationPath(Validated&lt;E, A&gt; value, Semigroup&lt;E&gt; semigroup) {</span>
<span class="fc" id="L96">    this.value = Objects.requireNonNull(value, &quot;value must not be null&quot;);</span>
<span class="fc" id="L97">    this.semigroup = Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>
<span class="fc" id="L98">  }</span>

  /**
   * Returns the underlying Validated value.
   *
   * @return the wrapped Validated
   */
  public Validated&lt;E, A&gt; run() {
<span class="fc" id="L106">    return value;</span>
  }

  /**
   * Returns the Semigroup used for error accumulation.
   *
   * @return the semigroup
   */
  public Semigroup&lt;E&gt; semigroup() {
<span class="fc" id="L115">    return semigroup;</span>
  }

  /**
   * Returns the success value if valid, otherwise returns the provided default.
   *
   * @param defaultValue the value to return if this path is invalid
   * @return the success value or the default
   */
  public A getOrElse(A defaultValue) {
<span class="fc" id="L125">    return value.fold(_ -&gt; defaultValue, a -&gt; a);</span>
  }

  /**
   * Returns the success value if valid, otherwise invokes the supplier.
   *
   * @param supplier provides the default value; must not be null
   * @return the success value or the supplier's result
   * @throws NullPointerException if supplier is null
   */
  public A getOrElseGet(Supplier&lt;? extends A&gt; supplier) {
<span class="fc" id="L136">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L137">    return value.fold(_ -&gt; supplier.get(), a -&gt; a);</span>
  }

  /**
   * Folds both cases of this path into a single value.
   *
   * @param invalidMapper the function to apply if invalid; must not be null
   * @param validMapper the function to apply if valid; must not be null
   * @param &lt;B&gt; the result type
   * @return the result of applying the appropriate function
   * @throws NullPointerException if either mapper is null
   */
  public &lt;B&gt; B fold(
      Function&lt;? super E, ? extends B&gt; invalidMapper,
      Function&lt;? super A, ? extends B&gt; validMapper) {
<span class="fc" id="L152">    Objects.requireNonNull(invalidMapper, &quot;invalidMapper must not be null&quot;);</span>
<span class="fc" id="L153">    Objects.requireNonNull(validMapper, &quot;validMapper must not be null&quot;);</span>
<span class="fc" id="L154">    return value.fold(invalidMapper, validMapper);</span>
  }

  /**
   * Returns true if this path contains a valid value.
   *
   * @return true if valid, false if invalid
   */
  public boolean isValid() {
<span class="fc" id="L163">    return value.isValid();</span>
  }

  /**
   * Returns true if this path contains an error.
   *
   * @return true if invalid, false if valid
   */
  public boolean isInvalid() {
<span class="fc" id="L172">    return value.isInvalid();</span>
  }

  // ===== Conversions =====

  /**
   * Converts this ValidationPath to an EitherPath.
   *
   * @return an EitherPath containing either the error (left) or value (right)
   */
  public EitherPath&lt;E, A&gt; toEitherPath() {
<span class="fc" id="L183">    return value.fold(</span>
<span class="fc" id="L184">        e -&gt; new EitherPath&lt;&gt;(Either.left(e)), a -&gt; new EitherPath&lt;&gt;(Either.right(a)));</span>
  }

  /**
   * Converts this ValidationPath to a MaybePath, discarding the error.
   *
   * @return a MaybePath containing the value if valid, or empty if invalid
   */
  public MaybePath&lt;A&gt; toMaybePath() {
<span class="fc" id="L193">    return value.fold(_ -&gt; new MaybePath&lt;&gt;(Maybe.nothing()), a -&gt; new MaybePath&lt;&gt;(Maybe.just(a)));</span>
  }

  /**
   * Converts this ValidationPath to a TryPath.
   *
   * @param errorToException converts the error to an exception; must not be null
   * @return a TryPath representing this path's value or the exception
   * @throws NullPointerException if errorToException is null
   */
  public TryPath&lt;A&gt; toTryPath(Function&lt;? super E, ? extends Throwable&gt; errorToException) {
<span class="fc" id="L204">    Objects.requireNonNull(errorToException, &quot;errorToException must not be null&quot;);</span>
<span class="fc" id="L205">    return value.fold(</span>
<span class="fc" id="L206">        e -&gt; new TryPath&lt;&gt;(Try.failure(errorToException.apply(e))),</span>
<span class="fc" id="L207">        a -&gt; new TryPath&lt;&gt;(Try.success(a)));</span>
  }

  /**
   * Converts this ValidationPath to an OptionalPath, discarding the error.
   *
   * @return an OptionalPath containing the value if Valid, or empty if Invalid
   */
  public OptionalPath&lt;A&gt; toOptionalPath() {
<span class="fc" id="L216">    return value.fold(</span>
<span class="fc" id="L217">        _ -&gt; new OptionalPath&lt;&gt;(Optional.empty()), a -&gt; new OptionalPath&lt;&gt;(Optional.of(a)));</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; ValidationPath&lt;E, B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L224">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L225">    return new ValidationPath&lt;&gt;(value.map(mapper), semigroup);</span>
  }

  @Override
  public ValidationPath&lt;E, A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L230">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L231">    value.ifValid(consumer);</span>
<span class="fc" id="L232">    return this;</span>
  }

  /**
   * Observes the error value without modifying it (for debugging).
   *
   * @param consumer the action to perform on the error; must not be null
   * @return this path unchanged
   * @throws NullPointerException if consumer is null
   */
  public ValidationPath&lt;E, A&gt; peekInvalid(Consumer&lt;? super E&gt; consumer) {
<span class="fc" id="L243">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L244">    value.ifInvalid(consumer);</span>
<span class="fc" id="L245">    return this;</span>
  }

  // ===== Combinable implementation (short-circuits) =====

  @Override
  public &lt;B, C&gt; ValidationPath&lt;E, C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L253">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L254">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">    if (!(other instanceof ValidationPath&lt;?, ?&gt; otherValidated)) {</span>
<span class="fc" id="L257">      throw new IllegalArgumentException(&quot;Cannot zipWith non-ValidationPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L261">    ValidationPath&lt;E, B&gt; typedOther = (ValidationPath&lt;E, B&gt;) otherValidated;</span>

    // Short-circuit: return first error encountered
<span class="fc" id="L264">    return this.value.fold(</span>
<span class="fc" id="L265">        e -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e), semigroup),</span>
        a -&gt;
<span class="fc" id="L267">            typedOther.value.fold(</span>
<span class="fc" id="L268">                e -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e), semigroup),</span>
<span class="fc" id="L269">                b -&gt; new ValidationPath&lt;&gt;(Validated.valid(combiner.apply(a, b)), semigroup)));</span>
  }

  /**
   * Combines this path with two others using a ternary function (short-circuits).
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result, or the first error encountered
   */
  public &lt;B, C, D&gt; ValidationPath&lt;E, D&gt; zipWith3(
      ValidationPath&lt;E, B&gt; second,
      ValidationPath&lt;E, C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L287">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L288">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L289">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

    // Short-circuit: return first error encountered
<span class="fc" id="L292">    return this.value.fold(</span>
<span class="fc" id="L293">        e -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e), semigroup),</span>
        a -&gt;
<span class="fc" id="L295">            second.value.fold(</span>
<span class="fc" id="L296">                e -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e), semigroup),</span>
                b -&gt;
<span class="fc" id="L298">                    third.value.fold(</span>
<span class="fc" id="L299">                        e -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e), semigroup),</span>
                        c -&gt;
<span class="fc" id="L301">                            new ValidationPath&lt;&gt;(</span>
<span class="fc" id="L302">                                Validated.valid(combiner.apply(a, b, c)), semigroup))));</span>
  }

  // ===== Accumulating implementation (collects errors) =====

  @Override
  public &lt;B, C&gt; ValidationPath&lt;E, C&gt; zipWithAccum(
      Accumulating&lt;E, B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L310">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L311">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L313">    ValidationPath&lt;E, B&gt; typedOther = castAccumulatingForZipWithAccum(other);</span>

    // Accumulate errors from both
<span class="fc bfc" id="L316" title="All 2 branches covered.">    return switch (this.value) {</span>
<span class="fc" id="L317">      case Invalid&lt;E, A&gt;(var e1) -&gt;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">          switch (typedOther.value) {</span>
<span class="fc" id="L319">            case Invalid&lt;E, B&gt;(var e2) -&gt;</span>
<span class="fc" id="L320">                new ValidationPath&lt;&gt;(Validated.invalid(semigroup.combine(e1, e2)), semigroup);</span>
<span class="fc" id="L321">            case Valid&lt;E, B&gt; _ -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e1), semigroup);</span>
<span class="fc" id="L322">          };</span>
<span class="fc" id="L323">      case Valid&lt;E, A&gt;(var a) -&gt;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">          switch (typedOther.value) {</span>
<span class="fc" id="L325">            case Invalid&lt;E, B&gt;(var e2) -&gt; new ValidationPath&lt;&gt;(Validated.invalid(e2), semigroup);</span>
<span class="fc" id="L326">            case Valid&lt;E, B&gt;(var b) -&gt;</span>
<span class="fc" id="L327">                new ValidationPath&lt;&gt;(Validated.valid(combiner.apply(a, b)), semigroup);</span>
          };
    };
  }

  @Override
  public &lt;B, C, D&gt; ValidationPath&lt;E, D&gt; zipWith3Accum(
      Accumulating&lt;E, B&gt; second,
      Accumulating&lt;E, C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L337">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L338">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L339">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

    // Implement via two zipWithAccum calls to properly accumulate all errors
<span class="fc" id="L342">    return this.zipWithAccum(second, (a, b) -&gt; new Object[] {a, b})</span>
<span class="fc" id="L343">        .zipWithAccum(</span>
            third,
            (pair, c) -&gt; {
              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L347">              A a = (A) pair[0];</span>
              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L349">              B b = (B) pair[1];</span>
<span class="fc" id="L350">              return combiner.apply(a, b, c);</span>
            });
  }

  @Override
  public ValidationPath&lt;E, A&gt; andAlso(Accumulating&lt;E, ?&gt; other) {
<span class="fc" id="L356">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>

<span class="fc" id="L358">    ValidationPath&lt;E, ?&gt; typedOther = castAccumulatingForAndAlso(other);</span>

<span class="fc" id="L360">    return zipWithAccum(typedOther, (a, _) -&gt; a);</span>
  }

  @Override
  public &lt;B&gt; ValidationPath&lt;E, B&gt; andThen(Accumulating&lt;E, B&gt; other) {
<span class="fc" id="L365">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>

<span class="fc" id="L367">    ValidationPath&lt;E, B&gt; typedOther = castAccumulatingForAndThen(other);</span>

<span class="fc" id="L369">    return zipWithAccum(typedOther, (_, b) -&gt; b);</span>
  }

  // ===== Chainable implementation (short-circuits) =====

  @Override
  public &lt;B&gt; ValidationPath&lt;E, B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L376">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (value.isInvalid()) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L380">      ValidationPath&lt;E, B&gt; result = (ValidationPath&lt;E, B&gt;) this;</span>
<span class="fc" id="L381">      return result;</span>
    }

<span class="fc" id="L384">    Chainable&lt;B&gt; result = mapper.apply(value.get());</span>
<span class="fc" id="L385">    Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (!(result instanceof ValidationPath&lt;?, ?&gt; validatedPath)) {</span>
<span class="fc" id="L388">      throw new IllegalArgumentException(</span>
<span class="fc" id="L389">          &quot;via mapper must return ValidationPath, got: &quot; + result.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L393">    ValidationPath&lt;E, B&gt; typedResult = (ValidationPath&lt;E, B&gt;) validatedPath;</span>
<span class="fc" id="L394">    return typedResult;</span>
  }

  @Override
  public &lt;B&gt; ValidationPath&lt;E, B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L399">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">    if (value.isInvalid()) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L403">      ValidationPath&lt;E, B&gt; result = (ValidationPath&lt;E, B&gt;) this;</span>
<span class="fc" id="L404">      return result;</span>
    }

<span class="fc" id="L407">    Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L408">    Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">    if (!(result instanceof ValidationPath&lt;?, ?&gt; validatedPath)) {</span>
<span class="fc" id="L411">      throw new IllegalArgumentException(</span>
<span class="fc" id="L412">          &quot;then supplier must return ValidationPath, got: &quot; + result.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L416">    ValidationPath&lt;E, B&gt; typedResult = (ValidationPath&lt;E, B&gt;) validatedPath;</span>
<span class="fc" id="L417">    return typedResult;</span>
  }

  // ===== Recoverable implementation =====

  @Override
  public ValidationPath&lt;E, A&gt; recover(Function&lt;? super E, ? extends A&gt; recovery) {
<span class="fc" id="L424">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">    if (value.isValid()) {</span>
<span class="fc" id="L426">      return this;</span>
    }
<span class="fc" id="L428">    return new ValidationPath&lt;&gt;(Validated.valid(recovery.apply(value.getError())), semigroup);</span>
  }

  @Override
  public ValidationPath&lt;E, A&gt; recoverWith(
      Function&lt;? super E, ? extends Recoverable&lt;E, A&gt;&gt; recovery) {
<span class="fc" id="L434">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (value.isValid()) {</span>
<span class="fc" id="L436">      return this;</span>
    }
<span class="fc" id="L438">    Recoverable&lt;E, A&gt; result = recovery.apply(value.getError());</span>
<span class="fc" id="L439">    Objects.requireNonNull(result, &quot;recovery must not return null&quot;);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">    if (!(result instanceof ValidationPath&lt;?, ?&gt; validatedPath)) {</span>
<span class="fc" id="L441">      throw new IllegalArgumentException(</span>
<span class="fc" id="L442">          &quot;recovery must return ValidationPath, got: &quot; + result.getClass());</span>
    }
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L445">    ValidationPath&lt;E, A&gt; typedResult = (ValidationPath&lt;E, A&gt;) validatedPath;</span>
<span class="fc" id="L446">    return typedResult;</span>
  }

  @Override
  public ValidationPath&lt;E, A&gt; orElse(Supplier&lt;? extends Recoverable&lt;E, A&gt;&gt; alternative) {
<span class="fc" id="L451">    Objects.requireNonNull(alternative, &quot;alternative must not be null&quot;);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">    if (value.isValid()) {</span>
<span class="fc" id="L453">      return this;</span>
    }
<span class="fc" id="L455">    Recoverable&lt;E, A&gt; result = alternative.get();</span>
<span class="fc" id="L456">    Objects.requireNonNull(result, &quot;alternative must not return null&quot;);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">    if (!(result instanceof ValidationPath&lt;?, ?&gt; validatedPath)) {</span>
<span class="fc" id="L458">      throw new IllegalArgumentException(</span>
<span class="fc" id="L459">          &quot;alternative must return ValidationPath, got: &quot; + result.getClass());</span>
    }
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L462">    ValidationPath&lt;E, A&gt; typedResult = (ValidationPath&lt;E, A&gt;) validatedPath;</span>
<span class="fc" id="L463">    return typedResult;</span>
  }

  /**
   * Transforms the error type.
   *
   * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method throws {@link UnsupportedOperationException} for invalid
   * values because error type transformation requires a new {@link org.higherkindedj.hkt.Semigroup}
   * for the transformed error type, which cannot be inferred.
   *
   * &lt;h2&gt;Recommended Alternatives&lt;/h2&gt;
   *
   * &lt;p&gt;Use one of these approaches instead:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@link #mapErrorWith(Function, Semigroup)} - Transform errors with a new Semigroup
   *   &lt;li&gt;Convert to EitherPath, transform, then convert back:
   *       &lt;pre&gt;{@code
   * ValidationPath&lt;NewError, A&gt; result = validationPath
   *     .toEitherPath()
   *     .mapError(oldError -&gt; newError)
   *     .toValidationPath(newErrorSemigroup);
   * }&lt;/pre&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;For valid values, this method returns a ValidationPath with a placeholder Semigroup that
   * will throw if accumulation is attempted. This allows the value to flow through pipelines where
   * no accumulation occurs.
   *
   * @param mapper the function to transform the error; must not be null
   * @param &lt;E2&gt; the new error type
   * @return a new ValidationPath with the transformed error type (for valid values only)
   * @throws UnsupportedOperationException if this ValidationPath contains an invalid value
   * @throws NullPointerException if mapper is null
   * @see #mapErrorWith(Function, Semigroup)
   * @see #toEitherPath()
   */
  @Override
  public &lt;E2&gt; ValidationPath&lt;E2, A&gt; mapError(Function&lt;? super E, ? extends E2&gt; mapper) {
<span class="fc" id="L502">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
    // Note: mapError changes the error type, so we can't preserve the semigroup directly
    // The user must provide a new ValidationPath with appropriate semigroup when needed
<span class="fc" id="L505">    return value.fold(</span>
        e -&gt; {
          // We can't create a proper ValidationPath&lt;E2, A&gt; without a Semigroup&lt;E2&gt;
          // Return with a null semigroup - operations requiring accumulation will fail
          // This matches the semantic that error transformation changes the domain
<span class="fc" id="L510">          throw new UnsupportedOperationException(</span>
              &quot;mapError on ValidationPath requires creating a new ValidationPath with &quot;
                  + &quot;an appropriate Semigroup for the new error type. Use toEitherPath().mapError() &quot;
                  + &quot;then convert back with a new Semigroup instead.&quot;);
        },
        a -&gt; {
          // For valid values, we need a Semigroup&lt;E2&gt; which we don't have
          // Use a placeholder that will fail if accumulation is attempted
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L519">          Semigroup&lt;E2&gt; placeholderSemigroup =</span>
              (e1, e2) -&gt; {
<span class="fc" id="L521">                throw new UnsupportedOperationException(</span>
                    &quot;Cannot accumulate errors after mapError. Create a new ValidationPath with proper Semigroup.&quot;);
              };
<span class="fc" id="L524">          return new ValidationPath&lt;&gt;(Validated.valid(a), placeholderSemigroup);</span>
        });
  }

  /**
   * Transforms the error type with a new Semigroup for the transformed error type.
   *
   * &lt;p&gt;This is the preferred way to transform errors while maintaining accumulation capability.
   *
   * @param mapper the function to transform the error; must not be null
   * @param newSemigroup the Semigroup for the new error type; must not be null
   * @param &lt;E2&gt; the new error type
   * @return a ValidationPath with the transformed error type and new Semigroup
   */
  public &lt;E2&gt; ValidationPath&lt;E2, A&gt; mapErrorWith(
      Function&lt;? super E, ? extends E2&gt; mapper, Semigroup&lt;E2&gt; newSemigroup) {
<span class="fc" id="L540">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L541">    Objects.requireNonNull(newSemigroup, &quot;newSemigroup must not be null&quot;);</span>
<span class="fc" id="L542">    return new ValidationPath&lt;&gt;(value.mapError(mapper), newSemigroup);</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    if (!(obj instanceof ValidationPath&lt;?, ?&gt; other)) return false;</span>
<span class="fc" id="L551">    return value.equals(other.value);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L556">    return value.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L561">    return &quot;ValidationPath(&quot; + value + &quot;)&quot;;</span>
  }

  // ===== Defensive checks for sealed interface (excluded from coverage) =====
  // These methods contain instanceof checks that are always true in normal usage because
  // Accumulating is a sealed interface that only permits ValidationPath. The checks exist
  // as defensive measures and are excluded from coverage via @Generated annotation.

  @Generated(&quot;sealed-interface-defensive-check&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;E, B&gt; ValidationPath&lt;E, B&gt; castAccumulatingForZipWithAccum(
      Accumulating&lt;E, B&gt; other) {
    if (!(other instanceof ValidationPath&lt;?, ?&gt; otherValidated)) {
      throw new IllegalArgumentException(
          &quot;Cannot zipWithAccum non-ValidationPath: &quot; + other.getClass());
    }
    return (ValidationPath&lt;E, B&gt;) otherValidated;
  }

  @Generated(&quot;sealed-interface-defensive-check&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;E&gt; ValidationPath&lt;E, ?&gt; castAccumulatingForAndAlso(Accumulating&lt;E, ?&gt; other) {
    if (!(other instanceof ValidationPath&lt;?, ?&gt; otherValidated)) {
      throw new IllegalArgumentException(&quot;Cannot andAlso non-ValidationPath: &quot; + other.getClass());
    }
    return (ValidationPath&lt;E, ?&gt;) otherValidated;
  }

  @Generated(&quot;sealed-interface-defensive-check&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;E, B&gt; ValidationPath&lt;E, B&gt; castAccumulatingForAndThen(Accumulating&lt;E, B&gt; other) {
    if (!(other instanceof ValidationPath&lt;?, ?&gt; otherValidated)) {
      throw new IllegalArgumentException(&quot;Cannot andThen non-ValidationPath: &quot; + other.getClass());
    }
    return (ValidationPath&lt;E, B&gt;) otherValidated;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>