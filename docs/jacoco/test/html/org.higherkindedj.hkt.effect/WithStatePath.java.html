<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WithStatePath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">WithStatePath.java</span></div><h1>WithStatePath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.id.Id;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.state.State;
import org.higherkindedj.hkt.state.StateTuple;

/**
 * A fluent path wrapper for {@link State} computations.
 *
 * &lt;p&gt;{@code WithStatePath} represents computations that thread state through a sequence of
 * operations. Each step can read and modify the state, producing both a new state and a result
 * value.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Stateful parsers
 *   &lt;li&gt;Random number generation
 *   &lt;li&gt;Counter or ID generation
 *   &lt;li&gt;Building data structures
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating WithStatePath instances&lt;/h2&gt;
 *
 * &lt;p&gt;Use the {@link Path} factory class or static factory methods:
 *
 * &lt;pre&gt;{@code
 * // Pure value (state unchanged)
 * WithStatePath&lt;Integer, String&gt; pure = WithStatePath.pure(&quot;hello&quot;);
 *
 * // Get current state
 * WithStatePath&lt;Integer, Integer&gt; getState = WithStatePath.get();
 *
 * // Set new state
 * WithStatePath&lt;Integer, Unit&gt; setState = WithStatePath.set(42);
 *
 * // Modify state
 * WithStatePath&lt;Integer, Unit&gt; increment = WithStatePath.modify(n -&gt; n + 1);
 *
 * // Inspect state
 * WithStatePath&lt;AppState, String&gt; getName = WithStatePath.inspect(AppState::userName);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Counter state example
 * WithStatePath&lt;Integer, Integer&gt; nextId = WithStatePath.&lt;Integer&gt;modify(n -&gt; n + 1)
 *     .then(() -&gt; WithStatePath.get());
 *
 * // Generate multiple IDs
 * WithStatePath&lt;Integer, List&lt;Integer&gt;&gt; threeIds = nextId
 *     .via(id1 -&gt; nextId.via(id2 -&gt; nextId.map(id3 -&gt; List.of(id1, id2, id3))));
 *
 * // Run starting from 0
 * StateTuple&lt;Integer, List&lt;Integer&gt;&gt; result = threeIds.run(0);
 * // result = StateTuple(value=[1, 2, 3], state=3)
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; the state type
 * @param &lt;A&gt; the type of the computed value
 */
public final class WithStatePath&lt;S, A&gt; implements Chainable&lt;A&gt; {

  private final State&lt;S, A&gt; state;

  /**
   * Creates a new WithStatePath wrapping the given State.
   *
   * @param state the State to wrap; must not be null
   */
<span class="fc" id="L85">  WithStatePath(State&lt;S, A&gt; state) {</span>
<span class="fc" id="L86">    this.state = Objects.requireNonNull(state, &quot;state must not be null&quot;);</span>
<span class="fc" id="L87">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a WithStatePath that returns a constant value without modifying state.
   *
   * @param value the value to return
   * @param &lt;S&gt; the state type
   * @param &lt;A&gt; the type of the value
   * @return a WithStatePath that always returns the given value
   */
  public static &lt;S, A&gt; WithStatePath&lt;S, A&gt; pure(A value) {
<span class="fc" id="L100">    return new WithStatePath&lt;&gt;(State.pure(value));</span>
  }

  /**
   * Creates a WithStatePath that returns the current state as its value.
   *
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that returns the current state
   */
  public static &lt;S&gt; WithStatePath&lt;S, S&gt; get() {
<span class="fc" id="L110">    return new WithStatePath&lt;&gt;(State.get());</span>
  }

  /**
   * Creates a WithStatePath that sets the state to the given value and returns {@link Unit}.
   *
   * @param newState the new state value; must not be null
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that sets the state
   * @throws NullPointerException if newState is null
   */
  public static &lt;S&gt; WithStatePath&lt;S, Unit&gt; set(S newState) {
<span class="fc" id="L122">    Objects.requireNonNull(newState, &quot;newState must not be null&quot;);</span>
<span class="fc" id="L123">    return new WithStatePath&lt;&gt;(State.set(newState));</span>
  }

  /**
   * Creates a WithStatePath that modifies the state using the given function and returns {@link
   * Unit}.
   *
   * @param f the function to modify the state; must not be null
   * @param &lt;S&gt; the state type
   * @return a WithStatePath that modifies the state
   * @throws NullPointerException if f is null
   */
  public static &lt;S&gt; WithStatePath&lt;S, Unit&gt; modify(UnaryOperator&lt;S&gt; f) {
<span class="fc" id="L136">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L137">    return new WithStatePath&lt;&gt;(State.modify(f));</span>
  }

  /**
   * Creates a WithStatePath that extracts a value from the state without modifying it.
   *
   * @param f the function to extract a value from the state; must not be null
   * @param &lt;S&gt; the state type
   * @param &lt;A&gt; the type of the extracted value
   * @return a WithStatePath that inspects the state
   * @throws NullPointerException if f is null
   */
  public static &lt;S, A&gt; WithStatePath&lt;S, A&gt; inspect(Function&lt;? super S, ? extends A&gt; f) {
<span class="fc" id="L150">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L151">    return new WithStatePath&lt;&gt;(State.inspect(f::apply));</span>
  }

  // ===== Terminal Operations =====

  /**
   * Runs this computation with the given initial state.
   *
   * @param initialState the initial state; must not be null
   * @return a tuple containing the computed value and the final state
   * @throws NullPointerException if initialState is null
   */
  public StateTuple&lt;S, A&gt; run(S initialState) {
<span class="fc" id="L164">    Objects.requireNonNull(initialState, &quot;initialState must not be null&quot;);</span>
<span class="fc" id="L165">    return state.run(initialState);</span>
  }

  /**
   * Runs this computation and returns only the result, discarding the final state.
   *
   * @param initialState the initial state; must not be null
   * @return the computed value
   * @throws NullPointerException if initialState is null
   */
  public A evalState(S initialState) {
<span class="fc" id="L176">    return run(initialState).value();</span>
  }

  /**
   * Runs this computation and returns only the final state, discarding the result.
   *
   * @param initialState the initial state; must not be null
   * @return the final state
   * @throws NullPointerException if initialState is null
   */
  public S execState(S initialState) {
<span class="fc" id="L187">    return run(initialState).state();</span>
  }

  /**
   * Returns the underlying State.
   *
   * @return the wrapped State
   */
  public State&lt;S, A&gt; toState() {
<span class="fc" id="L196">    return state;</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; WithStatePath&lt;S, B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L203">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L204">    return new WithStatePath&lt;&gt;(state.map(mapper));</span>
  }

  @Override
  public WithStatePath&lt;S, A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L209">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L210">    return new WithStatePath&lt;&gt;(</span>
<span class="fc" id="L211">        State.of(</span>
            s -&gt; {
<span class="fc" id="L213">              StateTuple&lt;S, A&gt; result = state.run(s);</span>
<span class="fc" id="L214">              consumer.accept(result.value());</span>
<span class="fc" id="L215">              return result;</span>
            }));
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; WithStatePath&lt;S, C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L224">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L225">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">    if (!(other instanceof WithStatePath&lt;?, ?&gt; otherState)) {</span>
<span class="fc" id="L228">      throw new IllegalArgumentException(&quot;Cannot zipWith non-WithStatePath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L232">    WithStatePath&lt;S, B&gt; typedOther = (WithStatePath&lt;S, B&gt;) otherState;</span>

<span class="fc" id="L234">    return new WithStatePath&lt;&gt;(</span>
<span class="fc" id="L235">        State.of(</span>
            s -&gt; {
<span class="fc" id="L237">              StateTuple&lt;S, A&gt; resultA = this.state.run(s);</span>
<span class="fc" id="L238">              StateTuple&lt;S, B&gt; resultB = typedOther.state.run(resultA.state());</span>
<span class="fc" id="L239">              return new StateTuple&lt;&gt;(</span>
<span class="fc" id="L240">                  combiner.apply(resultA.value(), resultB.value()), resultB.state());</span>
            }));
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result
   */
  public &lt;B, C, D&gt; WithStatePath&lt;S, D&gt; zipWith3(
      WithStatePath&lt;S, B&gt; second,
      WithStatePath&lt;S, C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L259">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L260">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L261">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L263">    return new WithStatePath&lt;&gt;(</span>
<span class="fc" id="L264">        State.of(</span>
            s -&gt; {
<span class="fc" id="L266">              StateTuple&lt;S, A&gt; resultA = this.state.run(s);</span>
<span class="fc" id="L267">              StateTuple&lt;S, B&gt; resultB = second.state.run(resultA.state());</span>
<span class="fc" id="L268">              StateTuple&lt;S, C&gt; resultC = third.state.run(resultB.state());</span>
<span class="fc" id="L269">              return new StateTuple&lt;&gt;(</span>
<span class="fc" id="L270">                  combiner.apply(resultA.value(), resultB.value(), resultC.value()),</span>
<span class="fc" id="L271">                  resultC.state());</span>
            }));
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; WithStatePath&lt;S, B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L279">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L281">    return new WithStatePath&lt;&gt;(</span>
<span class="fc" id="L282">        state.flatMap(</span>
            a -&gt; {
<span class="fc" id="L284">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L285">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">              if (!(result instanceof WithStatePath&lt;?, ?&gt; statePath)) {</span>
<span class="fc" id="L288">                throw new IllegalArgumentException(</span>
<span class="fc" id="L289">                    &quot;via mapper must return WithStatePath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L293">              WithStatePath&lt;S, B&gt; typedResult = (WithStatePath&lt;S, B&gt;) statePath;</span>
<span class="fc" id="L294">              return typedResult.state;</span>
            }));
  }

  @Override
  public &lt;B&gt; WithStatePath&lt;S, B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L300">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc" id="L302">    return new WithStatePath&lt;&gt;(</span>
<span class="fc" id="L303">        State.of(</span>
            s -&gt; {
              // Run this state computation to get the new state
<span class="fc" id="L306">              StateTuple&lt;S, A&gt; result = this.state.run(s);</span>

<span class="fc" id="L308">              Chainable&lt;B&gt; next = supplier.get();</span>
<span class="fc" id="L309">              Objects.requireNonNull(next, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L311" title="All 2 branches covered.">              if (!(next instanceof WithStatePath&lt;?, ?&gt; statePath)) {</span>
<span class="fc" id="L312">                throw new IllegalArgumentException(</span>
<span class="fc" id="L313">                    &quot;then supplier must return WithStatePath, got: &quot; + next.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L317">              WithStatePath&lt;S, B&gt; typedResult = (WithStatePath&lt;S, B&gt;) statePath;</span>
<span class="fc" id="L318">              return typedResult.state.run(result.state());</span>
            }));
  }

  // ===== Conversions =====

  /**
   * Converts to an IOPath by providing the initial state.
   *
   * &lt;p&gt;The resulting IOPath, when run, will execute this State with the given initial state and
   * return only the computed value.
   *
   * @param initialState the initial state to use; must not be null
   * @return an IOPath that produces the computed value
   * @throws NullPointerException if initialState is null
   */
  public IOPath&lt;A&gt; toIOPath(S initialState) {
<span class="fc" id="L335">    Objects.requireNonNull(initialState, &quot;initialState must not be null&quot;);</span>
<span class="fc" id="L336">    return new IOPath&lt;&gt;(() -&gt; evalState(initialState));</span>
  }

  /**
   * Converts to an IdPath by providing the initial state.
   *
   * @param initialState the initial state to use; must not be null
   * @return an IdPath containing the computed value
   * @throws NullPointerException if initialState is null
   */
  public IdPath&lt;A&gt; toIdPath(S initialState) {
<span class="fc" id="L347">    Objects.requireNonNull(initialState, &quot;initialState must not be null&quot;);</span>
<span class="fc" id="L348">    return new IdPath&lt;&gt;(Id.of(evalState(initialState)));</span>
  }

  /**
   * Converts to a MaybePath by providing the initial state.
   *
   * &lt;p&gt;If the computed value is null, returns an empty MaybePath.
   *
   * @param initialState the initial state to use; must not be null
   * @return a MaybePath containing the computed value if non-null
   * @throws NullPointerException if initialState is null
   */
  public MaybePath&lt;A&gt; toMaybePath(S initialState) {
<span class="fc" id="L361">    Objects.requireNonNull(initialState, &quot;initialState must not be null&quot;);</span>
<span class="fc" id="L362">    A result = evalState(initialState);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">    return result != null ? new MaybePath&lt;&gt;(Maybe.just(result)) : new MaybePath&lt;&gt;(Maybe.nothing());</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">    if (!(obj instanceof WithStatePath&lt;?, ?&gt; other)) return false;</span>
<span class="fc" id="L372">    return state.equals(other.state);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L377">    return state.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L382">    return &quot;WithStatePath(&quot; + state + &quot;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>