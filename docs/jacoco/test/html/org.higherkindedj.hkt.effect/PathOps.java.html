<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathOps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">PathOps.java</span></div><h1>PathOps.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.vtask.Par;
import org.higherkindedj.hkt.vtask.VTask;
import org.higherkindedj.optics.Each;
import org.higherkindedj.optics.util.Traversals;

/**
 * Utility operations for working with Path types.
 *
 * &lt;p&gt;Provides common functional programming patterns like sequence and traverse that operate across
 * collections of Path values. These operations allow you to transform and combine multiple paths
 * efficiently.
 *
 * &lt;h2&gt;Sequence Operations&lt;/h2&gt;
 *
 * &lt;p&gt;Sequence transforms a list of paths into a path of list:
 *
 * &lt;pre&gt;{@code
 * List&lt;MaybePath&lt;Integer&gt;&gt; paths = List.of(Path.just(1), Path.just(2), Path.just(3));
 * MaybePath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceMaybe(paths);
 * // result = Just([1, 2, 3])
 *
 * List&lt;MaybePath&lt;Integer&gt;&gt; withNothing = List.of(Path.just(1), Path.nothing(), Path.just(3));
 * MaybePath&lt;List&lt;Integer&gt;&gt; emptyResult = PathOps.sequenceMaybe(withNothing);
 * // emptyResult = Nothing
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Traverse Operations&lt;/h2&gt;
 *
 * &lt;p&gt;Traverse combines map and sequence in one operation:
 *
 * &lt;pre&gt;{@code
 * List&lt;Integer&gt; ids = List.of(1, 2, 3);
 * MaybePath&lt;List&lt;User&gt;&gt; users = PathOps.traverseMaybe(ids, id -&gt; userRepo.findById(id));
 * // returns Just([user1, user2, user3]) if all found, Nothing otherwise
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Error Handling&lt;/h2&gt;
 *
 * &lt;p&gt;Different path types handle errors differently:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code MaybePath}: Returns Nothing if any element is Nothing
 *   &lt;li&gt;{@code EitherPath}: Returns first Left error
 *   &lt;li&gt;{@code ValidationPath}: Accumulates all errors using the provided Semigroup
 *   &lt;li&gt;{@code TryPath}: Returns first failure
 *   &lt;li&gt;{@code VTaskPath}: Executes sequentially by default; use {@code sequenceVTaskPar} for
 *       parallel
 * &lt;/ul&gt;
 *
 * @see MaybePath
 * @see EitherPath
 * @see ValidationPath
 * @see TryPath
 * @see VTaskPath
 */
public final class PathOps {

  private PathOps() {
    // Utility class - no instantiation
  }

  // ===== MaybePath Operations =====

  /**
   * Converts a list of MaybePaths into a MaybePath of list.
   *
   * &lt;p&gt;If all paths contain values, returns a path containing the list of values. If any path is
   * Nothing, returns Nothing.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a MaybePath containing a list, or Nothing if any path is Nothing
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; MaybePath&lt;List&lt;A&gt;&gt; sequenceMaybe(List&lt;MaybePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L96">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L98">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">    for (MaybePath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L100">      Maybe&lt;A&gt; maybe = path.run();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">      if (maybe.isNothing()) {</span>
<span class="fc" id="L102">        return new MaybePath&lt;&gt;(Maybe.nothing());</span>
      }
<span class="fc" id="L104">      results.add(maybe.get());</span>
<span class="fc" id="L105">    }</span>
<span class="fc" id="L106">    return new MaybePath&lt;&gt;(Maybe.just(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * &lt;p&gt;This is equivalent to mapping the function over the list, then sequencing the results, but
   * potentially more efficient.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a MaybePath containing a list, or Nothing if any application fails
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; MaybePath&lt;List&lt;B&gt;&gt; traverseMaybe(
      List&lt;A&gt; items, Function&lt;A, MaybePath&lt;B&gt;&gt; f) {
<span class="fc" id="L124">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L125">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L127">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L129">      MaybePath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L130">      Maybe&lt;B&gt; maybe = path.run();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">      if (maybe.isNothing()) {</span>
<span class="fc" id="L132">        return new MaybePath&lt;&gt;(Maybe.nothing());</span>
      }
<span class="fc" id="L134">      results.add(maybe.get());</span>
<span class="fc" id="L135">    }</span>
<span class="fc" id="L136">    return new MaybePath&lt;&gt;(Maybe.just(results));</span>
  }

  // ===== EitherPath Operations =====

  /**
   * Converts a list of EitherPaths into an EitherPath of list.
   *
   * &lt;p&gt;If all paths are Right, returns a path containing the list of values. If any path is Left,
   * returns the first Left error encountered.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the element type
   * @return an EitherPath containing a list, or the first error
   * @throws NullPointerException if paths is null
   */
  public static &lt;E, A&gt; EitherPath&lt;E, List&lt;A&gt;&gt; sequenceEither(List&lt;EitherPath&lt;E, A&gt;&gt; paths) {
<span class="fc" id="L154">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L156">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">    for (EitherPath&lt;E, A&gt; path : paths) {</span>
<span class="fc" id="L158">      Either&lt;E, A&gt; either = path.run();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      if (either.isLeft()) {</span>
<span class="fc" id="L160">        return new EitherPath&lt;&gt;(Either.left(either.getLeft()));</span>
      }
<span class="fc" id="L162">      results.add(either.getRight());</span>
<span class="fc" id="L163">    }</span>
<span class="fc" id="L164">    return new EitherPath&lt;&gt;(Either.right(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return an EitherPath containing a list, or the first error
   * @throws NullPointerException if items or f is null
   */
  public static &lt;E, A, B&gt; EitherPath&lt;E, List&lt;B&gt;&gt; traverseEither(
      List&lt;A&gt; items, Function&lt;A, EitherPath&lt;E, B&gt;&gt; f) {
<span class="fc" id="L180">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L181">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L183">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L185">      EitherPath&lt;E, B&gt; path = f.apply(item);</span>
<span class="fc" id="L186">      Either&lt;E, B&gt; either = path.run();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">      if (either.isLeft()) {</span>
<span class="fc" id="L188">        return new EitherPath&lt;&gt;(Either.left(either.getLeft()));</span>
      }
<span class="fc" id="L190">      results.add(either.getRight());</span>
<span class="fc" id="L191">    }</span>
<span class="fc" id="L192">    return new EitherPath&lt;&gt;(Either.right(results));</span>
  }

  // ===== ValidationPath Operations =====

  /**
   * Converts a list of ValidationPaths into a ValidationPath of list.
   *
   * &lt;p&gt;If all paths are Valid, returns a path containing the list of values. If any paths are
   * Invalid, accumulates all errors using the provided Semigroup.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the element type
   * @return a ValidationPath containing a list, or all accumulated errors
   * @throws NullPointerException if paths or semigroup is null
   */
  public static &lt;E, A&gt; ValidationPath&lt;E, List&lt;A&gt;&gt; sequenceValidated(
      List&lt;ValidationPath&lt;E, A&gt;&gt; paths, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L212">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc" id="L213">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>

<span class="fc" id="L215">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc" id="L216">    E accumulatedErrors = null;</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">    for (ValidationPath&lt;E, A&gt; path : paths) {</span>
<span class="fc" id="L219">      Validated&lt;E, A&gt; validated = path.run();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">      if (validated.isValid()) {</span>
<span class="fc" id="L221">        results.add(validated.get());</span>
      } else {
<span class="fc" id="L223">        E error = validated.getError();</span>
        accumulatedErrors =
<span class="fc bfc" id="L225" title="All 2 branches covered.">            accumulatedErrors == null ? error : semigroup.combine(accumulatedErrors, error);</span>
      }
<span class="fc" id="L227">    }</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (accumulatedErrors != null) {</span>
<span class="fc" id="L230">      return new ValidationPath&lt;&gt;(Validated.invalid(accumulatedErrors), semigroup);</span>
    }
<span class="fc" id="L232">    return new ValidationPath&lt;&gt;(Validated.valid(results), semigroup);</span>
  }

  /**
   * Maps a function over a list and sequences the results, accumulating errors.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a ValidationPath containing a list, or all accumulated errors
   * @throws NullPointerException if any argument is null
   */
  public static &lt;E, A, B&gt; ValidationPath&lt;E, List&lt;B&gt;&gt; traverseValidated(
      List&lt;A&gt; items, Function&lt;A, ValidationPath&lt;E, B&gt;&gt; f, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L249">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L250">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L251">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>

<span class="fc" id="L253">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc" id="L254">    E accumulatedErrors = null;</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L257">      ValidationPath&lt;E, B&gt; path = f.apply(item);</span>
<span class="fc" id="L258">      Validated&lt;E, B&gt; validated = path.run();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      if (validated.isValid()) {</span>
<span class="fc" id="L260">        results.add(validated.get());</span>
      } else {
<span class="fc" id="L262">        E error = validated.getError();</span>
        accumulatedErrors =
<span class="fc bfc" id="L264" title="All 2 branches covered.">            accumulatedErrors == null ? error : semigroup.combine(accumulatedErrors, error);</span>
      }
<span class="fc" id="L266">    }</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">    if (accumulatedErrors != null) {</span>
<span class="fc" id="L269">      return new ValidationPath&lt;&gt;(Validated.invalid(accumulatedErrors), semigroup);</span>
    }
<span class="fc" id="L271">    return new ValidationPath&lt;&gt;(Validated.valid(results), semigroup);</span>
  }

  // ===== TryPath Operations =====

  /**
   * Converts a list of TryPaths into a TryPath of list.
   *
   * &lt;p&gt;If all paths are Success, returns a path containing the list of values. If any path fails,
   * returns the first failure encountered.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a TryPath containing a list, or the first failure
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; TryPath&lt;List&lt;A&gt;&gt; sequenceTry(List&lt;TryPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L288">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L290">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">    for (TryPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L292">      Try&lt;A&gt; tryValue = path.run();</span>
      // Use fold to safely extract value or return failure
<span class="fc" id="L294">      TryPath&lt;List&lt;A&gt;&gt; maybeFailure =</span>
<span class="fc" id="L295">          tryValue.fold(</span>
              a -&gt; {
<span class="fc" id="L297">                results.add(a);</span>
<span class="fc" id="L298">                return null; // continue processing</span>
              },
<span class="fc" id="L300">              ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">      if (maybeFailure != null) {</span>
<span class="fc" id="L302">        return maybeFailure;</span>
      }
<span class="fc" id="L304">    }</span>
<span class="fc" id="L305">    return new TryPath&lt;&gt;(Try.success(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a TryPath containing a list, or the first failure
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; TryPath&lt;List&lt;B&gt;&gt; traverseTry(List&lt;A&gt; items, Function&lt;A, TryPath&lt;B&gt;&gt; f) {
<span class="fc" id="L319">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L320">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L322">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L324">      TryPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L325">      Try&lt;B&gt; tryValue = path.run();</span>
      // Use fold to safely extract value or return failure
<span class="fc" id="L327">      TryPath&lt;List&lt;B&gt;&gt; maybeFailure =</span>
<span class="fc" id="L328">          tryValue.fold(</span>
              b -&gt; {
<span class="fc" id="L330">                results.add(b);</span>
<span class="fc" id="L331">                return null; // continue processing</span>
              },
<span class="fc" id="L333">              ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">      if (maybeFailure != null) {</span>
<span class="fc" id="L335">        return maybeFailure;</span>
      }
<span class="fc" id="L337">    }</span>
<span class="fc" id="L338">    return new TryPath&lt;&gt;(Try.success(results));</span>
  }

  /**
   * Returns the first successful path, or the last failure if all fail.
   *
   * &lt;p&gt;This is useful for trying multiple fallback strategies until one succeeds.
   *
   * @param paths the paths to try; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return the first successful path, or the last failure
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; TryPath&lt;A&gt; firstSuccess(List&lt;TryPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L353">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L355">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc" id="L358">    TryPath&lt;A&gt; lastFailure = null;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">    for (TryPath&lt;A&gt; path : paths) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">      if (path.run().isSuccess()) {</span>
<span class="fc" id="L361">        return path;</span>
      }
<span class="fc" id="L363">      lastFailure = path;</span>
<span class="fc" id="L364">    }</span>
<span class="fc" id="L365">    return lastFailure;</span>
  }

  // ===== VTaskPath Operations =====

  /**
   * Converts a list of VTaskPaths into a VTaskPath of list (sequential execution).
   *
   * &lt;p&gt;If all paths succeed, returns a path containing the list of values. If any path fails,
   * returns the first failure encountered. Paths are executed sequentially in order.
   *
   * &lt;p&gt;For parallel execution, use {@link #sequenceVTaskPar(List)}.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a VTaskPath containing a list, or the first failure
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; VTaskPath&lt;List&lt;A&gt;&gt; sequenceVTask(List&lt;VTaskPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L384">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L387">      return Path.vtaskPure(List.of());</span>
    }

<span class="fc" id="L390">    return Path.vtaskPath(</span>
<span class="fc" id="L391">        VTask.delay(</span>
            () -&gt; {
<span class="fc" id="L393">              List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">              for (VTaskPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L395">                results.add(path.unsafeRun());</span>
<span class="fc" id="L396">              }</span>
<span class="fc" id="L397">              return results;</span>
            }));
  }

  /**
   * Maps a function over a list and sequences the results (sequential execution).
   *
   * &lt;p&gt;This is equivalent to mapping the function over the list, then sequencing the results, but
   * potentially more efficient. Paths are executed sequentially in order.
   *
   * &lt;p&gt;For parallel execution, use {@link #traverseVTaskPar(List, Function)}.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a VTaskPath containing a list, or the first failure
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; VTaskPath&lt;List&lt;B&gt;&gt; traverseVTask(
      List&lt;A&gt; items, Function&lt;A, VTaskPath&lt;B&gt;&gt; f) {
<span class="fc" id="L418">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L419">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L422">      return Path.vtaskPure(List.of());</span>
    }

<span class="fc" id="L425">    return Path.vtaskPath(</span>
<span class="fc" id="L426">        VTask.delay(</span>
            () -&gt; {
<span class="fc" id="L428">              List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">              for (A item : items) {</span>
<span class="fc" id="L430">                VTaskPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L431">                results.add(path.unsafeRun());</span>
<span class="fc" id="L432">              }</span>
<span class="fc" id="L433">              return results;</span>
            }));
  }

  /**
   * Converts a list of VTaskPaths into a VTaskPath of list (parallel execution).
   *
   * &lt;p&gt;All paths are executed concurrently on virtual threads using {@link Par#all(List)}. If any
   * path fails, the result fails with that exception.
   *
   * &lt;p&gt;For sequential execution, use {@link #sequenceVTask(List)}.
   *
   * @param paths the list of paths to sequence in parallel; must not be null
   * @param &lt;A&gt; the element type
   * @return a VTaskPath containing a list, or the first failure
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; VTaskPath&lt;List&lt;A&gt;&gt; sequenceVTaskPar(List&lt;VTaskPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L451">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L454">      return Path.vtaskPure(List.of());</span>
    }

<span class="fc" id="L457">    List&lt;VTask&lt;A&gt;&gt; tasks = paths.stream().map(VTaskPath::run).toList();</span>
<span class="fc" id="L458">    return Path.vtaskPath(Par.all(tasks));</span>
  }

  /**
   * Maps a function over a list and sequences the results (parallel execution).
   *
   * &lt;p&gt;Applies the function to each element and executes the resulting VTasks in parallel using
   * virtual threads.
   *
   * &lt;p&gt;For sequential execution, use {@link #traverseVTask(List, Function)}.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a VTaskPath containing a list, or the first failure
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; VTaskPath&lt;List&lt;B&gt;&gt; traverseVTaskPar(
      List&lt;A&gt; items, Function&lt;A, VTaskPath&lt;B&gt;&gt; f) {
<span class="fc" id="L478">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L479">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L482">      return Path.vtaskPure(List.of());</span>
    }

<span class="fc" id="L485">    List&lt;VTask&lt;B&gt;&gt; tasks = items.stream().map(item -&gt; f.apply(item).run()).toList();</span>
<span class="fc" id="L486">    return Path.vtaskPath(Par.all(tasks));</span>
  }

  /**
   * Races multiple VTaskPaths, returning the first to complete successfully.
   *
   * &lt;p&gt;All VTaskPaths are executed concurrently on virtual threads. The first to complete
   * successfully wins. If all fail, the last failure is propagated.
   *
   * @param paths the VTaskPaths to race; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return a VTaskPath that completes with the first successful result
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; VTaskPath&lt;A&gt; raceVTask(List&lt;VTaskPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L502">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L504">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc bfc" id="L507" title="All 2 branches covered.">    if (paths.size() == 1) {</span>
<span class="fc" id="L508">      return paths.getFirst();</span>
    }

<span class="fc" id="L511">    List&lt;VTask&lt;A&gt;&gt; tasks = paths.stream().map(VTaskPath::run).toList();</span>
<span class="fc" id="L512">    return Path.vtaskPath(Par.race(tasks));</span>
  }

  /**
   * Returns the first successful VTaskPath, or the last failure if all fail.
   *
   * &lt;p&gt;This is useful for trying multiple fallback strategies until one succeeds. Unlike {@link
   * #raceVTask(List)}, paths are tried sequentially (not in parallel).
   *
   * @param paths the paths to try; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return the first successful path, or the last failure
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; VTaskPath&lt;A&gt; firstVTaskSuccess(List&lt;VTaskPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L528">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L530">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc" id="L533">    return Path.vtaskPath(</span>
<span class="fc" id="L534">        VTask.delay(</span>
            () -&gt; {
<span class="fc" id="L536">              Throwable lastError = null;</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">              for (VTaskPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L538">                Try&lt;A&gt; result = path.runSafe();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                if (result.isSuccess()) {</span>
                  // Use fold to extract value without throwing checked exception
<span class="pc" id="L541">                  return result.fold(a -&gt; a, cause -&gt; null);</span>
                }
                // Extract the cause from the Failure using fold
<span class="pc" id="L544">                lastError = result.fold(a -&gt; null, cause -&gt; cause);</span>
<span class="fc" id="L545">              }</span>
              // VTaskPath.unsafeRun() only throws RuntimeException or Error
              // (checked exceptions are wrapped), so lastError will always be one of these
<span class="fc bfc" id="L548" title="All 2 branches covered.">              if (lastError instanceof RuntimeException re) {</span>
<span class="fc" id="L549">                throw re;</span>
              }
<span class="fc" id="L551">              throw (Error) lastError;</span>
            }));
  }

  // ===== OptionalPath Operations =====

  /**
   * Converts a list of OptionalPaths into an OptionalPath of list.
   *
   * &lt;p&gt;If all paths contain values, returns a path containing the list of values. If any path is
   * empty, returns empty.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return an OptionalPath containing a list, or empty if any path is empty
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; OptionalPath&lt;List&lt;A&gt;&gt; sequenceOptional(List&lt;OptionalPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L569">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L571">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    for (OptionalPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L573">      Optional&lt;A&gt; optional = path.run();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">      if (optional.isEmpty()) {</span>
<span class="fc" id="L575">        return new OptionalPath&lt;&gt;(Optional.empty());</span>
      }
<span class="fc" id="L577">      results.add(optional.get());</span>
<span class="fc" id="L578">    }</span>
<span class="fc" id="L579">    return new OptionalPath&lt;&gt;(Optional.of(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return an OptionalPath containing a list, or empty if any application returns empty
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; OptionalPath&lt;List&lt;B&gt;&gt; traverseOptional(
      List&lt;A&gt; items, Function&lt;A, OptionalPath&lt;B&gt;&gt; f) {
<span class="fc" id="L594">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L595">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L597">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L599">      OptionalPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L600">      Optional&lt;B&gt; optional = path.run();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">      if (optional.isEmpty()) {</span>
<span class="fc" id="L602">        return new OptionalPath&lt;&gt;(Optional.empty());</span>
      }
<span class="fc" id="L604">      results.add(optional.get());</span>
<span class="fc" id="L605">    }</span>
<span class="fc" id="L606">    return new OptionalPath&lt;&gt;(Optional.of(results));</span>
  }

  // ===== NonDetPath Operations =====

  /**
   * Converts a list of NonDetPaths into a NonDetPath of list (Cartesian product).
   *
   * &lt;p&gt;This operation produces all possible combinations of elements from each path. The result is
   * the Cartesian product of all inner lists.
   *
   * &lt;pre&gt;{@code
   * List&lt;NonDetPath&lt;Integer&gt;&gt; paths = List.of(
   *     NonDetPath.of(List.of(1, 2)),
   *     NonDetPath.of(List.of(3, 4))
   * );
   * NonDetPath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceNonDet(paths);
   * // result.run() = [[1,3], [1,4], [2,3], [2,4]]
   * }&lt;/pre&gt;
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a NonDetPath containing all combinations
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; NonDetPath&lt;List&lt;A&gt;&gt; sequenceNonDet(List&lt;NonDetPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L632">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L635">      return NonDetPath.of(List.of(List.of()));</span>
    }

    // Start with a list containing a single empty list
<span class="fc" id="L639">    NonDetPath&lt;List&lt;A&gt;&gt; result = NonDetPath.pure(new ArrayList&lt;&gt;());</span>

<span class="fc bfc" id="L641" title="All 2 branches covered.">    for (NonDetPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L642">      result =</span>
<span class="fc" id="L643">          result.via(</span>
              acc -&gt;
<span class="fc" id="L645">                  path.map(</span>
                      a -&gt; {
<span class="fc" id="L647">                        List&lt;A&gt; newAcc = new ArrayList&lt;&gt;(acc);</span>
<span class="fc" id="L648">                        newAcc.add(a);</span>
<span class="fc" id="L649">                        return newAcc;</span>
                      }));
<span class="fc" id="L651">    }</span>

<span class="fc" id="L653">    return result;</span>
  }

  /**
   * Maps a function over a list and sequences the results (Cartesian product).
   *
   * &lt;p&gt;Applies the function to each element and produces all possible combinations of results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a NonDetPath containing all combinations
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; NonDetPath&lt;List&lt;B&gt;&gt; traverseNonDet(
      List&lt;A&gt; items, Function&lt;A, NonDetPath&lt;B&gt;&gt; f) {
<span class="fc" id="L670">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L671">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L673" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L674">      return NonDetPath.of(List.of(List.of()));</span>
    }

<span class="fc" id="L677">    NonDetPath&lt;List&lt;B&gt;&gt; result = NonDetPath.pure(new ArrayList&lt;&gt;());</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L680">      NonDetPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L681">      result =</span>
<span class="fc" id="L682">          result.via(</span>
              acc -&gt;
<span class="fc" id="L684">                  path.map(</span>
                      b -&gt; {
<span class="fc" id="L686">                        List&lt;B&gt; newAcc = new ArrayList&lt;&gt;(acc);</span>
<span class="fc" id="L687">                        newAcc.add(b);</span>
<span class="fc" id="L688">                        return newAcc;</span>
                      }));
<span class="fc" id="L690">    }</span>

<span class="fc" id="L692">    return result;</span>
  }

  /**
   * Flattens a NonDetPath of NonDetPaths into a single NonDetPath.
   *
   * &lt;p&gt;Concatenates all inner lists.
   *
   * @param nested the nested NonDetPath to flatten; must not be null
   * @param &lt;A&gt; the element type
   * @return a flattened NonDetPath
   * @throws NullPointerException if nested is null
   */
  public static &lt;A&gt; NonDetPath&lt;A&gt; flatten(NonDetPath&lt;NonDetPath&lt;A&gt;&gt; nested) {
<span class="fc" id="L706">    Objects.requireNonNull(nested, &quot;nested must not be null&quot;);</span>

<span class="fc" id="L708">    List&lt;A&gt; flattened =</span>
<span class="fc" id="L709">        nested.run().stream().flatMap(innerPath -&gt; innerPath.run().stream()).toList();</span>

<span class="fc" id="L711">    return NonDetPath.of(flattened);</span>
  }

  // ===== ListPath Operations =====

  /**
   * Converts a list of ListPaths into a ListPath of lists using positional zipping.
   *
   * &lt;p&gt;Unlike {@link #sequenceNonDet}, which produces a Cartesian product, this method transposes
   * the list of lists, pairing elements at corresponding positions.
   *
   * &lt;pre&gt;{@code
   * List&lt;ListPath&lt;Integer&gt;&gt; paths = List.of(
   *     ListPath.of(1, 2, 3),
   *     ListPath.of(4, 5, 6)
   * );
   * ListPath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceListPath(paths);
   * // result.run() = [[1, 4], [2, 5], [3, 6]]
   * }&lt;/pre&gt;
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a ListPath containing lists of corresponding elements
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; ListPath&lt;List&lt;A&gt;&gt; sequenceListPath(List&lt;ListPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L737">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L739" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L740">      return ListPath.of(List.of(List.of()));</span>
    }

    // Find the minimum size among all lists
<span class="fc" id="L744">    int minSize = paths.stream().mapToInt(ListPath::size).min().orElse(0);</span>

    // Transpose: collect element at position i from each list
<span class="fc" id="L747">    List&lt;List&lt;A&gt;&gt; result = new ArrayList&lt;&gt;(minSize);</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">    for (int i = 0; i &lt; minSize; i++) {</span>
<span class="fc" id="L749">      final int index = i;</span>
<span class="fc" id="L750">      List&lt;A&gt; row = paths.stream().map(path -&gt; path.run().get(index)).toList();</span>
<span class="fc" id="L751">      result.add(row);</span>
    }

<span class="fc" id="L754">    return ListPath.of(result);</span>
  }

  /**
   * Applies a function to each item and sequences the results positionally.
   *
   * &lt;pre&gt;{@code
   * List&lt;String&gt; items = List.of(&quot;a&quot;, &quot;b&quot;);
   * ListPath&lt;List&lt;String&gt;&gt; result = PathOps.traverseListPath(
   *     items,
   *     s -&gt; ListPath.of(s.toUpperCase(), s + s)
   * );
   * // result.run() = [[&quot;A&quot;, &quot;aa&quot;], [&quot;B&quot;, &quot;bb&quot;]]
   * }&lt;/pre&gt;
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply to each item; must not be null
   * @param &lt;A&gt; the input item type
   * @param &lt;B&gt; the element type of the resulting ListPaths
   * @return a ListPath of lists containing corresponding transformed elements
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; ListPath&lt;List&lt;B&gt;&gt; traverseListPath(
      List&lt;A&gt; items, Function&lt;A, ListPath&lt;B&gt;&gt; f) {
<span class="fc" id="L778">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L779">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L781" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L782">      return ListPath.of(List.of(List.of()));</span>
    }

<span class="fc" id="L785">    List&lt;ListPath&lt;B&gt;&gt; mapped = items.stream().map(f).toList();</span>
<span class="fc" id="L786">    return sequenceListPath(mapped);</span>
  }

  /**
   * Flattens a ListPath of ListPaths by concatenating all inner lists.
   *
   * @param nested the nested ListPath to flatten; must not be null
   * @param &lt;A&gt; the element type
   * @return a flattened ListPath
   * @throws NullPointerException if nested is null
   */
  public static &lt;A&gt; ListPath&lt;A&gt; flattenListPath(ListPath&lt;ListPath&lt;A&gt;&gt; nested) {
<span class="fc" id="L798">    Objects.requireNonNull(nested, &quot;nested must not be null&quot;);</span>

<span class="fc" id="L800">    List&lt;A&gt; flattened =</span>
<span class="fc" id="L801">        nested.run().stream().flatMap(innerPath -&gt; innerPath.run().stream()).toList();</span>

<span class="fc" id="L803">    return ListPath.of(flattened);</span>
  }

  /**
   * Zips a list of ListPaths element-wise, producing a ListPath of tuples (as lists).
   *
   * &lt;p&gt;This is similar to Python's {@code zip(*lists)} - it transposes rows and columns.
   *
   * @param paths the list of paths to zip; must not be null
   * @param &lt;A&gt; the element type
   * @return a ListPath where each element is a list of corresponding elements
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; ListPath&lt;List&lt;A&gt;&gt; zipAll(List&lt;ListPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L817">    return sequenceListPath(paths);</span>
  }

  // ===== CompletableFuturePath Operations =====

  /**
   * Converts a list of CompletableFuturePaths into a CompletableFuturePath of list.
   *
   * &lt;p&gt;Runs all futures concurrently and collects all results. If any future fails, the result
   * fails with that exception.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;List&lt;A&gt;&gt; sequenceFuture(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L835">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L837" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L838">      return CompletableFuturePath.completed(List.of());</span>
    }

<span class="fc" id="L841">    List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L842">        paths.stream().map(CompletableFuturePath::toCompletableFuture).collect(Collectors.toList());</span>

<span class="fc" id="L844">    CompletableFuture&lt;List&lt;A&gt;&gt; combined =</span>
<span class="fc" id="L845">        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L846">            .thenApply(_ -&gt; futures.stream().map(CompletableFuture::join).toList());</span>

<span class="fc" id="L848">    return CompletableFuturePath.fromFuture(combined);</span>
  }

  /**
   * Maps a function over a list and sequences the results concurrently.
   *
   * &lt;p&gt;Applies the function to each element concurrently and collects all results. If any
   * application fails, the result fails with that exception.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; CompletableFuturePath&lt;List&lt;B&gt;&gt; traverseFuture(
      List&lt;A&gt; items, Function&lt;A, CompletableFuturePath&lt;B&gt;&gt; f) {
<span class="fc" id="L866">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L867">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L869" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L870">      return CompletableFuturePath.completed(List.of());</span>
    }

<span class="fc" id="L873">    List&lt;CompletableFuture&lt;B&gt;&gt; futures =</span>
<span class="fc" id="L874">        items.stream().map(item -&gt; f.apply(item).toCompletableFuture()).toList();</span>

<span class="fc" id="L876">    CompletableFuture&lt;List&lt;B&gt;&gt; combined =</span>
<span class="fc" id="L877">        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L878">            .thenApply(_ -&gt; futures.stream().map(CompletableFuture::join).toList());</span>

<span class="fc" id="L880">    return CompletableFuturePath.fromFuture(combined);</span>
  }

  /**
   * Returns the first successful future path, or the last failure if all fail.
   *
   * &lt;p&gt;Note: Unlike {@link #firstSuccess(List)} for TryPath, this races the futures concurrently
   * rather than trying them sequentially.
   *
   * @param paths the paths to race; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return the first completed successful path, or a path with the last exception
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; firstCompletedSuccess(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L897">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L899">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc bfc" id="L902" title="All 2 branches covered.">    if (paths.size() == 1) {</span>
<span class="fc" id="L903">      return paths.getFirst();</span>
    }

    // Use anyOf to race, but we need the first SUCCESS, not just first completion
    // This requires a more complex implementation
<span class="fc" id="L908">    CompletableFuture&lt;A&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L909">    List&lt;Throwable&gt; failures = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L911" title="All 2 branches covered.">    for (CompletableFuturePath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L912">      path.toCompletableFuture()</span>
<span class="fc" id="L913">          .whenComplete(</span>
              (value, ex) -&gt; {
<span class="fc bfc" id="L915" title="All 4 branches covered.">                if (ex == null &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L916">                  result.complete(value);</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">                } else if (ex != null) {</span>
<span class="fc" id="L918">                  synchronized (failures) {</span>
<span class="fc" id="L919">                    failures.add(ex);</span>
<span class="pc bpc" id="L920" title="1 of 4 branches missed.">                    if (failures.size() == paths.size() &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L921">                      result.completeExceptionally(failures.getLast());</span>
                    }
<span class="fc" id="L923">                  }</span>
                }
<span class="fc" id="L925">              });</span>
<span class="fc" id="L926">    }</span>

<span class="fc" id="L928">    return CompletableFuturePath.fromFuture(result);</span>
  }

  // ===== Parallel IOPath Operations =====

  /**
   * Executes a list of IOPaths in parallel and collects results.
   *
   * &lt;p&gt;All IOPaths are executed concurrently using CompletableFuture. If any IOPath fails, the
   * result fails with that exception.
   *
   * @param paths the IOPaths to execute in parallel; must not be null
   * @param &lt;A&gt; the element type
   * @return an IOPath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; IOPath&lt;List&lt;A&gt;&gt; parSequenceIO(List&lt;IOPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L945">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L947" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L948">      return Path.ioPure(List.of());</span>
    }

<span class="fc" id="L951">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L952">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L954">              List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L955">                  paths.stream()</span>
<span class="fc" id="L956">                      .map(path -&gt; CompletableFuture.supplyAsync(path::unsafeRun))</span>
<span class="fc" id="L957">                      .toList();</span>

              try {
<span class="fc" id="L960">                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();</span>
<span class="fc" id="L961">                return futures.stream().map(CompletableFuture::join).toList();</span>
<span class="fc" id="L962">              } catch (InterruptedException e) {</span>
<span class="fc" id="L963">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L964">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L965">              } catch (ExecutionException e) {</span>
<span class="fc" id="L966">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L968">                  throw re;</span>
                }
<span class="fc" id="L970">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Executes a list of CompletableFuturePaths in parallel and collects results.
   *
   * &lt;p&gt;All futures run concurrently. If any fails, the result fails.
   *
   * @param paths the paths to execute; must not be null
   * @param &lt;A&gt; the element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;List&lt;A&gt;&gt; parSequenceFuture(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
    // This already exists as sequenceFuture, which is already parallel
<span class="fc" id="L988">    return sequenceFuture(paths);</span>
  }

  /**
   * Combines three IOPaths in parallel.
   *
   * @param first the first IOPath; must not be null
   * @param second the second IOPath; must not be null
   * @param third the third IOPath; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;A&gt; the type of the first value
   * @param &lt;B&gt; the type of the second value
   * @param &lt;C&gt; the type of the third value
   * @param &lt;D&gt; the type of the combined result
   * @return an IOPath containing the combined result
   * @throws NullPointerException if any argument is null
   */
  public static &lt;A, B, C, D&gt; IOPath&lt;D&gt; parZip3(
      IOPath&lt;A&gt; first,
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L1010">    Objects.requireNonNull(first, &quot;first must not be null&quot;);</span>
<span class="fc" id="L1011">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L1012">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L1013">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L1015">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L1016">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L1018">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(first::unsafeRun);</span>
<span class="fc" id="L1019">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(second::unsafeRun);</span>
<span class="fc" id="L1020">              CompletableFuture&lt;C&gt; futureC = CompletableFuture.supplyAsync(third::unsafeRun);</span>

              try {
<span class="fc" id="L1023">                CompletableFuture.allOf(futureA, futureB, futureC).get();</span>
<span class="fc" id="L1024">                return combiner.apply(futureA.join(), futureB.join(), futureC.join());</span>
<span class="fc" id="L1025">              } catch (InterruptedException e) {</span>
<span class="fc" id="L1026">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L1027">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L1028">              } catch (ExecutionException e) {</span>
<span class="fc" id="L1029">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L1031">                  throw re;</span>
                }
<span class="fc" id="L1033">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Combines four IOPaths in parallel.
   *
   * @param first the first IOPath; must not be null
   * @param second the second IOPath; must not be null
   * @param third the third IOPath; must not be null
   * @param fourth the fourth IOPath; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;A&gt; the type of the first value
   * @param &lt;B&gt; the type of the second value
   * @param &lt;C&gt; the type of the third value
   * @param &lt;D&gt; the type of the fourth value
   * @param &lt;E&gt; the type of the combined result
   * @return an IOPath containing the combined result
   * @throws NullPointerException if any argument is null
   */
  public static &lt;A, B, C, D, E&gt; IOPath&lt;E&gt; parZip4(
      IOPath&lt;A&gt; first,
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      IOPath&lt;D&gt; fourth,
      Function4&lt;? super A, ? super B, ? super C, ? super D, ? extends E&gt; combiner) {
<span class="fc" id="L1060">    Objects.requireNonNull(first, &quot;first must not be null&quot;);</span>
<span class="fc" id="L1061">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L1062">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L1063">    Objects.requireNonNull(fourth, &quot;fourth must not be null&quot;);</span>
<span class="fc" id="L1064">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L1066">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L1067">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L1069">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(first::unsafeRun);</span>
<span class="fc" id="L1070">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(second::unsafeRun);</span>
<span class="fc" id="L1071">              CompletableFuture&lt;C&gt; futureC = CompletableFuture.supplyAsync(third::unsafeRun);</span>
<span class="fc" id="L1072">              CompletableFuture&lt;D&gt; futureD = CompletableFuture.supplyAsync(fourth::unsafeRun);</span>

              try {
<span class="fc" id="L1075">                CompletableFuture.allOf(futureA, futureB, futureC, futureD).get();</span>
<span class="fc" id="L1076">                return combiner.apply(</span>
<span class="fc" id="L1077">                    futureA.join(), futureB.join(), futureC.join(), futureD.join());</span>
<span class="fc" id="L1078">              } catch (InterruptedException e) {</span>
<span class="fc" id="L1079">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L1080">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L1081">              } catch (ExecutionException e) {</span>
<span class="fc" id="L1082">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L1084">                  throw re;</span>
                }
<span class="fc" id="L1086">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Races multiple IOPaths, returning the first to complete successfully.
   *
   * &lt;p&gt;All IOPaths are executed concurrently. The first to complete successfully wins. If all fail,
   * the last failure is propagated.
   *
   * @param paths the IOPaths to race; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return an IOPath that completes with the first successful result
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; IOPath&lt;A&gt; raceIO(List&lt;IOPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L1104">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L1106">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc bfc" id="L1109" title="All 2 branches covered.">    if (paths.size() == 1) {</span>
<span class="fc" id="L1110">      return paths.getFirst();</span>
    }

<span class="fc" id="L1113">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L1114">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L1116">              CompletableFuture&lt;A&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L1117">              List&lt;Throwable&gt; failures = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1119">              List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L1120">                  paths.stream()</span>
<span class="fc" id="L1121">                      .map(path -&gt; CompletableFuture.supplyAsync(path::unsafeRun))</span>
<span class="fc" id="L1122">                      .toList();</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">              for (CompletableFuture&lt;A&gt; future : futures) {</span>
<span class="fc" id="L1125">                future.whenComplete(</span>
                    (value, ex) -&gt; {
<span class="fc bfc" id="L1127" title="All 4 branches covered.">                      if (ex == null &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L1128">                        result.complete(value);</span>
                        // Cancel others (best effort)
<span class="fc" id="L1130">                        futures.forEach(f -&gt; f.cancel(true));</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                      } else if (ex != null) {</span>
<span class="fc" id="L1132">                        synchronized (failures) {</span>
<span class="fc" id="L1133">                          failures.add(ex);</span>
<span class="pc bpc" id="L1134" title="1 of 4 branches missed.">                          if (failures.size() == paths.size() &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L1135">                            result.completeExceptionally(failures.getLast());</span>
                          }
<span class="fc" id="L1137">                        }</span>
                      }
<span class="fc" id="L1139">                    });</span>
<span class="fc" id="L1140">              }</span>

              try {
<span class="fc" id="L1143">                return result.get();</span>
<span class="fc" id="L1144">              } catch (InterruptedException e) {</span>
<span class="fc" id="L1145">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L1146">                throw new RuntimeException(&quot;Race interrupted&quot;, e);</span>
<span class="fc" id="L1147">              } catch (ExecutionException e) {</span>
<span class="fc" id="L1148">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L1150">                  throw re;</span>
                }
<span class="fc" id="L1152">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  // ===== Each-based Traversal Operations =====
  //
  // Performance Note: These methods use a two-pass approach:
  // 1. First pass: Collect all elements from the structure into an intermediate List
  // 2. Second pass: Apply the effectful function to each element with fail-fast semantics
  //
  // This approach was chosen to provide fail-fast behavior for Maybe/Either/Try - once a
  // failure is encountered, processing stops immediately without evaluating remaining elements.
  // However, the intermediate List allocation may be inefficient for very large structures.
  //
  // For traverseEachValidated, which accumulates all errors rather than failing fast, a
  // single-pass foldMap-based approach could avoid the intermediate allocation. This
  // optimization may be added in a future version.

  /**
   * Traverses a structure using an {@link org.higherkindedj.optics.Each} instance, applying a
   * MaybePath-returning function to each element.
   *
   * &lt;p&gt;This method extracts all elements from the structure using the Each instance, applies the
   * effectful function to each element, and collects the results. If any element produces Nothing,
   * the entire result is Nothing (fail-fast semantics).
   *
   * &lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; This method first collects all elements into an intermediate
   * list, then processes them. The fail-fast behavior means processing stops at the first Nothing,
   * but the initial element collection traverses the entire structure. For very large structures
   * where early failure is likely, consider streaming approaches or lazy evaluation patterns.
   *
   * &lt;pre&gt;{@code
   * // Validate all orders in a user's order list
   * Each&lt;List&lt;Order&gt;, Order&gt; listEach = EachInstances.listEach();
   * MaybePath&lt;List&lt;Order&gt;&gt; validated = PathOps.traverseEachMaybe(
   *     user.orders(),
   *     listEach,
   *     order -&gt; validateOrder(order)  // Returns MaybePath&lt;Order&gt;
   * );
   * }&lt;/pre&gt;
   *
   * @param structure the structure to traverse; must not be null
   * @param each the Each instance for extracting elements; must not be null
   * @param f the function to apply to each element; must not be null
   * @param &lt;S&gt; the structure type
   * @param &lt;A&gt; the element type
   * @return a MaybePath containing a list of results, or Nothing if any element fails
   * @throws NullPointerException if any argument is null
   */
  public static &lt;S, A&gt; MaybePath&lt;List&lt;A&gt;&gt; traverseEachMaybe(
      S structure, Each&lt;S, A&gt; each, Function&lt;A, MaybePath&lt;A&gt;&gt; f) {
<span class="fc" id="L1204">    Objects.requireNonNull(structure, &quot;structure must not be null&quot;);</span>
<span class="fc" id="L1205">    Objects.requireNonNull(each, &quot;each must not be null&quot;);</span>
<span class="fc" id="L1206">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L1208">    List&lt;A&gt; elements = Traversals.getAll(each.each(), structure);</span>
<span class="fc" id="L1209">    return traverseMaybe(elements, f);</span>
  }

  /**
   * Traverses a structure using an {@link org.higherkindedj.optics.Each} instance, applying an
   * EitherPath-returning function to each element.
   *
   * &lt;p&gt;If any element produces a Left error, the entire result is that Left error (fail-fast
   * semantics).
   *
   * &lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; This method first collects all elements into an intermediate
   * list, then processes them. The fail-fast behavior means processing stops at the first Left, but
   * the initial element collection traverses the entire structure. For very large structures where
   * early failure is likely, consider streaming approaches or lazy evaluation patterns.
   *
   * &lt;pre&gt;{@code
   * Each&lt;List&lt;Order&gt;, Order&gt; listEach = EachInstances.listEach();
   * EitherPath&lt;String, List&lt;Order&gt;&gt; result = PathOps.traverseEachEither(
   *     user.orders(),
   *     listEach,
   *     order -&gt; processOrder(order)  // Returns EitherPath&lt;String, Order&gt;
   * );
   * }&lt;/pre&gt;
   *
   * @param structure the structure to traverse; must not be null
   * @param each the Each instance for extracting elements; must not be null
   * @param f the function to apply to each element; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;S&gt; the structure type
   * @param &lt;A&gt; the element type
   * @return an EitherPath containing a list of results, or the first error
   * @throws NullPointerException if any argument is null
   */
  public static &lt;E, S, A&gt; EitherPath&lt;E, List&lt;A&gt;&gt; traverseEachEither(
      S structure, Each&lt;S, A&gt; each, Function&lt;A, EitherPath&lt;E, A&gt;&gt; f) {
<span class="fc" id="L1244">    Objects.requireNonNull(structure, &quot;structure must not be null&quot;);</span>
<span class="fc" id="L1245">    Objects.requireNonNull(each, &quot;each must not be null&quot;);</span>
<span class="fc" id="L1246">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L1248">    List&lt;A&gt; elements = Traversals.getAll(each.each(), structure);</span>
<span class="fc" id="L1249">    return traverseEither(elements, f);</span>
  }

  /**
   * Traverses a structure using an {@link org.higherkindedj.optics.Each} instance, applying a
   * ValidationPath-returning function to each element with error accumulation.
   *
   * &lt;p&gt;Unlike {@link #traverseEachEither}, this method accumulates all errors using the provided
   * Semigroup instead of failing on the first error. All elements are processed regardless of
   * earlier failures.
   *
   * &lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; This method first collects all elements into an intermediate
   * list, then processes them. Since error accumulation requires processing all elements anyway, a
   * future optimization could use a single-pass foldMap approach with a suitable Monoid to avoid
   * the intermediate list allocation for very large structures.
   *
   * &lt;pre&gt;{@code
   * Each&lt;List&lt;Order&gt;, Order&gt; listEach = EachInstances.listEach();
   * Semigroup&lt;List&lt;String&gt;&gt; errorSemigroup = Semigroups.listConcat();
   *
   * ValidationPath&lt;List&lt;String&gt;, List&lt;Order&gt;&gt; result = PathOps.traverseEachValidated(
   *     user.orders(),
   *     listEach,
   *     order -&gt; validateOrder(order),  // Returns ValidationPath&lt;List&lt;String&gt;, Order&gt;
   *     errorSemigroup
   * );
   * // Result contains all validation errors if any, or all valid orders
   * }&lt;/pre&gt;
   *
   * @param structure the structure to traverse; must not be null
   * @param each the Each instance for extracting elements; must not be null
   * @param f the function to apply to each element; must not be null
   * @param semigroup the Semigroup for accumulating errors; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;S&gt; the structure type
   * @param &lt;A&gt; the element type
   * @return a ValidationPath containing a list of results, or all accumulated errors
   * @throws NullPointerException if any argument is null
   */
  public static &lt;E, S, A&gt; ValidationPath&lt;E, List&lt;A&gt;&gt; traverseEachValidated(
      S structure, Each&lt;S, A&gt; each, Function&lt;A, ValidationPath&lt;E, A&gt;&gt; f, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L1290">    Objects.requireNonNull(structure, &quot;structure must not be null&quot;);</span>
<span class="fc" id="L1291">    Objects.requireNonNull(each, &quot;each must not be null&quot;);</span>
<span class="fc" id="L1292">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L1293">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>

<span class="fc" id="L1295">    List&lt;A&gt; elements = Traversals.getAll(each.each(), structure);</span>
<span class="fc" id="L1296">    return traverseValidated(elements, f, semigroup);</span>
  }

  /**
   * Traverses a structure using an {@link org.higherkindedj.optics.Each} instance, applying a
   * TryPath-returning function to each element.
   *
   * &lt;p&gt;If any element throws an exception, the entire result is that failure (fail-fast semantics).
   *
   * &lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; This method first collects all elements into an intermediate
   * list, then processes them. The fail-fast behavior means processing stops at the first failure,
   * but the initial element collection traverses the entire structure. For very large structures
   * where early failure is likely, consider streaming approaches or lazy evaluation patterns.
   *
   * &lt;pre&gt;{@code
   * Each&lt;List&lt;Order&gt;, Order&gt; listEach = EachInstances.listEach();
   * TryPath&lt;List&lt;Order&gt;&gt; result = PathOps.traverseEachTry(
   *     user.orders(),
   *     listEach,
   *     order -&gt; processOrderUnsafe(order)  // Returns TryPath&lt;Order&gt;
   * );
   * }&lt;/pre&gt;
   *
   * @param structure the structure to traverse; must not be null
   * @param each the Each instance for extracting elements; must not be null
   * @param f the function to apply to each element; must not be null
   * @param &lt;S&gt; the structure type
   * @param &lt;A&gt; the element type
   * @return a TryPath containing a list of results, or the first failure
   * @throws NullPointerException if any argument is null
   */
  public static &lt;S, A&gt; TryPath&lt;List&lt;A&gt;&gt; traverseEachTry(
      S structure, Each&lt;S, A&gt; each, Function&lt;A, TryPath&lt;A&gt;&gt; f) {
<span class="fc" id="L1329">    Objects.requireNonNull(structure, &quot;structure must not be null&quot;);</span>
<span class="fc" id="L1330">    Objects.requireNonNull(each, &quot;each must not be null&quot;);</span>
<span class="fc" id="L1331">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L1333">    List&lt;A&gt; elements = Traversals.getAll(each.each(), structure);</span>
<span class="fc" id="L1334">    return traverseTry(elements, f);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>