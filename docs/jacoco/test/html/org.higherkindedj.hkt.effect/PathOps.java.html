<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathOps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">PathOps.java</span></div><h1>PathOps.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.higherkindedj.hkt.Semigroup;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.function.Function4;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;

/**
 * Utility operations for working with Path types.
 *
 * &lt;p&gt;Provides common functional programming patterns like sequence and traverse that operate across
 * collections of Path values. These operations allow you to transform and combine multiple paths
 * efficiently.
 *
 * &lt;h2&gt;Sequence Operations&lt;/h2&gt;
 *
 * &lt;p&gt;Sequence transforms a list of paths into a path of list:
 *
 * &lt;pre&gt;{@code
 * List&lt;MaybePath&lt;Integer&gt;&gt; paths = List.of(Path.just(1), Path.just(2), Path.just(3));
 * MaybePath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceMaybe(paths);
 * // result = Just([1, 2, 3])
 *
 * List&lt;MaybePath&lt;Integer&gt;&gt; withNothing = List.of(Path.just(1), Path.nothing(), Path.just(3));
 * MaybePath&lt;List&lt;Integer&gt;&gt; emptyResult = PathOps.sequenceMaybe(withNothing);
 * // emptyResult = Nothing
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Traverse Operations&lt;/h2&gt;
 *
 * &lt;p&gt;Traverse combines map and sequence in one operation:
 *
 * &lt;pre&gt;{@code
 * List&lt;Integer&gt; ids = List.of(1, 2, 3);
 * MaybePath&lt;List&lt;User&gt;&gt; users = PathOps.traverseMaybe(ids, id -&gt; userRepo.findById(id));
 * // returns Just([user1, user2, user3]) if all found, Nothing otherwise
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Error Handling&lt;/h2&gt;
 *
 * &lt;p&gt;Different path types handle errors differently:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code MaybePath}: Returns Nothing if any element is Nothing
 *   &lt;li&gt;{@code EitherPath}: Returns first Left error
 *   &lt;li&gt;{@code ValidationPath}: Accumulates all errors using the provided Semigroup
 *   &lt;li&gt;{@code TryPath}: Returns first failure
 * &lt;/ul&gt;
 *
 * @see MaybePath
 * @see EitherPath
 * @see ValidationPath
 * @see TryPath
 */
public final class PathOps {

  private PathOps() {
    // Utility class - no instantiation
  }

  // ===== MaybePath Operations =====

  /**
   * Converts a list of MaybePaths into a MaybePath of list.
   *
   * &lt;p&gt;If all paths contain values, returns a path containing the list of values. If any path is
   * Nothing, returns Nothing.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a MaybePath containing a list, or Nothing if any path is Nothing
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; MaybePath&lt;List&lt;A&gt;&gt; sequenceMaybe(List&lt;MaybePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L89">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L91">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">    for (MaybePath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L93">      Maybe&lt;A&gt; maybe = path.run();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">      if (maybe.isNothing()) {</span>
<span class="fc" id="L95">        return new MaybePath&lt;&gt;(Maybe.nothing());</span>
      }
<span class="fc" id="L97">      results.add(maybe.get());</span>
<span class="fc" id="L98">    }</span>
<span class="fc" id="L99">    return new MaybePath&lt;&gt;(Maybe.just(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * &lt;p&gt;This is equivalent to mapping the function over the list, then sequencing the results, but
   * potentially more efficient.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a MaybePath containing a list, or Nothing if any application fails
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; MaybePath&lt;List&lt;B&gt;&gt; traverseMaybe(
      List&lt;A&gt; items, Function&lt;A, MaybePath&lt;B&gt;&gt; f) {
<span class="fc" id="L117">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L118">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L120">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L122">      MaybePath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L123">      Maybe&lt;B&gt; maybe = path.run();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">      if (maybe.isNothing()) {</span>
<span class="fc" id="L125">        return new MaybePath&lt;&gt;(Maybe.nothing());</span>
      }
<span class="fc" id="L127">      results.add(maybe.get());</span>
<span class="fc" id="L128">    }</span>
<span class="fc" id="L129">    return new MaybePath&lt;&gt;(Maybe.just(results));</span>
  }

  // ===== EitherPath Operations =====

  /**
   * Converts a list of EitherPaths into an EitherPath of list.
   *
   * &lt;p&gt;If all paths are Right, returns a path containing the list of values. If any path is Left,
   * returns the first Left error encountered.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the element type
   * @return an EitherPath containing a list, or the first error
   * @throws NullPointerException if paths is null
   */
  public static &lt;E, A&gt; EitherPath&lt;E, List&lt;A&gt;&gt; sequenceEither(List&lt;EitherPath&lt;E, A&gt;&gt; paths) {
<span class="fc" id="L147">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L149">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    for (EitherPath&lt;E, A&gt; path : paths) {</span>
<span class="fc" id="L151">      Either&lt;E, A&gt; either = path.run();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">      if (either.isLeft()) {</span>
<span class="fc" id="L153">        return new EitherPath&lt;&gt;(Either.left(either.getLeft()));</span>
      }
<span class="fc" id="L155">      results.add(either.getRight());</span>
<span class="fc" id="L156">    }</span>
<span class="fc" id="L157">    return new EitherPath&lt;&gt;(Either.right(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return an EitherPath containing a list, or the first error
   * @throws NullPointerException if items or f is null
   */
  public static &lt;E, A, B&gt; EitherPath&lt;E, List&lt;B&gt;&gt; traverseEither(
      List&lt;A&gt; items, Function&lt;A, EitherPath&lt;E, B&gt;&gt; f) {
<span class="fc" id="L173">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L174">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L176">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L178">      EitherPath&lt;E, B&gt; path = f.apply(item);</span>
<span class="fc" id="L179">      Either&lt;E, B&gt; either = path.run();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">      if (either.isLeft()) {</span>
<span class="fc" id="L181">        return new EitherPath&lt;&gt;(Either.left(either.getLeft()));</span>
      }
<span class="fc" id="L183">      results.add(either.getRight());</span>
<span class="fc" id="L184">    }</span>
<span class="fc" id="L185">    return new EitherPath&lt;&gt;(Either.right(results));</span>
  }

  // ===== ValidationPath Operations =====

  /**
   * Converts a list of ValidationPaths into a ValidationPath of list.
   *
   * &lt;p&gt;If all paths are Valid, returns a path containing the list of values. If any paths are
   * Invalid, accumulates all errors using the provided Semigroup.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the element type
   * @return a ValidationPath containing a list, or all accumulated errors
   * @throws NullPointerException if paths or semigroup is null
   */
  public static &lt;E, A&gt; ValidationPath&lt;E, List&lt;A&gt;&gt; sequenceValidated(
      List&lt;ValidationPath&lt;E, A&gt;&gt; paths, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L205">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc" id="L206">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>

<span class="fc" id="L208">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc" id="L209">    E accumulatedErrors = null;</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">    for (ValidationPath&lt;E, A&gt; path : paths) {</span>
<span class="fc" id="L212">      Validated&lt;E, A&gt; validated = path.run();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">      if (validated.isValid()) {</span>
<span class="fc" id="L214">        results.add(validated.get());</span>
      } else {
<span class="fc" id="L216">        E error = validated.getError();</span>
        accumulatedErrors =
<span class="fc bfc" id="L218" title="All 2 branches covered.">            accumulatedErrors == null ? error : semigroup.combine(accumulatedErrors, error);</span>
      }
<span class="fc" id="L220">    }</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (accumulatedErrors != null) {</span>
<span class="fc" id="L223">      return new ValidationPath&lt;&gt;(Validated.invalid(accumulatedErrors), semigroup);</span>
    }
<span class="fc" id="L225">    return new ValidationPath&lt;&gt;(Validated.valid(results), semigroup);</span>
  }

  /**
   * Maps a function over a list and sequences the results, accumulating errors.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param semigroup the Semigroup for error accumulation; must not be null
   * @param &lt;E&gt; the error type
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a ValidationPath containing a list, or all accumulated errors
   * @throws NullPointerException if any argument is null
   */
  public static &lt;E, A, B&gt; ValidationPath&lt;E, List&lt;B&gt;&gt; traverseValidated(
      List&lt;A&gt; items, Function&lt;A, ValidationPath&lt;E, B&gt;&gt; f, Semigroup&lt;E&gt; semigroup) {
<span class="fc" id="L242">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L243">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L244">    Objects.requireNonNull(semigroup, &quot;semigroup must not be null&quot;);</span>

<span class="fc" id="L246">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc" id="L247">    E accumulatedErrors = null;</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L250">      ValidationPath&lt;E, B&gt; path = f.apply(item);</span>
<span class="fc" id="L251">      Validated&lt;E, B&gt; validated = path.run();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">      if (validated.isValid()) {</span>
<span class="fc" id="L253">        results.add(validated.get());</span>
      } else {
<span class="fc" id="L255">        E error = validated.getError();</span>
        accumulatedErrors =
<span class="fc bfc" id="L257" title="All 2 branches covered.">            accumulatedErrors == null ? error : semigroup.combine(accumulatedErrors, error);</span>
      }
<span class="fc" id="L259">    }</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">    if (accumulatedErrors != null) {</span>
<span class="fc" id="L262">      return new ValidationPath&lt;&gt;(Validated.invalid(accumulatedErrors), semigroup);</span>
    }
<span class="fc" id="L264">    return new ValidationPath&lt;&gt;(Validated.valid(results), semigroup);</span>
  }

  // ===== TryPath Operations =====

  /**
   * Converts a list of TryPaths into a TryPath of list.
   *
   * &lt;p&gt;If all paths are Success, returns a path containing the list of values. If any path fails,
   * returns the first failure encountered.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a TryPath containing a list, or the first failure
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; TryPath&lt;List&lt;A&gt;&gt; sequenceTry(List&lt;TryPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L281">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L283">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">    for (TryPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L285">      Try&lt;A&gt; tryValue = path.run();</span>
      // Use fold to safely extract value or return failure
<span class="fc" id="L287">      TryPath&lt;List&lt;A&gt;&gt; maybeFailure =</span>
<span class="fc" id="L288">          tryValue.fold(</span>
              a -&gt; {
<span class="fc" id="L290">                results.add(a);</span>
<span class="fc" id="L291">                return null; // continue processing</span>
              },
<span class="fc" id="L293">              ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">      if (maybeFailure != null) {</span>
<span class="fc" id="L295">        return maybeFailure;</span>
      }
<span class="fc" id="L297">    }</span>
<span class="fc" id="L298">    return new TryPath&lt;&gt;(Try.success(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a TryPath containing a list, or the first failure
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; TryPath&lt;List&lt;B&gt;&gt; traverseTry(List&lt;A&gt; items, Function&lt;A, TryPath&lt;B&gt;&gt; f) {
<span class="fc" id="L312">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L313">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L315">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L317">      TryPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L318">      Try&lt;B&gt; tryValue = path.run();</span>
      // Use fold to safely extract value or return failure
<span class="fc" id="L320">      TryPath&lt;List&lt;B&gt;&gt; maybeFailure =</span>
<span class="fc" id="L321">          tryValue.fold(</span>
              b -&gt; {
<span class="fc" id="L323">                results.add(b);</span>
<span class="fc" id="L324">                return null; // continue processing</span>
              },
<span class="fc" id="L326">              ex -&gt; new TryPath&lt;&gt;(Try.failure(ex)));</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (maybeFailure != null) {</span>
<span class="fc" id="L328">        return maybeFailure;</span>
      }
<span class="fc" id="L330">    }</span>
<span class="fc" id="L331">    return new TryPath&lt;&gt;(Try.success(results));</span>
  }

  /**
   * Returns the first successful path, or the last failure if all fail.
   *
   * &lt;p&gt;This is useful for trying multiple fallback strategies until one succeeds.
   *
   * @param paths the paths to try; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return the first successful path, or the last failure
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; TryPath&lt;A&gt; firstSuccess(List&lt;TryPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L346">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L348">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc" id="L351">    TryPath&lt;A&gt; lastFailure = null;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    for (TryPath&lt;A&gt; path : paths) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (path.run().isSuccess()) {</span>
<span class="fc" id="L354">        return path;</span>
      }
<span class="fc" id="L356">      lastFailure = path;</span>
<span class="fc" id="L357">    }</span>
<span class="fc" id="L358">    return lastFailure;</span>
  }

  // ===== OptionalPath Operations =====

  /**
   * Converts a list of OptionalPaths into an OptionalPath of list.
   *
   * &lt;p&gt;If all paths contain values, returns a path containing the list of values. If any path is
   * empty, returns empty.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return an OptionalPath containing a list, or empty if any path is empty
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; OptionalPath&lt;List&lt;A&gt;&gt; sequenceOptional(List&lt;OptionalPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L375">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc" id="L377">    List&lt;A&gt; results = new ArrayList&lt;&gt;(paths.size());</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">    for (OptionalPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L379">      Optional&lt;A&gt; optional = path.run();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (optional.isEmpty()) {</span>
<span class="fc" id="L381">        return new OptionalPath&lt;&gt;(Optional.empty());</span>
      }
<span class="fc" id="L383">      results.add(optional.get());</span>
<span class="fc" id="L384">    }</span>
<span class="fc" id="L385">    return new OptionalPath&lt;&gt;(Optional.of(results));</span>
  }

  /**
   * Maps a function over a list and sequences the results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return an OptionalPath containing a list, or empty if any application returns empty
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; OptionalPath&lt;List&lt;B&gt;&gt; traverseOptional(
      List&lt;A&gt; items, Function&lt;A, OptionalPath&lt;B&gt;&gt; f) {
<span class="fc" id="L400">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L401">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc" id="L403">    List&lt;B&gt; results = new ArrayList&lt;&gt;(items.size());</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L405">      OptionalPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L406">      Optional&lt;B&gt; optional = path.run();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">      if (optional.isEmpty()) {</span>
<span class="fc" id="L408">        return new OptionalPath&lt;&gt;(Optional.empty());</span>
      }
<span class="fc" id="L410">      results.add(optional.get());</span>
<span class="fc" id="L411">    }</span>
<span class="fc" id="L412">    return new OptionalPath&lt;&gt;(Optional.of(results));</span>
  }

  // ===== NonDetPath Operations =====

  /**
   * Converts a list of NonDetPaths into a NonDetPath of list (Cartesian product).
   *
   * &lt;p&gt;This operation produces all possible combinations of elements from each path. The result is
   * the Cartesian product of all inner lists.
   *
   * &lt;pre&gt;{@code
   * List&lt;NonDetPath&lt;Integer&gt;&gt; paths = List.of(
   *     NonDetPath.of(List.of(1, 2)),
   *     NonDetPath.of(List.of(3, 4))
   * );
   * NonDetPath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceNonDet(paths);
   * // result.run() = [[1,3], [1,4], [2,3], [2,4]]
   * }&lt;/pre&gt;
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a NonDetPath containing all combinations
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; NonDetPath&lt;List&lt;A&gt;&gt; sequenceNonDet(List&lt;NonDetPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L438">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L440" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L441">      return NonDetPath.of(List.of(List.of()));</span>
    }

    // Start with a list containing a single empty list
<span class="fc" id="L445">    NonDetPath&lt;List&lt;A&gt;&gt; result = NonDetPath.pure(new ArrayList&lt;&gt;());</span>

<span class="fc bfc" id="L447" title="All 2 branches covered.">    for (NonDetPath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L448">      result =</span>
<span class="fc" id="L449">          result.via(</span>
              acc -&gt;
<span class="fc" id="L451">                  path.map(</span>
                      a -&gt; {
<span class="fc" id="L453">                        List&lt;A&gt; newAcc = new ArrayList&lt;&gt;(acc);</span>
<span class="fc" id="L454">                        newAcc.add(a);</span>
<span class="fc" id="L455">                        return newAcc;</span>
                      }));
<span class="fc" id="L457">    }</span>

<span class="fc" id="L459">    return result;</span>
  }

  /**
   * Maps a function over a list and sequences the results (Cartesian product).
   *
   * &lt;p&gt;Applies the function to each element and produces all possible combinations of results.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a NonDetPath containing all combinations
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; NonDetPath&lt;List&lt;B&gt;&gt; traverseNonDet(
      List&lt;A&gt; items, Function&lt;A, NonDetPath&lt;B&gt;&gt; f) {
<span class="fc" id="L476">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L477">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L480">      return NonDetPath.of(List.of(List.of()));</span>
    }

<span class="fc" id="L483">    NonDetPath&lt;List&lt;B&gt;&gt; result = NonDetPath.pure(new ArrayList&lt;&gt;());</span>

<span class="fc bfc" id="L485" title="All 2 branches covered.">    for (A item : items) {</span>
<span class="fc" id="L486">      NonDetPath&lt;B&gt; path = f.apply(item);</span>
<span class="fc" id="L487">      result =</span>
<span class="fc" id="L488">          result.via(</span>
              acc -&gt;
<span class="fc" id="L490">                  path.map(</span>
                      b -&gt; {
<span class="fc" id="L492">                        List&lt;B&gt; newAcc = new ArrayList&lt;&gt;(acc);</span>
<span class="fc" id="L493">                        newAcc.add(b);</span>
<span class="fc" id="L494">                        return newAcc;</span>
                      }));
<span class="fc" id="L496">    }</span>

<span class="fc" id="L498">    return result;</span>
  }

  /**
   * Flattens a NonDetPath of NonDetPaths into a single NonDetPath.
   *
   * &lt;p&gt;Concatenates all inner lists.
   *
   * @param nested the nested NonDetPath to flatten; must not be null
   * @param &lt;A&gt; the element type
   * @return a flattened NonDetPath
   * @throws NullPointerException if nested is null
   */
  public static &lt;A&gt; NonDetPath&lt;A&gt; flatten(NonDetPath&lt;NonDetPath&lt;A&gt;&gt; nested) {
<span class="fc" id="L512">    Objects.requireNonNull(nested, &quot;nested must not be null&quot;);</span>

<span class="fc" id="L514">    List&lt;A&gt; flattened =</span>
<span class="fc" id="L515">        nested.run().stream().flatMap(innerPath -&gt; innerPath.run().stream()).toList();</span>

<span class="fc" id="L517">    return NonDetPath.of(flattened);</span>
  }

  // ===== ListPath Operations =====

  /**
   * Converts a list of ListPaths into a ListPath of lists using positional zipping.
   *
   * &lt;p&gt;Unlike {@link #sequenceNonDet}, which produces a Cartesian product, this method transposes
   * the list of lists, pairing elements at corresponding positions.
   *
   * &lt;pre&gt;{@code
   * List&lt;ListPath&lt;Integer&gt;&gt; paths = List.of(
   *     ListPath.of(1, 2, 3),
   *     ListPath.of(4, 5, 6)
   * );
   * ListPath&lt;List&lt;Integer&gt;&gt; result = PathOps.sequenceListPath(paths);
   * // result.run() = [[1, 4], [2, 5], [3, 6]]
   * }&lt;/pre&gt;
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a ListPath containing lists of corresponding elements
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; ListPath&lt;List&lt;A&gt;&gt; sequenceListPath(List&lt;ListPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L543">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L546">      return ListPath.of(List.of(List.of()));</span>
    }

    // Find the minimum size among all lists
<span class="fc" id="L550">    int minSize = paths.stream().mapToInt(ListPath::size).min().orElse(0);</span>

    // Transpose: collect element at position i from each list
<span class="fc" id="L553">    List&lt;List&lt;A&gt;&gt; result = new ArrayList&lt;&gt;(minSize);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">    for (int i = 0; i &lt; minSize; i++) {</span>
<span class="fc" id="L555">      final int index = i;</span>
<span class="fc" id="L556">      List&lt;A&gt; row = paths.stream().map(path -&gt; path.run().get(index)).toList();</span>
<span class="fc" id="L557">      result.add(row);</span>
    }

<span class="fc" id="L560">    return ListPath.of(result);</span>
  }

  /**
   * Applies a function to each item and sequences the results positionally.
   *
   * &lt;pre&gt;{@code
   * List&lt;String&gt; items = List.of(&quot;a&quot;, &quot;b&quot;);
   * ListPath&lt;List&lt;String&gt;&gt; result = PathOps.traverseListPath(
   *     items,
   *     s -&gt; ListPath.of(s.toUpperCase(), s + s)
   * );
   * // result.run() = [[&quot;A&quot;, &quot;aa&quot;], [&quot;B&quot;, &quot;bb&quot;]]
   * }&lt;/pre&gt;
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply to each item; must not be null
   * @param &lt;A&gt; the input item type
   * @param &lt;B&gt; the element type of the resulting ListPaths
   * @return a ListPath of lists containing corresponding transformed elements
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; ListPath&lt;List&lt;B&gt;&gt; traverseListPath(
      List&lt;A&gt; items, Function&lt;A, ListPath&lt;B&gt;&gt; f) {
<span class="fc" id="L584">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L585">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L587" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L588">      return ListPath.of(List.of(List.of()));</span>
    }

<span class="fc" id="L591">    List&lt;ListPath&lt;B&gt;&gt; mapped = items.stream().map(f).toList();</span>
<span class="fc" id="L592">    return sequenceListPath(mapped);</span>
  }

  /**
   * Flattens a ListPath of ListPaths by concatenating all inner lists.
   *
   * @param nested the nested ListPath to flatten; must not be null
   * @param &lt;A&gt; the element type
   * @return a flattened ListPath
   * @throws NullPointerException if nested is null
   */
  public static &lt;A&gt; ListPath&lt;A&gt; flattenListPath(ListPath&lt;ListPath&lt;A&gt;&gt; nested) {
<span class="fc" id="L604">    Objects.requireNonNull(nested, &quot;nested must not be null&quot;);</span>

<span class="fc" id="L606">    List&lt;A&gt; flattened =</span>
<span class="fc" id="L607">        nested.run().stream().flatMap(innerPath -&gt; innerPath.run().stream()).toList();</span>

<span class="fc" id="L609">    return ListPath.of(flattened);</span>
  }

  /**
   * Zips a list of ListPaths element-wise, producing a ListPath of tuples (as lists).
   *
   * &lt;p&gt;This is similar to Python's {@code zip(*lists)} - it transposes rows and columns.
   *
   * @param paths the list of paths to zip; must not be null
   * @param &lt;A&gt; the element type
   * @return a ListPath where each element is a list of corresponding elements
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; ListPath&lt;List&lt;A&gt;&gt; zipAll(List&lt;ListPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L623">    return sequenceListPath(paths);</span>
  }

  // ===== CompletableFuturePath Operations =====

  /**
   * Converts a list of CompletableFuturePaths into a CompletableFuturePath of list.
   *
   * &lt;p&gt;Runs all futures concurrently and collects all results. If any future fails, the result
   * fails with that exception.
   *
   * @param paths the list of paths to sequence; must not be null
   * @param &lt;A&gt; the element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;List&lt;A&gt;&gt; sequenceFuture(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L641">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L644">      return CompletableFuturePath.completed(List.of());</span>
    }

<span class="fc" id="L647">    List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L648">        paths.stream().map(CompletableFuturePath::toCompletableFuture).collect(Collectors.toList());</span>

<span class="fc" id="L650">    CompletableFuture&lt;List&lt;A&gt;&gt; combined =</span>
<span class="fc" id="L651">        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L652">            .thenApply(_ -&gt; futures.stream().map(CompletableFuture::join).toList());</span>

<span class="fc" id="L654">    return CompletableFuturePath.fromFuture(combined);</span>
  }

  /**
   * Maps a function over a list and sequences the results concurrently.
   *
   * &lt;p&gt;Applies the function to each element concurrently and collects all results. If any
   * application fails, the result fails with that exception.
   *
   * @param items the items to traverse; must not be null
   * @param f the function to apply; must not be null
   * @param &lt;A&gt; the input element type
   * @param &lt;B&gt; the output element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if items or f is null
   */
  public static &lt;A, B&gt; CompletableFuturePath&lt;List&lt;B&gt;&gt; traverseFuture(
      List&lt;A&gt; items, Function&lt;A, CompletableFuturePath&lt;B&gt;&gt; f) {
<span class="fc" id="L672">    Objects.requireNonNull(items, &quot;items must not be null&quot;);</span>
<span class="fc" id="L673">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L676">      return CompletableFuturePath.completed(List.of());</span>
    }

<span class="fc" id="L679">    List&lt;CompletableFuture&lt;B&gt;&gt; futures =</span>
<span class="fc" id="L680">        items.stream()</span>
<span class="fc" id="L681">            .map(item -&gt; f.apply(item).toCompletableFuture())</span>
<span class="fc" id="L682">            .collect(Collectors.toList());</span>

<span class="fc" id="L684">    CompletableFuture&lt;List&lt;B&gt;&gt; combined =</span>
<span class="fc" id="L685">        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L686">            .thenApply(_ -&gt; futures.stream().map(CompletableFuture::join).toList());</span>

<span class="fc" id="L688">    return CompletableFuturePath.fromFuture(combined);</span>
  }

  /**
   * Returns the first successful future path, or the last failure if all fail.
   *
   * &lt;p&gt;Note: Unlike {@link #firstSuccess(List)} for TryPath, this races the futures concurrently
   * rather than trying them sequentially.
   *
   * @param paths the paths to race; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return the first completed successful path, or a path with the last exception
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; CompletableFuturePath&lt;A&gt; firstCompletedSuccess(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
<span class="fc" id="L705">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L707">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc bfc" id="L710" title="All 2 branches covered.">    if (paths.size() == 1) {</span>
<span class="fc" id="L711">      return paths.getFirst();</span>
    }

    // Use anyOf to race, but we need the first SUCCESS, not just first completion
    // This requires a more complex implementation
<span class="fc" id="L716">    CompletableFuture&lt;A&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L717">    List&lt;Throwable&gt; failures = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">    for (CompletableFuturePath&lt;A&gt; path : paths) {</span>
<span class="fc" id="L720">      path.toCompletableFuture()</span>
<span class="fc" id="L721">          .whenComplete(</span>
              (value, ex) -&gt; {
<span class="fc bfc" id="L723" title="All 4 branches covered.">                if (ex == null &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L724">                  result.complete(value);</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">                } else if (ex != null) {</span>
<span class="fc" id="L726">                  synchronized (failures) {</span>
<span class="fc" id="L727">                    failures.add(ex);</span>
<span class="pc bpc" id="L728" title="1 of 4 branches missed.">                    if (failures.size() == paths.size() &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L729">                      result.completeExceptionally(failures.getLast());</span>
                    }
<span class="fc" id="L731">                  }</span>
                }
<span class="fc" id="L733">              });</span>
<span class="fc" id="L734">    }</span>

<span class="fc" id="L736">    return CompletableFuturePath.fromFuture(result);</span>
  }

  // ===== Parallel IOPath Operations =====

  /**
   * Executes a list of IOPaths in parallel and collects results.
   *
   * &lt;p&gt;All IOPaths are executed concurrently using CompletableFuture. If any IOPath fails, the
   * result fails with that exception.
   *
   * @param paths the IOPaths to execute in parallel; must not be null
   * @param &lt;A&gt; the element type
   * @return an IOPath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; IOPath&lt;List&lt;A&gt;&gt; parSequenceIO(List&lt;IOPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L753">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>

<span class="fc bfc" id="L755" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L756">      return Path.ioPure(List.of());</span>
    }

<span class="fc" id="L759">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L760">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L762">              List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L763">                  paths.stream()</span>
<span class="fc" id="L764">                      .map(path -&gt; CompletableFuture.supplyAsync(path::unsafeRun))</span>
<span class="fc" id="L765">                      .collect(Collectors.toList());</span>

              try {
<span class="fc" id="L768">                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();</span>
<span class="fc" id="L769">                return futures.stream().map(CompletableFuture::join).toList();</span>
<span class="nc" id="L770">              } catch (InterruptedException e) {</span>
<span class="nc" id="L771">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L772">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L773">              } catch (ExecutionException e) {</span>
<span class="fc" id="L774">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L776">                  throw re;</span>
                }
<span class="nc" id="L778">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Executes a list of CompletableFuturePaths in parallel and collects results.
   *
   * &lt;p&gt;All futures run concurrently. If any fails, the result fails.
   *
   * @param paths the paths to execute; must not be null
   * @param &lt;A&gt; the element type
   * @return a CompletableFuturePath containing a list of all results
   * @throws NullPointerException if paths is null
   */
  public static &lt;A&gt; CompletableFuturePath&lt;List&lt;A&gt;&gt; parSequenceFuture(
      List&lt;CompletableFuturePath&lt;A&gt;&gt; paths) {
    // This already exists as sequenceFuture, which is already parallel
<span class="fc" id="L796">    return sequenceFuture(paths);</span>
  }

  /**
   * Combines three IOPaths in parallel.
   *
   * @param first the first IOPath; must not be null
   * @param second the second IOPath; must not be null
   * @param third the third IOPath; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;A&gt; the type of the first value
   * @param &lt;B&gt; the type of the second value
   * @param &lt;C&gt; the type of the third value
   * @param &lt;D&gt; the type of the combined result
   * @return an IOPath containing the combined result
   * @throws NullPointerException if any argument is null
   */
  public static &lt;A, B, C, D&gt; IOPath&lt;D&gt; parZip3(
      IOPath&lt;A&gt; first,
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L818">    Objects.requireNonNull(first, &quot;first must not be null&quot;);</span>
<span class="fc" id="L819">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L820">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L821">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L823">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L824">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L826">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(first::unsafeRun);</span>
<span class="fc" id="L827">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(second::unsafeRun);</span>
<span class="fc" id="L828">              CompletableFuture&lt;C&gt; futureC = CompletableFuture.supplyAsync(third::unsafeRun);</span>

              try {
<span class="fc" id="L831">                CompletableFuture.allOf(futureA, futureB, futureC).get();</span>
<span class="fc" id="L832">                return combiner.apply(futureA.join(), futureB.join(), futureC.join());</span>
<span class="nc" id="L833">              } catch (InterruptedException e) {</span>
<span class="nc" id="L834">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L835">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L836">              } catch (ExecutionException e) {</span>
<span class="fc" id="L837">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L839">                  throw re;</span>
                }
<span class="nc" id="L841">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Combines four IOPaths in parallel.
   *
   * @param first the first IOPath; must not be null
   * @param second the second IOPath; must not be null
   * @param third the third IOPath; must not be null
   * @param fourth the fourth IOPath; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;A&gt; the type of the first value
   * @param &lt;B&gt; the type of the second value
   * @param &lt;C&gt; the type of the third value
   * @param &lt;D&gt; the type of the fourth value
   * @param &lt;E&gt; the type of the combined result
   * @return an IOPath containing the combined result
   * @throws NullPointerException if any argument is null
   */
  public static &lt;A, B, C, D, E&gt; IOPath&lt;E&gt; parZip4(
      IOPath&lt;A&gt; first,
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      IOPath&lt;D&gt; fourth,
      Function4&lt;? super A, ? super B, ? super C, ? super D, ? extends E&gt; combiner) {
<span class="fc" id="L868">    Objects.requireNonNull(first, &quot;first must not be null&quot;);</span>
<span class="fc" id="L869">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L870">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L871">    Objects.requireNonNull(fourth, &quot;fourth must not be null&quot;);</span>
<span class="fc" id="L872">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L874">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L875">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L877">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(first::unsafeRun);</span>
<span class="fc" id="L878">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(second::unsafeRun);</span>
<span class="fc" id="L879">              CompletableFuture&lt;C&gt; futureC = CompletableFuture.supplyAsync(third::unsafeRun);</span>
<span class="fc" id="L880">              CompletableFuture&lt;D&gt; futureD = CompletableFuture.supplyAsync(fourth::unsafeRun);</span>

              try {
<span class="fc" id="L883">                CompletableFuture.allOf(futureA, futureB, futureC, futureD).get();</span>
<span class="fc" id="L884">                return combiner.apply(</span>
<span class="fc" id="L885">                    futureA.join(), futureB.join(), futureC.join(), futureD.join());</span>
<span class="nc" id="L886">              } catch (InterruptedException e) {</span>
<span class="nc" id="L887">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L888">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L889">              } catch (ExecutionException e) {</span>
<span class="fc" id="L890">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L892">                  throw re;</span>
                }
<span class="nc" id="L894">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Races multiple IOPaths, returning the first to complete successfully.
   *
   * &lt;p&gt;All IOPaths are executed concurrently. The first to complete successfully wins. If all fail,
   * the last failure is propagated.
   *
   * @param paths the IOPaths to race; must not be null or empty
   * @param &lt;A&gt; the element type
   * @return an IOPath that completes with the first successful result
   * @throws NullPointerException if paths is null
   * @throws IllegalArgumentException if paths is empty
   */
  public static &lt;A&gt; IOPath&lt;A&gt; raceIO(List&lt;IOPath&lt;A&gt;&gt; paths) {
<span class="fc" id="L912">    Objects.requireNonNull(paths, &quot;paths must not be null&quot;);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">    if (paths.isEmpty()) {</span>
<span class="fc" id="L914">      throw new IllegalArgumentException(&quot;paths must not be empty&quot;);</span>
    }

<span class="fc bfc" id="L917" title="All 2 branches covered.">    if (paths.size() == 1) {</span>
<span class="fc" id="L918">      return paths.getFirst();</span>
    }

<span class="fc" id="L921">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L922">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L924">              CompletableFuture&lt;A&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L925">              List&lt;Throwable&gt; failures = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L927">              List&lt;CompletableFuture&lt;A&gt;&gt; futures =</span>
<span class="fc" id="L928">                  paths.stream()</span>
<span class="fc" id="L929">                      .map(path -&gt; CompletableFuture.supplyAsync(path::unsafeRun))</span>
<span class="fc" id="L930">                      .toList();</span>

<span class="fc bfc" id="L932" title="All 2 branches covered.">              for (CompletableFuture&lt;A&gt; future : futures) {</span>
<span class="fc" id="L933">                future.whenComplete(</span>
                    (value, ex) -&gt; {
<span class="pc bpc" id="L935" title="1 of 4 branches missed.">                      if (ex == null &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L936">                        result.complete(value);</span>
                        // Cancel others (best effort)
<span class="fc" id="L938">                        futures.forEach(f -&gt; f.cancel(true));</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">                      } else if (ex != null) {</span>
<span class="fc" id="L940">                        synchronized (failures) {</span>
<span class="fc" id="L941">                          failures.add(ex);</span>
<span class="pc bpc" id="L942" title="1 of 4 branches missed.">                          if (failures.size() == paths.size() &amp;&amp; !result.isDone()) {</span>
<span class="fc" id="L943">                            result.completeExceptionally(failures.getLast());</span>
                          }
<span class="fc" id="L945">                        }</span>
                      }
<span class="fc" id="L947">                    });</span>
<span class="fc" id="L948">              }</span>

              try {
<span class="fc" id="L951">                return result.get();</span>
<span class="nc" id="L952">              } catch (InterruptedException e) {</span>
<span class="nc" id="L953">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L954">                throw new RuntimeException(&quot;Race interrupted&quot;, e);</span>
<span class="fc" id="L955">              } catch (ExecutionException e) {</span>
<span class="fc" id="L956">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L958">                  throw re;</span>
                }
<span class="nc" id="L960">                throw new RuntimeException(cause);</span>
              }
            }));
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>