<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NaturalTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">NaturalTransformation.java</span></div><h1>NaturalTransformation.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import org.higherkindedj.hkt.Kind;

/**
 * A natural transformation from functor F to functor G.
 *
 * &lt;p&gt;Natural transformations allow converting computations from one effect type to another while
 * preserving structure. This is the categorical concept of a morphism between functors.
 *
 * &lt;h2&gt;Laws&lt;/h2&gt;
 *
 * &lt;p&gt;For a natural transformation {@code nt: F ~&gt; G}, the following naturality law must hold for
 * all functions {@code f: A -&gt; B}:
 *
 * &lt;pre&gt;
 * nt.apply(fa.map(f)) == nt.apply(fa).map(f)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;In other words, it doesn't matter whether you transform first then map, or map first then
 * transform - the result is the same.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Converting between effect types (e.g., Maybe to Either)
 *   &lt;li&gt;Interpreting a DSL into a concrete implementation
 *   &lt;li&gt;Running tests with a different effect type than production
 *   &lt;li&gt;Adapting between library boundaries
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Convert Maybe to Either with a default error
 * NaturalTransformation&lt;MaybeKind.Witness, EitherKind.Witness&lt;String&gt;&gt; maybeToEither =
 *     new NaturalTransformation&lt;&gt;() {
 *         @Override
 *         public &lt;A&gt; Kind&lt;EitherKind.Witness&lt;String&gt;, A&gt; apply(Kind&lt;MaybeKind.Witness, A&gt; fa) {
 *             Maybe&lt;A&gt; maybe = MaybeKindHelper.narrow(fa);
 *             return maybe.isJust()
 *                 ? EitherKind.widen(Either.right(maybe.get()))
 *                 : EitherKind.widen(Either.left(&quot;Value was Nothing&quot;));
 *         }
 *     };
 *
 * // Use with GenericPath
 * GenericPath&lt;MaybeKind.Witness, User&gt; userPath = ...;
 * GenericPath&lt;EitherKind.Witness&lt;String&gt;, User&gt; eitherPath =
 *     userPath.mapK(maybeToEither, eitherMonad);
 * }&lt;/pre&gt;
 *
 * @param &lt;F&gt; the source witness type
 * @param &lt;G&gt; the target witness type
 */
@FunctionalInterface
public interface NaturalTransformation&lt;F, G&gt; {

  /**
   * Applies this natural transformation to a Kind value.
   *
   * @param fa the source Kind value; must not be null
   * @param &lt;A&gt; the value type
   * @return the transformed Kind value
   */
  &lt;A&gt; Kind&lt;G, A&gt; apply(Kind&lt;F, A&gt; fa);

  /**
   * Composes this natural transformation with another.
   *
   * &lt;p&gt;The resulting transformation first applies this transformation, then the {@code after}
   * transformation.
   *
   * @param after the transformation to apply after this one; must not be null
   * @param &lt;H&gt; the final target witness type
   * @return a composed natural transformation
   */
  default &lt;H&gt; NaturalTransformation&lt;F, H&gt; andThen(NaturalTransformation&lt;G, H&gt; after) {
<span class="fc" id="L81">    return new NaturalTransformation&lt;&gt;() {</span>
      @Override
      public &lt;A&gt; Kind&lt;H, A&gt; apply(Kind&lt;F, A&gt; fa) {
<span class="fc" id="L84">        return after.apply(NaturalTransformation.this.apply(fa));</span>
      }
    };
  }

  /**
   * Composes this natural transformation with another applied before this one.
   *
   * &lt;p&gt;The resulting transformation first applies the {@code before} transformation, then this
   * transformation.
   *
   * @param before the transformation to apply before this one; must not be null
   * @param &lt;E&gt; the initial source witness type
   * @return a composed natural transformation
   */
  default &lt;E&gt; NaturalTransformation&lt;E, G&gt; compose(NaturalTransformation&lt;E, F&gt; before) {
<span class="fc" id="L100">    return new NaturalTransformation&lt;&gt;() {</span>
      @Override
      public &lt;A&gt; Kind&lt;G, A&gt; apply(Kind&lt;E, A&gt; ea) {
<span class="fc" id="L103">        return NaturalTransformation.this.apply(before.apply(ea));</span>
      }
    };
  }

  /**
   * Returns the identity natural transformation that returns its input unchanged.
   *
   * @param &lt;F&gt; the witness type
   * @return the identity natural transformation
   */
  static &lt;F&gt; NaturalTransformation&lt;F, F&gt; identity() {
<span class="fc" id="L115">    return new NaturalTransformation&lt;&gt;() {</span>
      @Override
      public &lt;A&gt; Kind&lt;F, A&gt; apply(Kind&lt;F, A&gt; fa) {
<span class="fc" id="L118">        return fa;</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>