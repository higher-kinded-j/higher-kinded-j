<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">IOPath.java</span></div><h1>IOPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.effect.capability.Effectful;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.resilience.Retry;
import org.higherkindedj.hkt.resilience.RetryPolicy;

/**
 * A fluent path wrapper for {@link IO} values.
 *
 * &lt;p&gt;{@code IOPath} provides a chainable API for composing deferred side-effecting computations. It
 * implements {@link Effectful} to provide methods for executing the deferred computation.
 *
 * &lt;h2&gt;Creating IOPath instances&lt;/h2&gt;
 *
 * &lt;p&gt;Use the {@link Path} factory class to create instances:
 *
 * &lt;pre&gt;{@code
 * IOPath&lt;String&gt; path = Path.io(() -&gt; Files.readString(file));
 * IOPath&lt;Unit&gt; action = Path.ioRunnable(() -&gt; System.out.println(&quot;Hello&quot;));
 * IOPath&lt;Integer&gt; pure = Path.ioPure(42);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;p&gt;IOPath operations are lazy - they describe a computation but don't execute it until {@link
 * #unsafeRun()} or {@link #runSafe()} is called.
 *
 * &lt;pre&gt;{@code
 * IOPath&lt;Config&gt; config = Path.io(() -&gt; readConfigFile())
 *     .map(Config::parse)
 *     .via(c -&gt; Path.io(() -&gt; validate(c)));
 *
 * // Nothing has happened yet!
 * Config result = config.unsafeRun();  // Now the computation runs
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Executing the computation&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Unsafe - exceptions propagate
 * String content = Path.io(() -&gt; Files.readString(path)).unsafeRun();
 *
 * // Safe - exceptions are captured
 * Try&lt;String&gt; result = Path.io(() -&gt; Files.readString(path)).runSafe();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the type of the value produced by the computation
 */
public final class IOPath&lt;A&gt; implements Effectful&lt;A&gt; {

  private final IO&lt;A&gt; value;

  /**
   * Creates a new IOPath wrapping the given IO.
   *
   * @param value the IO to wrap; must not be null
   */
<span class="fc" id="L73">  IOPath(IO&lt;A&gt; value) {</span>
<span class="fc" id="L74">    this.value = Objects.requireNonNull(value, &quot;value must not be null&quot;);</span>
<span class="fc" id="L75">  }</span>

  /**
   * Returns the underlying IO value.
   *
   * @return the wrapped IO
   */
  public IO&lt;A&gt; run() {
<span class="fc" id="L83">    return value;</span>
  }

  @Override
  public A unsafeRun() {
<span class="fc" id="L88">    return value.unsafeRunSync();</span>
  }

  // runSafe() uses the default implementation from Effectful interface

  /**
   * Converts the result of this IOPath to Unit, discarding any value.
   *
   * &lt;p&gt;Useful when you only care about the side effect, not the result.
   *
   * @return an IOPath that produces Unit
   */
  public IOPath&lt;Unit&gt; asUnit() {
<span class="fc" id="L101">    return new IOPath&lt;&gt;(value.asUnit());</span>
  }

  /**
   * Converts this IOPath to a TryPath by executing it safely.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This executes the IO immediately to capture success or failure.
   *
   * @return a TryPath containing the result or exception
   */
  public TryPath&lt;A&gt; toTryPath() {
<span class="fc" id="L112">    return new TryPath&lt;&gt;(runSafe());</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L119">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L120">    return new IOPath&lt;&gt;(value.map(mapper));</span>
  }

  @Override
  public IOPath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L125">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L126">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L127">        value.map(</span>
            a -&gt; {
<span class="fc" id="L129">              consumer.accept(a);</span>
<span class="fc" id="L130">              return a;</span>
            }));
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; IOPath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L139">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L140">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">    if (!(other instanceof IOPath&lt;?&gt; otherIO)) {</span>
<span class="fc" id="L143">      throw new IllegalArgumentException(&quot;Cannot zipWith non-IOPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L147">    IOPath&lt;B&gt; typedOther = (IOPath&lt;B&gt;) otherIO;</span>

<span class="fc" id="L149">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L150">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L152">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L153">              B b = typedOther.value.unsafeRunSync();</span>
<span class="fc" id="L154">              return combiner.apply(a, b);</span>
            }));
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result
   */
  public &lt;B, C, D&gt; IOPath&lt;D&gt; zipWith3(
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L173">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L174">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L175">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L177">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L178">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L180">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L181">              B b = second.value.unsafeRunSync();</span>
<span class="fc" id="L182">              C c = third.value.unsafeRunSync();</span>
<span class="fc" id="L183">              return combiner.apply(a, b, c);</span>
            }));
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L191">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L193">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L194">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L196">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L197">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L198">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">              if (!(result instanceof IOPath&lt;?&gt; ioPath)) {</span>
<span class="fc" id="L201">                throw new IllegalArgumentException(</span>
<span class="fc" id="L202">                    &quot;via mapper must return IOPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L206">              IOPath&lt;B&gt; typedResult = (IOPath&lt;B&gt;) ioPath;</span>
<span class="fc" id="L207">              return typedResult.unsafeRun();</span>
            }));
  }

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; flatMap(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L213">    return via(mapper);</span>
  }

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L218">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc" id="L220">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L221">        IO.delay(</span>
            () -&gt; {
              // Execute this IO for its side effects
<span class="fc" id="L224">              this.value.unsafeRunSync();</span>

<span class="fc" id="L226">              Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L227">              Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">              if (!(result instanceof IOPath&lt;?&gt; ioPath)) {</span>
<span class="fc" id="L230">                throw new IllegalArgumentException(</span>
<span class="fc" id="L231">                    &quot;then supplier must return IOPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L235">              IOPath&lt;B&gt; typedResult = (IOPath&lt;B&gt;) ioPath;</span>
<span class="fc" id="L236">              return typedResult.unsafeRun();</span>
            }));
  }

  /**
   * Handles exceptions that occur during execution.
   *
   * &lt;p&gt;If an exception is thrown during execution, the recovery function is applied to produce an
   * alternative value.
   *
   * @param recovery the function to apply if an exception occurs; must not be null
   * @return an IOPath that will recover from exceptions
   * @throws NullPointerException if recovery is null
   */
  public IOPath&lt;A&gt; handleError(Function&lt;? super Throwable, ? extends A&gt; recovery) {
<span class="fc" id="L251">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L252">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L253">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L256">                return this.value.unsafeRunSync();</span>
<span class="fc" id="L257">              } catch (Throwable t) {</span>
<span class="fc" id="L258">                return recovery.apply(t);</span>
              }
            }));
  }

  /**
   * Handles exceptions that occur during execution with a recovery IO.
   *
   * &lt;p&gt;If an exception is thrown during execution, the recovery function is applied to produce an
   * alternative IOPath.
   *
   * @param recovery the function to apply if an exception occurs; must not be null
   * @return an IOPath that will recover from exceptions
   * @throws NullPointerException if recovery is null
   */
  public IOPath&lt;A&gt; handleErrorWith(Function&lt;? super Throwable, ? extends IOPath&lt;A&gt;&gt; recovery) {
<span class="fc" id="L274">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L275">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L276">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L279">                return this.value.unsafeRunSync();</span>
<span class="fc" id="L280">              } catch (Throwable t) {</span>
<span class="fc" id="L281">                IOPath&lt;A&gt; fallback = recovery.apply(t);</span>
<span class="fc" id="L282">                Objects.requireNonNull(fallback, &quot;recovery must not return null&quot;);</span>
<span class="fc" id="L283">                return fallback.unsafeRun();</span>
              }
            }));
  }

  // ===== Resource Management =====

  /**
   * Bracket pattern: acquire a resource, use it, and guarantee cleanup.
   *
   * &lt;p&gt;This is the fundamental pattern for safe resource management. The release function is
   * guaranteed to be called even if the use function throws an exception.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; content = IOPath.bracket(
   *     () -&gt; Files.newInputStream(path),      // acquire
   *     in -&gt; new String(in.readAllBytes()),   // use
   *     in -&gt; { try { in.close(); } catch (IOException e) { } }  // release
   * );
   * }&lt;/pre&gt;
   *
   * @param acquire supplies the resource; must not be null
   * @param use function that uses the resource; must not be null
   * @param release function that releases the resource; must not be null
   * @param &lt;R&gt; the resource type
   * @param &lt;A&gt; the result type
   * @return an IOPath that acquires, uses, and releases the resource
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R, A&gt; IOPath&lt;A&gt; bracket(
      Supplier&lt;? extends R&gt; acquire,
      Function&lt;? super R, ? extends A&gt; use,
      Consumer&lt;? super R&gt; release) {
<span class="fc" id="L318">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L319">    Objects.requireNonNull(use, &quot;use must not be null&quot;);</span>
<span class="fc" id="L320">    Objects.requireNonNull(release, &quot;release must not be null&quot;);</span>

<span class="fc" id="L322">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L323">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L325">              R resource = acquire.get();</span>
              try {
<span class="fc" id="L327">                return use.apply(resource);</span>
              } finally {
<span class="fc" id="L329">                release.accept(resource);</span>
              }
            }));
  }

  /**
   * Bracket pattern where the use function returns an IOPath.
   *
   * &lt;p&gt;Similar to {@link #bracket} but the use function returns an IOPath instead of a plain value.
   * This is useful when the use operation itself is effectful.
   *
   * @param acquire supplies the resource; must not be null
   * @param useIO function that uses the resource and returns an IOPath; must not be null
   * @param release function that releases the resource; must not be null
   * @param &lt;R&gt; the resource type
   * @param &lt;A&gt; the result type
   * @return an IOPath that acquires, uses, and releases the resource
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R, A&gt; IOPath&lt;A&gt; bracketIO(
      Supplier&lt;? extends R&gt; acquire,
      Function&lt;? super R, ? extends IOPath&lt;A&gt;&gt; useIO,
      Consumer&lt;? super R&gt; release) {
<span class="fc" id="L352">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L353">    Objects.requireNonNull(useIO, &quot;useIO must not be null&quot;);</span>
<span class="fc" id="L354">    Objects.requireNonNull(release, &quot;release must not be null&quot;);</span>

<span class="fc" id="L356">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L357">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L359">              R resource = acquire.get();</span>
              try {
<span class="fc" id="L361">                IOPath&lt;A&gt; result = useIO.apply(resource);</span>
<span class="fc" id="L362">                Objects.requireNonNull(result, &quot;useIO must not return null&quot;);</span>
<span class="fc" id="L363">                return result.unsafeRun();</span>
              } finally {
<span class="fc" id="L365">                release.accept(resource);</span>
              }
            }));
  }

  /**
   * Convenience method for AutoCloseable resources.
   *
   * &lt;p&gt;The resource is automatically closed after use, even if an exception is thrown.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; content = IOPath.withResource(
   *     () -&gt; Files.newBufferedReader(path),
   *     reader -&gt; reader.lines().collect(Collectors.joining(&quot;\n&quot;))
   * );
   * }&lt;/pre&gt;
   *
   * @param resourceSupplier supplies the AutoCloseable resource; must not be null
   * @param use function that uses the resource; must not be null
   * @param &lt;R&gt; the resource type (must be AutoCloseable)
   * @param &lt;A&gt; the result type
   * @return an IOPath that manages the resource lifecycle
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R extends AutoCloseable, A&gt; IOPath&lt;A&gt; withResource(
      Supplier&lt;? extends R&gt; resourceSupplier, Function&lt;? super R, ? extends A&gt; use) {
<span class="fc" id="L393">    Objects.requireNonNull(resourceSupplier, &quot;resourceSupplier must not be null&quot;);</span>
<span class="fc" id="L394">    Objects.requireNonNull(use, &quot;use must not be null&quot;);</span>

<span class="fc" id="L396">    return bracket(</span>
        resourceSupplier,
        use,
        resource -&gt; {
          try {
<span class="fc" id="L401">            resource.close();</span>
<span class="fc" id="L402">          } catch (Exception e) {</span>
            // Silently ignore close exceptions, as is standard with try-with-resources
<span class="fc" id="L404">          }</span>
<span class="fc" id="L405">        });</span>
  }

  /**
   * Convenience method for AutoCloseable resources where the use function returns an IOPath.
   *
   * @param resourceSupplier supplies the AutoCloseable resource; must not be null
   * @param useIO function that uses the resource and returns an IOPath; must not be null
   * @param &lt;R&gt; the resource type (must be AutoCloseable)
   * @param &lt;A&gt; the result type
   * @return an IOPath that manages the resource lifecycle
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R extends AutoCloseable, A&gt; IOPath&lt;A&gt; withResourceIO(
      Supplier&lt;? extends R&gt; resourceSupplier, Function&lt;? super R, ? extends IOPath&lt;A&gt;&gt; useIO) {
<span class="fc" id="L420">    Objects.requireNonNull(resourceSupplier, &quot;resourceSupplier must not be null&quot;);</span>
<span class="fc" id="L421">    Objects.requireNonNull(useIO, &quot;useIO must not be null&quot;);</span>

<span class="fc" id="L423">    return bracketIO(</span>
        resourceSupplier,
        useIO,
        resource -&gt; {
          try {
<span class="fc" id="L428">            resource.close();</span>
<span class="fc" id="L429">          } catch (Exception e) {</span>
            // Silently ignore close exceptions, as is standard with try-with-resources
<span class="fc" id="L431">          }</span>
<span class="fc" id="L432">        });</span>
  }

  /**
   * Ensures a finalizer runs regardless of success or failure.
   *
   * &lt;p&gt;The finalizer is guaranteed to run even if this IOPath throws an exception. The original
   * exception (if any) is preserved and rethrown after the finalizer runs.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; operation = Path.io(() -&gt; doSomething())
   *     .guarantee(() -&gt; cleanup());
   * }&lt;/pre&gt;
   *
   * @param finalizer the action to run; must not be null
   * @return an IOPath that runs the finalizer after this computation
   * @throws NullPointerException if finalizer is null
   */
  public IOPath&lt;A&gt; guarantee(Runnable finalizer) {
<span class="fc" id="L453">    Objects.requireNonNull(finalizer, &quot;finalizer must not be null&quot;);</span>
<span class="fc" id="L454">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L455">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L458">                return this.value.unsafeRunSync();</span>
              } finally {
<span class="fc" id="L460">                finalizer.run();</span>
              }
            }));
  }

  /**
   * Ensures an IOPath finalizer runs regardless of success or failure.
   *
   * &lt;p&gt;Similar to {@link #guarantee} but the finalizer is itself an IOPath.
   *
   * @param finalizerIO the IOPath to run as finalizer; must not be null
   * @return an IOPath that runs the finalizer after this computation
   * @throws NullPointerException if finalizerIO is null
   */
  public IOPath&lt;A&gt; guaranteeIO(IOPath&lt;?&gt; finalizerIO) {
<span class="fc" id="L475">    Objects.requireNonNull(finalizerIO, &quot;finalizerIO must not be null&quot;);</span>
<span class="fc" id="L476">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L477">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L480">                return this.value.unsafeRunSync();</span>
              } finally {
<span class="fc" id="L482">                finalizerIO.unsafeRun();</span>
              }
            }));
  }

  // ===== Parallel Execution =====

  /**
   * Combines this IOPath with another in parallel.
   *
   * &lt;p&gt;Both IOPaths are executed concurrently using CompletableFuture, and their results are
   * combined using the provided function.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;UserProfile&gt; profile = fetchUser.parZipWith(
   *     fetchOrders,
   *     UserProfile::new
   * );
   * }&lt;/pre&gt;
   *
   * @param other the other IOPath to execute in parallel; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;B&gt; the type of the other value
   * @param &lt;C&gt; the type of the combined result
   * @return an IOPath that runs both computations in parallel and combines results
   * @throws NullPointerException if other or combiner is null
   */
  public &lt;B, C&gt; IOPath&lt;C&gt; parZipWith(
      IOPath&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L513">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L514">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L516">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L517">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L519">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(this::unsafeRun);</span>
<span class="fc" id="L520">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(other::unsafeRun);</span>

              try {
<span class="fc" id="L523">                A a = futureA.get();</span>
<span class="fc" id="L524">                B b = futureB.get();</span>
<span class="fc" id="L525">                return combiner.apply(a, b);</span>
<span class="nc" id="L526">              } catch (InterruptedException e) {</span>
<span class="nc" id="L527">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L528">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L529">              } catch (ExecutionException e) {</span>
<span class="fc" id="L530">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L532">                  throw re;</span>
                }
<span class="nc" id="L534">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Races this IOPath against another, returning the first to complete.
   *
   * &lt;p&gt;Both IOPaths are executed concurrently, and the result of whichever completes first is
   * returned. The other computation is cancelled if possible.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;Config&gt; config = loadFromCache.race(loadFromDisk);
   * }&lt;/pre&gt;
   *
   * @param other the other IOPath to race against; must not be null
   * @return an IOPath that returns the first result
   * @throws NullPointerException if other is null
   */
  public IOPath&lt;A&gt; race(IOPath&lt;A&gt; other) {
<span class="fc" id="L556">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>

<span class="fc" id="L558">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L559">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L561">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(this::unsafeRun);</span>
<span class="fc" id="L562">              CompletableFuture&lt;A&gt; futureB = CompletableFuture.supplyAsync(other::unsafeRun);</span>

              try {
                // anyOf returns when any future completes
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L567">                CompletableFuture&lt;A&gt; winner =</span>
                    (CompletableFuture&lt;A&gt;)
<span class="fc" id="L569">                        CompletableFuture.anyOf(futureA, futureB).thenApply(result -&gt; (A) result);</span>

<span class="fc" id="L571">                A result = winner.get();</span>

                // Cancel the loser (best effort)
<span class="fc" id="L574">                futureA.cancel(true);</span>
<span class="fc" id="L575">                futureB.cancel(true);</span>

<span class="fc" id="L577">                return result;</span>
<span class="nc" id="L578">              } catch (InterruptedException e) {</span>
<span class="nc" id="L579">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L580">                throw new RuntimeException(&quot;Race interrupted&quot;, e);</span>
<span class="fc" id="L581">              } catch (ExecutionException e) {</span>
<span class="fc" id="L582">                Throwable cause = e.getCause();</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L584">                  throw re;</span>
                }
<span class="nc" id="L586">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  // ===== Retry Operations =====

  /**
   * Returns an IOPath that retries this computation according to the given policy.
   *
   * &lt;p&gt;If the computation fails, it will be retried according to the policy's configuration (number
   * of attempts, delays, retry predicate).
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * RetryPolicy policy = RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofMillis(100))
   *     .retryOn(IOException.class);
   *
   * IOPath&lt;String&gt; resilient = Path.io(() -&gt; httpClient.get(url))
   *     .withRetry(policy);
   * }&lt;/pre&gt;
   *
   * @param policy the retry policy; must not be null
   * @return an IOPath that retries on failure
   * @throws NullPointerException if policy is null
   */
  public IOPath&lt;A&gt; withRetry(RetryPolicy policy) {
<span class="fc" id="L614">    Objects.requireNonNull(policy, &quot;policy must not be null&quot;);</span>
<span class="fc" id="L615">    return new IOPath&lt;&gt;(IO.delay(() -&gt; Retry.execute(policy, this::unsafeRun)));</span>
  }

  /**
   * Returns an IOPath that retries this computation with exponential backoff.
   *
   * &lt;p&gt;This is a convenience method that uses exponential backoff with jitter.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; resilient = Path.io(() -&gt; httpClient.get(url))
   *     .retry(3, Duration.ofMillis(100));
   * }&lt;/pre&gt;
   *
   * @param maxAttempts maximum number of attempts (must be at least 1)
   * @param initialDelay initial delay between attempts; must not be null
   * @return an IOPath that retries on failure
   * @throws NullPointerException if initialDelay is null
   * @throws IllegalArgumentException if maxAttempts is less than 1
   */
  public IOPath&lt;A&gt; retry(int maxAttempts, Duration initialDelay) {
<span class="fc" id="L637">    return withRetry(RetryPolicy.exponentialBackoffWithJitter(maxAttempts, initialDelay));</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
    // IO equality is based on reference since IO represents a computation
<span class="fc bfc" id="L645" title="All 2 branches covered.">    return this == obj;</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L650">    return System.identityHashCode(this);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L655">    return &quot;IOPath(&lt;deferred&gt;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>