<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">IOPath.java</span></div><h1>IOPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.effect.capability.Effectful;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.resilience.Retry;
import org.higherkindedj.hkt.resilience.RetryPolicy;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPath;

/**
 * A fluent path wrapper for {@link IO} values.
 *
 * &lt;p&gt;{@code IOPath} provides a chainable API for composing deferred side-effecting computations. It
 * implements {@link Effectful} to provide methods for executing the deferred computation.
 *
 * &lt;h2&gt;Creating IOPath instances&lt;/h2&gt;
 *
 * &lt;p&gt;Use the {@link Path} factory class to create instances:
 *
 * &lt;pre&gt;{@code
 * IOPath&lt;String&gt; path = Path.io(() -&gt; Files.readString(file));
 * IOPath&lt;Unit&gt; action = Path.ioRunnable(() -&gt; System.out.println(&quot;Hello&quot;));
 * IOPath&lt;Integer&gt; pure = Path.ioPure(42);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;p&gt;IOPath operations are lazy - they describe a computation but don't execute it until {@link
 * #unsafeRun()} or {@link #runSafe()} is called.
 *
 * &lt;pre&gt;{@code
 * IOPath&lt;Config&gt; config = Path.io(() -&gt; readConfigFile())
 *     .map(Config::parse)
 *     .via(c -&gt; Path.io(() -&gt; validate(c)));
 *
 * // Nothing has happened yet!
 * Config result = config.unsafeRun();  // Now the computation runs
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Executing the computation&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Unsafe - exceptions propagate
 * String content = Path.io(() -&gt; Files.readString(path)).unsafeRun();
 *
 * // Safe - exceptions are captured
 * Try&lt;String&gt; result = Path.io(() -&gt; Files.readString(path)).runSafe();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the type of the value produced by the computation
 */
public final class IOPath&lt;A&gt; implements Effectful&lt;A&gt; {

  private final IO&lt;A&gt; value;

  /**
   * Creates a new IOPath wrapping the given IO.
   *
   * @param value the IO to wrap; must not be null
   */
<span class="fc" id="L78">  IOPath(IO&lt;A&gt; value) {</span>
<span class="fc" id="L79">    this.value = Objects.requireNonNull(value, &quot;value must not be null&quot;);</span>
<span class="fc" id="L80">  }</span>

  /**
   * Returns the underlying IO value.
   *
   * @return the wrapped IO
   */
  public IO&lt;A&gt; run() {
<span class="fc" id="L88">    return value;</span>
  }

  @Override
  public A unsafeRun() {
<span class="fc" id="L93">    return value.unsafeRunSync();</span>
  }

  // runSafe() uses the default implementation from Effectful interface

  /**
   * Converts the result of this IOPath to Unit, discarding any value.
   *
   * &lt;p&gt;Useful when you only care about the side effect, not the result.
   *
   * @return an IOPath that produces Unit
   */
  public IOPath&lt;Unit&gt; asUnit() {
<span class="fc" id="L106">    return new IOPath&lt;&gt;(value.asUnit());</span>
  }

  /**
   * Converts this IOPath to a TryPath by executing it safely.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This executes the IO immediately to capture success or failure.
   *
   * @return a TryPath containing the result or exception
   */
  public TryPath&lt;A&gt; toTryPath() {
<span class="fc" id="L117">    return new TryPath&lt;&gt;(runSafe());</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L124">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L125">    return new IOPath&lt;&gt;(value.map(mapper));</span>
  }

  @Override
  public IOPath&lt;A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L130">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L131">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L132">        value.map(</span>
            a -&gt; {
<span class="fc" id="L134">              consumer.accept(a);</span>
<span class="fc" id="L135">              return a;</span>
            }));
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; IOPath&lt;C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L144">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L145">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (!(other instanceof IOPath&lt;?&gt; otherIO)) {</span>
<span class="fc" id="L148">      throw new IllegalArgumentException(&quot;Cannot zipWith non-IOPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L152">    IOPath&lt;B&gt; typedOther = (IOPath&lt;B&gt;) otherIO;</span>

<span class="fc" id="L154">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L155">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L157">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L158">              B b = typedOther.value.unsafeRunSync();</span>
<span class="fc" id="L159">              return combiner.apply(a, b);</span>
            }));
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result
   */
  public &lt;B, C, D&gt; IOPath&lt;D&gt; zipWith3(
      IOPath&lt;B&gt; second,
      IOPath&lt;C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L178">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L179">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L180">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L182">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L183">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L185">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L186">              B b = second.value.unsafeRunSync();</span>
<span class="fc" id="L187">              C c = third.value.unsafeRunSync();</span>
<span class="fc" id="L188">              return combiner.apply(a, b, c);</span>
            }));
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L196">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L198">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L199">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L201">              A a = this.value.unsafeRunSync();</span>
<span class="fc" id="L202">              Chainable&lt;B&gt; result = mapper.apply(a);</span>
<span class="fc" id="L203">              Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L205" title="All 2 branches covered.">              if (!(result instanceof IOPath&lt;?&gt; ioPath)) {</span>
<span class="fc" id="L206">                throw new IllegalArgumentException(</span>
<span class="fc" id="L207">                    &quot;via mapper must return IOPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L211">              IOPath&lt;B&gt; typedResult = (IOPath&lt;B&gt;) ioPath;</span>
<span class="fc" id="L212">              return typedResult.unsafeRun();</span>
            }));
  }

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; flatMap(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L218">    return via(mapper);</span>
  }

  @Override
  public &lt;B&gt; IOPath&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L223">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc" id="L225">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L226">        IO.delay(</span>
            () -&gt; {
              // Execute this IO for its side effects
<span class="fc" id="L229">              this.value.unsafeRunSync();</span>

<span class="fc" id="L231">              Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L232">              Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">              if (!(result instanceof IOPath&lt;?&gt; ioPath)) {</span>
<span class="fc" id="L235">                throw new IllegalArgumentException(</span>
<span class="fc" id="L236">                    &quot;then supplier must return IOPath, got: &quot; + result.getClass());</span>
              }

              @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L240">              IOPath&lt;B&gt; typedResult = (IOPath&lt;B&gt;) ioPath;</span>
<span class="fc" id="L241">              return typedResult.unsafeRun();</span>
            }));
  }

  /**
   * Handles exceptions that occur during execution.
   *
   * &lt;p&gt;If an exception is thrown during execution, the recovery function is applied to produce an
   * alternative value.
   *
   * @param recovery the function to apply if an exception occurs; must not be null
   * @return an IOPath that will recover from exceptions
   * @throws NullPointerException if recovery is null
   */
  public IOPath&lt;A&gt; handleError(Function&lt;? super Throwable, ? extends A&gt; recovery) {
<span class="fc" id="L256">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L257">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L258">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L261">                return this.value.unsafeRunSync();</span>
<span class="fc" id="L262">              } catch (Throwable t) {</span>
<span class="fc" id="L263">                return recovery.apply(t);</span>
              }
            }));
  }

  /**
   * Handles exceptions that occur during execution with a recovery IO.
   *
   * &lt;p&gt;If an exception is thrown during execution, the recovery function is applied to produce an
   * alternative IOPath.
   *
   * @param recovery the function to apply if an exception occurs; must not be null
   * @return an IOPath that will recover from exceptions
   * @throws NullPointerException if recovery is null
   */
  public IOPath&lt;A&gt; handleErrorWith(Function&lt;? super Throwable, ? extends IOPath&lt;A&gt;&gt; recovery) {
<span class="fc" id="L279">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L280">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L281">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L284">                return this.value.unsafeRunSync();</span>
<span class="fc" id="L285">              } catch (Throwable t) {</span>
<span class="fc" id="L286">                IOPath&lt;A&gt; fallback = recovery.apply(t);</span>
<span class="fc" id="L287">                Objects.requireNonNull(fallback, &quot;recovery must not return null&quot;);</span>
<span class="fc" id="L288">                return fallback.unsafeRun();</span>
              }
            }));
  }

  // ===== Resource Management =====

  /**
   * Bracket pattern: acquire a resource, use it, and guarantee cleanup.
   *
   * &lt;p&gt;This is the fundamental pattern for safe resource management. The release function is
   * guaranteed to be called even if the use function throws an exception.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; content = IOPath.bracket(
   *     () -&gt; Files.newInputStream(path),      // acquire
   *     in -&gt; new String(in.readAllBytes()),   // use
   *     in -&gt; { try { in.close(); } catch (IOException e) { } }  // release
   * );
   * }&lt;/pre&gt;
   *
   * @param acquire supplies the resource; must not be null
   * @param use function that uses the resource; must not be null
   * @param release function that releases the resource; must not be null
   * @param &lt;R&gt; the resource type
   * @param &lt;A&gt; the result type
   * @return an IOPath that acquires, uses, and releases the resource
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R, A&gt; IOPath&lt;A&gt; bracket(
      Supplier&lt;? extends R&gt; acquire,
      Function&lt;? super R, ? extends A&gt; use,
      Consumer&lt;? super R&gt; release) {
<span class="fc" id="L323">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L324">    Objects.requireNonNull(use, &quot;use must not be null&quot;);</span>
<span class="fc" id="L325">    Objects.requireNonNull(release, &quot;release must not be null&quot;);</span>

<span class="fc" id="L327">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L328">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L330">              R resource = acquire.get();</span>
              try {
<span class="fc" id="L332">                return use.apply(resource);</span>
              } finally {
<span class="fc" id="L334">                release.accept(resource);</span>
              }
            }));
  }

  /**
   * Bracket pattern where the use function returns an IOPath.
   *
   * &lt;p&gt;Similar to {@link #bracket} but the use function returns an IOPath instead of a plain value.
   * This is useful when the use operation itself is effectful.
   *
   * @param acquire supplies the resource; must not be null
   * @param useIO function that uses the resource and returns an IOPath; must not be null
   * @param release function that releases the resource; must not be null
   * @param &lt;R&gt; the resource type
   * @param &lt;A&gt; the result type
   * @return an IOPath that acquires, uses, and releases the resource
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R, A&gt; IOPath&lt;A&gt; bracketIO(
      Supplier&lt;? extends R&gt; acquire,
      Function&lt;? super R, ? extends IOPath&lt;A&gt;&gt; useIO,
      Consumer&lt;? super R&gt; release) {
<span class="fc" id="L357">    Objects.requireNonNull(acquire, &quot;acquire must not be null&quot;);</span>
<span class="fc" id="L358">    Objects.requireNonNull(useIO, &quot;useIO must not be null&quot;);</span>
<span class="fc" id="L359">    Objects.requireNonNull(release, &quot;release must not be null&quot;);</span>

<span class="fc" id="L361">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L362">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L364">              R resource = acquire.get();</span>
              try {
<span class="fc" id="L366">                IOPath&lt;A&gt; result = useIO.apply(resource);</span>
<span class="fc" id="L367">                Objects.requireNonNull(result, &quot;useIO must not return null&quot;);</span>
<span class="fc" id="L368">                return result.unsafeRun();</span>
              } finally {
<span class="fc" id="L370">                release.accept(resource);</span>
              }
            }));
  }

  /**
   * Convenience method for AutoCloseable resources.
   *
   * &lt;p&gt;The resource is automatically closed after use, even if an exception is thrown.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; content = IOPath.withResource(
   *     () -&gt; Files.newBufferedReader(path),
   *     reader -&gt; reader.lines().collect(Collectors.joining(&quot;\n&quot;))
   * );
   * }&lt;/pre&gt;
   *
   * @param resourceSupplier supplies the AutoCloseable resource; must not be null
   * @param use function that uses the resource; must not be null
   * @param &lt;R&gt; the resource type (must be AutoCloseable)
   * @param &lt;A&gt; the result type
   * @return an IOPath that manages the resource lifecycle
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R extends AutoCloseable, A&gt; IOPath&lt;A&gt; withResource(
      Supplier&lt;? extends R&gt; resourceSupplier, Function&lt;? super R, ? extends A&gt; use) {
<span class="fc" id="L398">    Objects.requireNonNull(resourceSupplier, &quot;resourceSupplier must not be null&quot;);</span>
<span class="fc" id="L399">    Objects.requireNonNull(use, &quot;use must not be null&quot;);</span>

<span class="fc" id="L401">    return bracket(</span>
        resourceSupplier,
        use,
        resource -&gt; {
          try {
<span class="fc" id="L406">            resource.close();</span>
<span class="fc" id="L407">          } catch (Exception e) {</span>
            // Silently ignore close exceptions, as is standard with try-with-resources
<span class="fc" id="L409">          }</span>
<span class="fc" id="L410">        });</span>
  }

  /**
   * Convenience method for AutoCloseable resources where the use function returns an IOPath.
   *
   * @param resourceSupplier supplies the AutoCloseable resource; must not be null
   * @param useIO function that uses the resource and returns an IOPath; must not be null
   * @param &lt;R&gt; the resource type (must be AutoCloseable)
   * @param &lt;A&gt; the result type
   * @return an IOPath that manages the resource lifecycle
   * @throws NullPointerException if any argument is null
   */
  public static &lt;R extends AutoCloseable, A&gt; IOPath&lt;A&gt; withResourceIO(
      Supplier&lt;? extends R&gt; resourceSupplier, Function&lt;? super R, ? extends IOPath&lt;A&gt;&gt; useIO) {
<span class="fc" id="L425">    Objects.requireNonNull(resourceSupplier, &quot;resourceSupplier must not be null&quot;);</span>
<span class="fc" id="L426">    Objects.requireNonNull(useIO, &quot;useIO must not be null&quot;);</span>

<span class="fc" id="L428">    return bracketIO(</span>
        resourceSupplier,
        useIO,
        resource -&gt; {
          try {
<span class="fc" id="L433">            resource.close();</span>
<span class="fc" id="L434">          } catch (Exception e) {</span>
            // Silently ignore close exceptions, as is standard with try-with-resources
<span class="fc" id="L436">          }</span>
<span class="fc" id="L437">        });</span>
  }

  /**
   * Ensures a finalizer runs regardless of success or failure.
   *
   * &lt;p&gt;The finalizer is guaranteed to run even if this IOPath throws an exception. The original
   * exception (if any) is preserved and rethrown after the finalizer runs.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; operation = Path.io(() -&gt; doSomething())
   *     .guarantee(() -&gt; cleanup());
   * }&lt;/pre&gt;
   *
   * @param finalizer the action to run; must not be null
   * @return an IOPath that runs the finalizer after this computation
   * @throws NullPointerException if finalizer is null
   */
  public IOPath&lt;A&gt; guarantee(Runnable finalizer) {
<span class="fc" id="L458">    Objects.requireNonNull(finalizer, &quot;finalizer must not be null&quot;);</span>
<span class="fc" id="L459">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L460">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L463">                return this.value.unsafeRunSync();</span>
              } finally {
<span class="fc" id="L465">                finalizer.run();</span>
              }
            }));
  }

  /**
   * Ensures an IOPath finalizer runs regardless of success or failure.
   *
   * &lt;p&gt;Similar to {@link #guarantee} but the finalizer is itself an IOPath.
   *
   * @param finalizerIO the IOPath to run as finalizer; must not be null
   * @return an IOPath that runs the finalizer after this computation
   * @throws NullPointerException if finalizerIO is null
   */
  public IOPath&lt;A&gt; guaranteeIO(IOPath&lt;?&gt; finalizerIO) {
<span class="fc" id="L480">    Objects.requireNonNull(finalizerIO, &quot;finalizerIO must not be null&quot;);</span>
<span class="fc" id="L481">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L482">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L485">                return this.value.unsafeRunSync();</span>
              } finally {
<span class="fc" id="L487">                finalizerIO.unsafeRun();</span>
              }
            }));
  }

  // ===== Parallel Execution =====

  /**
   * Combines this IOPath with another in parallel.
   *
   * &lt;p&gt;Both IOPaths are executed concurrently using CompletableFuture, and their results are
   * combined using the provided function.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;UserProfile&gt; profile = fetchUser.parZipWith(
   *     fetchOrders,
   *     UserProfile::new
   * );
   * }&lt;/pre&gt;
   *
   * @param other the other IOPath to execute in parallel; must not be null
   * @param combiner the function to combine results; must not be null
   * @param &lt;B&gt; the type of the other value
   * @param &lt;C&gt; the type of the combined result
   * @return an IOPath that runs both computations in parallel and combines results
   * @throws NullPointerException if other or combiner is null
   */
  public &lt;B, C&gt; IOPath&lt;C&gt; parZipWith(
      IOPath&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L518">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L519">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L521">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L522">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L524">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(this::unsafeRun);</span>
<span class="fc" id="L525">              CompletableFuture&lt;B&gt; futureB = CompletableFuture.supplyAsync(other::unsafeRun);</span>

              try {
<span class="fc" id="L528">                A a = futureA.get();</span>
<span class="fc" id="L529">                B b = futureB.get();</span>
<span class="fc" id="L530">                return combiner.apply(a, b);</span>
<span class="fc" id="L531">              } catch (InterruptedException e) {</span>
<span class="fc" id="L532">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L533">                throw new RuntimeException(&quot;Parallel execution interrupted&quot;, e);</span>
<span class="fc" id="L534">              } catch (ExecutionException e) {</span>
<span class="fc" id="L535">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L537">                  throw re;</span>
                }
<span class="fc" id="L539">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  /**
   * Races this IOPath against another, returning the first to complete.
   *
   * &lt;p&gt;Both IOPaths are executed concurrently, and the result of whichever completes first is
   * returned. The other computation is cancelled if possible.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;Config&gt; config = loadFromCache.race(loadFromDisk);
   * }&lt;/pre&gt;
   *
   * @param other the other IOPath to race against; must not be null
   * @return an IOPath that returns the first result
   * @throws NullPointerException if other is null
   */
  public IOPath&lt;A&gt; race(IOPath&lt;A&gt; other) {
<span class="fc" id="L561">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>

<span class="fc" id="L563">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L564">        IO.delay(</span>
            () -&gt; {
<span class="fc" id="L566">              CompletableFuture&lt;A&gt; futureA = CompletableFuture.supplyAsync(this::unsafeRun);</span>
<span class="fc" id="L567">              CompletableFuture&lt;A&gt; futureB = CompletableFuture.supplyAsync(other::unsafeRun);</span>

              try {
                // anyOf returns when any future completes
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L572">                CompletableFuture&lt;A&gt; winner =</span>
                    (CompletableFuture&lt;A&gt;)
<span class="fc" id="L574">                        CompletableFuture.anyOf(futureA, futureB).thenApply(result -&gt; (A) result);</span>

<span class="fc" id="L576">                A result = winner.get();</span>

                // Cancel the loser (best effort)
<span class="fc" id="L579">                futureA.cancel(true);</span>
<span class="fc" id="L580">                futureB.cancel(true);</span>

<span class="fc" id="L582">                return result;</span>
<span class="fc" id="L583">              } catch (InterruptedException e) {</span>
<span class="fc" id="L584">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L585">                throw new RuntimeException(&quot;Race interrupted&quot;, e);</span>
<span class="fc" id="L586">              } catch (ExecutionException e) {</span>
<span class="fc" id="L587">                Throwable cause = e.getCause();</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                if (cause instanceof RuntimeException re) {</span>
<span class="fc" id="L589">                  throw re;</span>
                }
<span class="fc" id="L591">                throw new RuntimeException(cause);</span>
              }
            }));
  }

  // ===== Retry Operations =====

  /**
   * Returns an IOPath that retries this computation according to the given policy.
   *
   * &lt;p&gt;If the computation fails, it will be retried according to the policy's configuration (number
   * of attempts, delays, retry predicate).
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * RetryPolicy policy = RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofMillis(100))
   *     .retryOn(IOException.class);
   *
   * IOPath&lt;String&gt; resilient = Path.io(() -&gt; httpClient.get(url))
   *     .withRetry(policy);
   * }&lt;/pre&gt;
   *
   * @param policy the retry policy; must not be null
   * @return an IOPath that retries on failure
   * @throws NullPointerException if policy is null
   */
  public IOPath&lt;A&gt; withRetry(RetryPolicy policy) {
<span class="fc" id="L619">    Objects.requireNonNull(policy, &quot;policy must not be null&quot;);</span>
<span class="fc" id="L620">    return new IOPath&lt;&gt;(IO.delay(() -&gt; Retry.execute(policy, this::unsafeRun)));</span>
  }

  /**
   * Returns an IOPath that retries this computation with exponential backoff.
   *
   * &lt;p&gt;This is a convenience method that uses exponential backoff with jitter.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;String&gt; resilient = Path.io(() -&gt; httpClient.get(url))
   *     .retry(3, Duration.ofMillis(100));
   * }&lt;/pre&gt;
   *
   * @param maxAttempts maximum number of attempts (must be at least 1)
   * @param initialDelay initial delay between attempts; must not be null
   * @return an IOPath that retries on failure
   * @throws NullPointerException if initialDelay is null
   * @throws IllegalArgumentException if maxAttempts is less than 1
   */
  public IOPath&lt;A&gt; retry(int maxAttempts, Duration initialDelay) {
<span class="fc" id="L642">    return withRetry(RetryPolicy.exponentialBackoffWithJitter(maxAttempts, initialDelay));</span>
  }

  // ===== Effect Wrapping Methods =====

  /**
   * Wraps the IO result in an Either, catching any exceptions.
   *
   * &lt;p&gt;Exceptions thrown during execution are caught and converted to the error type via the
   * provided mapper. Successful results are wrapped in {@link Either#right}.
   *
   * &lt;p&gt;This method is useful for converting exception-throwing computations into typed error
   * handling, enabling composition with other Either-based operations.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;Either&lt;ApiError, Response&gt;&gt; safe =
   *     Path.io(() -&gt; httpClient.get(url))
   *         .catching(ApiError::fromException);
   *
   * // Later, run and handle the Either
   * Either&lt;ApiError, Response&gt; result = safe.unsafeRun();
   * }&lt;/pre&gt;
   *
   * @param exceptionMapper converts exceptions to error type E; must not be null
   * @param &lt;E&gt; the error type
   * @return an IOPath producing Either instead of throwing
   * @throws NullPointerException if exceptionMapper is null
   */
  public &lt;E&gt; IOPath&lt;Either&lt;E, A&gt;&gt; catching(
      Function&lt;? super Throwable, ? extends E&gt; exceptionMapper) {
<span class="fc" id="L674">    Objects.requireNonNull(exceptionMapper, &quot;exceptionMapper must not be null&quot;);</span>
<span class="fc" id="L675">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L676">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L679">                return Either.right(this.value.unsafeRunSync());</span>
<span class="fc" id="L680">              } catch (Throwable t) {</span>
<span class="fc" id="L681">                return Either.left(exceptionMapper.apply(t));</span>
              }
            }));
  }

  /**
   * Wraps the IO result in a Maybe, treating exceptions as Nothing.
   *
   * &lt;p&gt;If the computation succeeds, the result is wrapped in {@link Maybe#just}. If it throws an
   * exception, the result is {@link Maybe#nothing()}.
   *
   * &lt;p&gt;This method is useful when you want to convert a potentially failing computation into an
   * optional result without preserving error information.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;Maybe&lt;Config&gt;&gt; config =
   *     Path.io(() -&gt; loadConfig())
   *         .asMaybe();
   *
   * // Later, run and handle the Maybe
   * Maybe&lt;Config&gt; result = config.unsafeRun();
   * Config cfg = result.orElse(Config.defaults());
   * }&lt;/pre&gt;
   *
   * @return an IOPath producing Maybe, with Nothing on failure
   */
  public IOPath&lt;Maybe&lt;A&gt;&gt; asMaybe() {
<span class="fc" id="L710">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L711">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L714">                return Maybe.just(this.value.unsafeRunSync());</span>
<span class="fc" id="L715">              } catch (Throwable t) {</span>
<span class="fc" id="L716">                return Maybe.nothing();</span>
              }
            }));
  }

  /**
   * Wraps the IO result in a Try, capturing success or failure.
   *
   * &lt;p&gt;Unlike {@link #toTryPath()} which executes immediately, this method returns a deferred
   * computation that produces a Try when run. The exception is captured in the Try rather than
   * propagating.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IOPath&lt;Try&lt;Data&gt;&gt; safeParse =
   *     Path.io(() -&gt; parseData(input))
   *         .asTry();
   *
   * // Later, run and handle the Try
   * Try&lt;Data&gt; result = safeParse.unsafeRun();
   * Data data = result.getOrElse(Data.empty());
   * }&lt;/pre&gt;
   *
   * @return an IOPath producing Try, capturing any failure
   */
  public IOPath&lt;Try&lt;A&gt;&gt; asTry() {
<span class="fc" id="L743">    return new IOPath&lt;&gt;(</span>
<span class="fc" id="L744">        IO.delay(</span>
            () -&gt; {
              try {
<span class="fc" id="L747">                return Try.success(this.value.unsafeRunSync());</span>
<span class="fc" id="L748">              } catch (Throwable t) {</span>
<span class="fc" id="L749">                return Try.failure(t);</span>
              }
            }));
  }

  // ===== Focus Bridge Methods =====

  /**
   * Applies a {@link FocusPath} to navigate within the contained value.
   *
   * &lt;p&gt;This bridges from the effect domain to the optics domain, allowing structural navigation
   * inside an IO context. The lens operation is deferred along with the IO computation.
   *
   * @param path the FocusPath to apply; must not be null
   * @param &lt;B&gt; the focused type
   * @return a new IOPath containing the focused value
   * @throws NullPointerException if path is null
   */
  public &lt;B&gt; IOPath&lt;B&gt; focus(FocusPath&lt;A, B&gt; path) {
<span class="fc" id="L768">    Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L769">    return map(path::get);</span>
  }

  /**
   * Applies an {@link AffinePath} to navigate within the contained value.
   *
   * &lt;p&gt;This bridges from the effect domain to the optics domain. If the AffinePath doesn't match, a
   * runtime exception is thrown when the IO is executed. For safer handling, consider using {@code
   * toTryPath()} first.
   *
   * @param path the AffinePath to apply; must not be null
   * @param exceptionIfAbsent supplies the exception if the path doesn't match; must not be null
   * @param &lt;B&gt; the focused type
   * @return a new IOPath containing the focused value
   * @throws NullPointerException if path or exceptionIfAbsent is null
   */
  public &lt;B&gt; IOPath&lt;B&gt; focus(
      AffinePath&lt;A, B&gt; path, Supplier&lt;? extends RuntimeException&gt; exceptionIfAbsent) {
<span class="fc" id="L787">    Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L788">    Objects.requireNonNull(exceptionIfAbsent, &quot;exceptionIfAbsent must not be null&quot;);</span>
<span class="fc" id="L789">    return via(</span>
        a -&gt;
<span class="fc" id="L791">            path.getOptional(a)</span>
<span class="fc" id="L792">                .&lt;IOPath&lt;B&gt;&gt;map(Path::ioPure)</span>
<span class="fc" id="L793">                .orElseGet(</span>
                    () -&gt;
<span class="fc" id="L795">                        Path.io(</span>
                            () -&gt; {
<span class="fc" id="L797">                              throw exceptionIfAbsent.get();</span>
                            })));
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
    // IO equality is based on reference since IO represents a computation
<span class="fc bfc" id="L806" title="All 2 branches covered.">    return this == obj;</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L811">    return System.identityHashCode(this);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L816">    return &quot;IOPath(&lt;deferred&gt;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>