<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriterPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect</a> &gt; <span class="el_source">WriterPath.java</span></div><h1>WriterPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.capability.Chainable;
import org.higherkindedj.hkt.effect.capability.Combinable;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.function.Function3;
import org.higherkindedj.hkt.id.Id;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.writer.Writer;

/**
 * A fluent path wrapper for {@link Writer} computations.
 *
 * &lt;p&gt;{@code WriterPath} represents computations that produce a value along with accumulated output.
 * The output type must have a {@link Monoid} instance for combining. This is useful for logging,
 * audit trails, or any scenario where you want to accumulate information alongside your
 * computation.
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Logging during computation
 *   &lt;li&gt;Audit trail generation
 *   &lt;li&gt;Collecting metrics
 *   &lt;li&gt;Building output alongside computation
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating WriterPath instances&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Using List&lt;String&gt; for log output
 * Monoid&lt;List&lt;String&gt;&gt; logMonoid = Monoids.list();
 *
 * // Pure value with empty log
 * WriterPath&lt;List&lt;String&gt;, Integer&gt; pure = WriterPath.pure(42, logMonoid);
 *
 * // Tell (log only, return Unit)
 * WriterPath&lt;List&lt;String&gt;, Unit&gt; log = WriterPath.tell(List.of(&quot;Starting...&quot;), logMonoid);
 *
 * // Writer with both value and log
 * WriterPath&lt;List&lt;String&gt;, Integer&gt; result = WriterPath.writer(42, List.of(&quot;Got 42&quot;), logMonoid);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Composing operations&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * Monoid&lt;List&lt;String&gt;&gt; logMonoid = Monoids.list();
 *
 * WriterPath&lt;List&lt;String&gt;, Integer&gt; computation =
 *     WriterPath.tell(List.of(&quot;Starting&quot;), logMonoid)
 *         .then(() -&gt; WriterPath.pure(42, logMonoid))
 *         .via(n -&gt; WriterPath.tell(List.of(&quot;Got &quot; + n), logMonoid)
 *             .map(_ -&gt; n * 2));
 *
 * Writer&lt;List&lt;String&gt;, Integer&gt; result = computation.run();
 * // result.log() = [&quot;Starting&quot;, &quot;Got 42&quot;]
 * // result.value() = 84
 * }&lt;/pre&gt;
 *
 * @param &lt;W&gt; the output/log type (must have Monoid)
 * @param &lt;A&gt; the type of the computed value
 */
public final class WriterPath&lt;W, A&gt; implements Chainable&lt;A&gt; {

  private final Writer&lt;W, A&gt; writer;
  private final Monoid&lt;W&gt; monoid;

  /**
   * Creates a new WriterPath wrapping the given Writer.
   *
   * @param writer the Writer to wrap; must not be null
   * @param monoid the Monoid for combining logs; must not be null
   */
<span class="fc" id="L83">  WriterPath(Writer&lt;W, A&gt; writer, Monoid&lt;W&gt; monoid) {</span>
<span class="fc" id="L84">    this.writer = Objects.requireNonNull(writer, &quot;writer must not be null&quot;);</span>
<span class="fc" id="L85">    this.monoid = Objects.requireNonNull(monoid, &quot;monoid must not be null&quot;);</span>
<span class="fc" id="L86">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a WriterPath with a value and empty log.
   *
   * @param value the value to return
   * @param monoid the Monoid for combining logs; must not be null
   * @param &lt;W&gt; the log type
   * @param &lt;A&gt; the value type
   * @return a WriterPath with the given value and empty log
   * @throws NullPointerException if monoid is null
   */
  public static &lt;W, A&gt; WriterPath&lt;W, A&gt; pure(A value, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L101">    Objects.requireNonNull(monoid, &quot;monoid must not be null&quot;);</span>
<span class="fc" id="L102">    return new WriterPath&lt;&gt;(Writer.value(monoid, value), monoid);</span>
  }

  /**
   * Creates a WriterPath that only produces output/log, with {@link Unit} as its value.
   *
   * @param log the log to produce; must not be null
   * @param monoid the Monoid for combining logs; must not be null
   * @param &lt;W&gt; the log type
   * @return a WriterPath that produces the given log
   * @throws NullPointerException if log or monoid is null
   */
  public static &lt;W&gt; WriterPath&lt;W, Unit&gt; tell(W log, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L115">    Objects.requireNonNull(log, &quot;log must not be null&quot;);</span>
<span class="fc" id="L116">    Objects.requireNonNull(monoid, &quot;monoid must not be null&quot;);</span>
<span class="fc" id="L117">    return new WriterPath&lt;&gt;(Writer.tell(log), monoid);</span>
  }

  /**
   * Creates a WriterPath from a value and output.
   *
   * @param value the value to return
   * @param log the log to produce; must not be null
   * @param monoid the Monoid for combining logs; must not be null
   * @param &lt;W&gt; the log type
   * @param &lt;A&gt; the value type
   * @return a WriterPath with the given value and log
   * @throws NullPointerException if log or monoid is null
   */
  public static &lt;W, A&gt; WriterPath&lt;W, A&gt; writer(A value, W log, Monoid&lt;W&gt; monoid) {
<span class="fc" id="L132">    Objects.requireNonNull(log, &quot;log must not be null&quot;);</span>
<span class="fc" id="L133">    Objects.requireNonNull(monoid, &quot;monoid must not be null&quot;);</span>
<span class="fc" id="L134">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(log, value), monoid);</span>
  }

  // ===== Terminal Operations =====

  /**
   * Returns the underlying Writer containing both value and log.
   *
   * @return the wrapped Writer
   */
  public Writer&lt;W, A&gt; run() {
<span class="fc" id="L145">    return writer;</span>
  }

  /**
   * Returns only the computed value, discarding the log.
   *
   * @return the computed value
   */
  public A value() {
<span class="fc" id="L154">    return writer.value();</span>
  }

  /**
   * Returns only the accumulated log, discarding the value.
   *
   * @return the accumulated log
   */
  public W written() {
<span class="fc" id="L163">    return writer.log();</span>
  }

  /**
   * Returns the Monoid used for combining logs.
   *
   * @return the log Monoid
   */
  public Monoid&lt;W&gt; monoid() {
<span class="fc" id="L172">    return monoid;</span>
  }

  // ===== Composable implementation =====

  @Override
  public &lt;B&gt; WriterPath&lt;W, B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L179">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L180">    return new WriterPath&lt;&gt;(writer.map(mapper), monoid);</span>
  }

  @Override
  public WriterPath&lt;W, A&gt; peek(Consumer&lt;? super A&gt; consumer) {
<span class="fc" id="L185">    Objects.requireNonNull(consumer, &quot;consumer must not be null&quot;);</span>
<span class="fc" id="L186">    consumer.accept(writer.value());</span>
<span class="fc" id="L187">    return this;</span>
  }

  // ===== Combinable implementation =====

  @Override
  public &lt;B, C&gt; WriterPath&lt;W, C&gt; zipWith(
      Combinable&lt;B&gt; other, BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner) {
<span class="fc" id="L195">    Objects.requireNonNull(other, &quot;other must not be null&quot;);</span>
<span class="fc" id="L196">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (!(other instanceof WriterPath&lt;?, ?&gt; otherWriter)) {</span>
<span class="fc" id="L199">      throw new IllegalArgumentException(&quot;Cannot zipWith non-WriterPath: &quot; + other.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L203">    WriterPath&lt;W, B&gt; typedOther = (WriterPath&lt;W, B&gt;) otherWriter;</span>

<span class="fc" id="L205">    W combinedLog = monoid.combine(this.writer.log(), typedOther.writer.log());</span>
<span class="fc" id="L206">    C combinedValue = combiner.apply(this.writer.value(), typedOther.writer.value());</span>

<span class="fc" id="L208">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(combinedLog, combinedValue), monoid);</span>
  }

  /**
   * Combines this path with two others using a ternary function.
   *
   * @param second the second path; must not be null
   * @param third the third path; must not be null
   * @param combiner the function to combine the values; must not be null
   * @param &lt;B&gt; the type of the second path's value
   * @param &lt;C&gt; the type of the third path's value
   * @param &lt;D&gt; the type of the combined result
   * @return a new path containing the combined result
   */
  public &lt;B, C, D&gt; WriterPath&lt;W, D&gt; zipWith3(
      WriterPath&lt;W, B&gt; second,
      WriterPath&lt;W, C&gt; third,
      Function3&lt;? super A, ? super B, ? super C, ? extends D&gt; combiner) {
<span class="fc" id="L226">    Objects.requireNonNull(second, &quot;second must not be null&quot;);</span>
<span class="fc" id="L227">    Objects.requireNonNull(third, &quot;third must not be null&quot;);</span>
<span class="fc" id="L228">    Objects.requireNonNull(combiner, &quot;combiner must not be null&quot;);</span>

<span class="fc" id="L230">    W combinedLog =</span>
<span class="fc" id="L231">        monoid.combine(monoid.combine(this.writer.log(), second.writer.log()), third.writer.log());</span>
<span class="fc" id="L232">    D combinedValue =</span>
<span class="fc" id="L233">        combiner.apply(this.writer.value(), second.writer.value(), third.writer.value());</span>

<span class="fc" id="L235">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(combinedLog, combinedValue), monoid);</span>
  }

  // ===== Chainable implementation =====

  @Override
  public &lt;B&gt; WriterPath&lt;W, B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; mapper) {
<span class="fc" id="L242">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>

<span class="fc" id="L244">    Chainable&lt;B&gt; result = mapper.apply(writer.value());</span>
<span class="fc" id="L245">    Objects.requireNonNull(result, &quot;mapper must not return null&quot;);</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (!(result instanceof WriterPath&lt;?, ?&gt; writerPath)) {</span>
<span class="fc" id="L248">      throw new IllegalArgumentException(</span>
<span class="fc" id="L249">          &quot;via mapper must return WriterPath, got: &quot; + result.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L253">    WriterPath&lt;W, B&gt; typedResult = (WriterPath&lt;W, B&gt;) writerPath;</span>

<span class="fc" id="L255">    W combinedLog = monoid.combine(this.writer.log(), typedResult.writer.log());</span>
<span class="fc" id="L256">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(combinedLog, typedResult.writer.value()), monoid);</span>
  }

  @Override
  public &lt;B&gt; WriterPath&lt;W, B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; supplier) {
<span class="fc" id="L261">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>

<span class="fc" id="L263">    Chainable&lt;B&gt; result = supplier.get();</span>
<span class="fc" id="L264">    Objects.requireNonNull(result, &quot;supplier must not return null&quot;);</span>

<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (!(result instanceof WriterPath&lt;?, ?&gt; writerPath)) {</span>
<span class="fc" id="L267">      throw new IllegalArgumentException(</span>
<span class="fc" id="L268">          &quot;then supplier must return WriterPath, got: &quot; + result.getClass());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L272">    WriterPath&lt;W, B&gt; typedResult = (WriterPath&lt;W, B&gt;) writerPath;</span>

<span class="fc" id="L274">    W combinedLog = monoid.combine(this.writer.log(), typedResult.writer.log());</span>
<span class="fc" id="L275">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(combinedLog, typedResult.writer.value()), monoid);</span>
  }

  // ===== Writer-Specific Operations =====

  /**
   * Transforms the log using the given function.
   *
   * &lt;p&gt;Note: The function must produce a value that is compatible with the existing Monoid. If you
   * need to change the Monoid, you should create a new WriterPath.
   *
   * @param f the function to transform the log; must not be null
   * @return a new WriterPath with the transformed log
   * @throws NullPointerException if f is null
   */
  public WriterPath&lt;W, A&gt; censor(Function&lt;? super W, ? extends W&gt; f) {
<span class="fc" id="L291">    Objects.requireNonNull(f, &quot;f must not be null&quot;);</span>
<span class="fc" id="L292">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(f.apply(writer.log()), writer.value()), monoid);</span>
  }

  /**
   * Adds additional output to the current log.
   *
   * @param additionalLog the additional log to append; must not be null
   * @return a new WriterPath with the combined log
   * @throws NullPointerException if additionalLog is null
   */
  public WriterPath&lt;W, A&gt; listen(W additionalLog) {
<span class="fc" id="L303">    Objects.requireNonNull(additionalLog, &quot;additionalLog must not be null&quot;);</span>
<span class="fc" id="L304">    W combinedLog = monoid.combine(writer.log(), additionalLog);</span>
<span class="fc" id="L305">    return new WriterPath&lt;&gt;(new Writer&lt;&gt;(combinedLog, writer.value()), monoid);</span>
  }

  // ===== Conversions =====

  /**
   * Converts to an IOPath, discarding the log.
   *
   * @return an IOPath that produces only the value
   */
  public IOPath&lt;A&gt; toIOPath() {
<span class="fc" id="L316">    return new IOPath&lt;&gt;(this::value);</span>
  }

  /**
   * Converts to an IdPath, discarding the log.
   *
   * @return an IdPath containing only the value
   */
  public IdPath&lt;A&gt; toIdPath() {
<span class="fc" id="L325">    return new IdPath&lt;&gt;(Id.of(value()));</span>
  }

  /**
   * Converts to a MaybePath, discarding the log.
   *
   * &lt;p&gt;If the value is null, returns an empty MaybePath.
   *
   * @return a MaybePath containing the value if non-null
   */
  public MaybePath&lt;A&gt; toMaybePath() {
<span class="fc" id="L336">    A val = value();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">    return val != null ? new MaybePath&lt;&gt;(Maybe.just(val)) : new MaybePath&lt;&gt;(Maybe.nothing());</span>
  }

  /**
   * Converts to an EitherPath, discarding the log.
   *
   * @param &lt;E&gt; the error type
   * @return an EitherPath containing the value as Right
   */
  public &lt;E&gt; EitherPath&lt;E, A&gt; toEitherPath() {
<span class="fc" id="L347">    return new EitherPath&lt;&gt;(Either.right(value()));</span>
  }

  // ===== Object methods =====

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (!(obj instanceof WriterPath&lt;?, ?&gt; other)) return false;</span>
<span class="fc bfc" id="L356" title="All 4 branches covered.">    return writer.equals(other.writer) &amp;&amp; monoid.equals(other.monoid);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L361">    return Objects.hash(writer, monoid);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L366">    return &quot;WriterPath(log=&quot; + writer.log() + &quot;, value=&quot; + writer.value() + &quot;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>