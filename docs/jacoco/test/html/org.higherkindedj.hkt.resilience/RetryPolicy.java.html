<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RetryPolicy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.resilience</a> &gt; <span class="el_source">RetryPolicy.java</span></div><h1>RetryPolicy.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.resilience;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Predicate;

/**
 * A configurable policy for retry behavior.
 *
 * &lt;p&gt;{@code RetryPolicy} defines how operations should be retried: how many times, with what delay
 * between attempts, and which exceptions should trigger retries.
 *
 * &lt;h2&gt;Built-in Policies&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #fixed(int, Duration)} - Fixed delay between attempts
 *   &lt;li&gt;{@link #exponentialBackoff(int, Duration)} - Exponentially increasing delays
 *   &lt;li&gt;{@link #exponentialBackoffWithJitter(int, Duration)} - Exponential backoff with
 *       randomization
 *   &lt;li&gt;{@link #noRetry()} - No retries (fail immediately)
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * RetryPolicy policy = RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofMillis(100))
 *     .withMaxDelay(Duration.ofSeconds(10))
 *     .retryOn(IOException.class);
 *
 * String result = Retry.execute(policy, () -&gt; httpClient.get(url));
 * }&lt;/pre&gt;
 *
 * @see Retry
 */
public final class RetryPolicy {

  private final int maxAttempts;
  private final Duration initialDelay;
  private final double backoffMultiplier;
  private final Duration maxDelay;
  private final boolean useJitter;
  private final Predicate&lt;Throwable&gt; retryPredicate;

  private RetryPolicy(
      int maxAttempts,
      Duration initialDelay,
      double backoffMultiplier,
      Duration maxDelay,
      boolean useJitter,
<span class="fc" id="L53">      Predicate&lt;Throwable&gt; retryPredicate) {</span>
<span class="fc" id="L54">    this.maxAttempts = maxAttempts;</span>
<span class="fc" id="L55">    this.initialDelay = initialDelay;</span>
<span class="fc" id="L56">    this.backoffMultiplier = backoffMultiplier;</span>
<span class="fc" id="L57">    this.maxDelay = maxDelay;</span>
<span class="fc" id="L58">    this.useJitter = useJitter;</span>
<span class="fc" id="L59">    this.retryPredicate = retryPredicate;</span>
<span class="fc" id="L60">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a policy with fixed delay between attempts.
   *
   * @param maxAttempts maximum number of attempts (must be at least 1)
   * @param delay the fixed delay between attempts; must not be null
   * @return a RetryPolicy with fixed delay
   * @throws IllegalArgumentException if maxAttempts is less than 1
   * @throws NullPointerException if delay is null
   */
  public static RetryPolicy fixed(int maxAttempts, Duration delay) {
<span class="fc" id="L74">    validateMaxAttempts(maxAttempts);</span>
<span class="fc" id="L75">    Objects.requireNonNull(delay, &quot;delay must not be null&quot;);</span>
<span class="fc" id="L76">    return new RetryPolicy(maxAttempts, delay, 1.0, delay, false, _ -&gt; true);</span>
  }

  /**
   * Creates a policy with exponentially increasing delays.
   *
   * &lt;p&gt;Each subsequent delay is multiplied by 2: delay, delay*2, delay*4, etc.
   *
   * @param maxAttempts maximum number of attempts (must be at least 1)
   * @param initialDelay the initial delay; must not be null
   * @return a RetryPolicy with exponential backoff
   * @throws IllegalArgumentException if maxAttempts is less than 1
   * @throws NullPointerException if initialDelay is null
   */
  public static RetryPolicy exponentialBackoff(int maxAttempts, Duration initialDelay) {
<span class="fc" id="L91">    validateMaxAttempts(maxAttempts);</span>
<span class="fc" id="L92">    Objects.requireNonNull(initialDelay, &quot;initialDelay must not be null&quot;);</span>
<span class="fc" id="L93">    return new RetryPolicy(maxAttempts, initialDelay, 2.0, Duration.ofMinutes(5), false, _ -&gt; true);</span>
  }

  /**
   * Creates a policy with exponential backoff plus jitter.
   *
   * &lt;p&gt;Jitter adds randomization to delays to prevent the &quot;thundering herd&quot; problem when many
   * clients retry simultaneously.
   *
   * @param maxAttempts maximum number of attempts (must be at least 1)
   * @param initialDelay the initial delay; must not be null
   * @return a RetryPolicy with exponential backoff and jitter
   * @throws IllegalArgumentException if maxAttempts is less than 1
   * @throws NullPointerException if initialDelay is null
   */
  public static RetryPolicy exponentialBackoffWithJitter(int maxAttempts, Duration initialDelay) {
<span class="fc" id="L109">    validateMaxAttempts(maxAttempts);</span>
<span class="fc" id="L110">    Objects.requireNonNull(initialDelay, &quot;initialDelay must not be null&quot;);</span>
<span class="fc" id="L111">    return new RetryPolicy(maxAttempts, initialDelay, 2.0, Duration.ofMinutes(5), true, _ -&gt; true);</span>
  }

  /**
   * Creates a policy that doesn't retry (fails immediately on first error).
   *
   * @return a RetryPolicy with no retries
   */
  public static RetryPolicy noRetry() {
<span class="fc" id="L120">    return new RetryPolicy(1, Duration.ZERO, 1.0, Duration.ZERO, false, _ -&gt; false);</span>
  }

  /**
   * Returns a builder for creating custom retry policies.
   *
   * @return a new Builder
   */
  public static Builder builder() {
<span class="fc" id="L129">    return new Builder();</span>
  }

  // ===== Configuration Methods =====

  /**
   * Returns a copy of this policy with a different maximum number of attempts.
   *
   * @param maxAttempts the new maximum attempts (must be at least 1)
   * @return a new RetryPolicy with the updated setting
   * @throws IllegalArgumentException if maxAttempts is less than 1
   */
  public RetryPolicy withMaxAttempts(int maxAttempts) {
<span class="fc" id="L142">    validateMaxAttempts(maxAttempts);</span>
<span class="fc" id="L143">    return new RetryPolicy(</span>
        maxAttempts, initialDelay, backoffMultiplier, maxDelay, useJitter, retryPredicate);
  }

  /**
   * Returns a copy of this policy with a different initial delay.
   *
   * @param initialDelay the new initial delay; must not be null
   * @return a new RetryPolicy with the updated setting
   * @throws NullPointerException if initialDelay is null
   */
  public RetryPolicy withInitialDelay(Duration initialDelay) {
<span class="fc" id="L155">    Objects.requireNonNull(initialDelay, &quot;initialDelay must not be null&quot;);</span>
<span class="fc" id="L156">    return new RetryPolicy(</span>
        maxAttempts, initialDelay, backoffMultiplier, maxDelay, useJitter, retryPredicate);
  }

  /**
   * Returns a copy of this policy with a different backoff multiplier.
   *
   * @param multiplier the new multiplier (must be at least 1.0)
   * @return a new RetryPolicy with the updated setting
   * @throws IllegalArgumentException if multiplier is less than 1.0
   */
  public RetryPolicy withBackoffMultiplier(double multiplier) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (multiplier &lt; 1.0) {</span>
<span class="fc" id="L169">      throw new IllegalArgumentException(&quot;backoffMultiplier must be at least 1.0&quot;);</span>
    }
<span class="fc" id="L171">    return new RetryPolicy(</span>
        maxAttempts, initialDelay, multiplier, maxDelay, useJitter, retryPredicate);
  }

  /**
   * Returns a copy of this policy with a different maximum delay.
   *
   * @param maxDelay the new maximum delay; must not be null
   * @return a new RetryPolicy with the updated setting
   * @throws NullPointerException if maxDelay is null
   */
  public RetryPolicy withMaxDelay(Duration maxDelay) {
<span class="fc" id="L183">    Objects.requireNonNull(maxDelay, &quot;maxDelay must not be null&quot;);</span>
<span class="fc" id="L184">    return new RetryPolicy(</span>
        maxAttempts, initialDelay, backoffMultiplier, maxDelay, useJitter, retryPredicate);
  }

  /**
   * Returns a copy of this policy that only retries for exceptions of the given type.
   *
   * @param exceptionClass the exception class to retry on
   * @return a new RetryPolicy that only retries on the specified exception type
   * @throws NullPointerException if exceptionClass is null
   */
  public RetryPolicy retryOn(Class&lt;? extends Throwable&gt; exceptionClass) {
<span class="fc" id="L196">    Objects.requireNonNull(exceptionClass, &quot;exceptionClass must not be null&quot;);</span>
<span class="fc" id="L197">    return new RetryPolicy(</span>
        maxAttempts,
        initialDelay,
        backoffMultiplier,
        maxDelay,
        useJitter,
<span class="fc" id="L203">        ex -&gt; exceptionClass.isInstance(ex));</span>
  }

  /**
   * Returns a copy of this policy that retries based on a custom predicate.
   *
   * @param predicate the predicate to determine if a retry should occur
   * @return a new RetryPolicy with the custom retry predicate
   * @throws NullPointerException if predicate is null
   */
  public RetryPolicy retryIf(Predicate&lt;Throwable&gt; predicate) {
<span class="fc" id="L214">    Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L215">    return new RetryPolicy(</span>
        maxAttempts, initialDelay, backoffMultiplier, maxDelay, useJitter, predicate);
  }

  // ===== Accessors =====

  /**
   * Returns the maximum number of attempts.
   *
   * @return the maximum attempts
   */
  public int maxAttempts() {
<span class="fc" id="L227">    return maxAttempts;</span>
  }

  /**
   * Returns the initial delay.
   *
   * @return the initial delay
   */
  public Duration initialDelay() {
<span class="fc" id="L236">    return initialDelay;</span>
  }

  /**
   * Returns the backoff multiplier.
   *
   * @return the backoff multiplier
   */
  public double backoffMultiplier() {
<span class="fc" id="L245">    return backoffMultiplier;</span>
  }

  /**
   * Returns the maximum delay.
   *
   * @return the maximum delay
   */
  public Duration maxDelay() {
<span class="fc" id="L254">    return maxDelay;</span>
  }

  /**
   * Returns whether jitter is enabled.
   *
   * @return true if jitter is enabled
   */
  public boolean useJitter() {
<span class="fc" id="L263">    return useJitter;</span>
  }

  /**
   * Tests whether the given exception should trigger a retry.
   *
   * @param throwable the exception to test
   * @return true if a retry should be attempted
   */
  public boolean shouldRetry(Throwable throwable) {
<span class="fc" id="L273">    return retryPredicate.test(throwable);</span>
  }

  /**
   * Calculates the delay for a given attempt number.
   *
   * @param attemptNumber the attempt number (1-based)
   * @return the delay duration for this attempt
   */
  public Duration delayForAttempt(int attemptNumber) {
<span class="fc bfc" id="L283" title="All 2 branches covered.">    if (attemptNumber &lt;= 1) {</span>
<span class="fc" id="L284">      return initialDelay;</span>
    }

    // Calculate exponential delay
<span class="fc" id="L288">    double multiplier = Math.pow(backoffMultiplier, attemptNumber - 1);</span>
<span class="fc" id="L289">    long delayMillis = (long) (initialDelay.toMillis() * multiplier);</span>

    // Cap at maxDelay
<span class="fc" id="L292">    delayMillis = Math.min(delayMillis, maxDelay.toMillis());</span>

    // Apply jitter if enabled (full jitter: 0 to delay)
<span class="fc bfc" id="L295" title="All 4 branches covered.">    if (useJitter &amp;&amp; delayMillis &gt; 0) {</span>
<span class="fc" id="L296">      delayMillis = ThreadLocalRandom.current().nextLong(delayMillis + 1);</span>
    }

<span class="fc" id="L299">    return Duration.ofMillis(delayMillis);</span>
  }

  // ===== Validation =====

  private static void validateMaxAttempts(int maxAttempts) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (maxAttempts &lt; 1) {</span>
<span class="fc" id="L306">      throw new IllegalArgumentException(&quot;maxAttempts must be at least 1&quot;);</span>
    }
<span class="fc" id="L308">  }</span>

  // ===== Builder =====

  /**
   * Builder for creating custom RetryPolicy instances.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * RetryPolicy policy = RetryPolicy.builder()
   *     .maxAttempts(5)
   *     .initialDelay(Duration.ofMillis(100))
   *     .backoffMultiplier(2.0)
   *     .maxDelay(Duration.ofSeconds(30))
   *     .useJitter(true)
   *     .retryIf(ex -&gt; ex instanceof IOException)
   *     .build();
   * }&lt;/pre&gt;
   */
  public static final class Builder {

<span class="fc" id="L330">    private int maxAttempts = 3;</span>
<span class="fc" id="L331">    private Duration initialDelay = Duration.ofMillis(100);</span>
<span class="fc" id="L332">    private double backoffMultiplier = 2.0;</span>
<span class="fc" id="L333">    private Duration maxDelay = Duration.ofMinutes(5);</span>
<span class="fc" id="L334">    private boolean useJitter = false;</span>
<span class="fc" id="L335">    private Predicate&lt;Throwable&gt; retryPredicate = _ -&gt; true;</span>

<span class="fc" id="L337">    private Builder() {}</span>

    /**
     * Sets the maximum number of attempts.
     *
     * @param maxAttempts the maximum attempts (must be at least 1)
     * @return this builder
     * @throws IllegalArgumentException if maxAttempts is less than 1
     */
    public Builder maxAttempts(int maxAttempts) {
<span class="fc" id="L347">      validateMaxAttempts(maxAttempts);</span>
<span class="fc" id="L348">      this.maxAttempts = maxAttempts;</span>
<span class="fc" id="L349">      return this;</span>
    }

    /**
     * Sets the initial delay.
     *
     * @param initialDelay the initial delay; must not be null
     * @return this builder
     * @throws NullPointerException if initialDelay is null
     */
    public Builder initialDelay(Duration initialDelay) {
<span class="fc" id="L360">      this.initialDelay = Objects.requireNonNull(initialDelay, &quot;initialDelay must not be null&quot;);</span>
<span class="fc" id="L361">      return this;</span>
    }

    /**
     * Sets the backoff multiplier.
     *
     * @param multiplier the multiplier (must be at least 1.0)
     * @return this builder
     * @throws IllegalArgumentException if multiplier is less than 1.0
     */
    public Builder backoffMultiplier(double multiplier) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">      if (multiplier &lt; 1.0) {</span>
<span class="fc" id="L373">        throw new IllegalArgumentException(&quot;backoffMultiplier must be at least 1.0&quot;);</span>
      }
<span class="fc" id="L375">      this.backoffMultiplier = multiplier;</span>
<span class="fc" id="L376">      return this;</span>
    }

    /**
     * Sets the maximum delay.
     *
     * @param maxDelay the maximum delay; must not be null
     * @return this builder
     * @throws NullPointerException if maxDelay is null
     */
    public Builder maxDelay(Duration maxDelay) {
<span class="fc" id="L387">      this.maxDelay = Objects.requireNonNull(maxDelay, &quot;maxDelay must not be null&quot;);</span>
<span class="fc" id="L388">      return this;</span>
    }

    /**
     * Sets whether to use jitter.
     *
     * @param useJitter true to enable jitter
     * @return this builder
     */
    public Builder useJitter(boolean useJitter) {
<span class="fc" id="L398">      this.useJitter = useJitter;</span>
<span class="fc" id="L399">      return this;</span>
    }

    /**
     * Sets the retry predicate.
     *
     * @param predicate the predicate to determine retries
     * @return this builder
     * @throws NullPointerException if predicate is null
     */
    public Builder retryIf(Predicate&lt;Throwable&gt; predicate) {
<span class="fc" id="L410">      this.retryPredicate = Objects.requireNonNull(predicate, &quot;predicate must not be null&quot;);</span>
<span class="fc" id="L411">      return this;</span>
    }

    /**
     * Sets the retry predicate to retry only on the specified exception type.
     *
     * @param exceptionClass the exception class to retry on
     * @return this builder
     * @throws NullPointerException if exceptionClass is null
     */
    public Builder retryOn(Class&lt;? extends Throwable&gt; exceptionClass) {
<span class="fc" id="L422">      Objects.requireNonNull(exceptionClass, &quot;exceptionClass must not be null&quot;);</span>
<span class="fc" id="L423">      this.retryPredicate = ex -&gt; exceptionClass.isInstance(ex);</span>
<span class="fc" id="L424">      return this;</span>
    }

    /**
     * Builds the RetryPolicy.
     *
     * @return the configured RetryPolicy
     */
    public RetryPolicy build() {
<span class="fc" id="L433">      return new RetryPolicy(</span>
          maxAttempts, initialDelay, backoffMultiplier, maxDelay, useJitter, retryPredicate);
    }
  }

  @Override
  public String toString() {
<span class="fc" id="L440">    return &quot;RetryPolicy{&quot;</span>
        + &quot;maxAttempts=&quot;
        + maxAttempts
        + &quot;, initialDelay=&quot;
        + initialDelay
        + &quot;, backoffMultiplier=&quot;
        + backoffMultiplier
        + &quot;, maxDelay=&quot;
        + maxDelay
        + &quot;, useJitter=&quot;
        + useJitter
        + '}';
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>