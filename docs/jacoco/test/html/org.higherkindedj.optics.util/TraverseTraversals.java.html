<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TraverseTraversals.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.util</a> &gt; <span class="el_source">TraverseTraversals.java</span></div><h1>TraverseTraversals.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.util;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Traverse;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListKindHelper;
import org.higherkindedj.hkt.list.ListTraverse;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeKindHelper;
import org.higherkindedj.hkt.stream.StreamKind;
import org.higherkindedj.hkt.stream.StreamTraverse;
import org.higherkindedj.optics.Traversal;
import org.jspecify.annotations.NullMarked;

/**
 * Utility class providing {@link Traversal} instances derived from {@link Traverse} type class
 * instances.
 *
 * &lt;p&gt;This class bridges the Traverse type class with the optics Traversal, enabling generic
 * collection manipulation through optics for any type with a Traverse instance.
 *
 * &lt;h2&gt;Usage Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create a Traversal for List elements
 * Traversal&lt;Kind&lt;ListKind.Witness, String&gt;, String&gt; listTraversal =
 *     TraverseTraversals.forTraverse(ListTraverse.INSTANCE);
 *
 * // Use convenience methods for common types
 * Traversal&lt;Maybe&lt;String&gt;, String&gt; maybeTraversal = TraverseTraversals.forMaybe();
 *
 * // Compose with other optics
 * FocusPath&lt;User, Kind&lt;ListKind.Witness, Role&gt;&gt; rolesPath = UserFocus.roles();
 * TraversalPath&lt;User, Role&gt; allRoles = rolesPath.traverseOver(
 *     ListTraverse.INSTANCE,
 *     ListKindHelper.LIST
 * );
 * }&lt;/pre&gt;
 *
 * @see Traverse
 * @see Traversal
 */
@NullMarked
public final class TraverseTraversals {

  /** Private constructor to prevent instantiation. */
  private TraverseTraversals() {}

  /**
   * Creates a {@link Traversal} for any type with a {@link Traverse} instance.
   *
   * &lt;p&gt;This is the fundamental bridge between the Traverse type class and optics Traversal. It
   * allows any traversable container to be used with the optics composition API.
   *
   * &lt;h2&gt;Example&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // For a custom Tree type with TreeTraverse instance
   * Traverse&lt;TreeKind.Witness&gt; treeTraverse = TreeTraverse.INSTANCE;
   *
   * Traversal&lt;Kind&lt;TreeKind.Witness, String&gt;, String&gt; treeTraversal =
   *     TraverseTraversals.forTraverse(treeTraverse);
   *
   * // Now use with optics
   * Kind&lt;TreeKind.Witness, String&gt; tree = createTree();
   * List&lt;String&gt; allValues = Traversals.getAll(treeTraversal, tree);
   * }&lt;/pre&gt;
   *
   * @param &lt;F&gt; the witness type of the traversable container
   * @param &lt;A&gt; the element type within the container
   * @param traverse the Traverse instance for the container type; must not be null
   * @return a Traversal over the container's elements; never null
   * @throws NullPointerException if traverse is null
   */
  public static &lt;F, A&gt; Traversal&lt;Kind&lt;F, A&gt;, A&gt; forTraverse(Traverse&lt;F&gt; traverse) {
<span class="fc" id="L86">    Objects.requireNonNull(traverse, &quot;traverse must not be null&quot;);</span>

<span class="fc" id="L88">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;G&gt; Kind&lt;G, Kind&lt;F, A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;G, A&gt;&gt; f, Kind&lt;F, A&gt; source, Applicative&lt;G&gt; applicative) {
        // Use Traverse.traverse to map over elements with the effectful function
<span class="fc" id="L93">        return traverse.traverse(applicative, f, source);</span>
      }
    };
  }

  /**
   * Creates a {@link Traversal} for {@link List} elements using the standard List encoding.
   *
   * &lt;p&gt;This traversal focuses on all elements within a {@code Kind&lt;ListKind.Witness, A&gt;}. For
   * working with raw {@code java.util.List}, use {@link ListTraversals#forList()} instead.
   *
   * &lt;h2&gt;Example&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;ListKind.Witness, String&gt; names = ListKindHelper.LIST.widen(List.of(&quot;Alice&quot;, &quot;Bob&quot;));
   *
   * Traversal&lt;Kind&lt;ListKind.Witness, String&gt;, String&gt; traversal =
   *     TraverseTraversals.forListKind();
   *
   * Kind&lt;ListKind.Witness, String&gt; upper = Traversals.modify(
   *     traversal,
   *     String::toUpperCase,
   *     names
   * );
   * // [&quot;ALICE&quot;, &quot;BOB&quot;]
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; the element type within the list
   * @return a Traversal over list elements; never null
   */
  public static &lt;A&gt; Traversal&lt;Kind&lt;ListKind.Witness, A&gt;, A&gt; forListKind() {
<span class="fc" id="L124">    return forTraverse(ListTraverse.INSTANCE);</span>
  }

  /**
   * Creates a {@link Traversal} for {@link Maybe} values.
   *
   * &lt;p&gt;This traversal focuses on the value inside a {@code Maybe} when present (the {@code Just}
   * case). When the {@code Maybe} is {@code Nothing}, the traversal has zero targets.
   *
   * &lt;h2&gt;Example&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * Maybe&lt;String&gt; present = Maybe.just(&quot;hello&quot;);
   * Maybe&lt;String&gt; absent = Maybe.nothing();
   *
   * Traversal&lt;Maybe&lt;String&gt;, String&gt; traversal = TraverseTraversals.forMaybe();
   *
   * Maybe&lt;String&gt; modified = Traversals.modify(traversal, String::toUpperCase, present);
   * // Maybe.just(&quot;HELLO&quot;)
   *
   * Maybe&lt;String&gt; unchanged = Traversals.modify(traversal, String::toUpperCase, absent);
   * // Maybe.nothing()
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; the element type within the Maybe
   * @return a Traversal over Maybe's value when present; never null
   */
  public static &lt;A&gt; Traversal&lt;Maybe&lt;A&gt;, A&gt; forMaybe() {
<span class="fc" id="L152">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;G&gt; Kind&lt;G, Maybe&lt;A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;G, A&gt;&gt; f, Maybe&lt;A&gt; source, Applicative&lt;G&gt; applicative) {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (source.isJust()) {</span>
<span class="fc" id="L157">          return applicative.map(Maybe::just, f.apply(source.get()));</span>
        }
<span class="fc" id="L159">        return applicative.of(source);</span>
      }
    };
  }

  /**
   * Creates a {@link Traversal} for {@link Maybe} values using the Kind encoding.
   *
   * &lt;p&gt;This is the Kind-encoded version of {@link #forMaybe()}, useful when working with the
   * higher-kinded type representation.
   *
   * @param &lt;A&gt; the element type within the Maybe
   * @return a Traversal over Maybe's value when present; never null
   */
  public static &lt;A&gt; Traversal&lt;Kind&lt;MaybeKind.Witness, A&gt;, A&gt; forMaybeKind() {
<span class="fc" id="L174">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;G&gt; Kind&lt;G, Kind&lt;MaybeKind.Witness, A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;G, A&gt;&gt; f,
          Kind&lt;MaybeKind.Witness, A&gt; source,
          Applicative&lt;G&gt; applicative) {
<span class="fc" id="L180">        Maybe&lt;A&gt; maybe = MaybeKindHelper.MAYBE.narrow(source);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (maybe.isJust()) {</span>
<span class="fc" id="L182">          return applicative.map(</span>
<span class="fc" id="L183">              a -&gt; MaybeKindHelper.MAYBE.widen(Maybe.just(a)), f.apply(maybe.get()));</span>
        }
<span class="fc" id="L185">        return applicative.of(source);</span>
      }
    };
  }

  /**
   * Creates a {@link Traversal} for {@link Stream} elements using the Kind encoding.
   *
   * &lt;p&gt;This traversal focuses on all elements within a {@code Kind&lt;StreamKind.Witness, A&gt;}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; Streams are consumed during traversal, so the resulting stream can only be used
   * once.
   *
   * @param &lt;A&gt; the element type within the stream
   * @return a Traversal over stream elements; never null
   */
  public static &lt;A&gt; Traversal&lt;Kind&lt;StreamKind.Witness, A&gt;, A&gt; forStreamKind() {
<span class="fc" id="L202">    return forTraverse(StreamTraverse.INSTANCE);</span>
  }

  /**
   * Creates a {@link Traversal} for {@link java.util.Set} elements.
   *
   * &lt;p&gt;This traversal focuses on all elements within a {@code Set&lt;A&gt;}. Since sets have no defined
   * order, the traversal order may vary between invocations.
   *
   * &lt;h2&gt;Example&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * Set&lt;String&gt; names = Set.of(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);
   *
   * Traversal&lt;Set&lt;String&gt;, String&gt; traversal = TraverseTraversals.forSet();
   *
   * Set&lt;String&gt; upper = Traversals.modify(traversal, String::toUpperCase, names);
   * // Set.of(&quot;ALICE&quot;, &quot;BOB&quot;, &quot;CHARLIE&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; the element type within the set
   * @return a Traversal over set elements; never null
   */
  public static &lt;A&gt; Traversal&lt;Set&lt;A&gt;, A&gt; forSet() {
<span class="fc" id="L226">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;G&gt; Kind&lt;G, Set&lt;A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;G, A&gt;&gt; f, Set&lt;A&gt; source, Applicative&lt;G&gt; applicative) {
        // Convert Set to List for traversal, then collect back to Set
<span class="fc" id="L231">        List&lt;A&gt; asList = List.copyOf(source);</span>
<span class="fc" id="L232">        Kind&lt;ListKind.Witness, A&gt; listKind = ListKindHelper.LIST.widen(asList);</span>

<span class="fc" id="L234">        Kind&lt;G, Kind&lt;ListKind.Witness, A&gt;&gt; traversed =</span>
<span class="fc" id="L235">            ListTraverse.INSTANCE.traverse(applicative, f, listKind);</span>

<span class="fc" id="L237">        return applicative.map(</span>
            kindResult -&gt; {
<span class="fc" id="L239">              List&lt;A&gt; resultList = ListKindHelper.LIST.narrow(kindResult);</span>
<span class="fc" id="L240">              return Set.copyOf(resultList);</span>
            },
            traversed);
      }
    };
  }

  /**
   * Creates a {@link Traversal} for {@link java.util.stream.Stream} elements.
   *
   * &lt;p&gt;This traversal focuses on all elements within a {@code Stream&lt;A&gt;}.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Streams can only be consumed once. After using this traversal, the original
   * stream will be exhausted. The result will be a new stream.
   *
   * @param &lt;A&gt; the element type within the stream
   * @return a Traversal over stream elements; never null
   */
  public static &lt;A&gt; Traversal&lt;Stream&lt;A&gt;, A&gt; forStream() {
<span class="fc" id="L259">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;G&gt; Kind&lt;G, Stream&lt;A&gt;&gt; modifyF(
          Function&lt;A, Kind&lt;G, A&gt;&gt; f, Stream&lt;A&gt; source, Applicative&lt;G&gt; applicative) {
        // Collect stream to list (consuming it), traverse, then convert back to stream
<span class="fc" id="L264">        List&lt;A&gt; asList = source.collect(Collectors.toList());</span>
<span class="fc" id="L265">        Kind&lt;ListKind.Witness, A&gt; listKind = ListKindHelper.LIST.widen(asList);</span>

<span class="fc" id="L267">        Kind&lt;G, Kind&lt;ListKind.Witness, A&gt;&gt; traversed =</span>
<span class="fc" id="L268">            ListTraverse.INSTANCE.traverse(applicative, f, listKind);</span>

<span class="fc" id="L270">        return applicative.map(</span>
            kindResult -&gt; {
<span class="fc" id="L272">              List&lt;A&gt; resultList = ListKindHelper.LIST.narrow(kindResult);</span>
<span class="fc" id="L273">              return resultList.stream();</span>
            },
            traversed);
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>