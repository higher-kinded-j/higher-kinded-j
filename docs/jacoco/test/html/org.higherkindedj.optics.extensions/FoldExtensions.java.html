<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FoldExtensions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.extensions</a> &gt; <span class="el_source">FoldExtensions.java</span></div><h1>FoldExtensions.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.extensions;

import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.optics.Fold;
import org.jspecify.annotations.NullMarked;

/**
 * Extension utilities for {@link Fold} that integrate with higher-kinded-j core types.
 *
 * &lt;p&gt;This class provides {@link Maybe}-based alternatives to {@link Fold}'s {@link Optional}-
 * returning methods, ensuring consistency with higher-kinded-j's functional programming patterns.
 *
 * &lt;h2&gt;Why Maybe Instead of Optional?&lt;/h2&gt;
 *
 * &lt;p&gt;While {@code Optional} is part of the Java standard library, {@code Maybe} provides better
 * integration with higher-kinded-j's type class system and functional patterns. Using {@code Maybe}
 * consistently across optics operations provides:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Seamless integration with other higher-kinded-j core types ({@code Either}, {@code
 *       Validated})
 *   &lt;li&gt;Participation in the HKT (Higher-Kinded Type) framework
 *   &lt;li&gt;More expressive method names ({@code isJust}/{@code isNothing} vs {@code isPresent}/ {@code
 *       isEmpty})
 *   &lt;li&gt;Consistent functional programming style throughout the codebase
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * import static org.higherkindedj.optics.extensions.FoldExtensions.*;
 *
 * // Define a fold over a list of users
 * record User(String name, int age) {}
 * record Team(List&lt;User&gt; members) {}
 *
 * Fold&lt;Team, User&gt; membersFold = ...;
 * Team team = new Team(List.of(
 *     new User(&quot;Alice&quot;, 30),
 *     new User(&quot;Bob&quot;, 25),
 *     new User(&quot;Charlie&quot;, 35)
 * ));
 *
 * // Get first member as Maybe
 * Maybe&lt;User&gt; firstMember = previewMaybe(membersFold, team);
 * firstMember.ifJust(user -&gt; System.out.println(&quot;First: &quot; + user.name()));
 *
 * // Find member matching predicate
 * Maybe&lt;User&gt; adult = findMaybe(membersFold, user -&gt; user.age() &gt;= 30, team);
 * String name = adult.map(User::name).orElse(&quot;No adults found&quot;);
 *
 * // Get all members wrapped in Maybe (distinguishes empty from nothing)
 * Maybe&lt;List&lt;User&gt;&gt; allMembers = getAllMaybe(membersFold, team);
 * allMembers.ifJust(members -&gt; System.out.println(&quot;Count: &quot; + members.size()));
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Method Correspondence&lt;/h2&gt;
 *
 * &lt;table&gt;
 *   &lt;caption&gt;Fold methods and their Maybe-based equivalents&lt;/caption&gt;
 *   &lt;thead&gt;
 *     &lt;tr&gt;
 *       &lt;th&gt;Fold Method&lt;/th&gt;
 *       &lt;th&gt;FoldExtensions Method&lt;/th&gt;
 *       &lt;th&gt;Return Type&lt;/th&gt;
 *     &lt;/tr&gt;
 *   &lt;/thead&gt;
 *   &lt;tbody&gt;
 *     &lt;tr&gt;
 *       &lt;td&gt;{@link Fold#preview(Object)}&lt;/td&gt;
 *       &lt;td&gt;{@link #previewMaybe(Fold, Object)}&lt;/td&gt;
 *       &lt;td&gt;{@code Maybe&lt;A&gt;}&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td&gt;{@link Fold#find(Predicate, Object)}&lt;/td&gt;
 *       &lt;td&gt;{@link #findMaybe(Fold, Predicate, Object)}&lt;/td&gt;
 *       &lt;td&gt;{@code Maybe&lt;A&gt;}&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td&gt;{@link Fold#getAll(Object)}&lt;/td&gt;
 *       &lt;td&gt;{@link #getAllMaybe(Fold, Object)}&lt;/td&gt;
 *       &lt;td&gt;{@code Maybe&lt;List&lt;A&gt;&gt;}&lt;/td&gt;
 *     &lt;/tr&gt;
 *   &lt;/tbody&gt;
 * &lt;/table&gt;
 *
 * @see Fold
 * @see Maybe
 * @since 1.0
 */
@NullMarked
public final class FoldExtensions {

<span class="fc" id="L99">  private FoldExtensions() {</span>
<span class="fc" id="L100">    throw new UnsupportedOperationException(&quot;Utility class - do not instantiate&quot;);</span>
  }

  /**
   * Returns the first focused part as {@link Maybe}.
   *
   * &lt;p&gt;This is a {@code Maybe}-based alternative to {@link Fold#preview(Object)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Maybe&lt;User&gt; firstUser = previewMaybe(userFold, team);
   * firstUser.ifJust(user -&gt; System.out.println(&quot;Found: &quot; + user));
   *
   * // Chain with other Maybe operations
   * Maybe&lt;String&gt; userName = previewMaybe(userFold, team)
   *     .map(User::name)
   *     .map(String::toUpperCase);
   * }&lt;/pre&gt;
   *
   * @param fold The fold to use for focusing on parts of the structure
   * @param source The source structure to query
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code Maybe.just(value)} if a focus exists, {@code Maybe.nothing()} otherwise
   */
  public static &lt;S, A&gt; Maybe&lt;A&gt; previewMaybe(Fold&lt;S, A&gt; fold, S source) {
<span class="fc" id="L127">    return Maybe.fromOptional(fold.preview(source));</span>
  }

  /**
   * Finds the first focused part matching the given predicate as {@link Maybe}.
   *
   * &lt;p&gt;This is a {@code Maybe}-based alternative to {@link Fold#find(Predicate, Object)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Maybe&lt;Item&gt; expensiveItem = findMaybe(
   *     itemFold,
   *     item -&gt; item.price() &gt; 100,
   *     order
   * );
   *
   * expensiveItem.fold(
   *     () -&gt; System.out.println(&quot;No expensive items&quot;),
   *     item -&gt; applyDiscount(item)
   * );
   * }&lt;/pre&gt;
   *
   * @param fold The fold to use for focusing on parts of the structure
   * @param predicate The predicate to test each focused part against
   * @param source The source structure to query
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code Maybe.just(value)} if a matching focus exists, {@code Maybe.nothing()} otherwise
   */
  public static &lt;S, A&gt; Maybe&lt;A&gt; findMaybe(
      Fold&lt;S, A&gt; fold, Predicate&lt;? super A&gt; predicate, S source) {
<span class="fc" id="L159">    return Maybe.fromOptional(fold.find(predicate, source));</span>
  }

  /**
   * Gets all focused parts wrapped in {@link Maybe}.
   *
   * &lt;p&gt;Returns {@code Maybe.just(list)} if the list is non-empty, {@code Maybe.nothing()} for empty
   * lists. This is useful when you want to distinguish between &quot;no results&quot; and &quot;results exist&quot;.
   *
   * &lt;p&gt;This method differs from {@link Fold#getAll(Object)} by wrapping the result in {@code
   * Maybe}, allowing you to treat an empty result as a failure case that can be handled with {@code
   * Maybe}'s monadic operations.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Maybe&lt;List&lt;String&gt;&gt; names = getAllMaybe(nameFold, team);
   *
   * names.fold(
   *     () -&gt; System.out.println(&quot;No names found&quot;),
   *     list -&gt; System.out.println(&quot;Found &quot; + list.size() + &quot; names&quot;)
   * );
   *
   * // Chain with Maybe operations
   * Maybe&lt;Integer&gt; totalLength = getAllMaybe(nameFold, team)
   *     .map(list -&gt; list.stream()
   *         .mapToInt(String::length)
   *         .sum());
   * }&lt;/pre&gt;
   *
   * &lt;h3&gt;When to Use This vs {@code getAll}&lt;/h3&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Use {@code getAllMaybe} when an empty result should be treated as a &quot;nothing&quot; case that
   *       can be chained with other {@code Maybe} operations
   *   &lt;li&gt;Use {@link Fold#getAll(Object)} when you need the list directly and will handle emptiness
   *       with {@code List.isEmpty()}
   * &lt;/ul&gt;
   *
   * @param fold The fold to use for focusing on parts of the structure
   * @param source The source structure to query
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return {@code Maybe.just(list)} if the list is non-empty, {@code Maybe.nothing()} if the list
   *     is empty
   */
  public static &lt;S, A&gt; Maybe&lt;List&lt;A&gt;&gt; getAllMaybe(Fold&lt;S, A&gt; fold, S source) {
<span class="fc" id="L206">    List&lt;A&gt; all = fold.getAll(source);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">    return all.isEmpty() ? Maybe.nothing() : Maybe.just(all);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>