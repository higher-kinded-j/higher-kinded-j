<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EachExtensions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.extensions</a> &gt; <span class="el_source">EachExtensions.java</span></div><h1>EachExtensions.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.extensions;

import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.optics.Each;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.util.TraverseTraversals;
import org.jspecify.annotations.NullMarked;

/**
 * Provides {@link Each} instances for hkj-core types.
 *
 * &lt;p&gt;This class contains factory methods that create {@code Each} instances for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Maybe} - traverses the value if Just (0 or 1 element)
 *   &lt;li&gt;{@link Either} - traverses the Right value (0 or 1 element)
 *   &lt;li&gt;{@link Try} - traverses the Success value (0 or 1 element)
 *   &lt;li&gt;{@link Validated} - traverses the Valid value (0 or 1 element)
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Usage Examples:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Maybe traversal
 * Each&lt;Maybe&lt;String&gt;, String&gt; maybeEach = EachExtensions.maybeEach();
 * Traversal&lt;Maybe&lt;String&gt;, String&gt; trav = maybeEach.each();
 * Maybe&lt;String&gt; upper = Traversals.modify(trav, String::toUpperCase, maybe);
 *
 * // Either right traversal
 * Each&lt;Either&lt;Error, Value&gt;, Value&gt; eitherEach = EachExtensions.eitherRightEach();
 * List&lt;Value&gt; values = Traversals.getAll(eitherEach.each(), either);
 * }&lt;/pre&gt;
 *
 * @see Each
 * @see Traversal
 * @see org.higherkindedj.optics.each.EachInstances
 */
@NullMarked
public final class EachExtensions {

  /** Private constructor to prevent instantiation. */
  private EachExtensions() {}

  // ===== Maybe =====

  /**
   * Creates an {@link Each} instance for {@link Maybe} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses the value if Just (0 or 1 element). Does not support
   * indexed access.
   *
   * @param &lt;A&gt; The element type of the maybe
   * @return An {@code Each} instance for maybes
   */
  public static &lt;A&gt; Each&lt;Maybe&lt;A&gt;, A&gt; maybeEach() {
<span class="fc" id="L66">    return new MaybeEach&lt;&gt;();</span>
  }

  private static final class MaybeEach&lt;A&gt; implements Each&lt;Maybe&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;Maybe&lt;A&gt;, A&gt; each() {
<span class="fc" id="L72">      return TraverseTraversals.forMaybe();</span>
    }
  }

  // ===== Either (Right) =====

  /**
   * Creates an {@link Each} instance for the Right value of {@link Either} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses the Right value if present (0 or 1 element). Left values
   * are not traversed. Does not support indexed access.
   *
   * @param &lt;L&gt; The Left type of the either
   * @param &lt;R&gt; The Right type of the either (traversed element type)
   * @return An {@code Each} instance for Either right values
   */
  public static &lt;L, R&gt; Each&lt;Either&lt;L, R&gt;, R&gt; eitherRightEach() {
<span class="fc" id="L89">    return new EitherRightEach&lt;&gt;();</span>
  }

  private static final class EitherRightEach&lt;L, R&gt; implements Each&lt;Either&lt;L, R&gt;, R&gt; {
    @Override
    public Traversal&lt;Either&lt;L, R&gt;, R&gt; each() {
<span class="fc" id="L95">      return new EitherRightTraversal&lt;&gt;();</span>
    }
  }

  private static final class EitherRightTraversal&lt;L, R&gt; implements Traversal&lt;Either&lt;L, R&gt;, R&gt; {
    @Override
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, Either&lt;L, R&gt;&gt; modifyF(
        Function&lt;R, Kind&lt;F, R&gt;&gt; f, Either&lt;L, R&gt; source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">      if (source.isRight()) {</span>
<span class="fc" id="L104">        return app.map(Either::right, f.apply(source.getRight()));</span>
      }
<span class="fc" id="L106">      return app.of(source);</span>
    }
  }

  // ===== Try (Success) =====

  /**
   * Creates an {@link Each} instance for the Success value of {@link Try} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses the Success value if present (0 or 1 element). Failure
   * values are not traversed. Does not support indexed access.
   *
   * @param &lt;A&gt; The Success type of the try
   * @return An {@code Each} instance for Try success values
   */
  public static &lt;A&gt; Each&lt;Try&lt;A&gt;, A&gt; trySuccessEach() {
<span class="fc" id="L122">    return new TrySuccessEach&lt;&gt;();</span>
  }

  private static final class TrySuccessEach&lt;A&gt; implements Each&lt;Try&lt;A&gt;, A&gt; {
    @Override
    public Traversal&lt;Try&lt;A&gt;, A&gt; each() {
<span class="fc" id="L128">      return new TrySuccessTraversal&lt;&gt;();</span>
    }
  }

  private static final class TrySuccessTraversal&lt;A&gt; implements Traversal&lt;Try&lt;A&gt;, A&gt; {
    @Override
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, Try&lt;A&gt;&gt; modifyF(
        Function&lt;A, Kind&lt;F, A&gt;&gt; f, Try&lt;A&gt; source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">      if (source instanceof Try.Success&lt;A&gt; success) {</span>
<span class="fc" id="L137">        return app.map(Try::success, f.apply(success.value()));</span>
      }
<span class="fc" id="L139">      return app.of(source);</span>
    }
  }

  // ===== Validated (Valid) =====

  /**
   * Creates an {@link Each} instance for the Valid value of {@link Validated} types.
   *
   * &lt;p&gt;The returned {@code Each} traverses the Valid value if present (0 or 1 element). Invalid
   * values are not traversed. Does not support indexed access.
   *
   * @param &lt;E&gt; The Error type of the validated
   * @param &lt;A&gt; The Valid type of the validated (traversed element type)
   * @return An {@code Each} instance for Validated valid values
   */
  public static &lt;E, A&gt; Each&lt;Validated&lt;E, A&gt;, A&gt; validatedEach() {
<span class="fc" id="L156">    return new ValidatedValidEach&lt;&gt;();</span>
  }

  private static final class ValidatedValidEach&lt;E, A&gt; implements Each&lt;Validated&lt;E, A&gt;, A&gt; {
    @Override
    public Traversal&lt;Validated&lt;E, A&gt;, A&gt; each() {
<span class="fc" id="L162">      return new ValidatedValidTraversal&lt;&gt;();</span>
    }
  }

  private static final class ValidatedValidTraversal&lt;E, A&gt;
      implements Traversal&lt;Validated&lt;E, A&gt;, A&gt; {
    @Override
    public &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, Validated&lt;E, A&gt;&gt; modifyF(
        Function&lt;A, Kind&lt;F, A&gt;&gt; f, Validated&lt;E, A&gt; source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">      if (source.isValid()) {</span>
<span class="fc" id="L172">        return app.map(Validated::valid, f.apply(source.get()));</span>
      }
<span class="fc" id="L174">      return app.of(source);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>