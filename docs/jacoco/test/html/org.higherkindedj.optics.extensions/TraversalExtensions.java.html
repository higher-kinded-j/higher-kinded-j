<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TraversalExtensions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.extensions</a> &gt; <span class="el_source">TraversalExtensions.java</span></div><h1>TraversalExtensions.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.extensions;

import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;
import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.List;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Semigroups;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherKind;
import org.higherkindedj.hkt.either.EitherMonad;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.util.Traversals;
import org.jspecify.annotations.NullMarked;

/**
 * Static utility methods for using {@link Traversal} with hkj-core types (Maybe, Either,
 * Validated).
 *
 * &lt;p&gt;This class provides ergonomic helpers for common patterns when working with traversals and
 * operations that can fail or accumulate errors.
 *
 * &lt;p&gt;Example usage:
 *
 * &lt;pre&gt;{@code
 * import static org.higherkindedj.optics.extensions.TraversalExtensions.*;
 *
 * Traversal&lt;List&lt;User&gt;, String&gt; allEmails =
 *     Traversals.forList().andThen(UserLenses.email().asTraversal());
 *
 * // Get all values as Maybe (empty if no targets)
 * Maybe&lt;List&lt;String&gt;&gt; emails = getAllMaybe(allEmails, users);
 *
 * // Modify with validation (fail-fast on first error)
 * Either&lt;String, List&lt;User&gt;&gt; result = modifyAllEither(
 *     allEmails,
 *     email -&gt; email.contains(&quot;@&quot;)
 *         ? Either.right(email)
 *         : Either.left(&quot;Invalid email: &quot; + email),
 *     users
 * );
 *
 * // Modify with validation (accumulate all errors)
 * Validated&lt;List&lt;String&gt;, List&lt;User&gt;&gt; results = modifyAllValidated(
 *     allEmails,
 *     email -&gt; email.contains(&quot;@&quot;)
 *         ? Validated.valid(email)
 *         : Validated.invalid(&quot;Invalid: &quot; + email),
 *     users
 * );
 * }&lt;/pre&gt;
 */
@NullMarked
public final class TraversalExtensions {
  /** Private constructor to prevent instantiation. */
  private TraversalExtensions() {}

  /**
   * Gets all targets from a {@link Traversal} wrapped in a {@link Maybe}.
   *
   * &lt;p&gt;Returns {@code Maybe.just(list)} if the list is non-empty, {@code Maybe.nothing()} if empty.
   *
   * @param traversal The traversal to extract from
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return {@code Maybe.just(list)} if non-empty, {@code Maybe.nothing()} otherwise
   */
  public static &lt;S, A&gt; Maybe&lt;List&lt;A&gt;&gt; getAllMaybe(Traversal&lt;S, A&gt; traversal, S source) {
<span class="fc" id="L80">    List&lt;A&gt; results = Traversals.getAll(traversal, source);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">    return results.isEmpty() ? Maybe.nothing() : Maybe.just(results);</span>
  }

  /**
   * Modifies all targets with a function that returns {@link Maybe}.
   *
   * &lt;p&gt;This is &quot;all or nothing&quot; - if any modification returns {@code Maybe.nothing()}, the entire
   * operation returns {@code Maybe.nothing()}.
   *
   * @param traversal The traversal to modify through
   * @param f The modification function returning {@code Maybe}
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return {@code Maybe.just(updatedSource)} if all modifications succeeded, {@code
   *     Maybe.nothing()} if any failed
   */
  public static &lt;S, A&gt; Maybe&lt;S&gt; modifyAllMaybe(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Maybe&lt;A&gt;&gt; f, S source) {
<span class="fc" id="L100">    Kind&lt;MaybeKind.Witness, S&gt; result =</span>
<span class="fc" id="L101">        traversal.modifyF(a -&gt; MAYBE.widen(f.apply(a)), source, MaybeMonad.INSTANCE);</span>
<span class="fc" id="L102">    return MAYBE.narrow(result);</span>
  }

  /**
   * Modifies all targets with a function that returns {@link Either}.
   *
   * &lt;p&gt;This is fail-fast: the first error encountered will be returned immediately.
   *
   * @param traversal The traversal to modify through
   * @param f The modification function returning {@code Either}
   * @param source The source structure
   * @param &lt;E&gt; The type of the error value
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return {@code Either.right(updatedSource)} if all modifications succeeded, {@code
   *     Either.left(firstError)} otherwise
   */
  public static &lt;E, S, A&gt; Either&lt;E, S&gt; modifyAllEither(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Either&lt;E, A&gt;&gt; f, S source) {
<span class="fc" id="L121">    Kind&lt;EitherKind.Witness&lt;E&gt;, S&gt; result =</span>
<span class="fc" id="L122">        traversal.modifyF(a -&gt; EITHER.widen(f.apply(a)), source, EitherMonad.instance());</span>
<span class="fc" id="L123">    return EITHER.narrow(result);</span>
  }

  /**
   * Modifies all targets with a function that returns {@link Validated}.
   *
   * &lt;p&gt;This accumulates all errors: if multiple modifications fail, all error messages are
   * collected into a list.
   *
   * @param traversal The traversal to modify through
   * @param f The modification function returning {@code Validated}
   * @param source The source structure
   * @param &lt;E&gt; The type of the error value
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return {@code Validated.valid(updatedSource)} if all modifications succeeded, {@code
   *     Validated.invalid(listOfErrors)} otherwise
   */
  public static &lt;E, S, A&gt; Validated&lt;List&lt;E&gt;, S&gt; modifyAllValidated(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Validated&lt;E, A&gt;&gt; f, S source) {
<span class="fc" id="L143">    Kind&lt;ValidatedKind.Witness&lt;List&lt;E&gt;&gt;, S&gt; result =</span>
<span class="fc" id="L144">        traversal.modifyF(</span>
<span class="fc" id="L145">            a -&gt; VALIDATED.widen(f.apply(a).mapError(List::of)),</span>
            source,
<span class="fc" id="L147">            ValidatedMonad.instance(Semigroups.list()));</span>
<span class="fc" id="L148">    return VALIDATED.narrow(result);</span>
  }

  /**
   * Filters and modifies targets with a function that returns {@link Maybe}.
   *
   * &lt;p&gt;Only targets where the function returns {@code Maybe.just(newValue)} are modified. Targets
   * where the function returns {@code Maybe.nothing()} are left unchanged.
   *
   * @param traversal The traversal to modify through
   * @param f The modification function returning {@code Maybe}
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return The updated source structure with selective modifications
   */
  public static &lt;S, A&gt; S modifyWherePossible(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Maybe&lt;A&gt;&gt; f, S source) {
<span class="fc" id="L166">    return Traversals.modify(traversal, a -&gt; f.apply(a).orElse(a), source);</span>
  }

  /**
   * Counts how many targets match a validation function.
   *
   * @param traversal The traversal to check
   * @param validator Validation function that returns {@code Either.right} for valid targets
   * @param source The source structure
   * @param &lt;E&gt; The type of the error value
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return The number of targets that passed validation
   */
  public static &lt;E, S, A&gt; int countValid(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Either&lt;E, A&gt;&gt; validator, S source) {
<span class="fc" id="L182">    return (int)</span>
<span class="fc" id="L183">        Traversals.getAll(traversal, source).stream()</span>
<span class="fc" id="L184">            .filter(a -&gt; validator.apply(a).isRight())</span>
<span class="fc" id="L185">            .count();</span>
  }

  /**
   * Collects all validation errors from targets.
   *
   * @param traversal The traversal to validate
   * @param validator Validation function
   * @param source The source structure
   * @param &lt;E&gt; The type of the error value
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused parts
   * @return List of all validation errors
   */
  public static &lt;E, S, A&gt; List&lt;E&gt; collectErrors(
      Traversal&lt;S, A&gt; traversal, Function&lt;A, Either&lt;E, A&gt;&gt; validator, S source) {
<span class="fc" id="L201">    return Traversals.getAll(traversal, source).stream()</span>
<span class="fc" id="L202">        .map(validator)</span>
<span class="fc" id="L203">        .filter(Either::isLeft)</span>
<span class="fc" id="L204">        .map(Either::getLeft)</span>
<span class="fc" id="L205">        .toList();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>