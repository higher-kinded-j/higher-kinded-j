<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompletableFutureMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.future</a> &gt; <span class="el_source">CompletableFutureMonad.java</span></div><h1>CompletableFutureMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.future;

import static org.higherkindedj.hkt.future.CompletableFutureKindHelper.*;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Implements the {@link MonadError} type class for {@link java.util.concurrent.CompletableFuture},
 * using {@link CompletableFutureKind.Witness} as the higher-kinded type witness and {@link
 * Throwable} as the error type. This class is a stateless singleton, accessible via {@link
 * #INSTANCE}.
 *
 * &lt;p&gt;This class extends {@link CompletableFutureApplicative} and adds error handling capabilities:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #raiseError(Throwable)}: Creates a {@code CompletableFuture} that is already
 *       completed exceptionally.
 *   &lt;li&gt;{@link #handleErrorWith(Kind, Function)}: Allows recovery from an exceptionally completed
 *       {@code CompletableFuture} by providing a new {@code CompletableFuture}.
 * &lt;/ul&gt;
 *
 * @see MonadError
 * @see CompletableFutureApplicative
 * @see CompletableFuture
 * @see CompletableFutureKind.Witness
 */
public class CompletableFutureMonad extends CompletableFutureApplicative
    implements MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; {

<span class="fc" id="L39">  public static Class&lt;CompletableFutureMonad&gt; COMPLETABLE_FUTURE_MONAD_CLASS =</span>
      CompletableFutureMonad.class;

  /** Singleton instance of {@code CompletableFutureMonad}. */
<span class="fc" id="L43">  public static final CompletableFutureMonad INSTANCE = new CompletableFutureMonad();</span>

  /** Private constructor to enforce the singleton pattern. */
  private CompletableFutureMonad() {
    // Default constructor
  }

  /**
   * Sequentially composes two asynchronous computations, where the second computation (produced by
   * function {@code f}) depends on the result of the first computation ({@code ma}).
   *
   * &lt;p&gt;If the first {@code CompletableFuture} ({@code ma}) completes successfully with a value
   * {@code a}, the function {@code f} is applied to {@code a}. {@code f} must return a {@code
   * Kind&lt;CompletableFutureKind.Witness, B&gt;}, which represents another {@code CompletableFuture&lt;B&gt;}.
   * The result of this {@code flatMap} operation is this new {@code CompletableFuture&lt;B&gt;}.
   *
   * &lt;p&gt;If {@code ma} completes exceptionally, or if the application of {@code f} throws an
   * exception, or if {@code f} returns a {@code Kind} that unwraps to a {@code CompletableFuture}
   * that later completes exceptionally, then the resulting {@code CompletableFuture} will also
   * complete exceptionally.
   *
   * &lt;p&gt;This operation is analogous to {@code bind} or {@code &gt;&gt;=} in other monadic contexts and is
   * implemented using {@link CompletableFuture#thenCompose(Function)}.
   *
   * @param &lt;A&gt; The type of the result of the first computation {@code ma}.
   * @param &lt;B&gt; The type of the result of the second computation returned by function {@code f}.
   * @param f A function that takes a value of type {@code A} (the result of {@code ma}) and returns
   *     a {@code Kind&lt;CompletableFutureKind.Witness, B&gt;}, representing the next asynchronous
   *     computation. Must not be null.
   * @param ma A {@code Kind&lt;CompletableFutureKind.Witness, A&gt;} representing the first asynchronous
   *     computation {@code CompletableFuture&lt;A&gt;}. Must not be null.
   * @return A {@code Kind&lt;CompletableFutureKind.Witness, B&gt;} representing a new {@code
   *     CompletableFuture&lt;B&gt;} that will complete with the result of the composed asynchronous
   *     operations. Never null.
   * @throws NullPointerException if {@code f} or {@code ma} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} or the {@code Kind}
   *     returned by {@code f} cannot be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;CompletableFutureKind.Witness, B&gt; flatMap(
      Function&lt;? super @Nullable A, ? extends Kind&lt;CompletableFutureKind.Witness, B&gt;&gt; f,
      Kind&lt;CompletableFutureKind.Witness, A&gt; ma) {

<span class="fc" id="L86">    Validation.function().requireFlatMapper(f, &quot;f&quot;, COMPLETABLE_FUTURE_MONAD_CLASS, FLAT_MAP);</span>
<span class="fc" id="L87">    Validation.kind().requireNonNull(ma, COMPLETABLE_FUTURE_MONAD_CLASS, FLAT_MAP);</span>

<span class="fc" id="L89">    CompletableFuture&lt;A&gt; futureA = FUTURE.narrow(ma);</span>
<span class="fc" id="L90">    CompletableFuture&lt;B&gt; futureB =</span>
<span class="fc" id="L91">        futureA.thenCompose(</span>
            a -&gt; {
<span class="fc" id="L93">              Kind&lt;CompletableFutureKind.Witness, B&gt; kindB = f.apply(a);</span>
<span class="fc" id="L94">              return FUTURE.narrow(kindB);</span>
            });
<span class="fc" id="L96">    return FUTURE.widen(futureB);</span>
  }

  /**
   * Creates a {@code Kind&lt;CompletableFutureKind.Witness, A&gt;} that represents an already
   * exceptionally completed {@link CompletableFuture} with the given {@code error}.
   *
   * @param &lt;A&gt; The phantom type of the value (since this future is failed).
   * @param error The {@link Throwable} with which the future should fail. Must not be null.
   * @return A {@code Kind&lt;CompletableFutureKind.Witness, A&gt;} representing {@code
   *     CompletableFuture.failedFuture(error)}. Never null.
   * @throws NullPointerException if {@code error} is null.
   */
  @Override
  public &lt;A&gt; Kind&lt;CompletableFutureKind.Witness, A&gt; raiseError(Throwable error) {
    // Validate that error (Throwable) is not null
<span class="fc" id="L112">    Validation.coreType().requireError(error, COMPLETABLE_FUTURE_MONAD_CLASS, RAISE_ERROR);</span>
<span class="fc" id="L113">    return FUTURE.widen(CompletableFuture.failedFuture(error));</span>
  }

  /**
   * Handles an exceptionally completed {@code CompletableFuture} (represented by {@code ma}) by
   * applying a recovery function {@code handler}.
   *
   * &lt;p&gt;If {@code ma} completes successfully, its result is returned. If {@code ma} completes
   * exceptionally, the {@code handler} function is applied to the {@link Throwable}. The {@code
   * handler} must return a new {@code Kind&lt;CompletableFutureKind.Witness, A&gt;} (another {@code
   * CompletableFuture&lt;A&gt;}), which then determines the outcome of the operation.
   *
   * &lt;p&gt;The {@link Throwable} passed to the handler is typically the cause of the failure, unwrapped
   * from {@link CompletionException} if necessary.
   *
   * @param &lt;A&gt; The type of the value.
   * @param ma The {@code Kind&lt;CompletableFutureKind.Witness, A&gt;} to handle. Must not be null.
   * @param handler The function to apply if {@code ma} completes exceptionally. It takes the {@link
   *     Throwable} and returns a new {@code Kind&lt;CompletableFutureKind.Witness, A&gt;}. Must not be
   *     null.
   * @return A {@code Kind&lt;CompletableFutureKind.Witness, A&gt;}, either the original if successful, or
   *     the result from the {@code handler}. Never null.
   * @throws NullPointerException if {@code ma} or {@code handler} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} or the result of
   *     {@code handler} cannot be unwrapped.
   */
  @Override
  public &lt;A&gt; Kind&lt;CompletableFutureKind.Witness, A&gt; handleErrorWith(
      Kind&lt;CompletableFutureKind.Witness, A&gt; ma,
      Function&lt;? super Throwable, ? extends Kind&lt;CompletableFutureKind.Witness, A&gt;&gt; handler) {

    // Enhanced validation with descriptive parameter
<span class="fc" id="L145">    Validation.kind()</span>
<span class="fc" id="L146">        .requireNonNull(ma, COMPLETABLE_FUTURE_MONAD_CLASS, HANDLE_ERROR_WITH, &quot;source&quot;);</span>
<span class="fc" id="L147">    Validation.function()</span>
<span class="fc" id="L148">        .requireFunction(handler, &quot;handler&quot;, COMPLETABLE_FUTURE_MONAD_CLASS, HANDLE_ERROR_WITH);</span>

<span class="fc" id="L150">    CompletableFuture&lt;A&gt; futureA = FUTURE.narrow(ma);</span>

    // Optimisation: If already successfully completed, no need to attach handler.
<span class="fc bfc" id="L153" title="All 4 branches covered.">    if (futureA.isDone() &amp;&amp; !futureA.isCompletedExceptionally()) {</span>
<span class="fc" id="L154">      return ma;</span>
    }

<span class="fc" id="L157">    CompletableFuture&lt;A&gt; recoveredFuture =</span>
<span class="fc" id="L158">        futureA.exceptionallyCompose(</span>
            throwable -&gt; {
              Throwable cause =
<span class="fc bfc" id="L161" title="All 4 branches covered.">                  (throwable instanceof CompletionException &amp;&amp; throwable.getCause() != null)</span>
<span class="fc" id="L162">                      ? throwable.getCause()</span>
<span class="fc" id="L163">                      : throwable;</span>
<span class="fc" id="L164">              Kind&lt;CompletableFutureKind.Witness, A&gt; recoveryKind = handler.apply(cause);</span>
<span class="fc" id="L165">              return FUTURE.narrow(recoveryKind);</span>
            });
<span class="fc" id="L167">    return FUTURE.widen(recoveredFuture);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>