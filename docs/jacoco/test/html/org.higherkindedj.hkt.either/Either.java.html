<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Either.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.either</a> &gt; <span class="el_source">Either.java</span></div><h1>Either.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.either;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.NoSuchElementException;
import java.util.function.Consumer;
import java.util.function.Function;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Represents a value of one of two possible types: {@link Left} or {@link Right}. {@code Either} is
 * a sum type, also known as a disjoint union.
 *
 * &lt;p&gt;By convention, {@link Left} is used to represent an error, an alternative flow, or an invalid
 * state, while {@link Right} is used to represent a successful computation or the primary expected
 * value. This convention makes {@code Either} &quot;right-biased&quot; for monadic operations like {@link
 * #map(Function)} and {@link #flatMap(Function)}, which operate on the {@link Right} value and pass
 * {@link Left} values through unchanged.
 *
 * &lt;p&gt;It is a sealed interface, meaning its only direct implementations are {@link Left} and {@link
 * Right}, which are provided as nested records. This allows for exhaustive pattern matching using
 * `switch` expressions.
 *
 * &lt;p&gt;Example of use:
 *
 * &lt;pre&gt;{@code
 * public Either&lt;String, Integer&gt; parseInteger(String s) {
 *  try {
 *    return Either.right(Integer.parseInt(s));
 *  } catch (NumberFormatException e) {
 *    return Either.left(&quot;Invalid number format: &quot; + s);
 *  }
 * }
 *
 * Either&lt;String, Integer&gt; result = parseInteger(&quot;123&quot;);
 * result.fold(
 *  error -&gt; System.out.println(&quot;Error: &quot; + error),
 *  value -&gt; System.out.println(&quot;Parsed value: &quot; + value)
 * );
 *
 * Either&lt;String, Integer&gt; length = result.map(v -&gt; v * 2); // Only maps if result was Right
 * }&lt;/pre&gt;
 *
 * @param &lt;L&gt; The type of the value if this is a {@link Left}. Conventionally the error type.
 * @param &lt;R&gt; The type of the value if this is a {@link Right}. Conventionally the success type.
 */
public sealed interface Either&lt;L, R&gt; permits Either.Left, Either.Right {

<span class="fc" id="L52">  Class&lt;Either&gt; EITHER_CLASS = Either.class;</span>

  /**
   * Checks if this {@code Either} instance is a {@link Left}.
   *
   * @return {@code true} if this is a {@link Left}, {@code false} otherwise.
   */
  boolean isLeft();

  /**
   * Checks if this {@code Either} instance is a {@link Right}.
   *
   * @return {@code true} if this is a {@link Right}, {@code false} otherwise.
   */
  boolean isRight();

  /**
   * Retrieves the value if this is a {@link Left}.
   *
   * &lt;p&gt;&lt;b&gt;Caution:&lt;/b&gt; This method should typically be called only after ensuring {@link #isLeft()}
   * returns {@code true}, or within a context where being a {@code Left} is guaranteed. Otherwise,
   * prefer using {@link #fold(Function, Function)} or pattern matching to safely access the value.
   *
   * @return The value of type {@code L} if this is a {@link Left}.
   * @throws NoSuchElementException if this is a {@link Right}.
   */
  @Nullable L getLeft() throws NoSuchElementException;

  /**
   * Retrieves the value if this is a {@link Right}.
   *
   * &lt;p&gt;&lt;b&gt;Caution:&lt;/b&gt; This method should typically be called only after ensuring {@link
   * #isRight()} returns {@code true}, or within a context where being a {@code Right} is
   * guaranteed. Otherwise, prefer using {@link #fold(Function, Function)}, {@link #map(Function)},
   * or pattern matching to safely access the value.
   *
   * @return The value of type {@code R} if this is a {@link Right}.
   * @throws NoSuchElementException if this is a {@link Left}.
   */
  R getRight() throws NoSuchElementException;

  /**
   * Applies one of two functions depending on whether this instance is a {@link Left} or a {@link
   * Right}. This is a universal way to extract the value from an {@code Either} by handling both
   * cases explicitly.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, Integer&gt; either = Either.right(10);
   * String result = either.fold(
   * error -&gt; &quot;Error: &quot; + error,
   * value -&gt; &quot;Success: &quot; + value.toString()
   * );
   * // result will be &quot;Success: 10&quot;
   * }&lt;/pre&gt;
   *
   * @param leftMapper The non-null function to apply if this is a {@link Left}. It accepts the
   *     {@code L} value and returns a {@code T}.
   * @param rightMapper The non-null function to apply if this is a {@link Right}. It accepts the
   *     {@code R} value and returns a {@code T}.
   * @param &lt;T&gt; The target type to which both paths will be mapped.
   * @return The result of applying the appropriate mapping function. The result is guaranteed to be
   *     non-null if both mappers produce non-null results.
   * @throws NullPointerException if either {@code leftMapper} or {@code rightMapper} is null.
   */
  default &lt;T&gt; T fold(
      Function&lt;? super L, ? extends T&gt; leftMapper, Function&lt;? super R, ? extends T&gt; rightMapper) {
<span class="fc" id="L120">    Validation.function().requireFunction(leftMapper, &quot;leftMapper&quot;, EITHER_CLASS, FOLD);</span>
<span class="fc" id="L121">    Validation.function().requireFunction(rightMapper, &quot;rightMapper&quot;, EITHER_CLASS, FOLD);</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L124">      case Left&lt;L, R&gt;(var leftValue) -&gt; leftMapper.apply(leftValue);</span>
<span class="fc" id="L125">      case Right&lt;L, R&gt;(var rightValue) -&gt; rightMapper.apply(rightValue);</span>
    };
  }

  /**
   * If this is a {@link Right}, applies the given mapping function to its value, returning a new
   * {@code Either.Right} containing the result. If this is a {@link Left}, it returns the original
   * {@link Left} instance unchanged.
   *
   * &lt;p&gt;This operation is &quot;right-biased&quot;.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, Integer&gt; right = Either.right(5);
   * Either&lt;String, String&gt; mappedRight = right.map(i -&gt; &quot;Value: &quot; + i); // Right(&quot;Value: 5&quot;)
   *
   * Either&lt;String, Integer&gt; left = Either.left(&quot;Error&quot;);
   * Either&lt;String, String&gt; mappedLeft = left.map(i -&gt; &quot;Value: &quot; + i); // Left(&quot;Error&quot;)
   * }&lt;/pre&gt;
   *
   * @param mapper The non-null function to apply to the {@link Right} value.
   * @param &lt;R2&gt; The type of the value in the resulting {@link Right} if this is a {@link Right}.
   * @return A new {@code Either&lt;L, R2&gt;} resulting from applying the mapper if this is a {@link
   *     Right}, or the original {@link Left} instance cast to {@code Either&lt;L, R2&gt;}. The returned
   *     {@code Either} will be non-null.
   * @throws NullPointerException if {@code mapper} is null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;R2&gt; Either&lt;L, R2&gt; map(Function&lt;? super R, ? extends R2&gt; mapper) {
<span class="fc" id="L155">    Validation.function().requireMapper(mapper, &quot;mapper&quot;, EITHER_CLASS, MAP);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L157">      case Left&lt;L, R&gt; l -&gt; (Either&lt;L, R2&gt;) l; // Return self, cast is safe.</span>
<span class="fc" id="L158">      case Right&lt;L, R&gt;(var rValue) -&gt; Either.right(mapper.apply(rValue)); // Create new Right</span>
    };
  }

  /**
   * Transforms both the {@link Left} and {@link Right} values of this {@code Either} using the
   * provided mapping functions, producing a new {@code Either} with potentially different types for
   * both parameters.
   *
   * &lt;p&gt;This is the fundamental bifunctor operation for {@code Either}, allowing simultaneous
   * transformation of both the error channel (left) and success channel (right). Exactly one of the
   * two functions will be applied, depending on whether this is a {@link Left} or {@link Right}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, Integer&gt; success = Either.right(42);
   * Either&lt;Exception, String&gt; result1 = success.bimap(
   *     Exception::new,           // Transform left (error) - not applied
   *     n -&gt; &quot;Value: &quot; + n        // Transform right (success) - applied
   * );
   * // result1 = Right(&quot;Value: 42&quot;)
   *
   * Either&lt;String, Integer&gt; failure = Either.left(&quot;not found&quot;);
   * Either&lt;Exception, String&gt; result2 = failure.bimap(
   *     Exception::new,           // Transform left (error) - applied
   *     n -&gt; &quot;Value: &quot; + n        // Transform right (success) - not applied
   * );
   * // result2 = Left(new Exception(&quot;not found&quot;))
   * }&lt;/pre&gt;
   *
   * @param leftMapper The non-null function to apply to the {@link Left} value if this is a {@link
   *     Left}.
   * @param rightMapper The non-null function to apply to the {@link Right} value if this is a
   *     {@link Right}.
   * @param &lt;L2&gt; The type of the {@link Left} value in the resulting {@code Either}.
   * @param &lt;R2&gt; The type of the {@link Right} value in the resulting {@code Either}.
   * @return A new {@code Either&lt;L2, R2&gt;} with one of its values transformed according to the
   *     appropriate mapper. The returned {@code Either} will be non-null.
   * @throws NullPointerException if either {@code leftMapper} or {@code rightMapper} is null.
   */
  default &lt;L2, R2&gt; Either&lt;L2, R2&gt; bimap(
      Function&lt;? super L, ? extends L2&gt; leftMapper, Function&lt;? super R, ? extends R2&gt; rightMapper) {
<span class="fc" id="L201">    Validation.function().requireMapper(leftMapper, &quot;leftMapper&quot;, EITHER_CLASS, BIMAP);</span>
<span class="fc" id="L202">    Validation.function().requireMapper(rightMapper, &quot;rightMapper&quot;, EITHER_CLASS, BIMAP);</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L205">      case Left&lt;L, R&gt;(var leftValue) -&gt; Either.left(leftMapper.apply(leftValue));</span>
<span class="fc" id="L206">      case Right&lt;L, R&gt;(var rightValue) -&gt; Either.right(rightMapper.apply(rightValue));</span>
    };
  }

  /**
   * Transforms only the {@link Left} value of this {@code Either}, leaving the {@link Right} value
   * unchanged if present.
   *
   * &lt;p&gt;This operation allows you to transform the error channel whilst preserving the success
   * channel. It is useful for converting error types, enriching error messages, or mapping between
   * different error representations.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, Integer&gt; failure = Either.left(&quot;invalid input&quot;);
   * Either&lt;Exception, Integer&gt; result1 = failure.mapLeft(Exception::new);
   * // result1 = Left(new Exception(&quot;invalid input&quot;))
   *
   * Either&lt;String, Integer&gt; success = Either.right(42);
   * Either&lt;Exception, Integer&gt; result2 = success.mapLeft(Exception::new);
   * // result2 = Right(42) - right value unchanged
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is equivalent to calling {@code bimap(leftMapper, Function.identity())}.
   *
   * @param leftMapper The non-null function to apply to the {@link Left} value if this is a {@link
   *     Left}.
   * @param &lt;L2&gt; The type of the {@link Left} value in the resulting {@code Either}.
   * @return A new {@code Either&lt;L2, R&gt;} with the left value transformed if this was a {@link Left},
   *     or the original {@link Right} value unchanged. The returned {@code Either} will be
   *     non-null.
   * @throws NullPointerException if {@code leftMapper} is null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;L2&gt; Either&lt;L2, R&gt; mapLeft(Function&lt;? super L, ? extends L2&gt; leftMapper) {
<span class="fc" id="L242">    Validation.function().requireMapper(leftMapper, &quot;leftMapper&quot;, EITHER_CLASS, MAP_LEFT);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L245">      case Left&lt;L, R&gt;(var leftValue) -&gt; Either.left(leftMapper.apply(leftValue));</span>
<span class="fc" id="L246">      case Right&lt;L, R&gt; r -&gt; (Either&lt;L2, R&gt;) r; // Right remains unchanged, cast is safe</span>
    };
  }

  /**
   * Transforms only the {@link Right} value of this {@code Either}, leaving the {@link Left} value
   * unchanged if present.
   *
   * &lt;p&gt;This operation is functionally identical to {@link #map(Function)} but is provided for
   * symmetry with {@link #mapLeft(Function)} and to make bifunctor operations explicit. It
   * transforms the success channel whilst preserving the error channel.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either&lt;String, Integer&gt; success = Either.right(42);
   * Either&lt;String, String&gt; result1 = success.mapRight(n -&gt; &quot;Value: &quot; + n);
   * // result1 = Right(&quot;Value: 42&quot;)
   *
   * Either&lt;String, Integer&gt; failure = Either.left(&quot;error&quot;);
   * Either&lt;String, String&gt; result2 = failure.mapRight(n -&gt; &quot;Value: &quot; + n);
   * // result2 = Left(&quot;error&quot;) - left value unchanged
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is equivalent to calling {@link #map(Function)} or {@code
   * bimap(Function.identity(), rightMapper)}.
   *
   * @param rightMapper The non-null function to apply to the {@link Right} value if this is a
   *     {@link Right}.
   * @param &lt;R2&gt; The type of the {@link Right} value in the resulting {@code Either}.
   * @return A new {@code Either&lt;L, R2&gt;} with the right value transformed if this was a {@link
   *     Right}, or the original {@link Left} value unchanged. The returned {@code Either} will be
   *     non-null.
   * @throws NullPointerException if {@code rightMapper} is null.
   * @see #map(Function)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;R2&gt; Either&lt;L, R2&gt; mapRight(Function&lt;? super R, ? extends R2&gt; rightMapper) {
<span class="fc" id="L284">    Validation.function().requireMapper(rightMapper, &quot;rightMapper&quot;, EITHER_CLASS, MAP_RIGHT);</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L287">      case Left&lt;L, R&gt; l -&gt; (Either&lt;L, R2&gt;) l; // Left remains unchanged, cast is safe</span>
<span class="fc" id="L288">      case Right&lt;L, R&gt;(var rightValue) -&gt; Either.right(rightMapper.apply(rightValue));</span>
    };
  }

  /**
   * If this is a {@link Right}, applies the given {@code Either}-bearing function to its value and
   * returns the result. If this is a {@link Left}, it returns the original {@link Left} instance
   * unchanged.
   *
   * &lt;p&gt;This operation is &quot;right-biased&quot; and is fundamental for monadic sequencing. It allows
   * chaining operations that each return an {@code Either}, propagating {@link Left} values
   * automatically.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Function&lt;Integer, Either&lt;String, Double&gt;&gt; half =
   * val -&gt; val % 2 == 0 ? Either.right(val / 2.0) : Either.left(&quot;Cannot half odd number&quot;);
   *
   * Either&lt;String, Integer&gt; r1 = Either.right(10);
   * Either&lt;String, Double&gt; result1 = r1.flatMap(half); // Right(5.0)
   *
   * Either&lt;String, Integer&gt; r2 = Either.right(5);
   * Either&lt;String, Double&gt; result2 = r2.flatMap(half); // Left(&quot;Cannot half odd number&quot;)
   *
   * Either&lt;String, Integer&gt; l = Either.left(&quot;Initial error&quot;);
   * Either&lt;String, Double&gt; result3 = l.flatMap(half); // Left(&quot;Initial error&quot;)
   * }&lt;/pre&gt;
   *
   * @param mapper The non-null function to apply to the {@link Right} value. This function must
   *     return an {@code Either&lt;L, ? extends R2&gt;}.
   * @param &lt;R2&gt; The type of the {@link Right} value in the {@code Either} returned by the mapper.
   * @return The {@code Either&lt;L, R2&gt;} result from applying {@code mapper} if this is a {@link
   *     Right}, or the original {@link Left} instance cast to {@code Either&lt;L, R2&gt;}. The returned
   *     {@code Either} is guaranteed to be non-null if the mapper produces non-null Eithers.
   * @throws NullPointerException if {@code mapper} is null, or if {@code mapper} returns null when
   *     applied (the implementation in {@code Right#flatMap} checks this).
   */
  &lt;R2&gt; Either&lt;L, R2&gt; flatMap(Function&lt;? super R, ? extends Either&lt;L, ? extends R2&gt;&gt; mapper);

  /**
   * Performs the given action on the value if this is a {@link Left}. No action is performed if
   * this is a {@link Right}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either.left(&quot;Error details&quot;).ifLeft(System.err::println);
   * Either.right(42).ifLeft(error -&gt; System.err.println(&quot;Unexpected error: &quot; + error)); // No output
   * }&lt;/pre&gt;
   *
   * @param action The non-null {@link Consumer} to execute with the {@link Left} value.
   * @throws NullPointerException if {@code action} is null (checked by implementations).
   */
  void ifLeft(Consumer&lt;? super L&gt; action);

  /**
   * Performs the given action on the value if this is a {@link Right}. No action is performed if
   * this is a {@link Left}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Either.right(100).ifRight(value -&gt; System.out.println(&quot;Got value: &quot; + value));
   * Either.left(&quot;Error&quot;).ifRight(System.out::println); // No output
   * }&lt;/pre&gt;
   *
   * @param action The non-null {@link Consumer} to execute with the {@link Right} value.
   * @throws NullPointerException if {@code action} is null (checked by implementations).
   */
  void ifRight(Consumer&lt;? super R&gt; action);

  // --- Static Factory Methods ---

  /**
   * Creates an {@code Either} instance representing the {@link Left} case. The value for {@code
   * Left} can be null, aligning with common conventions where a left value might represent an error
   * state that doesn't carry detailed information, or where {@code null} itself is a valid
   * representation for the left type.
   *
   * @param value The value for the {@link Left} case. Can be {@code null}.
   * @param &lt;L&gt; The type of the {@link Left} value.
   * @param &lt;R&gt; The type of the (absent) {@link Right} value.
   * @return A new non-null {@link Left} instance containing the given value.
   */
  static &lt;L, R&gt; Either&lt;L, R&gt; left(@Nullable L value) {
<span class="fc" id="L374">    return new Left&lt;&gt;(value);</span>
  }

  /**
   * Creates an {@code Either} instance representing the {@link Right} case. The value for {@code
   * Right} can be {@code null} if {@code R} is a nullable type. If non-null values are strictly
   * desired for the {@code Right} case, callers should ensure this or use wrapper types like {@link
   * java.util.Optional} for {@code R}.
   *
   * @param value The value for the {@link Right} case. Can be {@code null}.
   * @param &lt;L&gt; The type of the (absent) {@link Left} value.
   * @param &lt;R&gt; The type of the {@link Right} value.
   * @return A new non-null {@link Right} instance containing the given value.
   */
  static &lt;L, R&gt; Either&lt;L, R&gt; right(@Nullable R value) {
<span class="fc" id="L389">    return new Right&lt;&gt;(value);</span>
  }

  /**
   * Represents the {@link Left} case of an {@link Either}. By convention, this holds an error or
   * alternative value. This is a {@link Record} for conciseness and immutability.
   *
   * &lt;p&gt;As part of the HKT pattern, this class implements both {@link EitherKind} and {@link
   * EitherKind2}, allowing it to be used with typeclasses expecting {@code
   * Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;} (for functors/monads) or {@code Kind2&lt;EitherKind2.Witness, L,
   * R&gt;} (for bifunctors).
   *
   * @param &lt;L&gt; The type of the value held.
   * @param &lt;R&gt; The type of the {@link Right} value (phantom type for {@code Left}).
   * @param value The value of type {@code L}. Can be {@code null}.
   */
<span class="fc" id="L405">  record Left&lt;L, R&gt;(@Nullable L value)</span>
      implements Either&lt;L, R&gt;, EitherKind&lt;L, R&gt;, EitherKind2&lt;L, R&gt; {

    @Override
    public boolean isLeft() {
<span class="fc" id="L410">      return true;</span>
    }

    @Override
    public boolean isRight() {
<span class="fc" id="L415">      return false;</span>
    }

    @Override
    public @Nullable L getLeft() {
<span class="fc" id="L420">      return value;</span>
    }

    @Override
    public R getRight() {
<span class="fc" id="L425">      throw new NoSuchElementException(&quot;Cannot invoke getRight() on a Left instance.&quot;);</span>
    }

    // flatMap is overridden from default for clarity, it does nothing on Left.
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;R2&gt; Either&lt;L, R2&gt; flatMap(
        Function&lt;? super R, ? extends Either&lt;L, ? extends R2&gt;&gt; mapper) {
<span class="fc" id="L433">      Validation.function().requireFlatMapper(mapper, &quot;mapper&quot;, Either.class, FLAT_MAP);</span>
<span class="fc" id="L434">      return (Either&lt;L, R2&gt;) this; // Left remains Left, type L is unchanged.</span>
    }

    @Override
    public void ifLeft(Consumer&lt;? super L&gt; action) {
<span class="fc" id="L439">      Validation.function().requireFunction(action, &quot;action&quot;, Either.class, IF_LEFT);</span>
<span class="fc" id="L440">      action.accept(value);</span>
<span class="fc" id="L441">    }</span>

    @Override
    public void ifRight(Consumer&lt;? super R&gt; action) {
<span class="fc" id="L445">      Validation.function().requireFunction(action, &quot;action&quot;, EITHER_CLASS, IF_RIGHT);</span>
<span class="fc" id="L446">    }</span>

    /**
     * Returns a string representation of this {@link Left} instance. Example: {@code
     * Left(ErrorDetails)}
     *
     * @return A string representation.
     */
    @Override
    public String toString() {
<span class="fc" id="L456">      return &quot;Left(&quot; + value + &quot;)&quot;;</span>
    }
  }

  /**
   * Represents the {@link Right} case of an {@link Either}. By convention, this holds the
   * successful or primary value. This is a {@link Record} for conciseness and immutability.
   *
   * &lt;p&gt;As part of the HKT pattern, this class implements both {@link EitherKind} and {@link
   * EitherKind2}, allowing it to be used with typeclasses expecting {@code
   * Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;} (for functors/monads) or {@code Kind2&lt;EitherKind2.Witness, L,
   * R&gt;} (for bifunctors).
   *
   * @param &lt;L&gt; The type of the {@link Left} value (phantom type for {@code Right}).
   * @param &lt;R&gt; The type of the value held.
   * @param value The value of type {@code R}. Can be {@code null}.
   */
<span class="fc" id="L473">  record Right&lt;L, R&gt;(@Nullable R value)</span>
      implements Either&lt;L, R&gt;, EitherKind&lt;L, R&gt;, EitherKind2&lt;L, R&gt; {
    @Override
    public boolean isLeft() {
<span class="fc" id="L477">      return false;</span>
    }

    @Override
    public boolean isRight() {
<span class="fc" id="L482">      return true;</span>
    }

    @Override
    public L getLeft() {
<span class="fc" id="L487">      throw new NoSuchElementException(&quot;Cannot invoke getLeft() on a Right instance.&quot;);</span>
    }

    @Override
    public @Nullable R getRight() {
<span class="fc" id="L492">      return value;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;R2&gt; Either&lt;L, R2&gt; flatMap(
        Function&lt;? super R, ? extends Either&lt;L, ? extends R2&gt;&gt; mapper) {
<span class="fc" id="L499">      Validation.function().requireFlatMapper(mapper, &quot;mapper&quot;, Either.class, FLAT_MAP);</span>
      // Apply the mapper, which itself returns an Either.
<span class="fc" id="L501">      Either&lt;L, ? extends R2&gt; result = mapper.apply(value);</span>
<span class="fc" id="L502">      Validation.function()</span>
<span class="fc" id="L503">          .requireNonNullResult(result, &quot;mapper&quot;, EITHER_CLASS, FLAT_MAP, EITHER_CLASS);</span>
      // Cast is safe because ? extends R2 is compatible with R2
<span class="fc" id="L505">      return (Either&lt;L, R2&gt;) result;</span>
    }

    @Override
    public void ifLeft(Consumer&lt;? super L&gt; action) {
<span class="fc" id="L510">      Validation.function().requireFunction(action, &quot;action&quot;, Either.class, IF_LEFT);</span>
<span class="fc" id="L511">    }</span>

    @Override
    public void ifRight(Consumer&lt;? super R&gt; action) {
<span class="fc" id="L515">      Validation.function().requireFunction(action, &quot;action&quot;, Either.class, IF_RIGHT);</span>
<span class="fc" id="L516">      action.accept(value);</span>
<span class="fc" id="L517">    }</span>

    /**
     * Returns a string representation of this {@link Right} instance. Example: {@code Right(42)}
     *
     * @return A string representation.
     */
    @Override
    public String toString() {
<span class="fc" id="L526">      return &quot;Right(&quot; + value + &quot;)&quot;;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>