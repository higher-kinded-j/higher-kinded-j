<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EitherSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.either</a> &gt; <span class="el_source">EitherSelective.java</span></div><h1>EitherSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.either;

import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Choice;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link Either}, with a fixed &quot;Left&quot; type {@code
 * L}. This provides selective applicative operations that allow conditional execution based on the
 * result of previous computations.
 *
 * &lt;p&gt;The Selective interface sits between {@link org.higherkindedj.hkt.Applicative} and {@link
 * org.higherkindedj.hkt.Monad} in terms of power. It allows for static analysis of effects while
 * still supporting conditional behaviour, unlike pure Applicatives which have no conditional
 * execution, and Monads which are fully dynamic.
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies an effectful function based on a Choice.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with different
 *       handlers.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes an effect based on a boolean.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional for selective functors.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This implementation is right-biased: operations work on {@link Either.Right} values and
 * propagate {@link Either.Left} unchanged.
 *
 * @param &lt;L&gt; The fixed type for the &quot;Left&quot; value, representing errors or alternative values.
 * @see Either
 * @see EitherMonad
 * @see Selective
 * @see Choice
 */
public final class EitherSelective&lt;L&gt; extends EitherMonad&lt;L&gt;
    implements Selective&lt;EitherKind.Witness&lt;L&gt;&gt; {

<span class="fc" id="L47">  private static final EitherSelective&lt;?&gt; INSTANCE = new EitherSelective&lt;&gt;();</span>
<span class="fc" id="L48">  private static final Class&lt;EitherSelective&gt; EITHER_SELECTIVE_CLASS = EitherSelective.class;</span>

  private EitherSelective() {
    super();
  }

  /**
   * Returns the singleton instance of {@code EitherSelective} for the specified Left type.
   *
   * @param &lt;L&gt; The type of the Left value (error type).
   * @return The singleton instance.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;L&gt; EitherSelective&lt;L&gt; instance() {
<span class="fc" id="L62">    return (EitherSelective&lt;L&gt;) INSTANCE;</span>
  }

  /**
   * The core selective operation for Either. Given an effectful choice {@code fab} and an effectful
   * function {@code ff}, applies the function only if the choice is a {@code Left}.
   *
   * &lt;p&gt;Since Either already implements Choice, we can work with it directly without conversion.
   *
   * &lt;p&gt;Behavior:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If {@code fab} is {@code Right(b)}: Returns {@code Right(b)}, {@code ff} is not
   *       evaluated.
   *   &lt;li&gt;If {@code fab} is {@code Left(a)}: Applies the function from {@code ff} to {@code a}.
   *   &lt;li&gt;If both {@code fab} and {@code ff} are {@code Left}: Returns the first {@code Left}
   *       (fail-fast).
   * &lt;/ul&gt;
   *
   * @param fab A {@link Kind} representing {@code Either&lt;L, Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param ff A {@link Kind} representing {@code Either&lt;L, Function&lt;A, B&gt;&gt;}. Must not be null.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left} of the Choice).
   * @param &lt;B&gt; The output type and the type inside {@code Right} of the Choice.
   * @return A {@link Kind} representing {@code Either&lt;L, B&gt;}. Never null.
   * @throws NullPointerException if {@code fab} or {@code ff} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;EitherKind.Witness&lt;L&gt;, B&gt; select(
      Kind&lt;EitherKind.Witness&lt;L&gt;, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;EitherKind.Witness&lt;L&gt;, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L95">    Validation.kind().requireNonNull(fab, EITHER_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L96">    Validation.kind().requireNonNull(ff, EITHER_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L98">    Either&lt;L, Choice&lt;A, B&gt;&gt; eitherChoice = EITHER.narrow(fab);</span>
<span class="fc" id="L99">    Either&lt;L, Function&lt;A, B&gt;&gt; eitherFunction = EITHER.narrow(ff);</span>

    // If eitherChoice is Left(error), propagate the error
<span class="fc bfc" id="L102" title="All 2 branches covered.">    if (eitherChoice.isLeft()) {</span>
<span class="fc" id="L103">      return EITHER.widen(Either.left(eitherChoice.getLeft()));</span>
    }

<span class="fc" id="L106">    Choice&lt;A, B&gt; choice = eitherChoice.getRight();</span>

    // If choice is Right(b), we already have our value
<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (choice.isRight()) {</span>
<span class="fc" id="L110">      return EITHER.widen(Either.right(choice.getRight()));</span>
    }

    // Choice is Left(a), so we need to apply the function
    // But first check if the function is available
<span class="fc bfc" id="L115" title="All 2 branches covered.">    if (eitherFunction.isLeft()) {</span>
      // Function is not available, propagate that error
<span class="fc" id="L117">      return EITHER.widen(Either.left(eitherFunction.getLeft()));</span>
    }

    // Apply the function to the value
<span class="fc" id="L121">    A value = choice.getLeft();</span>
<span class="fc" id="L122">    Function&lt;A, B&gt; function = eitherFunction.getRight();</span>
<span class="fc" id="L123">    B result = function.apply(value);</span>

<span class="fc" id="L125">    return EITHER.widen(Either.right(result));</span>
  }

  /**
   * Optimised implementation of {@code branch} for Either. Provides a two-way conditional choice,
   * applying the appropriate handler based on whether the Choice is Left or Right.
   *
   * &lt;p&gt;This implementation is more efficient than the default because it can short-circuit on the
   * first Left (error) encountered.
   *
   * @param fab A {@link Kind} representing {@code Either&lt;L, Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code Either&lt;L, Function&lt;A, C&gt;&gt;} for the Left case. Must
   *     not be null.
   * @param fr A {@link Kind} representing {@code Either&lt;L, Function&lt;B, C&gt;&gt;} for the Right case.
   *     Must not be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code Either&lt;L, C&gt;}. Never null.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;EitherKind.Witness&lt;L&gt;, C&gt; branch(
      Kind&lt;EitherKind.Witness&lt;L&gt;, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;EitherKind.Witness&lt;L&gt;, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;EitherKind.Witness&lt;L&gt;, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L151">    Validation.kind().requireNonNull(fab, EITHER_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L152">    Validation.kind().requireNonNull(fl, EITHER_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L153">    Validation.kind().requireNonNull(fr, EITHER_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L155">    Either&lt;L, Choice&lt;A, B&gt;&gt; eitherChoice = EITHER.narrow(fab);</span>

    // Short-circuit on error in choice
<span class="fc bfc" id="L158" title="All 2 branches covered.">    if (eitherChoice.isLeft()) {</span>
<span class="fc" id="L159">      return EITHER.widen(Either.left(eitherChoice.getLeft()));</span>
    }

<span class="fc" id="L162">    Choice&lt;A, B&gt; choice = eitherChoice.getRight();</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (choice.isLeft()) {</span>
      // Use left handler
<span class="fc" id="L166">      Either&lt;L, Function&lt;A, C&gt;&gt; leftFunction = EITHER.narrow(fl);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">      if (leftFunction.isLeft()) {</span>
<span class="fc" id="L168">        return EITHER.widen(Either.left(leftFunction.getLeft()));</span>
      }
<span class="fc" id="L170">      C result = leftFunction.getRight().apply(choice.getLeft());</span>
<span class="fc" id="L171">      return EITHER.widen(Either.right(result));</span>
    } else {
      // Use right handler
<span class="fc" id="L174">      Either&lt;L, Function&lt;B, C&gt;&gt; rightFunction = EITHER.narrow(fr);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (rightFunction.isLeft()) {</span>
<span class="fc" id="L176">        return EITHER.widen(Either.left(rightFunction.getLeft()));</span>
      }
<span class="fc" id="L178">      C result = rightFunction.getRight().apply(choice.getRight());</span>
<span class="fc" id="L179">      return EITHER.widen(Either.right(result));</span>
    }
  }

  /**
   * Conditionally executes a Unit-returning effect based on a boolean condition.
   *
   * &lt;p&gt;Key improvement: Returns Either.right(Unit.INSTANCE) instead of Either.right(null), making
   * the &quot;no-op&quot; case explicit and type-safe.
   *
   * @param fcond The effectful condition
   * @param fa The Unit-returning effect to execute if condition is true
   * @return Either with Unit result
   */
  @Override
  public Kind&lt;EitherKind.Witness&lt;L&gt;, Unit&gt; whenS(
      Kind&lt;EitherKind.Witness&lt;L&gt;, Boolean&gt; fcond, Kind&lt;EitherKind.Witness&lt;L&gt;, Unit&gt; fa) {

<span class="fc" id="L197">    Validation.kind().requireNonNull(fcond, EITHER_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L198">    Validation.kind().requireNonNull(fa, EITHER_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L200">    Either&lt;L, Boolean&gt; condEither = EITHER.narrow(fcond);</span>

    // Short-circuit on error in condition
<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (condEither.isLeft()) {</span>
<span class="fc" id="L204">      return EITHER.widen(Either.left(condEither.getLeft()));</span>
    }

<span class="fc" id="L207">    boolean condition = condEither.getRight();</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">    if (condition) {</span>
      // Execute and return the effect
<span class="fc" id="L211">      return fa;</span>
    } else {
      // Condition is false, return Unit wrapped in Right (not null!)
<span class="fc" id="L214">      return EITHER.widen(Either.right(Unit.INSTANCE));</span>
    }
  }

  /**
   * Optimised implementation of {@code ifS} for Either. A ternary conditional operator for
   * selective functors.
   *
   * @param fcond A {@link Kind} representing {@code Either&lt;L, Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code Either&lt;L, A&gt;} for the true branch. Must not be
   *     null.
   * @param felse A {@link Kind} representing {@code Either&lt;L, A&gt;} for the false branch. Must not be
   *     null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code Either&lt;L, A&gt;}. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;EitherKind.Witness&lt;L&gt;, A&gt; ifS(
      Kind&lt;EitherKind.Witness&lt;L&gt;, Boolean&gt; fcond,
      Kind&lt;EitherKind.Witness&lt;L&gt;, A&gt; fthen,
      Kind&lt;EitherKind.Witness&lt;L&gt;, A&gt; felse) {

<span class="fc" id="L236">    Validation.kind().requireNonNull(fcond, EITHER_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L237">    Validation.kind().requireNonNull(fthen, EITHER_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L238">    Validation.kind().requireNonNull(felse, EITHER_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L240">    Either&lt;L, Boolean&gt; condEither = EITHER.narrow(fcond);</span>

    // Short-circuit on error in condition
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (condEither.isLeft()) {</span>
<span class="fc" id="L244">      return EITHER.widen(Either.left(condEither.getLeft()));</span>
    }

<span class="fc" id="L247">    boolean condition = condEither.getRight();</span>

    // Return the appropriate branch
    // Note: We don't evaluate both branches - this is key for selective functors
<span class="fc bfc" id="L251" title="All 2 branches covered.">    return condition ? fthen : felse;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>