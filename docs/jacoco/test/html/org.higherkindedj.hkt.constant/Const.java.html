<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Const.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.constant</a> &gt; <span class="el_source">Const.java</span></div><h1>Const.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.constant;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * A constant functor that holds a value of type {@code C} and ignores the phantom type {@code A}.
 *
 * &lt;p&gt;The {@code Const} type is useful for operations where you need to accumulate or preserve a
 * value while abstracting over a type parameter. When mapping over the second type parameter (the
 * phantom {@code A}), the constant value remains unchanged. This makes {@code Const} particularly
 * useful for implementing efficient folds and traversals.
 *
 * &lt;p&gt;As a {@link java.lang.Record}, it automatically provides a canonical constructor, an accessor
 * ({@code value()}), and implementations for {@code equals()}, {@code hashCode()}, and {@code
 * toString()}.
 *
 * &lt;p&gt;This type is a natural Bifunctor, where:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Mapping the first parameter transforms the constant value
 *   &lt;li&gt;Mapping the second parameter has no effect (the phantom type is ignored)
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Example usage:
 *
 * &lt;pre&gt;{@code
 * // Create a Const holding a string value
 * Const&lt;String, Integer&gt; const1 = new Const&lt;&gt;(&quot;hello&quot;);
 *
 * // Mapping the phantom type (Integer -&gt; Double) has no effect on the value
 * Const&lt;String, Double&gt; const2 = const1.mapSecond(i -&gt; i * 2.0);
 * // const2.value() is still &quot;hello&quot;
 *
 * // Mapping the first parameter transforms the constant value
 * Const&lt;Integer, Double&gt; const3 = const2.mapFirst(String::length);
 * // const3.value() is 5
 * }&lt;/pre&gt;
 *
 * @param &lt;C&gt; The type of the constant value.
 * @param &lt;A&gt; The phantom type parameter (not stored).
 * @param value The constant value held by this instance.
 */
<span class="fc" id="L48">public record Const&lt;C, A&gt;(C value) {</span>

<span class="fc" id="L50">  private static final Class&lt;?&gt; CONST_CLASS = Const.class;</span>

  /**
   * Transforms both the constant value and the phantom type parameter.
   *
   * &lt;p&gt;This is the fundamental bifunctor operation for {@code Const}. The first function is applied
   * to the constant value, while the second function affects only the phantom type parameter (and
   * thus has no runtime effect on the value).
   *
   * &lt;p&gt;&lt;b&gt;Note on exception propagation:&lt;/b&gt; Although the second function doesn't affect the
   * constant value, it is still applied (to a null input) to ensure that any exceptions it might
   * throw are properly propagated. This maintains consistency with bifunctor exception semantics.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Const&lt;String, Integer&gt; const = new Const&lt;&gt;(&quot;hello&quot;);
   * Const&lt;Integer, String&gt; result = const.bimap(
   *     String::length,           // Transform constant: &quot;hello&quot; -&gt; 5
   *     i -&gt; &quot;Value: &quot; + i        // Transform phantom type only
   * );
   * // result.value() is 5
   * }&lt;/pre&gt;
   *
   * @param firstMapper The non-null function to apply to the constant value.
   * @param secondMapper The non-null function that defines the phantom type transformation.
   * @param &lt;D&gt; The type of the constant value in the resulting {@code Const}.
   * @param &lt;B&gt; The phantom type parameter in the resulting {@code Const}.
   * @return A new {@code Const&lt;D, B&gt;} with the constant value transformed. The returned instance
   *     will be non-null.
   * @throws NullPointerException if either {@code firstMapper} or {@code secondMapper} is null.
   */
  public &lt;D, B&gt; Const&lt;D, B&gt; bimap(
      Function&lt;? super C, ? extends D&gt; firstMapper, Function&lt;? super A, ? extends B&gt; secondMapper) {
<span class="fc" id="L84">    Validation.function().requireMapper(firstMapper, &quot;firstMapper&quot;, CONST_CLASS, BIMAP);</span>
<span class="fc" id="L85">    Validation.function().requireMapper(secondMapper, &quot;secondMapper&quot;, CONST_CLASS, BIMAP);</span>

    // Apply secondMapper to ensure exception propagation, even though we ignore the result
    // since A is phantom. We use null as the input since we don't have a value of type A.
<span class="fc" id="L89">    secondMapper.apply(null);</span>

<span class="fc" id="L91">    return new Const&lt;&gt;(firstMapper.apply(value));</span>
  }

  /**
   * Transforms only the constant value, leaving the phantom type unchanged.
   *
   * &lt;p&gt;This operation transforms the stored constant value whilst preserving the phantom type
   * parameter.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Const&lt;String, Integer&gt; const = new Const&lt;&gt;(&quot;hello&quot;);
   * Const&lt;Integer, Integer&gt; result = const.mapFirst(String::length);
   * // result.value() is 5
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is equivalent to calling {@code bimap(firstMapper, Function.identity())}.
   *
   * @param firstMapper The non-null function to apply to the constant value.
   * @param &lt;D&gt; The type of the constant value in the resulting {@code Const}.
   * @return A new {@code Const&lt;D, A&gt;} with the constant value transformed. The returned instance
   *     will be non-null.
   * @throws NullPointerException if {@code firstMapper} is null.
   */
  public &lt;D&gt; Const&lt;D, A&gt; mapFirst(Function&lt;? super C, ? extends D&gt; firstMapper) {
<span class="fc" id="L117">    Validation.function().requireMapper(firstMapper, &quot;firstMapper&quot;, CONST_CLASS, MAP_FIRST);</span>

<span class="fc" id="L119">    return new Const&lt;&gt;(firstMapper.apply(value));</span>
  }

  /**
   * Transforms only the phantom type parameter, leaving the constant value unchanged.
   *
   * &lt;p&gt;Since the second type parameter is phantom (not stored), this operation has no effect on the
   * constant value. It only changes the phantom type in the type signature.
   *
   * &lt;p&gt;&lt;b&gt;Note on exception propagation:&lt;/b&gt; Although this operation doesn't affect the constant
   * value, the mapper is still applied (to a null input) to ensure that any exceptions it might
   * throw are properly propagated. This maintains consistency with bifunctor exception semantics.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Const&lt;String, Integer&gt; const = new Const&lt;&gt;(&quot;hello&quot;);
   * Const&lt;String, Double&gt; result = const.mapSecond(i -&gt; i * 2.0);
   * // result.value() is still &quot;hello&quot; (unchanged)
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is equivalent to calling {@code bimap(Function.identity(), secondMapper)}.
   *
   * @param secondMapper The non-null function that defines the phantom type transformation.
   * @param &lt;B&gt; The phantom type parameter in the resulting {@code Const}.
   * @return A new {@code Const&lt;C, B&gt;} with the same constant value but a different phantom type.
   *     The returned instance will be non-null.
   * @throws NullPointerException if {@code secondMapper} is null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;B&gt; Const&lt;C, B&gt; mapSecond(Function&lt;? super A, ? extends B&gt; secondMapper) {
<span class="fc" id="L150">    Validation.function().requireMapper(secondMapper, &quot;secondMapper&quot;, CONST_CLASS, MAP_SECOND);</span>

    // Apply secondMapper to ensure exception propagation, even though we ignore the result
    // since A is phantom. We use null as the input since we don't have a value of type A.
<span class="fc" id="L154">    secondMapper.apply(null);</span>

    // Since A is phantom, we can safely cast - the constant value remains unchanged
<span class="fc" id="L157">    return (Const&lt;C, B&gt;) this;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>