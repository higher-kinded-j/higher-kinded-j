<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstApplicative.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.constant</a> &gt; <span class="el_source">ConstApplicative.java</span></div><h1>ConstApplicative.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.constant;

import static org.higherkindedj.hkt.constant.ConstKindHelper.CONST;
import static org.higherkindedj.hkt.util.validation.Operation.AP;
import static org.higherkindedj.hkt.util.validation.Operation.MAP;
import static org.higherkindedj.hkt.util.validation.Operation.MAP_2;

import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * The {@link Applicative} instance for {@link Const} with a monoidal first parameter.
 *
 * &lt;p&gt;This applicative accumulates values of type {@code M} using a {@link Monoid}, whilst ignoring
 * the phantom second parameter {@code A}. This makes it perfect for implementing efficient folds
 * over traversable structures without creating intermediate lists.
 *
 * &lt;p&gt;The {@code Const} applicative is widely used in functional programming for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Implementing {@code foldMap} operations over complex structures
 *   &lt;li&gt;Converting traversals to folds efficiently
 *   &lt;li&gt;Aggregating values whilst traversing data structures
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Example usage:
 *
 * &lt;pre&gt;{@code
 * // Sum all integers in a structure
 * Monoid&lt;Integer&gt; sumMonoid = Monoid.of(0, Integer::sum);
 * ConstApplicative&lt;Integer&gt; constApp = new ConstApplicative&lt;&gt;(sumMonoid);
 *
 * // Accumulate values
 * Const&lt;Integer, String&gt; c1 = new Const&lt;&gt;(5);
 * Const&lt;Integer, String&gt; c2 = new Const&lt;&gt;(10);
 *
 * Kind&lt;ConstKind.Witness&lt;Integer&gt;, String&gt; result =
 *     constApp.map2(
 *         CONST.widen(c1),
 *         CONST.widen(c2),
 *         (a, b) -&gt; &quot;ignored&quot;  // The phantom type is never used
 *     );
 *
 * // Extract accumulated result
 * Const&lt;Integer, String&gt; finalConst = CONST.narrow(result);
 * int sum = finalConst.value();  // 15
 * }&lt;/pre&gt;
 *
 * @param &lt;M&gt; The monoidal type being accumulated
 */
public final class ConstApplicative&lt;M&gt; implements Applicative&lt;ConstKind.Witness&lt;M&gt;&gt; {

<span class="fc" id="L60">  private static final Class&lt;ConstApplicative&gt; CONST_APPLICATIVE_CLASS = ConstApplicative.class;</span>

  private final Monoid&lt;M&gt; monoid;

  /**
   * Creates a new {@code ConstApplicative} with the given {@link Monoid}.
   *
   * @param monoid The monoid used to combine accumulated values. Must not be null.
   * @throws NullPointerException if {@code monoid} is null.
   */
<span class="fc" id="L70">  public ConstApplicative(Monoid&lt;M&gt; monoid) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">    if (monoid == null) {</span>
<span class="fc" id="L72">      throw new NullPointerException(&quot;Monoid cannot be null&quot;);</span>
    }
<span class="fc" id="L74">    this.monoid = monoid;</span>
<span class="fc" id="L75">  }</span>

  /**
   * Lifts a phantom value into a {@code Const} containing the monoid's empty element.
   *
   * &lt;p&gt;Since {@code Const} ignores its second type parameter, the input value {@code a} is
   * discarded, and the result contains only the monoid's identity element.
   *
   * @param a The phantom value (ignored). Can be null.
   * @param &lt;A&gt; The phantom type parameter.
   * @return A {@code Const&lt;M, A&gt;} containing the monoid's empty element. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;ConstKind.Witness&lt;M&gt;, A&gt; of(@Nullable A a) {
<span class="fc" id="L89">    return CONST.widen(new Const&lt;&gt;(monoid.empty()));</span>
  }

  /**
   * Maps a function over a {@code Const}, which has no effect on the accumulated value.
   *
   * &lt;p&gt;Since {@code Const} ignores its second type parameter, the mapping function is never
   * applied. The accumulated monoidal value passes through unchanged.
   *
   * @param f The mapping function (never applied). Must not be null.
   * @param fa The {@code Const&lt;M, A&gt;} to map over. Must not be null.
   * @param &lt;A&gt; The input phantom type.
   * @param &lt;B&gt; The output phantom type.
   * @return A {@code Const&lt;M, B&gt;} with the same accumulated value. Never null.
   * @throws NullPointerException if {@code f} or {@code fa} is null.
   */
  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;A, B&gt; Kind&lt;ConstKind.Witness&lt;M&gt;, B&gt; map(
      Function&lt;? super A, ? extends B&gt; f, Kind&lt;ConstKind.Witness&lt;M&gt;, A&gt; fa) {

<span class="fc" id="L110">    Validation.function().requireMapper(f, &quot;f&quot;, CONST_APPLICATIVE_CLASS, MAP);</span>
<span class="fc" id="L111">    Validation.kind().requireNonNull(fa, CONST_APPLICATIVE_CLASS, MAP);</span>

    // Since A is phantom in Const&lt;M, A&gt;, we can safely change the type parameter
    // The actual value (type M) remains unchanged
<span class="fc" id="L115">    Const&lt;M, A&gt; constA = CONST.narrow(fa);</span>
<span class="fc" id="L116">    return (Kind&lt;ConstKind.Witness&lt;M&gt;, B&gt;) CONST.widen(new Const&lt;&gt;(constA.value()));</span>
  }

  /**
   * Applies a function wrapped in a {@code Const} to a value wrapped in a {@code Const}.
   *
   * &lt;p&gt;For {@code Const}, since both type parameters are phantom, the function itself is never
   * applied. Instead, this operation simply combines the accumulated monoidal values from both
   * {@code Const} instances using the monoid's combine operation.
   *
   * @param ff The {@code Const} containing a phantom function. Must not be null.
   * @param fa The {@code Const} containing a phantom value. Must not be null.
   * @param &lt;A&gt; The phantom input type.
   * @param &lt;B&gt; The phantom output type.
   * @return A {@code Const&lt;M, B&gt;} containing the combined monoidal values. Never null.
   * @throws NullPointerException if {@code ff} or {@code fa} is null.
   */
  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;A, B&gt; Kind&lt;ConstKind.Witness&lt;M&gt;, B&gt; ap(
      Kind&lt;ConstKind.Witness&lt;M&gt;, ? extends Function&lt;A, B&gt;&gt; ff, Kind&lt;ConstKind.Witness&lt;M&gt;, A&gt; fa) {

<span class="fc" id="L138">    Validation.kind().requireNonNull(ff, CONST_APPLICATIVE_CLASS, AP, &quot;function&quot;);</span>
<span class="fc" id="L139">    Validation.kind().requireNonNull(fa, CONST_APPLICATIVE_CLASS, AP, &quot;argument&quot;);</span>

    // Extract the monoidal values from both Const instances
<span class="fc" id="L142">    Const&lt;M, ? extends Function&lt;A, B&gt;&gt; constF = CONST.narrow(ff);</span>
<span class="fc" id="L143">    Const&lt;M, A&gt; constA = CONST.narrow(fa);</span>

    // Combine the accumulated monoidal values
<span class="fc" id="L146">    M combined = monoid.combine(constF.value(), constA.value());</span>

<span class="fc" id="L148">    return (Kind&lt;ConstKind.Witness&lt;M&gt;, B&gt;) CONST.widen(new Const&lt;&gt;(combined));</span>
  }

  /**
   * Combines two {@code Const} values using the monoid's combine operation.
   *
   * &lt;p&gt;This is the key operation that makes {@code Const} useful for folds. The accumulated
   * monoidal values are combined using {@code monoid.combine()}, whilst the phantom type parameters
   * and the combining function {@code f} are ignored.
   *
   * @param fa The first {@code Const&lt;M, A&gt;}. Must not be null.
   * @param fb The second {@code Const&lt;M, B&gt;}. Must not be null.
   * @param f The combining function (ignored, since both type parameters are phantom). Must not be
   *     null.
   * @param &lt;A&gt; The first phantom type.
   * @param &lt;B&gt; The second phantom type.
   * @param &lt;C&gt; The result phantom type.
   * @return A {@code Const&lt;M, C&gt;} containing the combined monoidal values. Never null.
   * @throws NullPointerException if any parameter is null.
   */
  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;A, B, C&gt; Kind&lt;ConstKind.Witness&lt;M&gt;, C&gt; map2(
      Kind&lt;ConstKind.Witness&lt;M&gt;, A&gt; fa,
      Kind&lt;ConstKind.Witness&lt;M&gt;, B&gt; fb,
      BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {

<span class="fc" id="L175">    Validation.kind().requireNonNull(fa, CONST_APPLICATIVE_CLASS, MAP_2, &quot;first&quot;);</span>
<span class="fc" id="L176">    Validation.kind().requireNonNull(fb, CONST_APPLICATIVE_CLASS, MAP_2, &quot;second&quot;);</span>
<span class="fc" id="L177">    Validation.function().requireFunction(f, &quot;combining function&quot;, CONST_APPLICATIVE_CLASS, MAP_2);</span>

<span class="fc" id="L179">    Const&lt;M, A&gt; constA = CONST.narrow(fa);</span>
<span class="fc" id="L180">    Const&lt;M, B&gt; constB = CONST.narrow(fb);</span>

    // Combine the accumulated monoidal values
<span class="fc" id="L183">    M combined = monoid.combine(constA.value(), constB.value());</span>

<span class="fc" id="L185">    return (Kind&lt;ConstKind.Witness&lt;M&gt;, C&gt;) CONST.widen(new Const&lt;&gt;(combined));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>