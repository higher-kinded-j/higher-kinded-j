<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VTaskContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.effect.context</a> &gt; <span class="el_source">VTaskContext.java</span></div><h1>VTaskContext.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.effect.context;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.effect.VTaskPath;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.vtask.VTask;

/**
 * Effect context for computations that execute on virtual threads.
 *
 * &lt;p&gt;VTaskContext provides a user-friendly Layer 2 API for working with {@link VTaskPath}. It wraps
 * VTask computations with convenient factory methods and chainable operations, hiding the
 * complexity of the underlying HKT machinery.
 *
 * &lt;h2&gt;Key Features&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Virtual Thread Execution:&lt;/b&gt; Computations run on lightweight virtual threads
 *   &lt;li&gt;&lt;b&gt;Lazy Evaluation:&lt;/b&gt; Computations are deferred until explicitly executed
 *   &lt;li&gt;&lt;b&gt;Error Recovery:&lt;/b&gt; Built-in error handling with {@link #recover} and {@link
 *       #recoverWith}
 *   &lt;li&gt;&lt;b&gt;Timeout Support:&lt;/b&gt; Set time limits on computations with {@link #timeout}
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Factory Methods&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #of(Callable)} - Create from a callable computation
 *   &lt;li&gt;{@link #exec(Runnable)} - Create from a side-effecting runnable
 *   &lt;li&gt;{@link #pure(Object)} - Create a context with an immediate value
 *   &lt;li&gt;{@link #fail(Throwable)} - Create a failed context
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Execution Methods&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #run()} - Execute eagerly and return {@code Try&lt;A&gt;}
 *   &lt;li&gt;{@link #runAsync()} - Execute asynchronously, returning a CompletableFuture
 *   &lt;li&gt;{@link #runOrThrow()} - Execute and throw on failure
 *   &lt;li&gt;{@link #runOrElse(Object)} - Execute with a default value on failure
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Usage Example&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * Try&lt;Profile&gt; result = VTaskContext
 *     .&lt;User&gt;of(() -&gt; userService.fetch(userId))
 *     .via(user -&gt; VTaskContext.of(() -&gt; profileService.fetch(user.profileId())))
 *     .timeout(Duration.ofSeconds(5))
 *     .recover(err -&gt; Profile.defaultProfile())
 *     .run();
 * }&lt;/pre&gt;
 *
 * @param &lt;A&gt; the value type
 * @see VTaskPath
 * @see VTask
 */
public final class VTaskContext&lt;A&gt; {

  private final VTaskPath&lt;A&gt; path;

<span class="fc" id="L71">  private VTaskContext(VTaskPath&lt;A&gt; path) {</span>
<span class="fc" id="L72">    this.path = Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L73">  }</span>

  // ===== Factory Methods =====

  /**
   * Creates a VTaskContext from a callable computation.
   *
   * &lt;p&gt;The computation is not executed until {@link #run()} or similar methods are called.
   *
   * @param callable the computation to execute; must not be null
   * @param &lt;A&gt; the result type
   * @return a new VTaskContext wrapping the computation
   * @throws NullPointerException if callable is null
   */
  public static &lt;A&gt; VTaskContext&lt;A&gt; of(Callable&lt;A&gt; callable) {
<span class="fc" id="L88">    Objects.requireNonNull(callable, &quot;callable must not be null&quot;);</span>
<span class="fc" id="L89">    return new VTaskContext&lt;&gt;(Path.vtask(callable));</span>
  }

  /**
   * Creates a VTaskContext from a side-effecting runnable.
   *
   * &lt;p&gt;The runnable is not executed until {@link #run()} or similar methods are called.
   *
   * @param runnable the side effect to execute; must not be null
   * @return a new VTaskContext that produces Unit when run
   * @throws NullPointerException if runnable is null
   */
  public static VTaskContext&lt;Unit&gt; exec(Runnable runnable) {
<span class="fc" id="L102">    Objects.requireNonNull(runnable, &quot;runnable must not be null&quot;);</span>
<span class="fc" id="L103">    return new VTaskContext&lt;&gt;(Path.vtaskExec(runnable));</span>
  }

  /**
   * Creates a VTaskContext containing a pure value.
   *
   * &lt;p&gt;The value is already computed; no side effects occur when this context is run.
   *
   * @param value the value to wrap
   * @param &lt;A&gt; the value type
   * @return a new VTaskContext that immediately produces the value when run
   */
  public static &lt;A&gt; VTaskContext&lt;A&gt; pure(A value) {
<span class="fc" id="L116">    return new VTaskContext&lt;&gt;(Path.vtaskPure(value));</span>
  }

  /**
   * Creates a failed VTaskContext containing the given exception.
   *
   * @param error the exception; must not be null
   * @param &lt;A&gt; the phantom type of the success value
   * @return a failed VTaskContext
   * @throws NullPointerException if error is null
   */
  public static &lt;A&gt; VTaskContext&lt;A&gt; fail(Throwable error) {
<span class="fc" id="L128">    Objects.requireNonNull(error, &quot;error must not be null&quot;);</span>
<span class="fc" id="L129">    return new VTaskContext&lt;&gt;(Path.vtaskFail(error));</span>
  }

  /**
   * Creates a VTaskContext from an existing VTaskPath.
   *
   * @param path the VTaskPath to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a new VTaskContext wrapping the path
   * @throws NullPointerException if path is null
   */
  public static &lt;A&gt; VTaskContext&lt;A&gt; fromPath(VTaskPath&lt;A&gt; path) {
<span class="fc" id="L141">    Objects.requireNonNull(path, &quot;path must not be null&quot;);</span>
<span class="fc" id="L142">    return new VTaskContext&lt;&gt;(path);</span>
  }

  /**
   * Creates a VTaskContext from an existing VTask.
   *
   * @param vtask the VTask to wrap; must not be null
   * @param &lt;A&gt; the value type
   * @return a new VTaskContext wrapping the VTask
   * @throws NullPointerException if vtask is null
   */
  public static &lt;A&gt; VTaskContext&lt;A&gt; fromVTask(VTask&lt;A&gt; vtask) {
<span class="fc" id="L154">    Objects.requireNonNull(vtask, &quot;vtask must not be null&quot;);</span>
<span class="fc" id="L155">    return new VTaskContext&lt;&gt;(Path.vtaskPath(vtask));</span>
  }

  // ===== Transformation Operations =====

  /**
   * Transforms the contained value using the provided function.
   *
   * &lt;p&gt;If this context fails, the function is not applied and the failure is preserved.
   *
   * @param mapper the function to apply to the value; must not be null
   * @param &lt;B&gt; the type of the transformed value
   * @return a new context with the transformed value
   * @throws NullPointerException if mapper is null
   */
  public &lt;B&gt; VTaskContext&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; mapper) {
<span class="fc" id="L171">    Objects.requireNonNull(mapper, &quot;mapper must not be null&quot;);</span>
<span class="fc" id="L172">    return new VTaskContext&lt;&gt;(path.map(mapper));</span>
  }

  /**
   * Chains a dependent computation that returns a VTaskContext.
   *
   * &lt;p&gt;This is the monadic bind operation, named {@code via} to match the Effect Path API
   * vocabulary. The function is applied to the contained value, and the resulting context becomes
   * the new context.
   *
   * &lt;p&gt;If this context fails, the function is not applied and the failure is propagated.
   *
   * @param fn the function to apply, returning a new context; must not be null
   * @param &lt;B&gt; the type of the value in the returned context
   * @return the context returned by the function, or a failed context
   * @throws NullPointerException if fn is null or returns null
   */
  public &lt;B&gt; VTaskContext&lt;B&gt; via(Function&lt;? super A, ? extends VTaskContext&lt;B&gt;&gt; fn) {
<span class="fc" id="L190">    Objects.requireNonNull(fn, &quot;fn must not be null&quot;);</span>
<span class="fc" id="L191">    return new VTaskContext&lt;&gt;(</span>
<span class="fc" id="L192">        path.via(</span>
            a -&gt; {
<span class="fc" id="L194">              VTaskContext&lt;B&gt; next = fn.apply(a);</span>
<span class="fc" id="L195">              Objects.requireNonNull(next, &quot;fn must not return null&quot;);</span>
<span class="fc" id="L196">              return next.path;</span>
            }));
  }

  /**
   * Chains a dependent computation using flatMap.
   *
   * &lt;p&gt;This is an alias for {@link #via(Function)} that matches traditional monad terminology.
   *
   * @param fn the function to apply, returning a new context; must not be null
   * @param &lt;B&gt; the type of the value in the returned context
   * @return the context returned by the function, or a failed context
   * @throws NullPointerException if fn is null or returns null
   */
  public &lt;B&gt; VTaskContext&lt;B&gt; flatMap(Function&lt;? super A, ? extends VTaskContext&lt;B&gt;&gt; fn) {
<span class="fc" id="L211">    return via(fn);</span>
  }

  /**
   * Sequences an independent computation, discarding this context's value.
   *
   * &lt;p&gt;This is useful for sequencing effects where only the final result matters.
   *
   * @param supplier provides the next context; must not be null
   * @param &lt;B&gt; the type of the value in the returned context
   * @return the context from the supplier
   * @throws NullPointerException if supplier is null or returns null
   */
  public &lt;B&gt; VTaskContext&lt;B&gt; then(Supplier&lt;? extends VTaskContext&lt;B&gt;&gt; supplier) {
<span class="fc" id="L225">    Objects.requireNonNull(supplier, &quot;supplier must not be null&quot;);</span>
<span class="fc" id="L226">    return via(ignored -&gt; supplier.get());</span>
  }

  // ===== Error Recovery Operations =====

  /**
   * Recovers from an error by providing a fallback value.
   *
   * &lt;p&gt;If this context fails, the recovery function is applied to produce a success value. If this
   * context succeeds, it is returned unchanged.
   *
   * @param recovery the function to apply to the error to produce a value; must not be null
   * @return a context containing either the original value or the recovered value
   * @throws NullPointerException if recovery is null
   */
  public VTaskContext&lt;A&gt; recover(Function&lt;? super Throwable, ? extends A&gt; recovery) {
<span class="fc" id="L242">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L243">    return new VTaskContext&lt;&gt;(path.handleError(recovery));</span>
  }

  /**
   * Recovers from an error by providing a fallback VTaskContext.
   *
   * &lt;p&gt;If this context fails, the recovery function is applied to produce an alternative context.
   * If this context succeeds, it is returned unchanged.
   *
   * @param recovery the function to apply to the error to produce a fallback context; must not be
   *     null
   * @return either this context (if successful) or the fallback context
   * @throws NullPointerException if recovery is null or returns null
   */
  public VTaskContext&lt;A&gt; recoverWith(
      Function&lt;? super Throwable, ? extends VTaskContext&lt;A&gt;&gt; recovery) {
<span class="fc" id="L259">    Objects.requireNonNull(recovery, &quot;recovery must not be null&quot;);</span>
<span class="fc" id="L260">    return new VTaskContext&lt;&gt;(</span>
<span class="fc" id="L261">        path.handleErrorWith(</span>
            error -&gt; {
<span class="fc" id="L263">              VTaskContext&lt;A&gt; next = recovery.apply(error);</span>
<span class="fc" id="L264">              Objects.requireNonNull(next, &quot;recovery must not return null&quot;);</span>
<span class="fc" id="L265">              return next.path;</span>
            }));
  }

  /**
   * Provides an alternative context if this one fails.
   *
   * &lt;p&gt;This is a convenience method that ignores the specific error and provides a fallback.
   *
   * @param alternative provides the fallback context; must not be null
   * @return either this context (if successful) or the alternative
   * @throws NullPointerException if alternative is null or returns null
   */
  public VTaskContext&lt;A&gt; orElse(Supplier&lt;? extends VTaskContext&lt;A&gt;&gt; alternative) {
<span class="fc" id="L279">    Objects.requireNonNull(alternative, &quot;alternative must not be null&quot;);</span>
<span class="fc" id="L280">    return recoverWith(ignored -&gt; alternative.get());</span>
  }

  // ===== Timeout =====

  /**
   * Creates a new VTaskContext that fails if this computation does not complete within the
   * specified duration.
   *
   * @param duration the maximum time to wait; must not be null
   * @return a VTaskContext with timeout behaviour
   * @throws NullPointerException if duration is null
   */
  public VTaskContext&lt;A&gt; timeout(Duration duration) {
<span class="fc" id="L294">    Objects.requireNonNull(duration, &quot;duration must not be null&quot;);</span>
<span class="fc" id="L295">    return new VTaskContext&lt;&gt;(path.timeout(duration));</span>
  }

  // ===== Execution Methods =====

  /**
   * Executes the computation eagerly and returns the result wrapped in a Try.
   *
   * &lt;p&gt;This is the primary execution method. It runs the VTask immediately and captures the result
   * or any exception in a Try.
   *
   * @return a Try containing the result or exception
   */
  public Try&lt;A&gt; run() {
<span class="fc" id="L309">    return path.runSafe();</span>
  }

  /**
   * Executes the computation asynchronously on a virtual thread.
   *
   * &lt;p&gt;The computation starts immediately on a virtual thread. The returned future can be used to
   * wait for the result or combine with other asynchronous operations.
   *
   * @return a CompletableFuture that will complete with the result
   */
  public CompletableFuture&lt;A&gt; runAsync() {
<span class="fc" id="L321">    return path.runAsync();</span>
  }

  /**
   * Executes the computation and returns the result, throwing on failure.
   *
   * &lt;p&gt;If the computation fails, the exception is wrapped in a RuntimeException and thrown.
   *
   * @return the success value
   * @throws RuntimeException if the computation fails
   */
  public A runOrThrow() {
<span class="fc" id="L333">    return path.unsafeRun();</span>
  }

  /**
   * Executes the computation and returns the result, or a default on failure.
   *
   * @param defaultValue the value to return if the computation fails
   * @return the success value or the default
   */
  public A runOrElse(A defaultValue) {
<span class="fc" id="L343">    return run().orElse(defaultValue);</span>
  }

  /**
   * Executes the computation and returns the result, or applies a handler on failure.
   *
   * @param errorHandler the function to apply to the error to produce a value; must not be null
   * @return the success value or the result of the error handler
   * @throws NullPointerException if errorHandler is null
   */
  public A runOrElseGet(Function&lt;? super Throwable, ? extends A&gt; errorHandler) {
<span class="fc" id="L354">    Objects.requireNonNull(errorHandler, &quot;errorHandler must not be null&quot;);</span>
<span class="fc" id="L355">    return run().fold(a -&gt; a, errorHandler);</span>
  }

  // ===== Access to Underlying Path =====

  /**
   * Returns the underlying VTaskPath.
   *
   * &lt;p&gt;This is an escape hatch to Layer 1 for users who need full control over the VTaskPath
   * operations.
   *
   * @return the underlying VTaskPath
   */
  public VTaskPath&lt;A&gt; toPath() {
<span class="fc" id="L369">    return path;</span>
  }

  /**
   * Returns the underlying VTask.
   *
   * &lt;p&gt;This is an escape hatch for users who need direct access to the VTask.
   *
   * @return the underlying VTask
   */
  public VTask&lt;A&gt; toVTask() {
<span class="fc" id="L380">    return path.run();</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L385">    return &quot;VTaskContext(&lt;deferred&gt;)&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>