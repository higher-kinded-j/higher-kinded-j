<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Free.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.free</a> &gt; <span class="el_source">Free.java</span></div><h1>Free.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.free;

import java.util.function.Function;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.Natural;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.trampoline.Trampoline;

/**
 * Free monad for creating Domain-Specific Languages (DSLs).
 *
 * &lt;p&gt;The Free monad allows you to build programs as data structures that can be interpreted in
 * different ways. It's particularly useful for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Creating DSLs with deferred execution
 *   &lt;li&gt;Separating program description from interpretation
 *   &lt;li&gt;Testing by providing mock interpreters
 *   &lt;li&gt;Optimizing programs before execution
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The implementation uses three constructors for stack-safe execution:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Pure} - A completed computation with a value
 *   &lt;li&gt;{@code Suspend} - A suspended computation in the functor F
 *   &lt;li&gt;{@code FlatMapped} - A sequenced computation (flatMap optimization)
 * &lt;/ul&gt;
 *
 * @param &lt;F&gt; The functor type representing the instruction set
 * @param &lt;A&gt; The result type
 */
public sealed interface Free&lt;F extends WitnessArity&lt;?&gt;, A&gt;
    permits Free.Pure, Free.Suspend, Free.FlatMapped {

  /**
   * Terminal case representing a pure value.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   */
<span class="fc" id="L47">  record Pure&lt;F extends WitnessArity&lt;?&gt;, A&gt;(A value) implements Free&lt;F, A&gt; {}</span>

  /**
   * Suspended computation wrapping a single instruction in F.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   */
<span class="fc" id="L55">  record Suspend&lt;F extends WitnessArity&lt;?&gt;, A&gt;(Kind&lt;F, Free&lt;F, A&gt;&gt; computation)</span>
      implements Free&lt;F, A&gt; {}

  /**
   * Chained computation representing flatMap. This constructor enables stack-safe execution of
   * deeply nested flatMaps.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;X&gt; The intermediate result type
   * @param &lt;A&gt; The final result type
   */
<span class="fc" id="L66">  record FlatMapped&lt;F extends WitnessArity&lt;?&gt;, X, A&gt;(</span>
      Free&lt;F, X&gt; sub, Function&lt;X, Free&lt;F, A&gt;&gt; continuation) implements Free&lt;F, A&gt; {}

  /**
   * Creates a Free monad from a pure value.
   *
   * @param value The value to lift
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   * @return A Free monad containing the value
   */
  static &lt;F extends WitnessArity&lt;?&gt;, A&gt; Free&lt;F, A&gt; pure(A value) {
<span class="fc" id="L78">    return new Pure&lt;&gt;(value);</span>
  }

  /**
   * Creates a Free monad from a suspended computation.
   *
   * @param computation The computation to suspend
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   * @return A Free monad suspending the computation
   */
  static &lt;F extends WitnessArity&lt;?&gt;, A&gt; Free&lt;F, A&gt; suspend(Kind&lt;F, Free&lt;F, A&gt;&gt; computation) {
<span class="fc" id="L90">    return new Suspend&lt;&gt;(computation);</span>
  }

  /**
   * Lifts a single instruction in F into the Free monad.
   *
   * @param fa The instruction to lift
   * @param functor The functor instance for F
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   * @return A Free monad containing the lifted instruction
   */
  static &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt; Free&lt;F, A&gt; liftF(
      Kind&lt;F, A&gt; fa, Functor&lt;F&gt; functor) {
<span class="fc" id="L104">    return new Suspend&lt;&gt;(functor.map(Free::pure, fa));</span>
  }

  /**
   * Maps a function over the result of this Free monad.
   *
   * @param f The function to apply
   * @param &lt;B&gt; The result type
   * @return A new Free monad with the function applied
   */
  default &lt;B&gt; Free&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L115">    return flatMap(a -&gt; pure(f.apply(a)));</span>
  }

  /**
   * Sequences this Free monad with a function that produces another Free monad.
   *
   * @param f The function to sequence with
   * @param &lt;B&gt; The result type
   * @return A new Free monad representing the sequence
   */
  default &lt;B&gt; Free&lt;F, B&gt; flatMap(Function&lt;A, Free&lt;F, B&gt;&gt; f) {
<span class="fc" id="L126">    return new FlatMapped&lt;&gt;(this, f);</span>
  }

  /**
   * Interprets this Free monad into a target monad M using a type-safe {@link Natural}
   * transformation. This is the preferred method for interpreting Free monads as it provides
   * compile-time type safety for the transformation.
   *
   * &lt;p&gt;This is a stack-safe interpreter that uses the {@link Trampoline} monad internally to ensure
   * stack safety during Free structure traversal.
   *
   * &lt;p&gt;By leveraging Higher-Kinded-J's own Trampoline implementation, this method demonstrates the
   * composability and practical utility of the library's abstractions whilst ensuring stack-safe
   * execution for deeply nested Free structures.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Define a natural transformation from your DSL to IO
   * Natural&lt;MyDSL.Witness, IO.Witness&gt; interpreter = new Natural&lt;&gt;() {
   *   @Override
   *   public &lt;A&gt; Kind&lt;IO.Witness, A&gt; apply(Kind&lt;MyDSL.Witness, A&gt; fa) {
   *     return switch (MyDSLKindHelper.narrow(fa)) {
   *       case ReadOp&lt;?&gt; r -&gt; IO.of(() -&gt; readFromConsole());
   *       case WriteOp&lt;?&gt; w -&gt; IO.of(() -&gt; writeToConsole(w.message()));
   *     };
   *   }
   * };
   *
   * // Interpret the Free program
   * Free&lt;MyDSL.Witness, String&gt; program = ...;
   * IO&lt;String&gt; executable = program.foldMap(interpreter, ioMonad);
   * }&lt;/pre&gt;
   *
   * @param transform The natural transformation from F to M. Must not be null.
   * @param monad The monad instance for M. Must not be null.
   * @param &lt;M&gt; The target monad type
   * @return The interpreted result in monad M
   * @see Natural
   */
  default &lt;M extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;M, A&gt; foldMap(
      Natural&lt;F, M&gt; transform, Monad&lt;M&gt; monad) {
<span class="fc" id="L168">    return interpretFreeNatural(this, transform, monad).run();</span>
  }

  /**
   * Interprets this Free monad into a target monad M using a raw function transformation.
   *
   * &lt;p&gt;This method is provided for backwards compatibility and convenience when a full {@link
   * Natural} transformation is not needed. For type-safe interpretation, prefer {@link
   * #foldMap(Natural, Monad)}.
   *
   * &lt;p&gt;This is a stack-safe interpreter that uses the {@link Trampoline} monad internally to ensure
   * stack safety during Free structure traversal.
   *
   * @param transform The transformation function from F to M (natural transformation as function)
   * @param monad The monad instance for M
   * @param &lt;M&gt; The target monad type
   * @return The interpreted result in monad M
   * @see #foldMap(Natural, Monad)
   */
  default &lt;M extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;M, A&gt; foldMap(
      Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform, Monad&lt;M&gt; monad) {
<span class="fc" id="L189">    return interpretFree(this, transform, monad).run();</span>
  }

  /**
   * Internal helper that interprets a Free monad using Trampoline for stack-safe traversal.
   *
   * @param free The Free monad to interpret
   * @param transform The natural transformation from F to M
   * @param monad The monad instance for M
   * @param &lt;F&gt; The functor type
   * @param &lt;M&gt; The target monad type
   * @param &lt;A&gt; The result type
   * @return A Trampoline that produces the interpreted result in monad M
   */
  private static &lt;F extends WitnessArity&lt;?&gt;, M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
      Trampoline&lt;Kind&lt;M, A&gt;&gt; interpretFree(
          Free&lt;F, A&gt; free, Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform, Monad&lt;M&gt; monad) {

<span class="fc bfc" id="L207" title="All 3 branches covered.">    return switch (free) {</span>
<span class="fc" id="L208">      case Pure&lt;F, A&gt; pure -&gt;</span>
          // Terminal case: lift the pure value into the target monad
<span class="fc" id="L210">          Trampoline.done(monad.of(pure.value()));</span>

<span class="fc" id="L212">      case Suspend&lt;F, A&gt; suspend -&gt; {</span>
        // Transform the suspended computation and recursively interpret
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L215">        Kind&lt;M, Free&lt;F, A&gt;&gt; transformed =</span>
<span class="fc" id="L216">            (Kind&lt;M, Free&lt;F, A&gt;&gt;) transform.apply(suspend.computation());</span>

        // Use Trampoline.defer to ensure stack safety for nested interpretations
<span class="fc" id="L219">        yield Trampoline.done(</span>
<span class="fc" id="L220">            monad.flatMap(</span>
<span class="fc" id="L221">                innerFree -&gt; interpretFree(innerFree, transform, monad).run(), transformed));</span>
      }

<span class="fc" id="L224">      case FlatMapped&lt;F, ?, A&gt; flatMapped -&gt; {</span>
        // Handle FlatMapped by deferring the interpretation
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L227">        FlatMapped&lt;F, Object, A&gt; fm = (FlatMapped&lt;F, Object, A&gt;) flatMapped;</span>

<span class="fc" id="L229">        yield Trampoline.defer(</span>
            () -&gt;
<span class="fc" id="L231">                interpretFree(fm.sub(), transform, monad)</span>
<span class="fc" id="L232">                    .map(</span>
                        kindOfX -&gt;
<span class="fc" id="L234">                            monad.flatMap(</span>
                                x -&gt; {
<span class="fc" id="L236">                                  Free&lt;F, A&gt; next = fm.continuation().apply(x);</span>
<span class="fc" id="L237">                                  return interpretFree(next, transform, monad).run();</span>
                                },
                                kindOfX)));
      }
    };
  }

  /**
   * Internal helper that interprets a Free monad using a type-safe {@link Natural} transformation
   * and Trampoline for stack-safe traversal.
   *
   * @param free The Free monad to interpret
   * @param transform The natural transformation from F to M
   * @param monad The monad instance for M
   * @param &lt;F&gt; The functor type
   * @param &lt;M&gt; The target monad type
   * @param &lt;A&gt; The result type
   * @return A Trampoline that produces the interpreted result in monad M
   */
  private static &lt;F extends WitnessArity&lt;?&gt;, M extends WitnessArity&lt;TypeArity.Unary&gt;, A&gt;
      Trampoline&lt;Kind&lt;M, A&gt;&gt; interpretFreeNatural(
          Free&lt;F, A&gt; free, Natural&lt;F, M&gt; transform, Monad&lt;M&gt; monad) {

<span class="fc bfc" id="L260" title="All 3 branches covered.">    return switch (free) {</span>
<span class="fc" id="L261">      case Pure&lt;F, A&gt; pure -&gt;</span>
          // Terminal case: lift the pure value into the target monad
<span class="fc" id="L263">          Trampoline.done(monad.of(pure.value()));</span>

<span class="fc" id="L265">      case Suspend&lt;F, A&gt; suspend -&gt; {</span>
        // Transform the suspended computation using the type-safe Natural transformation
        // The Natural transformation properly handles the type: Kind&lt;F, Free&lt;F, A&gt;&gt; -&gt; Kind&lt;M,
        // Free&lt;F, A&gt;&gt;
<span class="fc" id="L269">        Kind&lt;M, Free&lt;F, A&gt;&gt; transformed = transform.apply(suspend.computation());</span>

        // Use Trampoline.defer to ensure stack safety for nested interpretations
<span class="fc" id="L272">        yield Trampoline.done(</span>
<span class="fc" id="L273">            monad.flatMap(</span>
<span class="fc" id="L274">                innerFree -&gt; interpretFreeNatural(innerFree, transform, monad).run(), transformed));</span>
      }

<span class="fc" id="L277">      case FlatMapped&lt;F, ?, A&gt; flatMapped -&gt; {</span>
        // Handle FlatMapped by deferring the interpretation
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L280">        FlatMapped&lt;F, Object, A&gt; fm = (FlatMapped&lt;F, Object, A&gt;) flatMapped;</span>

<span class="fc" id="L282">        yield Trampoline.defer(</span>
            () -&gt;
<span class="fc" id="L284">                interpretFreeNatural(fm.sub(), transform, monad)</span>
<span class="fc" id="L285">                    .map(</span>
                        kindOfX -&gt;
<span class="fc" id="L287">                            monad.flatMap(</span>
                                x -&gt; {
<span class="fc" id="L289">                                  Free&lt;F, A&gt; next = fm.continuation().apply(x);</span>
<span class="fc" id="L290">                                  return interpretFreeNatural(next, transform, monad).run();</span>
                                },
                                kindOfX)));
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>