<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Free.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.free</a> &gt; <span class="el_source">Free.java</span></div><h1>Free.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.free;

import java.util.function.Function;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.trampoline.Trampoline;

/**
 * Free monad for creating Domain-Specific Languages (DSLs).
 *
 * &lt;p&gt;The Free monad allows you to build programs as data structures that can be interpreted in
 * different ways. It's particularly useful for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Creating DSLs with deferred execution
 *   &lt;li&gt;Separating program description from interpretation
 *   &lt;li&gt;Testing by providing mock interpreters
 *   &lt;li&gt;Optimizing programs before execution
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The implementation uses three constructors for stack-safe execution:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Pure} - A completed computation with a value
 *   &lt;li&gt;{@code Suspend} - A suspended computation in the functor F
 *   &lt;li&gt;{@code FlatMapped} - A sequenced computation (flatMap optimization)
 * &lt;/ul&gt;
 *
 * @param &lt;F&gt; The functor type representing the instruction set
 * @param &lt;A&gt; The result type
 */
public sealed interface Free&lt;F, A&gt; permits Free.Pure, Free.Suspend, Free.FlatMapped {

  /**
   * Terminal case representing a pure value.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   */
<span class="fc" id="L43">  record Pure&lt;F, A&gt;(A value) implements Free&lt;F, A&gt; {}</span>

  /**
   * Suspended computation wrapping a single instruction in F.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   */
<span class="fc" id="L51">  record Suspend&lt;F, A&gt;(Kind&lt;F, Free&lt;F, A&gt;&gt; computation) implements Free&lt;F, A&gt; {}</span>

  /**
   * Chained computation representing flatMap. This constructor enables stack-safe execution of
   * deeply nested flatMaps.
   *
   * @param &lt;F&gt; The functor type
   * @param &lt;X&gt; The intermediate result type
   * @param &lt;A&gt; The final result type
   */
<span class="fc" id="L61">  record FlatMapped&lt;F, X, A&gt;(Free&lt;F, X&gt; sub, Function&lt;X, Free&lt;F, A&gt;&gt; continuation)</span>
      implements Free&lt;F, A&gt; {}

  /**
   * Creates a Free monad from a pure value.
   *
   * @param value The value to lift
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The value type
   * @return A Free monad containing the value
   */
  static &lt;F, A&gt; Free&lt;F, A&gt; pure(A value) {
<span class="fc" id="L73">    return new Pure&lt;&gt;(value);</span>
  }

  /**
   * Creates a Free monad from a suspended computation.
   *
   * @param computation The computation to suspend
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   * @return A Free monad suspending the computation
   */
  static &lt;F, A&gt; Free&lt;F, A&gt; suspend(Kind&lt;F, Free&lt;F, A&gt;&gt; computation) {
<span class="fc" id="L85">    return new Suspend&lt;&gt;(computation);</span>
  }

  /**
   * Lifts a single instruction in F into the Free monad.
   *
   * @param fa The instruction to lift
   * @param functor The functor instance for F
   * @param &lt;F&gt; The functor type
   * @param &lt;A&gt; The result type
   * @return A Free monad containing the lifted instruction
   */
  static &lt;F, A&gt; Free&lt;F, A&gt; liftF(Kind&lt;F, A&gt; fa, Functor&lt;F&gt; functor) {
<span class="fc" id="L98">    return new Suspend&lt;&gt;(functor.map(Free::pure, fa));</span>
  }

  /**
   * Maps a function over the result of this Free monad.
   *
   * @param f The function to apply
   * @param &lt;B&gt; The result type
   * @return A new Free monad with the function applied
   */
  default &lt;B&gt; Free&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L109">    return flatMap(a -&gt; pure(f.apply(a)));</span>
  }

  /**
   * Sequences this Free monad with a function that produces another Free monad.
   *
   * @param f The function to sequence with
   * @param &lt;B&gt; The result type
   * @return A new Free monad representing the sequence
   */
  default &lt;B&gt; Free&lt;F, B&gt; flatMap(Function&lt;A, Free&lt;F, B&gt;&gt; f) {
<span class="fc" id="L120">    return new FlatMapped&lt;&gt;(this, f);</span>
  }

  /**
   * Interprets this Free monad into a target monad M using a natural transformation. This is a
   * stack-safe interpreter that uses the {@link Trampoline} monad internally to ensure stack safety
   * during Free structure traversal.
   *
   * &lt;p&gt;By leveraging Higher-Kinded-J's own Trampoline implementation, this method demonstrates the
   * composability and practical utility of the library's abstractions whilst ensuring stack-safe
   * execution for deeply nested Free structures.
   *
   * @param transform The natural transformation from F to M
   * @param monad The monad instance for M
   * @param &lt;M&gt; The target monad type
   * @return The interpreted result in monad M
   */
  default &lt;M&gt; Kind&lt;M, A&gt; foldMap(Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform, Monad&lt;M&gt; monad) {
<span class="fc" id="L138">    return interpretFree(this, transform, monad).run();</span>
  }

  /**
   * Internal helper that interprets a Free monad using Trampoline for stack-safe traversal.
   *
   * @param free The Free monad to interpret
   * @param transform The natural transformation from F to M
   * @param monad The monad instance for M
   * @param &lt;F&gt; The functor type
   * @param &lt;M&gt; The target monad type
   * @param &lt;A&gt; The result type
   * @return A Trampoline that produces the interpreted result in monad M
   */
  private static &lt;F, M, A&gt; Trampoline&lt;Kind&lt;M, A&gt;&gt; interpretFree(
      Free&lt;F, A&gt; free, Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform, Monad&lt;M&gt; monad) {

<span class="fc bfc" id="L155" title="All 3 branches covered.">    return switch (free) {</span>
<span class="fc" id="L156">      case Pure&lt;F, A&gt; pure -&gt;</span>
          // Terminal case: lift the pure value into the target monad
<span class="fc" id="L158">          Trampoline.done(monad.of(pure.value()));</span>

<span class="fc" id="L160">      case Suspend&lt;F, A&gt; suspend -&gt; {</span>
        // Transform the suspended computation and recursively interpret
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L163">        Kind&lt;M, Free&lt;F, A&gt;&gt; transformed =</span>
<span class="fc" id="L164">            (Kind&lt;M, Free&lt;F, A&gt;&gt;) transform.apply(suspend.computation());</span>

        // Use Trampoline.defer to ensure stack safety for nested interpretations
<span class="fc" id="L167">        yield Trampoline.done(</span>
<span class="fc" id="L168">            monad.flatMap(</span>
<span class="fc" id="L169">                innerFree -&gt; interpretFree(innerFree, transform, monad).run(), transformed));</span>
      }

<span class="fc" id="L172">      case FlatMapped&lt;F, ?, A&gt; flatMapped -&gt; {</span>
        // Handle FlatMapped by deferring the interpretation
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L175">        FlatMapped&lt;F, Object, A&gt; fm = (FlatMapped&lt;F, Object, A&gt;) flatMapped;</span>

<span class="fc" id="L177">        yield Trampoline.defer(</span>
            () -&gt;
<span class="fc" id="L179">                interpretFree(fm.sub(), transform, monad)</span>
<span class="fc" id="L180">                    .map(</span>
                        kindOfX -&gt;
<span class="fc" id="L182">                            monad.flatMap(</span>
                                x -&gt; {
<span class="fc" id="L184">                                  Free&lt;F, A&gt; next = fm.continuation().apply(x);</span>
<span class="fc" id="L185">                                  return interpretFree(next, transform, monad).run();</span>
                                },
                                kindOfX)));
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>