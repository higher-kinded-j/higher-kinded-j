<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.list</a> &gt; <span class="el_source">ListSelective.java</span></div><h1>ListSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.list;

import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import org.higherkindedj.hkt.Choice;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link List}. This provides selective applicative
 * operations that allow conditional execution based on the result of previous computations.
 *
 * &lt;p&gt;The Selective interface sits between {@link org.higherkindedj.hkt.Applicative} and {@link
 * org.higherkindedj.hkt.Monad} in terms of power. It allows for static analysis of effects while
 * still supporting conditional behaviour.
 *
 * &lt;p&gt;For List, selective operations work with non-deterministic computations, where each element in
 * the list represents a possible outcome. The selective operations handle choices for each element
 * independently.
 *
 * &lt;p&gt;&lt;b&gt;Unit Usage:&lt;/b&gt; The {@link #whenS(Kind, Kind)} method now uses {@link Unit} to represent
 * skipped effects in the non-deterministic context. When a condition is false, {@code
 * Unit.INSTANCE} is added to the result list, making it explicit that &quot;this branch was not taken&quot;
 * rather than using null.
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies functions to values based on Choice.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with different
 *       handlers.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes a Unit-returning effect based on a
 *       boolean.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional for selective functors.
 * &lt;/ul&gt;
 *
 * @see List
 * @see ListMonad
 * @see Selective
 * @see Choice
 * @see Unit
 */
public final class ListSelective extends ListMonad implements Selective&lt;ListKind.Witness&gt; {

  /** Singleton instance of {@code ListSelective}. */
<span class="fc" id="L55">  public static final ListSelective INSTANCE = new ListSelective();</span>

<span class="fc" id="L57">  private static final Class&lt;ListSelective&gt; LIST_SELECTIVE_CLASS = ListSelective.class;</span>

  /** Private constructor to enforce singleton pattern. */
  private ListSelective() {
    super();
  }

  /**
   * The core selective operation for List. Given a list of choices and a list of functions, applies
   * each function to the corresponding {@code Left} value, or returns the {@code Right} value
   * directly.
   *
   * &lt;p&gt;This operation processes each element independently, collecting all results.
   *
   * &lt;p&gt;Behavior:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;For each {@code Right(b)} in the choice list: Include {@code b} in the result.
   *   &lt;li&gt;For each {@code Left(a)} in the choice list: Apply each function from {@code ff} to
   *       {@code a}, adding all results to the output.
   * &lt;/ul&gt;
   *
   * @param fab A {@link Kind} representing {@code List&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param ff A {@link Kind} representing {@code List&lt;Function&lt;A, B&gt;&gt;}. Must not be null.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left} of the Choice).
   * @param &lt;B&gt; The output type and the type inside {@code Right} of the Choice.
   * @return A {@link Kind} representing {@code List&lt;B&gt;}. Never null.
   * @throws NullPointerException if {@code fab} or {@code ff} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;ListKind.Witness, B&gt; select(
      Kind&lt;ListKind.Witness, Choice&lt;A, B&gt;&gt; fab, Kind&lt;ListKind.Witness, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L92">    Validation.kind().requireNonNull(fab, LIST_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L93">    Validation.kind().requireNonNull(ff, LIST_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L95">    List&lt;Choice&lt;A, B&gt;&gt; choices = LIST.narrow(fab);</span>
<span class="fc" id="L96">    List&lt;Function&lt;A, B&gt;&gt; functions = LIST.narrow(ff);</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">    if (choices.isEmpty()) {</span>
<span class="fc" id="L99">      return LIST.widen(Collections.emptyList());</span>
    }

<span class="fc" id="L102">    List&lt;B&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">    for (Choice&lt;A, B&gt; choice : choices) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      if (choice.isRight()) {</span>
        // Already have the value, add it directly
<span class="fc" id="L107">        result.add(choice.getRight());</span>
      } else {
        // Need to apply functions - non-deterministic application
<span class="fc" id="L110">        A value = choice.getLeft();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (functions.isEmpty()) {</span>
          // No functions available, result is empty for this choice
<span class="fc" id="L113">          continue;</span>
        }
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (Function&lt;A, B&gt; func : functions) {</span>
<span class="fc" id="L116">          result.add(func.apply(value));</span>
<span class="fc" id="L117">        }</span>
      }
<span class="fc" id="L119">    }</span>

<span class="fc" id="L121">    return LIST.widen(result);</span>
  }

  /**
   * Optimised implementation of {@code branch} for List. Provides a two-way conditional choice,
   * applying the appropriate handler based on whether each Choice is Left or Right.
   *
   * @param fab A {@link Kind} representing {@code List&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code List&lt;Function&lt;A, C&gt;&gt;} for the Left case. Must not
   *     be null.
   * @param fr A {@link Kind} representing {@code List&lt;Function&lt;B, C&gt;&gt;} for the Right case. Must not
   *     be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code List&lt;C&gt;}. Never null.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;ListKind.Witness, C&gt; branch(
      Kind&lt;ListKind.Witness, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;ListKind.Witness, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;ListKind.Witness, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L144">    Validation.kind().requireNonNull(fab, LIST_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L145">    Validation.kind().requireNonNull(fl, LIST_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L146">    Validation.kind().requireNonNull(fr, LIST_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L148">    List&lt;Choice&lt;A, B&gt;&gt; choices = LIST.narrow(fab);</span>
<span class="fc" id="L149">    List&lt;Function&lt;A, C&gt;&gt; leftFunctions = LIST.narrow(fl);</span>
<span class="fc" id="L150">    List&lt;Function&lt;B, C&gt;&gt; rightFunctions = LIST.narrow(fr);</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (choices.isEmpty()) {</span>
<span class="fc" id="L153">      return LIST.widen(Collections.emptyList());</span>
    }

<span class="fc" id="L156">    List&lt;C&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">    for (Choice&lt;A, B&gt; choice : choices) {</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      if (choice.isLeft()) {</span>
        // Apply left handlers
<span class="fc" id="L161">        A value = choice.getLeft();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (leftFunctions.isEmpty()) {</span>
<span class="fc" id="L163">          continue;</span>
        }
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (Function&lt;A, C&gt; func : leftFunctions) {</span>
<span class="fc" id="L166">          result.add(func.apply(value));</span>
<span class="fc" id="L167">        }</span>
<span class="fc" id="L168">      } else {</span>
        // Apply right handlers
<span class="fc" id="L170">        B value = choice.getRight();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (rightFunctions.isEmpty()) {</span>
<span class="fc" id="L172">          continue;</span>
        }
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (Function&lt;B, C&gt; func : rightFunctions) {</span>
<span class="fc" id="L175">          result.add(func.apply(value));</span>
<span class="fc" id="L176">        }</span>
      }
<span class="fc" id="L178">    }</span>

<span class="fc" id="L180">    return LIST.widen(result);</span>
  }

  /**
   * Optimised implementation of {@code whenS} for List. Conditionally executes a Unit-returning
   * effect based on boolean conditions.
   *
   * &lt;p&gt;For List (representing non-deterministic computation), this operation works as follows:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;For each {@code true} condition: Includes all effect results from the effect list
   *   &lt;li&gt;For each {@code false} condition: Includes {@code Unit.INSTANCE} (operation skipped)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This maintains the non-deterministic semantics of List while providing type-safe handling of
   * skipped effects.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * List&lt;Boolean&gt; conditions = List.of(true, false, true);
   * List&lt;Unit&gt; effects = List.of(Unit.INSTANCE, Unit.INSTANCE);
   *
   * Kind&lt;ListKind.Witness, Unit&gt; result = listSelective.whenS(
   *     LIST.widen(conditions),
   *     LIST.widen(effects)
   * );
   * // Result list contains: [Unit.INSTANCE, Unit.INSTANCE, Unit.INSTANCE, Unit.INSTANCE]
   * // (2 effects for first true, 1 Unit for false, 2 effects for second true)
   * }&lt;/pre&gt;
   *
   * @param fcond A {@link Kind} representing {@code List&lt;Boolean&gt;}. Must not be null.
   * @param fa A {@link Kind} representing {@code List&lt;Unit&gt;} to execute if condition is true. Must
   *     not be null.
   * @return A {@link Kind} representing {@code List&lt;Unit&gt;}. Never null.
   */
  @Override
  public Kind&lt;ListKind.Witness, Unit&gt; whenS(
      Kind&lt;ListKind.Witness, Boolean&gt; fcond, Kind&lt;ListKind.Witness, Unit&gt; fa) {

<span class="fc" id="L220">    Validation.kind().requireNonNull(fcond, LIST_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L221">    Validation.kind().requireNonNull(fa, LIST_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L223">    List&lt;Boolean&gt; conditions = LIST.narrow(fcond);</span>
<span class="fc" id="L224">    List&lt;Unit&gt; effects = LIST.narrow(fa);</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (conditions.isEmpty()) {</span>
<span class="fc" id="L227">      return LIST.widen(Collections.emptyList());</span>
    }

<span class="fc" id="L230">    List&lt;Unit&gt; result = new ArrayList&lt;&gt;();</span>

    // For lists, we combine conditions with effects
    // Each true condition pairs with each effect value
    // Each false condition produces Unit.INSTANCE
<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (Boolean condition : conditions) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      if (condition) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (effects.isEmpty()) {</span>
<span class="fc" id="L238">          continue;</span>
        }
        // Add all effect values for this true condition
<span class="fc" id="L241">        result.addAll(effects);</span>
      } else {
        // Condition is false, add Unit.INSTANCE
<span class="fc" id="L244">        result.add(Unit.INSTANCE);</span>
      }
<span class="fc" id="L246">    }</span>

<span class="fc" id="L248">    return LIST.widen(result);</span>
  }

  /**
   * Optimised implementation of {@code ifS} for List. A ternary conditional operator for selective
   * functors.
   *
   * &lt;p&gt;For each condition, includes results from the then-branch if true, or from the else-branch
   * if false.
   *
   * @param fcond A {@link Kind} representing {@code List&lt;Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code List&lt;A&gt;} for the true branch. Must not be null.
   * @param felse A {@link Kind} representing {@code List&lt;A&gt;} for the false branch. Must not be
   *     null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code List&lt;A&gt;}. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;ListKind.Witness, A&gt; ifS(
      Kind&lt;ListKind.Witness, Boolean&gt; fcond,
      Kind&lt;ListKind.Witness, A&gt; fthen,
      Kind&lt;ListKind.Witness, A&gt; felse) {

<span class="fc" id="L271">    Validation.kind().requireNonNull(fcond, LIST_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L272">    Validation.kind().requireNonNull(fthen, LIST_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L273">    Validation.kind().requireNonNull(felse, LIST_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L275">    List&lt;Boolean&gt; conditions = LIST.narrow(fcond);</span>
<span class="fc" id="L276">    List&lt;A&gt; thenValues = LIST.narrow(fthen);</span>
<span class="fc" id="L277">    List&lt;A&gt; elseValues = LIST.narrow(felse);</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">    if (conditions.isEmpty()) {</span>
<span class="fc" id="L280">      return LIST.widen(Collections.emptyList());</span>
    }

<span class="fc" id="L283">    List&lt;A&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">    for (Boolean condition : conditions) {</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">      if (condition) {</span>
        // Add all values from then-branch
<span class="fc" id="L288">        result.addAll(thenValues);</span>
      } else {
        // Add all values from else-branch
<span class="fc" id="L291">        result.addAll(elseValues);</span>
      }
<span class="fc" id="L293">    }</span>

<span class="fc" id="L295">    return LIST.widen(result);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>