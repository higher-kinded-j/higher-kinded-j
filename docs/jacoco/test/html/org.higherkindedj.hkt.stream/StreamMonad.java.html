<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.stream</a> &gt; <span class="el_source">StreamMonad.java</span></div><h1>StreamMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.stream;

import static org.higherkindedj.hkt.stream.StreamKindHelper.STREAM;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * {@link MonadZero} instance for {@link StreamKind.Witness}. This class provides monadic operations
 * for streams, treating streams as a context that can hold zero or more values with lazy evaluation
 * semantics. It also provides a &quot;zero&quot; element (an empty stream).
 *
 * &lt;p&gt;&lt;b&gt;Lazy Evaluation:&lt;/b&gt; All operations provided by this monad maintain the lazy evaluation
 * characteristics of {@code java.util.stream.Stream}:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #map} - Lazy transformation, function not applied until terminal operation
 *   &lt;li&gt;{@link #flatMap} - Lazy flattening and transformation using {@code Stream.flatMap}
 *   &lt;li&gt;{@link #ap} - Applies functions to values, but evaluation is still lazy
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Single-Use Semantics:&lt;/b&gt; As with all stream operations, once a terminal operation has been
 * performed on a stream (including operations that narrow and inspect the stream), that stream
 * cannot be reused. This is a fundamental characteristic of {@code java.util.stream.Stream} and is
 * preserved in this HKT representation.
 *
 * &lt;p&gt;&lt;b&gt;Monadic Composition:&lt;/b&gt; This implementation allows for powerful stream pipeline
 * composition using monadic operations:
 *
 * &lt;pre&gt;{@code
 * // Example: Processing a stream of users
 * Kind&lt;StreamKind.Witness, User&gt; users = STREAM.widen(userRepository.findAll());
 *
 * // Lazy transformation pipeline
 * Kind&lt;StreamKind.Witness, Order&gt; recentOrders = streamMonad.flatMap(
 *     user -&gt; STREAM.widen(orderRepository.findByUser(user.getId())
 *         .filter(order -&gt; order.isRecent())),
 *     users
 * );
 *
 * // Only when we perform a terminal operation does computation happen
 * List&lt;Order&gt; collected = STREAM.narrow(recentOrders)
 *     .limit(100)
 *     .collect(Collectors.toList());
 * }&lt;/pre&gt;
 *
 * @see MonadZero
 * @see Stream
 * @see StreamKind
 * @see StreamFunctor
 */
public class StreamMonad implements MonadZero&lt;StreamKind.Witness&gt; {

  /** A StreamMonad singleton */
<span class="fc" id="L65">  public static final StreamMonad INSTANCE = new StreamMonad();</span>

  /** Private constructor to enforce singleton pattern. */
<span class="fc" id="L68">  protected StreamMonad() {}</span>

  /**
   * Lifts a single value {@code a} into the Stream context. If the value is null, it creates an
   * empty stream. Otherwise, it creates a singleton stream containing the value.
   *
   * &lt;p&gt;This operation is eager in the sense that it creates the stream immediately, but the stream
   * itself remains lazy until a terminal operation is performed.
   *
   * @param value The value to lift. Can be {@code null}.
   * @param &lt;A&gt; The type of the value.
   * @return A {@code Kind&lt;StreamKind.Witness, A&gt;} representing a stream. If value is null, it's an
   *     empty stream; otherwise, a stream containing the single value. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; of(@Nullable A value) {
<span class="fc bfc" id="L84" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L85">      return STREAM.widen(Stream.empty());</span>
    }
<span class="fc" id="L87">    return STREAM.widen(Stream.of(value));</span>
  }

  /**
   * Applies a function contained within a Stream context to a value contained within another Stream
   * context. This involves taking all functions from the first stream and applying each one to all
   * values from the second stream, collecting all results into a new stream.
   *
   * &lt;p&gt;&lt;b&gt;Eager Evaluation of Values:&lt;/b&gt; Due to the single-use semantics of {@code
   * java.util.stream.Stream}, the values stream {@code fa} is consumed &lt;b&gt;eagerly&lt;/b&gt; and collected
   * into a List. This is necessary to allow each function in {@code ff} to be applied to all values
   * without violating the stream's single-use constraint. The functions stream {@code ff} remains
   * lazy and is only consumed during terminal operations.
   *
   * &lt;p&gt;&lt;b&gt;Cartesian Product Semantics:&lt;/b&gt; Similar to {@code ListMonad}, this operation creates a
   * cartesian product of functions and values. For each function in {@code ff}, it is applied to
   * each value in {@code fa}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; If the functions stream {@code ff} is infinite, the resulting stream will also
   * be infinite and may require limiting operations to avoid unbounded computation. The values
   * stream {@code fa} must be finite since it is eagerly collected.
   *
   * @param ff A {@code Kind&lt;StreamKind.Witness, Function&lt;A, B&gt;&gt;} (a stream of functions). Must not
   *     be null. Remains lazy until terminal operation.
   * @param fa A {@code Kind&lt;StreamKind.Witness, A&gt;} (a stream of values). Must not be null.
   *     &lt;b&gt;Consumed eagerly&lt;/b&gt; into a List.
   * @param &lt;A&gt; The input type of the function.
   * @param &lt;B&gt; The output type of the function.
   * @return A {@code Kind&lt;StreamKind.Witness, B&gt;} containing all results of applying each function
   *     in {@code ff} to each value in {@code fa}. Never null. Functions are applied lazily.
   * @throws NullPointerException if {@code ff} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ff} or {@code fa} cannot
   *     be unwrapped to valid Stream representations.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;StreamKind.Witness, B&gt; ap(
      Kind&lt;StreamKind.Witness, ? extends Function&lt;A, B&gt;&gt; ff, Kind&lt;StreamKind.Witness, A&gt; fa) {

<span class="fc" id="L125">    Validation.kind().validateAp(ff, fa, StreamMonad.class);</span>

<span class="fc" id="L127">    Stream&lt;? extends Function&lt;A, B&gt;&gt; functions = STREAM.narrow(ff);</span>
<span class="fc" id="L128">    Stream&lt;A&gt; values = STREAM.narrow(fa);</span>

    // Eagerly collect values to avoid single-use stream violation
    // Each function needs to iterate over all values, which would fail if we tried to
    // reuse the values stream. We trade laziness for correctness here.
<span class="fc" id="L133">    List&lt;A&gt; valuesList = values.collect(Collectors.toList());</span>

    // Cartesian product: for each function, apply it to each value from the list
    // The functions stream remains lazy
<span class="fc" id="L137">    Stream&lt;B&gt; resultStream = functions.flatMap(func -&gt; valuesList.stream().map(func));</span>

<span class="fc" id="L139">    return STREAM.widen(resultStream);</span>
  }

  /**
   * Maps a function over a stream in a higher-kinded context. This delegates to the {@link
   * StreamFunctor} instance.
   *
   * &lt;p&gt;&lt;b&gt;Lazy Evaluation:&lt;/b&gt; The mapping is lazy and does not force evaluation of the stream.
   *
   * @param f The function to apply. Must not be null.
   * @param fa The {@code Kind&lt;StreamKind.Witness, A&gt;} (a stream of values). Must not be null.
   * @param &lt;A&gt; The input type of the function.
   * @param &lt;B&gt; The output type of the function.
   * @return A {@code Kind&lt;StreamKind.Witness, B&gt;} containing the results of applying {@code f} to
   *     each element. Never null. Evaluation is lazy.
   * @throws NullPointerException if {@code f} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fa} cannot be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;StreamKind.Witness, B&gt; map(
      Function&lt;? super A, ? extends B&gt; f, Kind&lt;StreamKind.Witness, A&gt; fa) {

<span class="fc" id="L161">    Validation.function().requireMapper(f, &quot;f&quot;, StreamMonad.class, MAP);</span>
<span class="fc" id="L162">    Validation.kind().requireNonNull(fa, StreamMonad.class, MAP);</span>

<span class="fc" id="L164">    return StreamFunctor.INSTANCE.map(f, fa);</span>
  }

  /**
   * Applies a function {@code f} to each element of a stream {@code ma}, where {@code f} itself
   * returns a stream (wrapped in {@code Kind&lt;StreamKind.Witness, B&gt;}). All resulting streams are
   * then concatenated (flattened) into a single result stream.
   *
   * &lt;p&gt;&lt;b&gt;Lazy Evaluation:&lt;/b&gt; This operation leverages {@code Stream.flatMap}, which is lazy. The
   * function {@code f} is not called, and the resulting streams are not generated, until a terminal
   * operation is performed on the result.
   *
   * &lt;p&gt;This is the key operation that distinguishes a Monad from an Applicative. It allows for
   * dependent sequencing where each step can depend on the result of the previous step.
   *
   * &lt;p&gt;&lt;b&gt;Example - Dependent Computation:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Get all orders for each user (dependent on user data)
   * Kind&lt;StreamKind.Witness, User&gt; users = STREAM.widen(Stream.of(user1, user2));
   * Kind&lt;StreamKind.Witness, Order&gt; allOrders = streamMonad.flatMap(
   *     user -&gt; STREAM.widen(getOrdersForUser(user)), // Returns Stream&lt;Order&gt;
   *     users
   * );
   * }&lt;/pre&gt;
   *
   * @param f A function from {@code A} to {@code Kind&lt;StreamKind.Witness, B&gt;} (a stream of {@code
   *     B}s). Must not be null.
   * @param ma The input {@code Kind&lt;StreamKind.Witness, A&gt;} (a stream of {@code A}s). Must not be
   *     null.
   * @param &lt;A&gt; The type of elements in the input stream.
   * @param &lt;B&gt; The type of elements in the streams produced by the function {@code f}.
   * @return A {@code Kind&lt;StreamKind.Witness, B&gt;} which is the flattened stream of all results.
   *     Never null. Evaluation is lazy.
   * @throws NullPointerException if {@code f} or {@code ma} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} or the result of
   *     {@code f} cannot be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;StreamKind.Witness, B&gt; flatMap(
      Function&lt;? super A, ? extends Kind&lt;StreamKind.Witness, B&gt;&gt; f,
      Kind&lt;StreamKind.Witness, A&gt; ma) {

<span class="fc" id="L207">    Validation.function().validateFlatMap(f, ma, StreamMonad.class);</span>

<span class="fc" id="L209">    Stream&lt;A&gt; inputStream = STREAM.narrow(ma);</span>

    // Leverage Stream.flatMap for lazy flattening
<span class="fc" id="L212">    Stream&lt;B&gt; resultStream =</span>
<span class="fc" id="L213">        inputStream.flatMap(</span>
            a -&gt; {
<span class="fc" id="L215">              Kind&lt;StreamKind.Witness, B&gt; kindB = f.apply(a);</span>
<span class="fc" id="L216">              Validation.function()</span>
<span class="fc" id="L217">                  .requireNonNullResult(kindB, &quot;f&quot;, StreamMonad.class, FLAT_MAP, Kind.class);</span>
<span class="fc" id="L218">              return STREAM.narrow(kindB);</span>
            });

<span class="fc" id="L221">    return STREAM.widen(resultStream);</span>
  }

  /**
   * Returns the &quot;zero&quot; or &quot;empty&quot; value for this Monad, which is an empty stream.
   *
   * &lt;p&gt;The empty stream can be combined with other streams using operations like {@code flatMap} or
   * stream concatenation. It serves as the identity element for stream concatenation.
   *
   * @param &lt;T&gt; The type parameter of the Kind.
   * @return A {@code Kind&lt;StreamKind.Witness, T&gt;} representing an empty stream. Never null.
   */
  @Override
  public &lt;T&gt; Kind&lt;StreamKind.Witness, T&gt; zero() {
<span class="fc" id="L235">    return STREAM.widen(Stream.empty());</span>
  }

  // --- Alternative Methods ---

  /**
   * Combines two streams by concatenating them.
   *
   * &lt;p&gt;This implements the Alternative pattern for Stream. Like List, orElse for Stream
   * concatenates both streams, representing non-deterministic choice (all possibilities). The
   * concatenation is performed lazily using {@link Stream#concat(Stream, Stream)}.
   *
   * &lt;p&gt;&lt;b&gt;Lazy Evaluation:&lt;/b&gt; The second stream is provided via {@link
   * java.util.function.Supplier}, but due to the semantics of stream concatenation, both streams
   * will be evaluated when the resulting stream is consumed. However, the supplier ensures the
   * second stream is not created until it's needed.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; stream1 = STREAM.widen(Stream.of(1, 2));
   * Kind&lt;StreamKind.Witness, Integer&gt; stream2 = () -&gt; STREAM.widen(Stream.of(3, 4));
   *
   * Kind&lt;StreamKind.Witness, Integer&gt; result = orElse(stream1, stream2);
   * // result is Stream.of(1, 2, 3, 4)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the elements in the streams
   * @param sa The first stream. Must not be null.
   * @param sb A {@link java.util.function.Supplier} providing the second stream. Must not be null.
   * @return A new stream containing all elements from both streams (sa followed by sb)
   * @throws NullPointerException if sa or sb is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if sa or the result of sb cannot be
   *     unwrapped
   */
  @Override
  public &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; orElse(
      Kind&lt;StreamKind.Witness, A&gt; sa, Supplier&lt;Kind&lt;StreamKind.Witness, A&gt;&gt; sb) {

<span class="fc" id="L274">    Validation.kind().requireNonNull(sa, StreamMonad.class, OR_ELSE, &quot;first stream&quot;);</span>
<span class="fc" id="L275">    Validation.function().requireFunction(sb, &quot;sb&quot;, StreamMonad.class, OR_ELSE);</span>

<span class="fc" id="L277">    Stream&lt;A&gt; streamA = STREAM.narrow(sa);</span>

    // Use lazy supplier to delay evaluation of second stream
<span class="fc" id="L280">    Stream&lt;A&gt; concatenated =</span>
<span class="fc" id="L281">        Stream.concat(</span>
            streamA,
<span class="fc" id="L283">            Stream.of((A) null)</span>
<span class="fc" id="L284">                .flatMap(</span>
                    ignored -&gt; {
<span class="fc" id="L286">                      Kind&lt;StreamKind.Witness, A&gt; kindB = sb.get();</span>
<span class="fc" id="L287">                      Validation.function()</span>
<span class="fc" id="L288">                          .requireNonNullResult(</span>
                              kindB, &quot;sb&quot;, StreamMonad.class, OR_ELSE, Stream.class);
<span class="fc" id="L290">                      return STREAM.narrow(kindB);</span>
                    }));

<span class="fc" id="L293">    return STREAM.widen(concatenated);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>