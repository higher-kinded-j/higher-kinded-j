<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamOps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.stream</a> &gt; <span class="el_source">StreamOps.java</span></div><h1>StreamOps.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.stream;

import static org.higherkindedj.hkt.stream.StreamKindHelper.STREAM;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.tuple.Tuple2;

/**
 * Utility operations for {@link Stream} in a higher-kinded type context. This class provides
 * convenient methods for common stream operations while maintaining the HKT abstraction.
 *
 * &lt;p&gt;All methods in this class are static and can be accessed directly or via static import:
 *
 * &lt;pre&gt;{@code
 * import static org.higherkindedj.hkt.stream.StreamOps.*;
 *
 * Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 10);
 * List&lt;Integer&gt; materialized = toList(numbers);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Categories of Operations:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Creation:&lt;/b&gt; {@link #fromIterable}, {@link #fromArray}, {@link #range}
 *   &lt;li&gt;&lt;b&gt;Materialization:&lt;/b&gt; {@link #toList}, {@link #toSet}
 *   &lt;li&gt;&lt;b&gt;Filtering:&lt;/b&gt; {@link #filter}, {@link #take}, {@link #drop}
 *   &lt;li&gt;&lt;b&gt;Combination:&lt;/b&gt; {@link #concat}, {@link #zip}, {@link #zipWithIndex}
 *   &lt;li&gt;&lt;b&gt;Effects:&lt;/b&gt; {@link #tap}, {@link #forEach}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Lazy vs Eager Operations:&lt;/b&gt;
 *
 * &lt;p&gt;Most operations maintain laziness (filter, take, drop, concat, zip), while some necessarily
 * force evaluation (toList, toSet, forEach, zipWithIndex).
 *
 * @see StreamKind
 * @see StreamKindHelper
 * @see StreamMonad
 */
public final class StreamOps {

  private StreamOps() {
    // Utility class, no instantiation
  }

  // ========== Creation Operations ==========

  /**
   * Creates a stream from an {@link Iterable}.
   *
   * &lt;p&gt;This is a lazy operation - the iterable is not consumed until a terminal operation is
   * performed on the resulting stream.
   *
   * @param iterable The iterable to create a stream from. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A {@code Kind&lt;StreamKind.Witness, A&gt;} representing the stream.
   * @throws NullPointerException if iterable is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; fromIterable(Iterable&lt;A&gt; iterable) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (iterable == null) {</span>
<span class="fc" id="L76">      throw new NullPointerException(&quot;Iterable cannot be null&quot;);</span>
    }
<span class="fc" id="L78">    return STREAM.widen(StreamSupport.stream(iterable.spliterator(), false));</span>
  }

  /**
   * Creates a stream from an array.
   *
   * &lt;p&gt;This is a lazy operation - the array is not traversed until a terminal operation is
   * performed on the resulting stream.
   *
   * @param array The array to create a stream from. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A {@code Kind&lt;StreamKind.Witness, A&gt;} representing the stream.
   * @throws NullPointerException if array is null.
   */
  @SafeVarargs
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; fromArray(A... array) {
<span class="fc bfc" id="L94" title="All 2 branches covered.">    if (array == null) {</span>
<span class="fc" id="L95">      throw new NullPointerException(&quot;Array cannot be null&quot;);</span>
    }
<span class="fc" id="L97">    return STREAM.widen(Arrays.stream(array));</span>
  }

  /**
   * Creates a stream of integers in the range [start, end).
   *
   * &lt;p&gt;This is a lazy operation. The range is not materialized until a terminal operation is
   * performed.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; oneToNine = range(1, 10);
   * // Represents: 1, 2, 3, 4, 5, 6, 7, 8, 9
   * }&lt;/pre&gt;
   *
   * @param start The starting value (inclusive).
   * @param end The ending value (exclusive).
   * @return A {@code Kind&lt;StreamKind.Witness, Integer&gt;} representing the range.
   */
  public static Kind&lt;StreamKind.Witness, Integer&gt; range(int start, int end) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">    return STREAM.widen(Stream.iterate(start, n -&gt; n &lt; end, n -&gt; n + 1));</span>
  }

  /**
   * Creates a stream of integers in the range [start, end].
   *
   * &lt;p&gt;This is a lazy operation. The range is not materialized until a terminal operation is
   * performed.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; oneToTen = rangeClosed(1, 10);
   * // Represents: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
   * }&lt;/pre&gt;
   *
   * @param start The starting value (inclusive).
   * @param end The ending value (inclusive).
   * @return A {@code Kind&lt;StreamKind.Witness, Integer&gt;} representing the range.
   */
  public static Kind&lt;StreamKind.Witness, Integer&gt; rangeClosed(int start, int end) {
<span class="fc bfc" id="L139" title="All 2 branches covered.">    return STREAM.widen(Stream.iterate(start, n -&gt; n &lt;= end, n -&gt; n + 1));</span>
  }

  // ========== Materialization Operations ==========

  /**
   * Forces evaluation of the stream and collects elements into a {@link List}.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This is a terminal operation that consumes the stream. The stream cannot be
   * reused after this operation.
   *
   * @param stream The stream to materialize. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A List containing all elements from the stream. Never null.
   * @throws NullPointerException if stream is null.
   */
  public static &lt;A&gt; List&lt;A&gt; toList(Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L156" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L157">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L159">    return STREAM.narrow(stream).collect(Collectors.toList());</span>
  }

  /**
   * Forces evaluation of the stream and collects elements into a {@link Set}.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This is a terminal operation that consumes the stream. The stream cannot be
   * reused after this operation.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; Duplicate elements will be removed based on their {@code equals} and {@code
   * hashCode} implementations.
   *
   * @param stream The stream to materialize. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A Set containing all unique elements from the stream. Never null.
   * @throws NullPointerException if stream is null.
   */
  public static &lt;A&gt; Set&lt;A&gt; toSet(Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L178">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L180">    return STREAM.narrow(stream).collect(Collectors.toSet());</span>
  }

  // ========== Filtering Operations ==========

  /**
   * Filters the stream, keeping only elements that match the predicate.
   *
   * &lt;p&gt;This is a lazy operation - the predicate is not applied until a terminal operation is
   * performed on the resulting stream.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 10);
   * Kind&lt;StreamKind.Witness, Integer&gt; evens = filter(n -&gt; n % 2 == 0, numbers);
   * // Represents: 2, 4, 6, 8
   * }&lt;/pre&gt;
   *
   * @param predicate The predicate to test elements. Must not be null.
   * @param stream The stream to filter. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A filtered stream containing only matching elements.
   * @throws NullPointerException if predicate or stream is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; filter(
      Predicate&lt;? super A&gt; predicate, Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (predicate == null) {</span>
<span class="fc" id="L208">      throw new NullPointerException(&quot;Predicate cannot be null&quot;);</span>
    }
<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L211">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L213">    return STREAM.widen(STREAM.narrow(stream).filter(predicate));</span>
  }

  /**
   * Takes the first {@code n} elements from the stream.
   *
   * &lt;p&gt;This is a lazy operation - elements are not materialized until a terminal operation is
   * performed on the resulting stream.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; infinite = STREAM.widen(Stream.iterate(1, n -&gt; n + 1));
   * Kind&lt;StreamKind.Witness, Integer&gt; firstTen = take(10, infinite);
   * // Represents: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
   * }&lt;/pre&gt;
   *
   * @param n The number of elements to take. Must be non-negative.
   * @param stream The stream to limit. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A stream containing at most the first {@code n} elements.
   * @throws IllegalArgumentException if n is negative.
   * @throws NullPointerException if stream is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; take(long n, Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (n &lt; 0) {</span>
<span class="fc" id="L239">      throw new IllegalArgumentException(&quot;Cannot take negative number of elements: &quot; + n);</span>
    }
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L242">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L244">    return STREAM.widen(STREAM.narrow(stream).limit(n));</span>
  }

  /**
   * Drops the first {@code n} elements from the stream.
   *
   * &lt;p&gt;This is a lazy operation - elements are not skipped until a terminal operation is performed
   * on the resulting stream.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 10);
   * Kind&lt;StreamKind.Witness, Integer&gt; afterFive = drop(5, numbers);
   * // Represents: 6, 7, 8, 9
   * }&lt;/pre&gt;
   *
   * @param n The number of elements to skip. Must be non-negative.
   * @param stream The stream to skip from. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A stream with the first {@code n} elements skipped.
   * @throws IllegalArgumentException if n is negative.
   * @throws NullPointerException if stream is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; drop(long n, Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">    if (n &lt; 0) {</span>
<span class="fc" id="L270">      throw new IllegalArgumentException(&quot;Cannot drop negative number of elements: &quot; + n);</span>
    }
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L273">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L275">    return STREAM.widen(STREAM.narrow(stream).skip(n));</span>
  }

  // ========== Combination Operations ==========

  /**
   * Concatenates two streams.
   *
   * &lt;p&gt;This is a lazy operation - neither stream is evaluated until a terminal operation is
   * performed on the resulting stream.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; first = range(1, 5);
   * Kind&lt;StreamKind.Witness, Integer&gt; second = range(5, 10);
   * Kind&lt;StreamKind.Witness, Integer&gt; combined = concat(first, second);
   * // Represents: 1, 2, 3, 4, 5, 6, 7, 8, 9
   * }&lt;/pre&gt;
   *
   * @param s1 The first stream. Must not be null.
   * @param s2 The second stream. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A stream containing all elements from s1 followed by all elements from s2.
   * @throws NullPointerException if s1 or s2 is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; concat(
      Kind&lt;StreamKind.Witness, A&gt; s1, Kind&lt;StreamKind.Witness, A&gt; s2) {
<span class="fc bfc" id="L303" title="All 4 branches covered.">    if (s1 == null || s2 == null) {</span>
<span class="fc" id="L304">      throw new NullPointerException(&quot;Streams cannot be null&quot;);</span>
    }
<span class="fc" id="L306">    return STREAM.widen(Stream.concat(STREAM.narrow(s1), STREAM.narrow(s2)));</span>
  }

  /**
   * Zips two streams together using a combining function.
   *
   * &lt;p&gt;The resulting stream ends when either input stream ends. Elements are paired in order.
   *
   * &lt;p&gt;This is a lazy operation - the zipper function is not applied until a terminal operation is
   * performed on the resulting stream.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, String&gt; names = fromArray(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);
   * Kind&lt;StreamKind.Witness, Integer&gt; ages = fromArray(25, 30, 35);
   * Kind&lt;StreamKind.Witness, String&gt; profiles = zip(names, ages,
   *     (name, age) -&gt; name + &quot; is &quot; + age + &quot; years old&quot;);
   * // Represents: &quot;Alice is 25 years old&quot;, &quot;Bob is 30 years old&quot;, &quot;Charlie is 35 years old&quot;
   * }&lt;/pre&gt;
   *
   * @param sa The first stream. Must not be null.
   * @param sb The second stream. Must not be null.
   * @param zipper The function to combine elements. Must not be null.
   * @param &lt;A&gt; The type of elements in the first stream.
   * @param &lt;B&gt; The type of elements in the second stream.
   * @param &lt;C&gt; The type of elements in the result stream.
   * @return A stream of combined elements.
   * @throws NullPointerException if any parameter is null.
   */
  public static &lt;A, B, C&gt; Kind&lt;StreamKind.Witness, C&gt; zip(
      Kind&lt;StreamKind.Witness, A&gt; sa,
      Kind&lt;StreamKind.Witness, B&gt; sb,
      BiFunction&lt;? super A, ? super B, ? extends C&gt; zipper) {
<span class="fc bfc" id="L340" title="All 6 branches covered.">    if (sa == null || sb == null || zipper == null) {</span>
<span class="fc" id="L341">      throw new NullPointerException(&quot;Parameters cannot be null&quot;);</span>
    }

<span class="fc" id="L344">    Iterator&lt;A&gt; iterA = STREAM.narrow(sa).iterator();</span>
<span class="fc" id="L345">    Iterator&lt;B&gt; iterB = STREAM.narrow(sb).iterator();</span>

    // Create an iterator that zips the two streams
<span class="fc" id="L348">    Iterator&lt;C&gt; zippedIterator =</span>
<span class="fc" id="L349">        new Iterator&lt;&gt;() {</span>
          @Override
          public boolean hasNext() {
<span class="fc bfc" id="L352" title="All 4 branches covered.">            return iterA.hasNext() &amp;&amp; iterB.hasNext();</span>
          }

          @Override
          public C next() {
<span class="fc" id="L357">            return zipper.apply(iterA.next(), iterB.next());</span>
          }
        };

    // Convert iterator to stream
<span class="fc" id="L362">    Stream&lt;C&gt; zippedStream =</span>
<span class="fc" id="L363">        StreamSupport.stream(</span>
<span class="fc" id="L364">            Spliterators.spliteratorUnknownSize(zippedIterator, Spliterator.ORDERED), false);</span>

<span class="fc" id="L366">    return STREAM.widen(zippedStream);</span>
  }

  /**
   * Pairs each element in the stream with its zero-based index.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This implementation uses a stateful function and is **not safe** for use
   * with parallel streams. It will produce non-deterministic and incorrect indices if the stream is
   * parallel. It should only be used with sequential streams. p&gt;The operation is lazy for
   * sequential streams.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Due to the nature of indexing, this operation must materialize the stream
   * into a list first, then recreate a stream with indices. This is not truly lazy.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, String&gt; names = fromArray(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);
   * Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, String&gt;&gt; indexed = zipWithIndex(names);
   * // Represents: (0, &quot;Alice&quot;), (1, &quot;Bob&quot;), (2, &quot;Charlie&quot;)
   * }&lt;/pre&gt;
   *
   * @param stream The stream to index. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return A stream of tuples where each tuple contains (index, element).
   * @throws NullPointerException if stream is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, A&gt;&gt; zipWithIndex(
      Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L395" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L396">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }

<span class="fc" id="L399">    AtomicInteger index = new AtomicInteger(0);</span>
<span class="fc" id="L400">    return STREAM.widen(</span>
<span class="fc" id="L401">        STREAM.narrow(stream).map(elem -&gt; new Tuple2&lt;&gt;(index.getAndIncrement(), elem)));</span>
  }

  // ========== Effect Operations ==========

  /**
   * Performs a side effect on each element without modifying the stream.
   *
   * &lt;p&gt;This is a lazy operation - the action is not performed until a terminal operation is
   * executed on the resulting stream. This is equivalent to {@code Stream.peek()}.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 5);
   * Kind&lt;StreamKind.Witness, Integer&gt; logged = tap(n -&gt; System.out.println(&quot;Processing: &quot; + n), numbers);
   * // Nothing printed yet - lazily evaluated
   * List&lt;Integer&gt; result = toList(logged);
   * // Now &quot;Processing: 1&quot;, &quot;Processing: 2&quot;, etc. are printed
   * }&lt;/pre&gt;
   *
   * @param action The action to perform on each element. Must not be null.
   * @param stream The stream to tap. Must not be null.
   * @param &lt;A&gt; The element type.
   * @return The same stream, but with the side effect registered.
   * @throws NullPointerException if action or stream is null.
   */
  public static &lt;A&gt; Kind&lt;StreamKind.Witness, A&gt; tap(
      Consumer&lt;? super A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L430" title="All 2 branches covered.">    if (action == null) {</span>
<span class="fc" id="L431">      throw new NullPointerException(&quot;Action cannot be null&quot;);</span>
    }
<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L434">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L436">    return STREAM.widen(STREAM.narrow(stream).peek(action));</span>
  }

  /**
   * Performs an action on each element of the stream, forcing evaluation.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This is a terminal operation that consumes the stream. The stream cannot be
   * reused after this operation. No value is returned.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Kind&lt;StreamKind.Witness, String&gt; messages = fromArray(&quot;Hello&quot;, &quot;World&quot;);
   * forEach(System.out::println, messages);
   * // Prints: Hello\nWorld
   * }&lt;/pre&gt;
   *
   * @param action The action to perform on each element. Must not be null.
   * @param stream The stream to process. Must not be null.
   * @param &lt;A&gt; The element type.
   * @throws NullPointerException if action or stream is null.
   */
  public static &lt;A&gt; void forEach(Consumer&lt;? super A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">    if (action == null) {</span>
<span class="fc" id="L460">      throw new NullPointerException(&quot;Action cannot be null&quot;);</span>
    }
<span class="fc bfc" id="L462" title="All 2 branches covered.">    if (stream == null) {</span>
<span class="fc" id="L463">      throw new NullPointerException(&quot;Stream cannot be null&quot;);</span>
    }
<span class="fc" id="L465">    STREAM.narrow(stream).forEach(action);</span>
<span class="fc" id="L466">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>