<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Coyoneda.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.coyoneda</a> &gt; <span class="el_source">Coyoneda.java</span></div><h1>Coyoneda.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.coyoneda;

import static java.util.Objects.requireNonNull;

import java.util.function.Function;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;

/**
 * Coyoneda is the &quot;free functor&quot; - it provides a Functor instance for any type constructor F
 * without requiring F to have a Functor instance.
 *
 * &lt;p&gt;Coyoneda works by deferring and accumulating {@code map} operations. Instead of immediately
 * applying functions, it stores them as a composed function that will be applied later when the
 * Coyoneda is &quot;lowered&quot; back to F using an actual Functor instance.
 *
 * &lt;h2&gt;Core Concept&lt;/h2&gt;
 *
 * &lt;p&gt;Coyoneda encapsulates:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A value of type {@code Kind&lt;F, X&gt;} where X is an &quot;existential&quot; (hidden) type
 *   &lt;li&gt;A function {@code X → A} representing the accumulated transformations
 * &lt;/ul&gt;
 *
 * &lt;p&gt;When you call {@code map(f)}, instead of requiring a Functor for F, Coyoneda simply composes f
 * with the existing transformation function. This means:
 *
 * &lt;pre&gt;
 * coyoneda.map(f).map(g).map(h)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Results in a single Coyoneda with the composed function {@code h ∘ g ∘ f}, achieving &lt;b&gt;map
 * fusion&lt;/b&gt; automatically.
 *
 * &lt;h2&gt;Key Benefits&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Automatic Functor instances:&lt;/b&gt; Any {@code Kind&lt;F, A&gt;} can be lifted into Coyoneda and
 *       mapped over, even if F doesn't have a Functor instance
 *   &lt;li&gt;&lt;b&gt;Map fusion:&lt;/b&gt; Multiple map operations are fused into a single traversal
 *   &lt;li&gt;&lt;b&gt;Deferred execution:&lt;/b&gt; No actual mapping happens until {@link #lower(Functor)} is
 *       called
 *   &lt;li&gt;&lt;b&gt;DSL simplification:&lt;/b&gt; Combined with Free monad, eliminates the need for instruction
 *       sets to be Functors
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Lift any Kind&lt;F, A&gt; into Coyoneda
 * Kind&lt;MyType.Witness, Integer&gt; myValue = ...;
 * Coyoneda&lt;MyType.Witness, Integer&gt; coyo = Coyoneda.lift(myValue);
 *
 * // Map without needing a Functor instance for MyType
 * Coyoneda&lt;MyType.Witness, String&gt; mapped = coyo
 *     .map(x -&gt; x * 2)
 *     .map(x -&gt; x + 1)
 *     .map(Object::toString);
 * // All three maps are fused into one function!
 *
 * // When ready, lower back to Kind&lt;F, A&gt; using a Functor
 * Functor&lt;MyType.Witness&gt; functor = ...;
 * Kind&lt;MyType.Witness, String&gt; result = mapped.lower(functor);
 * // Only ONE actual map operation is performed on MyType
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Mathematical Background&lt;/h2&gt;
 *
 * &lt;p&gt;Coyoneda is the &lt;em&gt;covariant Yoneda lemma&lt;/em&gt; applied to functors. For any functor F and
 * type A:
 *
 * &lt;pre&gt;
 * Coyoneda[F, A] ≅ F[A]
 * &lt;/pre&gt;
 *
 * &lt;p&gt;This isomorphism is witnessed by:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code lift}: F[A] → Coyoneda[F, A] (wraps with identity function)
 *   &lt;li&gt;{@code lower}: Coyoneda[F, A] → F[A] (applies the accumulated function via Functor.map)
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Functor Laws&lt;/h2&gt;
 *
 * &lt;p&gt;The Coyoneda Functor instance automatically satisfies the functor laws:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Identity:&lt;/b&gt; {@code coyo.map(x -&gt; x) ≡ coyo}
 *   &lt;li&gt;&lt;b&gt;Composition:&lt;/b&gt; {@code coyo.map(f).map(g) ≡ coyo.map(g.compose(f))}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;These hold by construction since map simply composes functions.
 *
 * @param &lt;F&gt; The type constructor being wrapped (witness type)
 * @param &lt;A&gt; The &quot;current&quot; result type after accumulated transformations
 * @see CoyonedaFunctor
 * @see org.higherkindedj.hkt.Functor
 */
public sealed interface Coyoneda&lt;F, A&gt; permits Coyoneda.Impl {

  /**
   * Lifts a {@code Kind&lt;F, A&gt;} into Coyoneda with the identity transformation.
   *
   * &lt;p&gt;This is the canonical way to create a Coyoneda. The value is wrapped with the identity
   * function, ready for subsequent map operations.
   *
   * &lt;pre&gt;{@code
   * Kind&lt;Maybe.Witness, Integer&gt; maybe = MAYBE.just(42);
   * Coyoneda&lt;Maybe.Witness, Integer&gt; coyo = Coyoneda.lift(maybe);
   * }&lt;/pre&gt;
   *
   * @param fa The value to lift into Coyoneda. Must not be null.
   * @param &lt;F&gt; The type constructor
   * @param &lt;A&gt; The value type
   * @return A Coyoneda wrapping the value with identity transformation
   * @throws NullPointerException if fa is null
   */
  static &lt;F, A&gt; Coyoneda&lt;F, A&gt; lift(Kind&lt;F, A&gt; fa) {
<span class="fc" id="L122">    requireNonNull(fa, &quot;Kind to lift cannot be null&quot;);</span>
<span class="fc" id="L123">    return new Impl&lt;&gt;(fa, Function.identity());</span>
  }

  /**
   * Creates a Coyoneda from a value and a transformation function.
   *
   * &lt;p&gt;This factory method is useful when you already have a transformation to apply. It's
   * equivalent to {@code Coyoneda.lift(fx).map(transform)} but more direct.
   *
   * @param fx The underlying value. Must not be null.
   * @param transform The transformation function. Must not be null.
   * @param &lt;F&gt; The type constructor
   * @param &lt;X&gt; The original value type in F
   * @param &lt;A&gt; The result type after transformation
   * @return A Coyoneda with the given value and transformation
   * @throws NullPointerException if fx or transform is null
   */
  static &lt;F, X, A&gt; Coyoneda&lt;F, A&gt; apply(Kind&lt;F, X&gt; fx, Function&lt;? super X, ? extends A&gt; transform) {
<span class="fc" id="L141">    requireNonNull(fx, &quot;Kind value cannot be null&quot;);</span>
<span class="fc" id="L142">    requireNonNull(transform, &quot;Transform function cannot be null&quot;);</span>
<span class="fc" id="L143">    return new Impl&lt;&gt;(fx, transform);</span>
  }

  /**
   * Maps a function over this Coyoneda, accumulating it with existing transformations.
   *
   * &lt;p&gt;This operation does NOT require a Functor instance for F. The function is simply composed
   * with the existing transformation, achieving map fusion:
   *
   * &lt;pre&gt;{@code
   * coyo.map(f).map(g).map(h)
   * // Internally becomes: Coyoneda(fx, h.compose(g).compose(f))
   * // Only ONE actual map when lowered!
   * }&lt;/pre&gt;
   *
   * @param f The function to apply. Must not be null.
   * @param &lt;B&gt; The result type
   * @return A new Coyoneda with the function composed into the transformation
   * @throws NullPointerException if f is null
   */
  &lt;B&gt; Coyoneda&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f);

  /**
   * Lowers this Coyoneda back to {@code Kind&lt;F, A&gt;} by applying the accumulated transformation.
   *
   * &lt;p&gt;This is where the actual mapping happens. The Functor instance for F is used to apply all
   * the accumulated transformations in a single map operation.
   *
   * &lt;pre&gt;{@code
   * Coyoneda&lt;Maybe.Witness, String&gt; coyo = Coyoneda.lift(MAYBE.just(42))
   *     .map(x -&gt; x * 2)
   *     .map(Object::toString);
   *
   * // Lower using Maybe's Functor
   * Kind&lt;Maybe.Witness, String&gt; result = coyo.lower(maybeFunctor);
   * // Result: Just(&quot;84&quot;)
   * }&lt;/pre&gt;
   *
   * @param functor The Functor instance for F. Must not be null.
   * @return The value with all transformations applied
   * @throws NullPointerException if functor is null
   */
  Kind&lt;F, A&gt; lower(Functor&lt;F&gt; functor);

  /**
   * Returns the underlying Kind value before any transformations.
   *
   * &lt;p&gt;This provides access to the original wrapped value. Note that the type parameter is
   * existentially quantified (hidden), so this returns a wildcard type.
   *
   * @return The underlying Kind value
   */
  Kind&lt;F, ?&gt; underlying();

  /**
   * Internal implementation of Coyoneda.
   *
   * &lt;p&gt;This record holds:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code fx}: The underlying value of type {@code Kind&lt;F, X&gt;}
   *   &lt;li&gt;{@code transform}: The accumulated transformation from X to A
   * &lt;/ul&gt;
   *
   * &lt;p&gt;The type parameter X is existentially quantified - it's hidden from the outside and only
   * known internally. This is achieved by having the record be package-private with a wildcard type
   * in some contexts.
   *
   * @param &lt;F&gt; The type constructor
   * @param &lt;X&gt; The original value type (existential)
   * @param &lt;A&gt; The current result type
   */
  record Impl&lt;F, X, A&gt;(Kind&lt;F, X&gt; fx, Function&lt;? super X, ? extends A&gt; transform)
      implements Coyoneda&lt;F, A&gt; {

    /**
     * Creates a new Impl with validation.
     *
     * @param fx The underlying value
     * @param transform The transformation function
     */
<span class="fc" id="L224">    public Impl {</span>
<span class="fc" id="L225">      requireNonNull(fx, &quot;Underlying Kind cannot be null&quot;);</span>
<span class="fc" id="L226">      requireNonNull(transform, &quot;Transform function cannot be null&quot;);</span>
<span class="fc" id="L227">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;B&gt; Coyoneda&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L232">      requireNonNull(f, &quot;Map function cannot be null&quot;);</span>
      // Compose the new function with the existing transformation
      // This achieves map fusion: multiple maps become one composed function
<span class="fc" id="L235">      Function&lt;X, B&gt; composed = ((Function&lt;X, A&gt;) transform).andThen((Function&lt;A, B&gt;) f);</span>
<span class="fc" id="L236">      return new Impl&lt;&gt;(fx, composed);</span>
    }

    @Override
    public Kind&lt;F, A&gt; lower(Functor&lt;F&gt; functor) {
<span class="fc" id="L241">      requireNonNull(functor, &quot;Functor cannot be null&quot;);</span>
      // Apply the accumulated transformation using the Functor
      // This is the only place where actual mapping happens
<span class="fc" id="L244">      return functor.map(transform, fx);</span>
    }

    @Override
    public Kind&lt;F, ?&gt; underlying() {
<span class="fc" id="L249">      return fx;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>