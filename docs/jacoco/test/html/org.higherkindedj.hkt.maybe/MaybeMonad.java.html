<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MaybeMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.maybe</a> &gt; <span class="el_source">MaybeMonad.java</span></div><h1>MaybeMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Monad and MonadError implementation for MaybeKind. The error type E is {@link Unit}, representing
 * the Nothing state. Provides Functor and Monad operations for the Maybe type within the HKT
 * Higher-Kinded-J.
 */
public class MaybeMonad extends MaybeFunctor
    implements MonadError&lt;MaybeKind.Witness, Unit&gt;, MonadZero&lt;MaybeKind.Witness&gt; {

  /** Singleton instance of {@code MaybeMonad}. */
<span class="fc" id="L26">  public static final MaybeMonad INSTANCE = new MaybeMonad();</span>

<span class="fc" id="L28">  private static final Class&lt;MaybeMonad&gt; MAYBE_MONAD_CLASS = MaybeMonad.class;</span>

  /** Private constructor to enforce the singleton pattern. */
  protected MaybeMonad() {
<span class="fc" id="L32">    super();</span>
<span class="fc" id="L33">  }</span>

  /**
   * Lifts a potentially null value into the Maybe context. If the value is null, creates Nothing;
   * otherwise creates Just(value).
   *
   * @param &lt;A&gt; The type of the value
   * @param value The value to lift, can be null
   * @return A Kind representing Just(value) if value is non-null, or Nothing if value is null
   */
  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; of(@Nullable A value) {
<span class="fc" id="L45">    return MAYBE.widen(Maybe.fromNullable(value));</span>
  }

  /**
   * Sequentially composes two Maybe computations. If the first computation succeeds (Just), applies
   * the function to the value. If the first computation fails (Nothing), propagates the Nothing.
   *
   * @param &lt;A&gt; The type of the value in the input Maybe
   * @param &lt;B&gt; The type of the value in the resulting Maybe
   * @param f The function to apply to the value if present. Must not be null.
   * @param ma The Maybe to transform. Must not be null.
   * @return The result of the computation chain
   * @throws NullPointerException if f or ma is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if ma cannot be unwrapped
   */
  @Override
  public &lt;A, B&gt; Kind&lt;MaybeKind.Witness, B&gt; flatMap(
      Function&lt;? super A, ? extends Kind&lt;MaybeKind.Witness, B&gt;&gt; f, Kind&lt;MaybeKind.Witness, A&gt; ma) {

<span class="fc" id="L64">    Validation.function().validateFlatMap(f, ma, MAYBE_MONAD_CLASS);</span>

<span class="fc" id="L66">    Maybe&lt;A&gt; maybeA = MAYBE.narrow(ma);</span>

<span class="fc" id="L68">    Maybe&lt;B&gt; resultMaybe =</span>
<span class="fc" id="L69">        maybeA.flatMap(</span>
            a -&gt; {
<span class="fc" id="L71">              Kind&lt;MaybeKind.Witness, B&gt; kindB = f.apply(a);</span>
<span class="fc" id="L72">              Validation.function()</span>
<span class="fc" id="L73">                  .requireNonNullResult(kindB, &quot;f&quot;, MAYBE_MONAD_CLASS, FLAT_MAP, Maybe.class);</span>
<span class="fc" id="L74">              return MAYBE.narrow(kindB);</span>
            });

<span class="fc" id="L77">    return MAYBE.widen(resultMaybe);</span>
  }

  /**
   * Applies a function wrapped in a Maybe to a value wrapped in a Maybe. If both are Just, applies
   * the function to the value. If either is Nothing, the result is Nothing.
   *
   * @param &lt;A&gt; The input type of the function
   * @param &lt;B&gt; The output type of the function
   * @param ff The Maybe containing the function. Must not be null.
   * @param fa The Maybe containing the value. Must not be null.
   * @return The result of applying the function if both are Just, otherwise Nothing
   * @throws NullPointerException if ff or fa is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if ff or fa cannot be unwrapped
   */
  @Override
  public &lt;A, B&gt; Kind&lt;MaybeKind.Witness, B&gt; ap(
      Kind&lt;MaybeKind.Witness, ? extends Function&lt;A, B&gt;&gt; ff, Kind&lt;MaybeKind.Witness, A&gt; fa) {

<span class="fc" id="L96">    Validation.kind().validateAp(ff, fa, MAYBE_MONAD_CLASS);</span>

<span class="fc" id="L98">    Maybe&lt;? extends Function&lt;A, B&gt;&gt; maybeF = MAYBE.narrow(ff);</span>
<span class="fc" id="L99">    Maybe&lt;A&gt; maybeA = MAYBE.narrow(fa);</span>

<span class="fc" id="L101">    Maybe&lt;B&gt; resultMaybe = maybeF.flatMap(maybeA::map);</span>
<span class="fc" id="L102">    return MAYBE.widen(resultMaybe);</span>
  }

  // --- MonadError Methods ---

  /**
   * Lifts the error state (Nothing) into the Maybe context. The input 'error' (Unit) is ignored,
   * but {@link Unit#INSTANCE} should be passed for consistency.
   *
   * @param &lt;A&gt; The phantom type parameter of the value
   * @param error The error value (Unit, typically {@link Unit#INSTANCE})
   * @return A Kind representing Nothing
   */
  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; raiseError(@Nullable Unit error) {
    // Note: For Unit error type, no validation needed - Unit is always valid
<span class="fc" id="L118">    return MAYBE.nothing();</span>
  }

  /**
   * Handles the error state (Nothing) within the Maybe context. If 'ma' is Just, it's returned
   * unchanged. If 'ma' is Nothing, the 'handler' function is applied with {@link Unit#INSTANCE}.
   *
   * @param &lt;A&gt; The type of the value within the Maybe
   * @param ma The Maybe to potentially recover from. Must not be null.
   * @param handler Function to handle the Nothing state. Must not be null.
   * @return Original Kind if Just, or result of handler if Nothing
   * @throws NullPointerException if ma or handler is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if ma cannot be unwrapped
   */
  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; handleErrorWith(
      Kind&lt;MaybeKind.Witness, A&gt; ma,
      Function&lt;? super Unit, ? extends Kind&lt;MaybeKind.Witness, A&gt;&gt; handler) {

<span class="fc" id="L137">    Validation.function().validateHandleErrorWith(ma, handler, MAYBE_MONAD_CLASS);</span>

<span class="fc" id="L139">    Maybe&lt;A&gt; maybe = MAYBE.narrow(ma);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (maybe.isNothing()) {</span>
<span class="fc" id="L142">      Kind&lt;MaybeKind.Witness, A&gt; result = handler.apply(Unit.INSTANCE);</span>
<span class="fc" id="L143">      Validation.function()</span>
<span class="fc" id="L144">          .requireNonNullResult(</span>
              result, &quot;handler&quot;, MAYBE_MONAD_CLASS, HANDLE_ERROR_WITH, Maybe.class);
<span class="fc" id="L146">      return result;</span>
    }

<span class="fc" id="L149">    return ma;</span>
  }

  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; recoverWith(
      final Kind&lt;MaybeKind.Witness, A&gt; ma, final Kind&lt;MaybeKind.Witness, A&gt; fallback) {

<span class="fc" id="L156">    Validation.kind().requireNonNull(ma, MAYBE_MONAD_CLASS, RECOVER_WITH, &quot;source&quot;);</span>
<span class="fc" id="L157">    Validation.kind().requireNonNull(fallback, MAYBE_MONAD_CLASS, RECOVER_WITH, &quot;fallback&quot;);</span>

<span class="fc" id="L159">    return handleErrorWith(ma, error -&gt; fallback);</span>
  }

  /**
   * Returns the zero element for the Maybe monad, which is {@code Nothing}. The result is
   * polymorphic and can be safely cast to any {@code Kind&lt;MaybeKind.Witness, T&gt;}.
   *
   * @param &lt;T&gt; The desired inner type of the zero value
   * @return The {@code Nothing} instance as a {@code Kind&lt;MaybeKind.Witness, T&gt;}
   */
  @Override
  public &lt;T&gt; Kind&lt;MaybeKind.Witness, T&gt; zero() {
<span class="fc" id="L171">    return MAYBE.nothing();</span>
  }

  // --- Alternative Methods ---

  /**
   * Combines two Maybe values, returning the first if it's Just, otherwise evaluating and returning
   * the second.
   *
   * &lt;p&gt;This implements the Alternative pattern for Maybe, providing a fallback mechanism. The
   * second argument is lazy (supplied via {@link java.util.function.Supplier}) to avoid unnecessary
   * computation when the first Maybe is Just.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Kind&lt;MaybeKind.Witness, String&gt; primary = MAYBE.just(&quot;value&quot;);
   * Kind&lt;MaybeKind.Witness, String&gt; fallback = () -&gt; MAYBE.just(&quot;default&quot;);
   *
   * Kind&lt;MaybeKind.Witness, String&gt; result = orElse(primary, fallback);
   * // result is Just(&quot;value&quot;)
   *
   * Kind&lt;MaybeKind.Witness, String&gt; result2 = orElse(MAYBE.nothing(), fallback);
   * // result2 is Just(&quot;default&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value within the Maybe
   * @param ma The first Maybe to try. Must not be null.
   * @param mb A {@link java.util.function.Supplier} providing the fallback Maybe. Must not be null.
   * @return The first Maybe if it's Just, otherwise the result of the supplier
   * @throws NullPointerException if ma or mb is null
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if ma cannot be unwrapped
   */
  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; orElse(
      Kind&lt;MaybeKind.Witness, A&gt; ma, Supplier&lt;Kind&lt;MaybeKind.Witness, A&gt;&gt; mb) {

<span class="fc" id="L208">    Validation.kind().requireNonNull(ma, MAYBE_MONAD_CLASS, OR_ELSE, &quot;first alternative&quot;);</span>
<span class="fc" id="L209">    Validation.function().requireFunction(mb, &quot;mb&quot;, MAYBE_MONAD_CLASS, OR_ELSE);</span>

<span class="fc" id="L211">    Maybe&lt;A&gt; maybeA = MAYBE.narrow(ma);</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">    if (maybeA.isJust()) {</span>
<span class="fc" id="L214">      return ma;</span>
    }

<span class="fc" id="L217">    Kind&lt;MaybeKind.Witness, A&gt; result = mb.get();</span>
<span class="fc" id="L218">    Validation.function()</span>
<span class="fc" id="L219">        .requireNonNullResult(result, &quot;mb&quot;, MAYBE_MONAD_CLASS, OR_ELSE, Maybe.class);</span>

<span class="fc" id="L221">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>