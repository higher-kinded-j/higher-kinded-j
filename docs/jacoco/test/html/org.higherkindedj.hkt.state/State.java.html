<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>State.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.state</a> &gt; <span class="el_source">State.java</span></div><h1>State.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.state;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Represents a stateful computation {@code S -&gt; (A, S)}. It wraps a function that takes an initial
 * state and returns a pair containing the computed value and the final state.
 *
 * @param &lt;S&gt; The type of the state. This type is expected to be non-null.
 * @param &lt;A&gt; The type of the computed value. This can be nullable.
 */
@FunctionalInterface
public interface State&lt;S, A&gt; {

<span class="fc" id="L22">  Class&lt;State&gt; STATE_CLASS = State.class;</span>

  /**
   * Runs the state computation with the given initial state.
   *
   * @param initialState The non-null initial state.
   * @return A non-null {@link StateTuple} containing the computed value and the final state.
   */
  StateTuple&lt;S, A&gt; run(S initialState);

  /**
   * Creates a {@code State} instance from a function that performs the state transition. The
   * provided function takes an initial state {@code S} and returns a {@link StateTuple} containing
   * the computed value {@code A} and the new state {@code S}.
   *
   * @param &lt;S&gt; The type of the state.
   * @param &lt;A&gt; The type of the computed value.
   * @param runFunction The non-null function representing the stateful computation, mapping an
   *     initial state to a {@link StateTuple}.
   * @return A non-null {@code State&lt;S, A&gt;} instance.
   * @throws NullPointerException if {@code runFunction} is null.
   */
  static &lt;S, A&gt; State&lt;S, A&gt; of(Function&lt;S, StateTuple&lt;S, A&gt;&gt; runFunction) {
<span class="fc" id="L45">    Validation.function().requireFunction(runFunction, &quot;runFunction&quot;, STATE_CLASS, OF);</span>
<span class="fc" id="L46">    return runFunction::apply;</span>
  }

  /**
   * Maps the result value of this stateful computation from type {@code A} to type {@code B}, while
   * preserving the state transition.
   *
   * &lt;p&gt;This operation is equivalent to:
   *
   * &lt;pre&gt;{@code
   * s -&gt; {
   * StateTuple&lt;S, A&gt; result = this.run(s);
   * return new StateTuple&lt;&gt;(f.apply(result.value()), result.state());
   * }
   * }&lt;/pre&gt;
   *
   * @param &lt;B&gt; The type of the new computed value.
   * @param f The non-null function to apply to the current computed value.
   * @return A new non-null {@code State&lt;S, B&gt;} instance with the mapped value and original state
   *     transition.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; State&lt;S, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L69">    Validation.function().requireMapper(f, &quot;f&quot;, STATE_CLASS, MAP);</span>
<span class="fc" id="L70">    return State.of(</span>
        initialState -&gt; {
<span class="fc" id="L72">          StateTuple&lt;S, A&gt; result = this.run(initialState);</span>
<span class="fc" id="L73">          B newValue = f.apply(result.value());</span>
<span class="fc" id="L74">          return new StateTuple&lt;&gt;(newValue, result.state());</span>
        });
  }

  /**
   * Composes this {@code State} computation with a function that takes the result of this
   * computation (type {@code A}) and returns a new {@code State&lt;S, B&gt;} computation. The state is
   * threaded through both computations.
   *
   * &lt;p&gt;This operation is equivalent to:
   *
   * &lt;pre&gt;{@code
   * s0 -&gt; {
   * StateTuple&lt;S, A&gt; result1 = this.run(s0); // (a, s1)
   * State&lt;S, ? extends B&gt; nextStateComputation = f.apply(result1.value());
   * return nextStateComputation.run(result1.state()); // (b, s2)
   * }
   * }&lt;/pre&gt;
   *
   * @param &lt;B&gt; The type of the computed value from the next state computation.
   * @param f The non-null function that takes the result of the current computation and returns the
   *     next {@code State} computation. This function must not return null.
   * @return A new non-null {@code State&lt;S, B&gt;} instance representing the composed computation.
   * @throws NullPointerException if {@code f} is null or if the {@code State} returned by {@code f}
   *     is null.
   */
  default &lt;B&gt; State&lt;S, B&gt; flatMap(Function&lt;? super A, ? extends State&lt;S, ? extends B&gt;&gt; f) {
<span class="fc" id="L101">    Validation.function().requireFlatMapper(f, &quot;f&quot;, STATE_CLASS, FLAT_MAP);</span>
<span class="fc" id="L102">    return State.of(</span>
        initialState -&gt; {
<span class="fc" id="L104">          StateTuple&lt;S, A&gt; result1 = this.run(initialState);</span>
<span class="fc" id="L105">          A valueA = result1.value();</span>
<span class="fc" id="L106">          S stateS1 = result1.state();</span>

<span class="fc" id="L108">          State&lt;S, ? extends B&gt; nextState = f.apply(valueA);</span>
<span class="fc" id="L109">          Validation.function()</span>
<span class="fc" id="L110">              .requireNonNullResult(nextState, &quot;f&quot;, STATE_CLASS, FLAT_MAP, STATE_CLASS);</span>

<span class="fc" id="L112">          StateTuple&lt;S, ? extends B&gt; finalResultTuple = nextState.run(stateS1);</span>

<span class="fc" id="L114">          B finalValue = (B) finalResultTuple.value();</span>
<span class="fc" id="L115">          S finalState = finalResultTuple.state();</span>

<span class="fc" id="L117">          return new StateTuple&lt;&gt;(finalValue, finalState);</span>
        });
  }

  // --- Static Helper Methods ---

  /**
   * Creates a {@code State} computation that returns the given value as its result and leaves the
   * state unchanged. This is the 'pure' or 'unit' operation for the State monad.
   *
   * &lt;p&gt;Equivalent to: {@code s -&gt; new StateTuple&lt;&gt;(value, s)}
   *
   * @param &lt;S&gt; The type of the state.
   * @param &lt;A&gt; The type of the value to lift into the State context.
   * @param value The value to be returned by the State computation. Can be {@code null}.
   * @return A non-null {@code State&lt;S, A&gt;} that always returns the given value and original state.
   */
  static &lt;S, A&gt; State&lt;S, A&gt; pure(@Nullable A value) {
<span class="fc" id="L135">    return State.of(s -&gt; new StateTuple&lt;&gt;(value, s));</span>
  }

  /**
   * Creates a {@code State} computation that returns the current state as its result and leaves the
   * state unchanged.
   *
   * &lt;p&gt;Equivalent to: {@code s -&gt; new StateTuple&lt;&gt;(s, s)}
   *
   * @param &lt;S&gt; The type of the state.
   * @return A non-null {@code State&lt;S, S&gt;} that returns the current state as its value.
   */
  static &lt;S&gt; State&lt;S, S&gt; get() {
<span class="fc" id="L148">    return State.of(s -&gt; new StateTuple&lt;&gt;(s, s));</span>
  }

  /**
   * Creates a {@code State} computation that replaces the current state with the given new state
   * and returns {@link Unit#INSTANCE}.
   *
   * &lt;p&gt;Equivalent to: {@code s -&gt; new StateTuple&lt;&gt;(Unit.INSTANCE, newState)}
   *
   * @param &lt;S&gt; The type of the state.
   * @param newState The non-null new state to set.
   * @return A non-null {@code State&lt;S, Unit&gt;} that sets the state and returns {@link
   *     Unit#INSTANCE}.
   * @throws NullPointerException if {@code newState} is null.
   */
  static &lt;S&gt; State&lt;S, Unit&gt; set(S newState) {
<span class="fc" id="L164">    Validation.coreType().requireValue(newState, &quot;newState&quot;, STATE_CLASS, SET);</span>
    // The old state `s` is ignored here, as `newState` replaces it.
<span class="fc" id="L166">    return State.of(s -&gt; new StateTuple&lt;&gt;(Unit.INSTANCE, newState));</span>
  }

  /**
   * Creates a {@code State} computation that modifies the current state using the given function
   * and returns {@link Unit#INSTANCE}.
   *
   * &lt;p&gt;Equivalent to: {@code s -&gt; new StateTuple&lt;&gt;(Unit.INSTANCE, f.apply(s))}
   *
   * @param &lt;S&gt; The type of the state.
   * @param f The non-null function to apply to the current state to produce the new state. This
   *     function must return a non-null state.
   * @return A non-null {@code State&lt;S, Unit&gt;} that modifies the state and returns {@link
   *     Unit#INSTANCE}.
   * @throws NullPointerException if {@code f} is null.
   */
  static &lt;S&gt; State&lt;S, Unit&gt; modify(Function&lt;S, S&gt; f) {
<span class="fc" id="L183">    Validation.function().requireFunction(f, &quot;f&quot;, STATE_CLASS, MODIFY);</span>
<span class="fc" id="L184">    return State.of(s -&gt; new StateTuple&lt;&gt;(Unit.INSTANCE, f.apply(s)));</span>
  }

  /**
   * Creates a {@code State} computation that inspects the current state using a function, returns
   * the result of that function as its value, and leaves the state unchanged.
   *
   * &lt;p&gt;Equivalent to: {@code s -&gt; new StateTuple&lt;&gt;(f.apply(s), s)}
   *
   * @param &lt;S&gt; The type of the state.
   * @param &lt;A&gt; The type of the value returned by the inspection function.
   * @param f The non-null function to apply to the current state to produce a value. This function
   *     can return a {@code null} value if {@code A} is nullable.
   * @return A non-null {@code State&lt;S, A&gt;} that returns the result of inspecting the state.
   * @throws NullPointerException if {@code f} is null.
   */
  static &lt;S, A&gt; State&lt;S, A&gt; inspect(Function&lt;S, @Nullable A&gt; f) {
<span class="fc" id="L201">    Validation.function().requireFunction(f, &quot;f&quot;, STATE_CLASS, INSPECT);</span>
<span class="fc" id="L202">    return State.of(s -&gt; new StateTuple&lt;&gt;(f.apply(s), s));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>