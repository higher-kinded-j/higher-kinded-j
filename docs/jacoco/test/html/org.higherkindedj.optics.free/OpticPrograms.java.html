<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpticPrograms.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.free</a> &gt; <span class="el_source">OpticPrograms.java</span></div><h1>OpticPrograms.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.free;

import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.constant.Const;
import org.higherkindedj.hkt.constant.ConstApplicative;
import org.higherkindedj.hkt.constant.ConstKind;
import org.higherkindedj.hkt.constant.ConstKindHelper;
import org.higherkindedj.hkt.free.Free;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Getter;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.jspecify.annotations.NullMarked;

/**
 * DSL for building optic programs using the Free monad.
 *
 * &lt;p&gt;This class provides methods to construct optic operations as Free monad programs that can be
 * interpreted in different ways:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Direct execution&lt;/b&gt; - Normal optic operations
 *   &lt;li&gt;&lt;b&gt;Logging&lt;/b&gt; - Record all operations for audit trails
 *   &lt;li&gt;&lt;b&gt;Validation&lt;/b&gt; - Check constraints before executing
 *   &lt;li&gt;&lt;b&gt;Optimization&lt;/b&gt; - Fuse multiple operations for efficiency
 *   &lt;li&gt;&lt;b&gt;Testing&lt;/b&gt; - Mock operations without real data
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Build a program
 * Free&lt;OpticOpKind.Witness, Person&gt; program =
 *     OpticPrograms.get(person, PersonLenses.age())
 *         .flatMap(age -&gt; {
 *             if (age &lt; 18) {
 *                 return Free.pure(person);
 *             } else {
 *                 return OpticPrograms.modify(person, PersonLenses.age(), a -&gt; a + 1)
 *                     .flatMap(p1 -&gt;
 *                         OpticPrograms.set(p1, PersonLenses.status(), &quot;ADULT&quot;));
 *             }
 *         });
 *
 * // Interpret it
 * Person result = OpticInterpreters.direct().run(program);
 *
 * // Or log it
 * LoggingInterpreter logger = OpticInterpreters.logging();
 * Person result = logger.run(program);
 * logger.getLog().forEach(System.out::println);
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;When to Use&lt;/h2&gt;
 *
 * &lt;p&gt;Use the Free monad DSL when you need:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Complex multi-step optic workflows
 *   &lt;li&gt;Audit trails of what changed
 *   &lt;li&gt;Validation before modification
 *   &lt;li&gt;Performance optimization (batch/fuse operations)
 *   &lt;li&gt;Multiple execution strategies
 * &lt;/ul&gt;
 *
 * &lt;p&gt;For simple operations, use {@link org.higherkindedj.optics.fluent.OpticOps} instead.
 */
@NullMarked
public final class OpticPrograms {

<span class="fc" id="L78">  private OpticPrograms() {</span>
<span class="fc" id="L79">    throw new UnsupportedOperationException(&quot;Utility class&quot;);</span>
  }

  /**
   * Lifts an optic operation into the Free monad.
   *
   * @param op The operation to lift
   * @param &lt;A&gt; The result type
   * @return A Free monad program
   */
  private static &lt;A&gt; Free&lt;OpticOpKind.Witness, A&gt; liftOp(OpticOp&lt;?, A&gt; op) {
<span class="fc" id="L90">    Kind&lt;OpticOpKind.Witness, A&gt; kindOp = OpticOpKindHelper.OP.widen(op);</span>
<span class="fc" id="L91">    return Free.liftF(kindOp, OpticOpFunctor.INSTANCE);</span>
  }

  /**
   * Converts a Lens to a Getter.
   *
   * @param lens The lens to convert
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Getter that represents the lens
   */
  private static &lt;S, A&gt; Getter&lt;S, A&gt; lensToGetter(Lens&lt;S, A&gt; lens) {
<span class="fc" id="L103">    return lens::get;</span>
  }

  /**
   * Converts a Traversal to a Fold by running it with the Id monad.
   *
   * @param traversal The traversal to convert
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Fold that represents the traversal
   */
  private static &lt;S, A&gt; Fold&lt;S, A&gt; traversalToFold(Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L115">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
        // Use the Const applicative to fold over the traversal efficiently
        // This is the standard functional programming approach that avoids side effects
<span class="fc" id="L120">        ConstApplicative&lt;M&gt; constApp = new ConstApplicative&lt;&gt;(monoid);</span>

        // Apply the traversal with the Const applicative
        // The traversal will accumulate values using the monoid whilst traversing
<span class="fc" id="L124">        Kind&lt;ConstKind.Witness&lt;M&gt;, S&gt; result =</span>
<span class="fc" id="L125">            traversal.modifyF(</span>
<span class="fc" id="L126">                a -&gt; ConstKindHelper.CONST.widen(new Const&lt;&gt;(f.apply(a))), source, constApp);</span>

        // Extract the accumulated result from the Const
<span class="fc" id="L129">        Const&lt;M, S&gt; finalConst = ConstKindHelper.CONST.narrow(result);</span>
<span class="fc" id="L130">        return finalConst.value();</span>
      }
    };
  }

  // ============================================================================
  // Get Operations
  // ============================================================================

  /**
   * Creates a program that gets a value through a {@link Getter} or {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, String&gt; program =
   *     OpticPrograms.get(person, PersonLenses.name());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param getter The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the focused value
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, A&gt; get(S source, Getter&lt;S, A&gt; getter) {
<span class="fc" id="L156">    return liftOp(new OpticOp.Get&lt;&gt;(source, getter));</span>
  }

  /**
   * Creates a program that gets a value through a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, String&gt; program =
   *     OpticPrograms.get(person, PersonLenses.name());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the focused value
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, A&gt; get(S source, Lens&lt;S, A&gt; lens) {
<span class="fc" id="L176">    return liftOp(new OpticOp.Get&lt;&gt;(source, lensToGetter(lens)));</span>
  }

  /**
   * Creates a program that gets the first value through a {@link Fold}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Optional&lt;Address&gt;&gt; program =
   *     OpticPrograms.preview(person, addressPrism);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns an Optional of the first focused value
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Optional&lt;A&gt;&gt; preview(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L196">    return liftOp(new OpticOp.Preview&lt;&gt;(source, fold));</span>
  }

  /**
   * Creates a program that gets the first value through a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Optional&lt;Person&gt;&gt; program =
   *     OpticPrograms.preview(team, playerTraversal);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns an Optional of the first focused value
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Optional&lt;A&gt;&gt; preview(
      S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L217">    return liftOp(new OpticOp.Preview&lt;&gt;(source, traversalToFold(traversal)));</span>
  }

  /**
   * Creates a program that gets all values through a {@link Fold} or {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, List&lt;String&gt;&gt; program =
   *     OpticPrograms.getAll(team, TeamTraversals.playerNames());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns a list of all focused values
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, List&lt;A&gt;&gt; getAll(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L237">    return liftOp(new OpticOp.GetAll&lt;&gt;(source, fold));</span>
  }

  /**
   * Creates a program that gets all values through a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, List&lt;String&gt;&gt; program =
   *     OpticPrograms.getAll(team, TeamTraversals.playerNames());
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns a list of all focused values
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, List&lt;A&gt;&gt; getAll(
      S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L258">    return liftOp(new OpticOp.GetAll&lt;&gt;(source, traversalToFold(traversal)));</span>
  }

  // ============================================================================
  // Set Operations
  // ============================================================================

  /**
   * Creates a program that sets a value through a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Person&gt; program =
   *     OpticPrograms.set(person, PersonLenses.age(), 30);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param value The new value to set
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the updated structure
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, S&gt; set(S source, Lens&lt;S, A&gt; lens, A value) {
<span class="fc" id="L283">    return liftOp(new OpticOp.Set&lt;&gt;(source, lens, value));</span>
  }

  /**
   * Creates a program that sets all values through a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Team&gt; program =
   *     OpticPrograms.setAll(team, playerScores, 100);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param value The new value to set for all focused elements
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the updated structure
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, S&gt; setAll(
      S source, Traversal&lt;S, A&gt; traversal, A value) {
<span class="fc" id="L305">    return liftOp(new OpticOp.SetAll&lt;&gt;(source, traversal, value));</span>
  }

  // ============================================================================
  // Modify Operations
  // ============================================================================

  /**
   * Creates a program that modifies a value through a {@link Lens}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Person&gt; program =
   *     OpticPrograms.modify(person, PersonLenses.age(), age -&gt; age + 1);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param lens The lens to focus with
   * @param modifier The function to transform the focused value
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the updated structure
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, S&gt; modify(
      S source, Lens&lt;S, A&gt; lens, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L331">    return liftOp(new OpticOp.Modify&lt;&gt;(source, lens, modifier));</span>
  }

  /**
   * Creates a program that modifies all values through a {@link Traversal}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Team&gt; program =
   *     OpticPrograms.modifyAll(team, playerScores, score -&gt; score + 10);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param modifier The function to transform each focused value
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the updated structure
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, S&gt; modifyAll(
      S source, Traversal&lt;S, A&gt; traversal, Function&lt;A, A&gt; modifier) {
<span class="fc" id="L353">    return liftOp(new OpticOp.ModifyAll&lt;&gt;(source, traversal, modifier));</span>
  }

  // ============================================================================
  // Query Operations
  // ============================================================================

  /**
   * Creates a program that checks if any focused element matches a predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Boolean&gt; program =
   *     OpticPrograms.exists(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns true if any element matches
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Boolean&gt; exists(
      S source, Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L379">    return liftOp(new OpticOp.Exists&lt;&gt;(source, fold, predicate));</span>
  }

  /**
   * Creates a program that checks if any focused element matches a predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Boolean&gt; program =
   *     OpticPrograms.exists(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns true if any element matches
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Boolean&gt; exists(
      S source, Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L401">    return liftOp(new OpticOp.Exists&lt;&gt;(source, traversalToFold(traversal), predicate));</span>
  }

  /**
   * Creates a program that checks if all focused elements match a predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Boolean&gt; program =
   *     OpticPrograms.all(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns true if all elements match
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Boolean&gt; all(
      S source, Fold&lt;S, A&gt; fold, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L423">    return liftOp(new OpticOp.All&lt;&gt;(source, fold, predicate));</span>
  }

  /**
   * Creates a program that checks if all focused elements match a predicate.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Boolean&gt; program =
   *     OpticPrograms.all(team, playerAges, age -&gt; age &gt;= 18);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param predicate The predicate to test
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns true if all elements match
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Boolean&gt; all(
      S source, Traversal&lt;S, A&gt; traversal, Predicate&lt;A&gt; predicate) {
<span class="fc" id="L445">    return liftOp(new OpticOp.All&lt;&gt;(source, traversalToFold(traversal), predicate));</span>
  }

  /**
   * Creates a program that counts the number of focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Integer&gt; program =
   *     OpticPrograms.count(team, players);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param fold The optic to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the count
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Integer&gt; count(S source, Fold&lt;S, A&gt; fold) {
<span class="fc" id="L465">    return liftOp(new OpticOp.Count&lt;&gt;(source, fold));</span>
  }

  /**
   * Creates a program that counts the number of focused elements.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Free&lt;OpticOpKind.Witness, Integer&gt; program =
   *     OpticPrograms.count(team, players);
   * }&lt;/pre&gt;
   *
   * @param source The source structure
   * @param traversal The traversal to focus with
   * @param &lt;S&gt; The source type
   * @param &lt;A&gt; The focused value type
   * @return A Free monad program that returns the count
   */
  public static &lt;S, A&gt; Free&lt;OpticOpKind.Witness, Integer&gt; count(
      S source, Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L486">    return liftOp(new OpticOp.Count&lt;&gt;(source, traversalToFold(traversal)));</span>
  }

  // ============================================================================
  // Utility Methods
  // ============================================================================

  /**
   * Creates a program that returns a pure value (no optic operation).
   *
   * &lt;p&gt;Useful for conditional logic in programs.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * OpticPrograms.get(person, PersonLenses.age())
   *     .flatMap(age -&gt; {
   *         if (age &lt; 18) {
   *             return OpticPrograms.pure(person);  // No changes
   *         } else {
   *             return OpticPrograms.set(person, statusLens, &quot;ADULT&quot;);
   *         }
   *     });
   * }&lt;/pre&gt;
   *
   * @param value The value to return
   * @param &lt;A&gt; The value type
   * @return A Free monad program that returns the value
   */
  public static &lt;A&gt; Free&lt;OpticOpKind.Witness, A&gt; pure(A value) {
<span class="fc" id="L516">    return Free.pure(value);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>