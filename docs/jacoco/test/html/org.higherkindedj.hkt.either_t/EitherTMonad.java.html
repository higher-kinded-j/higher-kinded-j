<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EitherTMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.either_t</a> &gt; <span class="el_source">EitherTMonad.java</span></div><h1>EitherTMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.either_t;

import static org.higherkindedj.hkt.either_t.EitherTKindHelper.EITHER_T;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Implements the {@link MonadError} interface for the {@link EitherT} monad transformer. The HKT
 * witness used is {@code EitherTKind.Witness&lt;F, L&gt;}.
 *
 * &lt;p&gt;This class requires a {@link Monad} instance for the outer monad {@code F}. The 'left' type
 * {@code L} of the inner {@link Either} serves as the error type {@code E} for this {@code
 * MonadError} instance.
 *
 * @param &lt;F&gt; The witness type of the outer monad (e.g., {@code OptionalKind.Witness}).
 * @param &lt;L&gt; The type of the 'left' (error) value in the inner {@link Either}. This is fixed for a
 *     given instance of {@code EitherTMonad}.
 * @see EitherT
 * @see EitherTKind
 * @see EitherTKind.Witness
 * @see MonadError
 * @see EitherTKindHelper
 */
public class EitherTMonad&lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, L&gt;
    implements MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt; {

<span class="fc" id="L38">  private static final Class&lt;EitherTMonad&gt; EITHER_T_MONAD_CLASS = EitherTMonad.class;</span>
  private final Monad&lt;F&gt; outerMonad;

  /**
   * Constructs an {@code EitherTMonad} instance.
   *
   * @param outerMonad The {@link Monad} instance for the outer monad {@code F}. Must not be null.
   * @throws NullPointerException if {@code outerMonad} is null.
   */
<span class="fc" id="L47">  public EitherTMonad(Monad&lt;F&gt; outerMonad) {</span>
<span class="fc" id="L48">    this.outerMonad =</span>
<span class="fc" id="L49">        Validation.transformer().requireOuterMonad(outerMonad, EITHER_T_MONAD_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L50">  }</span>

  /**
   * Lifts a 'right' value {@code r} into the {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;} context.
   * This results in an {@code EitherT} wrapping {@code F&lt;Right(r)&gt;}.
   *
   * @param &lt;R&gt; The type of the 'right' value.
   * @param r The 'right' value to lift. Can be null if {@code R} is nullable.
   * @return A {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;} representing the lifted 'right' value.
   *     Never null.
   */
  @Override
  public &lt;R&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt; of(@Nullable R r) {
<span class="fc" id="L63">    EitherT&lt;F, L, R&gt; concreteEitherT = EitherT.right(outerMonad, r);</span>
<span class="fc" id="L64">    return EITHER_T.widen(concreteEitherT);</span>
  }

  /**
   * Maps a function {@code f} over the 'right' value within a {@code Kind&lt;EitherTKind.Witness&lt;F,
   * L&gt;, R_IN&gt;}. The transformation occurs within the context of the outer monad {@code F} and the
   * inner {@link Either}.
   *
   * @param &lt;R_IN&gt; The original type of the 'right' value.
   * @param &lt;R_OUT&gt; The new type of the 'right' value after applying the function.
   * @param f The function to apply to the 'right' value. Must not be null.
   * @param fa The {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt;} to map over. Must not be null.
   * @return A new {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt;} with the function applied. Never
   *     null.
   * @throws NullPointerException if {@code f} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fa} cannot be unwrapped.
   */
  @Override
  public &lt;R_IN, R_OUT&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt; map(
      Function&lt;? super R_IN, ? extends R_OUT&gt; f, Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt; fa) {

<span class="fc" id="L85">    Validation.function().requireMapper(f, &quot;f&quot;, EITHER_T_MONAD_CLASS, MAP);</span>
<span class="fc" id="L86">    Validation.kind().requireNonNull(fa, EITHER_T_MONAD_CLASS, MAP);</span>

<span class="fc" id="L88">    EitherT&lt;F, L, R_IN&gt; eitherT = EITHER_T.narrow(fa);</span>
<span class="fc" id="L89">    Kind&lt;F, Either&lt;L, R_OUT&gt;&gt; newValue = outerMonad.map(either -&gt; either.map(f), eitherT.value());</span>
<span class="fc" id="L90">    return EITHER_T.widen(EitherT.fromKind(newValue));</span>
  }

  /**
   * Applies a function wrapped in {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, Function&lt;R_IN, R_OUT&gt;&gt;} to
   * a 'right' value wrapped in {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt;}. This operation
   * respects both the outer monad {@code F} and the inner {@link Either}'s error handling.
   *
   * @param &lt;R_IN&gt; The type of the input 'right' value.
   * @param &lt;R_OUT&gt; The type of the result 'right' value.
   * @param ff The wrapped function. Must not be null.
   * @param fa The wrapped 'right' value. Must not be null.
   * @return A new {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt;} representing the application.
   *     Never null.
   * @throws NullPointerException if {@code ff} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ff} or {@code fa} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;R_IN, R_OUT&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt; ap(
      Kind&lt;EitherTKind.Witness&lt;F, L&gt;, ? extends Function&lt;R_IN, R_OUT&gt;&gt; ff,
      Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt; fa) {

<span class="fc" id="L113">    Validation.kind().requireNonNull(ff, EITHER_T_MONAD_CLASS, AP, &quot;function&quot;);</span>
<span class="fc" id="L114">    Validation.kind().requireNonNull(fa, EITHER_T_MONAD_CLASS, AP, &quot;argument&quot;);</span>

<span class="fc" id="L116">    EitherT&lt;F, L, ? extends Function&lt;R_IN, R_OUT&gt;&gt; funcT = EITHER_T.narrow(ff);</span>
<span class="fc" id="L117">    EitherT&lt;F, L, R_IN&gt; valT = EITHER_T.narrow(fa);</span>

<span class="fc" id="L119">    Kind&lt;F, Either&lt;L, R_OUT&gt;&gt; resultValue =</span>
<span class="fc" id="L120">        outerMonad.flatMap(</span>
            eitherF -&gt;
<span class="fc" id="L122">                outerMonad.map(</span>
                    eitherA -&gt;
<span class="fc" id="L124">                        eitherF.flatMap(eitherA::map), // Applies func if both Eithers are Right</span>
<span class="fc" id="L125">                    valT.value()),</span>
<span class="fc" id="L126">            funcT.value());</span>

<span class="fc" id="L128">    return EITHER_T.widen(EitherT.fromKind(resultValue));</span>
  }

  /**
   * Applies a function {@code f} that returns a {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt;} to
   * the 'right' value within a {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt;}, and flattens the
   * result. This is the core monadic bind operation, sequencing computations within {@code
   * EitherT}.
   *
   * @param &lt;R_IN&gt; The original type of the 'right' value.
   * @param &lt;R_OUT&gt; The type of the 'right' value in the resulting {@code Kind}.
   * @param f The function to apply, returning a new {@code Kind}. Must not be null.
   * @param ma The {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt;} to transform. Must not be null.
   * @return A new {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt;}. Never null.
   * @throws NullPointerException if {@code f} or {@code ma} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} or the result of
   *     {@code f} cannot be unwrapped.
   */
  @Override
  public &lt;R_IN, R_OUT&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt; flatMap(
      Function&lt;? super R_IN, ? extends Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt;&gt; f,
      Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_IN&gt; ma) {

<span class="fc" id="L151">    Validation.function().requireFlatMapper(f, &quot;f&quot;, EITHER_T_MONAD_CLASS, FLAT_MAP);</span>
<span class="fc" id="L152">    Validation.kind().requireNonNull(ma, EITHER_T_MONAD_CLASS, FLAT_MAP);</span>

<span class="fc" id="L154">    EitherT&lt;F, L, R_IN&gt; eitherT_ma = EITHER_T.narrow(ma);</span>

<span class="fc" id="L156">    Kind&lt;F, Either&lt;L, R_OUT&gt;&gt; newUnderlyingValue =</span>
<span class="fc" id="L157">        outerMonad.flatMap(</span>
            (Either&lt;L, R_IN&gt; innerEither) -&gt; {
<span class="fc bfc" id="L159" title="All 2 branches covered.">              if (innerEither.isRight()) {</span>
<span class="fc" id="L160">                R_IN r_in = innerEither.getRight();</span>
<span class="fc" id="L161">                Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R_OUT&gt; resultKindT = f.apply(r_in);</span>
<span class="fc" id="L162">                Validation.function()</span>
<span class="fc" id="L163">                    .requireNonNullResult(resultKindT, &quot;f&quot;, EITHER_T_MONAD_CLASS, FLAT_MAP);</span>
<span class="fc" id="L164">                EitherT&lt;F, L, R_OUT&gt; resultT = EITHER_T.narrow(resultKindT);</span>
<span class="fc" id="L165">                return resultT.value(); // This is Kind&lt;F, Either&lt;L, R_OUT&gt;&gt;</span>
              } else {
                // Propagate the Left by lifting it into F
<span class="fc" id="L168">                return outerMonad.of(Either.left(innerEither.getLeft()));</span>
              }
            },
<span class="fc" id="L171">            eitherT_ma.value() // This is Kind&lt;F, Either&lt;L, R_IN&gt;&gt;</span>
            );
<span class="fc" id="L173">    return EITHER_T.widen(EitherT.fromKind(newUnderlyingValue));</span>
  }

  // --- MonadError Methods ---

  /**
   * Raises an error in the {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;} context. For {@code EitherT},
   * an error is represented by a 'left' value of type {@code L}. This method returns an {@code
   * EitherT} wrapping {@code F&lt;Left(error)&gt;}.
   *
   * @param &lt;R&gt; The type parameter for the 'right' side (will be absent).
   * @param error The 'left' (error) value. Can be null if {@code L} is nullable.
   * @return A {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;} representing {@code F&lt;Left(error)&gt;}. Never
   *     null.
   */
  @Override
  public &lt;R&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt; raiseError(@Nullable L error) {
    // Either allows null error values - no validation needed
<span class="fc" id="L191">    EitherT&lt;F, L, R&gt; concreteEitherT = EitherT.left(outerMonad, error);</span>
<span class="fc" id="L192">    return EITHER_T.widen(concreteEitherT);</span>
  }

  /**
   * Handles an error (a 'left' value) in the {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;}. If the
   * input {@code ma} represents {@code F&lt;Right(r)&gt;}, it's returned unchanged. If it represents
   * {@code F&lt;Left(l)&gt;}, the {@code handler} function is applied to {@code l}, and its result
   * (another {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;}) is returned. This operation is performed
   * within the context of the outer monad {@code F}.
   *
   * @param &lt;R&gt; The type of the 'right' value.
   * @param ma The {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;} to handle. Must not be null.
   * @param handler The function to apply if {@code ma} represents {@code F&lt;Left(l)&gt;}. Must not be
   *     null.
   * @return A {@code Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;}, either the original or the result of the
   *     handler. Never null.
   * @throws NullPointerException if {@code ma} or {@code handler} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} or the result of
   *     {@code handler} cannot be unwrapped.
   */
  @Override
  public &lt;R&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt; handleErrorWith(
      Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt; ma,
      Function&lt;? super L, ? extends Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt;&gt; handler) {

<span class="fc" id="L217">    Validation.kind().requireNonNull(ma, EITHER_T_MONAD_CLASS, HANDLE_ERROR_WITH, &quot;source&quot;);</span>
<span class="fc" id="L218">    Validation.function()</span>
<span class="fc" id="L219">        .requireFunction(handler, &quot;handler&quot;, EITHER_T_MONAD_CLASS, HANDLE_ERROR_WITH);</span>

<span class="fc" id="L221">    EitherT&lt;F, L, R&gt; eitherT_ma = EITHER_T.narrow(ma);</span>

<span class="fc" id="L223">    Kind&lt;F, Either&lt;L, R&gt;&gt; newUnderlyingValue =</span>
<span class="fc" id="L224">        outerMonad.flatMap(</span>
            (Either&lt;L, R&gt; innerEither) -&gt; {
<span class="fc bfc" id="L226" title="All 2 branches covered.">              if (innerEither.isRight()) {</span>
<span class="fc" id="L227">                return outerMonad.of(innerEither); // It's Right, re-wrap in F</span>
              } else {
<span class="fc" id="L229">                L leftVal = innerEither.getLeft();</span>
<span class="fc" id="L230">                Kind&lt;EitherTKind.Witness&lt;F, L&gt;, R&gt; resultKindT = handler.apply(leftVal);</span>
<span class="fc" id="L231">                Validation.function()</span>
<span class="fc" id="L232">                    .requireNonNullResult(</span>
                        resultKindT, &quot;handler&quot;, EitherT.class, HANDLE_ERROR_WITH, Kind.class);
<span class="fc" id="L234">                EitherT&lt;F, L, R&gt; resultT = EITHER_T.narrow(resultKindT);</span>
<span class="fc" id="L235">                return resultT.value(); // This is Kind&lt;F, Either&lt;L, R&gt;&gt;</span>
              }
            },
<span class="fc" id="L238">            eitherT_ma.value() // This is Kind&lt;F, Either&lt;L, R&gt;&gt;</span>
            );
<span class="fc" id="L240">    return EITHER_T.widen(EitherT.fromKind(newUnderlyingValue));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>