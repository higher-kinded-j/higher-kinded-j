<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StateT.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.state_t</a> &gt; <span class="el_source">StateT.java</span></div><h1>StateT.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.state_t;

import static org.higherkindedj.hkt.util.validation.Operation.CONSTRUCTION;

import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.state.StateTuple;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Represents the StateT monad transformer as a Java record. It allows composing stateful
 * computations within another monad F.
 *
 * &lt;p&gt;A StateT computation is essentially a function that takes an initial state `S` and returns a
 * computation in the underlying monad `F` which yields a pair of the resulting value `A` and the
 * final state `S`.
 *
 * @param &lt;S&gt; The type of the state.
 * @param &lt;F&gt; The higher-kinded type witness for the underlying monad.
 * @param &lt;A&gt; The type of the value produced by the computation.
 * @param runStateTFn The function defining the stateful computation. This function takes an initial
 *     state and returns a {@code Kind&lt;F, StateTuple&lt;S, A&gt;&gt;}.
 * @param monadF The {@link Monad} instance for the underlying monad {@code F}, used to sequence
 *     operations within that monad.
 */
public record StateT&lt;S, F, A&gt;(Function&lt;S, Kind&lt;F, StateTuple&lt;S, A&gt;&gt;&gt; runStateTFn, Monad&lt;F&gt; monadF)
    implements StateTKind&lt;S, F, A&gt; {

<span class="fc" id="L32">  private static final Class&lt;StateT&gt; STATE_T_CLASS = StateT.class;</span>

  /**
   * Canonical constructor for {@code StateT}.
   *
   * @param runStateTFn The function defining the stateful computation. Must not be null.
   * @param monadF The Monad instance for the underlying monad F. Must not be null.
   * @throws NullPointerException if runStateTFn or monadF is null.
   */
<span class="fc" id="L41">  public StateT {</span>
<span class="fc" id="L42">    Validation.function().requireFunction(runStateTFn, &quot;runStateTFn&quot;, STATE_T_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L43">    Validation.transformer().requireOuterMonad(monadF, STATE_T_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L44">  }</span>

  /**
   * Factory method to create a StateT instance. This delegates to the record's canonical
   * constructor.
   *
   * @param runStateTFn The function defining the stateful computation.
   * @param monadF The Monad instance for the underlying monad F.
   * @param &lt;S&gt; The state type.
   * @param &lt;F&gt; The higher-kinded type witness for F.
   * @param &lt;A&gt; The value type.
   * @return A new StateT instance.
   * @throws NullPointerException if {@code runStateTFn} or {@code monadF} is null.
   */
  public static &lt;S, F, A&gt; StateT&lt;S, F, A&gt; create(
      Function&lt;S, Kind&lt;F, StateTuple&lt;S, A&gt;&gt;&gt; runStateTFn, Monad&lt;F&gt; monadF) {
<span class="fc" id="L60">    return new StateT&lt;&gt;(runStateTFn, monadF);</span>
  }

  /**
   * Runs the stateful computation with an initial state.
   *
   * @param initialState The initial state.
   * @return The result of the computation within the underlying monad F, containing the final value
   *     and state.
   */
  public Kind&lt;F, StateTuple&lt;S, A&gt;&gt; runStateT(S initialState) {
<span class="fc" id="L71">    return this.runStateTFn.apply(initialState);</span>
  }

  /**
   * Runs the stateful computation and extracts only the final value, discarding the state.
   *
   * @param initialState The initial state.
   * @return The final value within the underlying monad F.
   */
  public Kind&lt;F, A&gt; evalStateT(S initialState) {
<span class="fc" id="L81">    return this.monadF.map(StateTuple::value, runStateT(initialState));</span>
  }

  /**
   * Runs the stateful computation and extracts only the final state, discarding the value.
   *
   * @param initialState The initial state.
   * @return The final state within the underlying monad F.
   */
  public Kind&lt;F, S&gt; execStateT(S initialState) {
<span class="fc" id="L91">    return this.monadF.map(StateTuple::state, runStateT(initialState));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>