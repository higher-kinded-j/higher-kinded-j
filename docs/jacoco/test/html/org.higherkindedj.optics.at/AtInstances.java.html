<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AtInstances.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.at</a> &gt; <span class="el_source">AtInstances.java</span></div><h1>AtInstances.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.at;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.higherkindedj.optics.At;
import org.higherkindedj.optics.Lens;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

/**
 * Provides standard {@link At} instances for common Java collection types.
 *
 * &lt;p&gt;This class contains factory methods that create {@code At} instances for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Map} - indexed by key type {@code K}
 *   &lt;li&gt;{@link List} - indexed by {@link Integer} position
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Usage Examples:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Map operations
 * At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();
 * Map&lt;String, Integer&gt; scores = Map.of(&quot;alice&quot;, 100);
 *
 * // Insert/update
 * Map&lt;String, Integer&gt; updated = mapAt.insertOrUpdate(&quot;bob&quot;, 85, scores);
 *
 * // Remove
 * Map&lt;String, Integer&gt; removed = mapAt.remove(&quot;alice&quot;, updated);
 *
 * // List operations
 * At&lt;List&lt;String&gt;, Integer, String&gt; listAt = AtInstances.listAt();
 * List&lt;String&gt; names = new ArrayList&lt;&gt;(List.of(&quot;alice&quot;, &quot;bob&quot;, &quot;charlie&quot;));
 *
 * // Get element
 * Optional&lt;String&gt; second = listAt.get(1, names);  // Optional[&quot;bob&quot;]
 *
 * // Remove element (shifts indices)
 * List&lt;String&gt; afterRemove = listAt.remove(1, names);  // [&quot;alice&quot;, &quot;charlie&quot;]
 * }&lt;/pre&gt;
 */
@NullMarked
public final class AtInstances {

  /** Private constructor to prevent instantiation. */
  private AtInstances() {}

  /**
   * Creates an {@link At} instance for {@link Map} types.
   *
   * &lt;p&gt;The returned {@code At} provides a lens to the optional presence of a value at a given key:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code get(key)} returns {@code Optional.empty()} if key is absent or has null value
   *   &lt;li&gt;{@code get(key)} returns {@code Optional.of(value)} if key is present with non-null value
   *   &lt;li&gt;{@code set(Optional.empty())} removes the key from the map
   *   &lt;li&gt;{@code set(Optional.of(value))} puts the key-value pair in the map
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Null Value Limitation:&lt;/strong&gt; Due to Java's {@link Optional} semantics, null map
   * values cannot be distinguished from absent keys. {@code Optional.ofNullable(null)} returns
   * {@code Optional.empty()}, so a key with null value appears the same as an absent key. If you
   * need to distinguish these cases, consider using a wrapper type or avoiding null values.
   *
   * &lt;p&gt;&lt;strong&gt;Immutability:&lt;/strong&gt; All operations return new {@link Map} instances, leaving the
   * original unchanged.
   *
   * @param &lt;K&gt; The key type of the map
   * @param &lt;V&gt; The value type of the map
   * @return An {@code At} instance for maps
   */
  public static &lt;K, V&gt; At&lt;Map&lt;K, V&gt;, K, @Nullable V&gt; mapAt() {
<span class="fc" id="L80">    return key -&gt;</span>
<span class="fc" id="L81">        Lens.of(</span>
<span class="fc" id="L82">            map -&gt; Optional.ofNullable(map.get(key)),</span>
            (map, optValue) -&gt; {
<span class="fc" id="L84">              Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(map);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">              if (optValue.isPresent()) {</span>
<span class="fc" id="L86">                newMap.put(key, optValue.get());</span>
              } else {
<span class="fc" id="L88">                newMap.remove(key);</span>
              }
<span class="fc" id="L90">              return newMap;</span>
            });
  }

  /**
   * Creates an {@link At} instance for {@link List} types.
   *
   * &lt;p&gt;The returned {@code At} provides a lens to the optional presence of a value at a given
   * index:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code get(index)} returns {@code Optional.empty()} if index is out of bounds
   *   &lt;li&gt;{@code get(index)} returns {@code Optional.of(value)} if index is valid
   *   &lt;li&gt;{@code set(Optional.empty())} removes the element at index (shifts subsequent elements)
   *   &lt;li&gt;{@code set(Optional.of(value))} updates the element at index (must be in bounds)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; Removing an element shifts all subsequent indices. This means
   * that after a removal, the list size decreases and elements after the removed index have new
   * positions.
   *
   * &lt;p&gt;&lt;strong&gt;Bounds Checking:&lt;/strong&gt; Setting a value at an out-of-bounds index will throw an
   * {@link IndexOutOfBoundsException}. Use {@link #listAtWithPadding(Object)} for auto-expanding
   * behavior.
   *
   * &lt;p&gt;&lt;strong&gt;Immutability:&lt;/strong&gt; All operations return new {@link List} instances, leaving the
   * original unchanged.
   *
   * @param &lt;A&gt; The element type of the list
   * @return An {@code At} instance for lists
   */
  public static &lt;A&gt; At&lt;List&lt;A&gt;, Integer, A&gt; listAt() {
<span class="fc" id="L122">    return index -&gt;</span>
<span class="fc" id="L123">        Lens.of(</span>
            list -&gt;
<span class="fc bfc" id="L125" title="All 4 branches covered.">                (index &gt;= 0 &amp;&amp; index &lt; list.size())</span>
<span class="fc" id="L126">                    ? Optional.ofNullable(list.get(index))</span>
<span class="fc" id="L127">                    : Optional.empty(),</span>
            (list, optValue) -&gt; {
<span class="fc" id="L129">              List&lt;A&gt; newList = new ArrayList&lt;&gt;(list);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">              if (optValue.isPresent()) {</span>
<span class="fc bfc" id="L131" title="All 4 branches covered.">                if (index &lt; 0 || index &gt;= newList.size()) {</span>
<span class="fc" id="L132">                  throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L133">                      &quot;Index &quot; + index + &quot; out of bounds for list of size &quot; + newList.size());</span>
                }
<span class="fc" id="L135">                newList.set(index, optValue.get());</span>
              } else {
<span class="fc bfc" id="L137" title="All 4 branches covered.">                if (index &gt;= 0 &amp;&amp; index &lt; newList.size()) {</span>
<span class="fc" id="L138">                  newList.remove((int) index);</span>
                }
                // If index is out of bounds for removal, no-op (nothing to remove)
              }
<span class="fc" id="L142">              return newList;</span>
            });
  }

  /**
   * Creates an {@link At} instance for {@link List} types with automatic null-padding for
   * insertions beyond current size.
   *
   * &lt;p&gt;This variant automatically expands the list with null values when setting a value at an
   * index beyond the current size:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Setting index 5 on a list of size 3 will pad indices 3 and 4 with the default value
   *   &lt;li&gt;Useful for sparse list representations
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This behavior can lead to unexpected nulls in your list. Use with
   * caution.
   *
   * @param &lt;A&gt; The element type of the list
   * @param defaultValue The value to use for padding (typically null)
   * @return An {@code At} instance for lists with padding behavior
   */
  public static &lt;A&gt; At&lt;List&lt;A&gt;, Integer, A&gt; listAtWithPadding(@Nullable A defaultValue) {
<span class="fc" id="L166">    return index -&gt;</span>
<span class="fc" id="L167">        Lens.of(</span>
            list -&gt;
<span class="fc bfc" id="L169" title="All 4 branches covered.">                (index &gt;= 0 &amp;&amp; index &lt; list.size())</span>
<span class="fc" id="L170">                    ? Optional.ofNullable(list.get(index))</span>
<span class="fc" id="L171">                    : Optional.empty(),</span>
            (list, optValue) -&gt; {
<span class="fc" id="L173">              List&lt;A&gt; newList = new ArrayList&lt;&gt;(list);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">              if (optValue.isPresent()) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L176">                  throw new IndexOutOfBoundsException(&quot;Index cannot be negative: &quot; + index);</span>
                }
                // Pad the list if necessary
<span class="fc bfc" id="L179" title="All 2 branches covered.">                while (newList.size() &lt;= index) {</span>
<span class="fc" id="L180">                  newList.add(defaultValue);</span>
                }
<span class="fc" id="L182">                newList.set(index, optValue.get());</span>
              } else {
<span class="fc bfc" id="L184" title="All 4 branches covered.">                if (index &gt;= 0 &amp;&amp; index &lt; newList.size()) {</span>
<span class="fc" id="L185">                  newList.remove((int) index);</span>
                }
              }
<span class="fc" id="L188">              return newList;</span>
            });
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>