<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.reader</a> &gt; <span class="el_source">Reader.java</span></div><h1>Reader.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.reader;

import static java.util.Objects.requireNonNull;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Consumer;
import java.util.function.Function;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Represents a computation that depends on a read-only environment {@code R} to produce a value
 * {@code A}. The {@code Reader} monad is a functional programming pattern used for dependency
 * injection, allowing computations to &quot;read&quot; from a shared environment or configuration without
 * explicitly passing it through all layers of function calls.
 *
 * &lt;p&gt;Essentially, a {@code Reader&lt;R, A&gt;} is a wrapper around a function {@code Function&lt;R, A&gt;}. It
 * encapsulates a step in a program that requires some external configuration or service (the
 * environment {@code R}) to produce its result ({@code A}).
 *
 * &lt;p&gt;&lt;b&gt;Key Use Cases:&lt;/b&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Dependency Injection:&lt;/b&gt; Provide dependencies (like database connections, configuration
 *       objects, or services) to computations in a clean and composable way.
 *   &lt;li&gt;&lt;b&gt;Context Propagation:&lt;/b&gt; Pass contextual information (like user identity or
 *       request-specific data) through a series of operations.
 *   &lt;li&gt;&lt;b&gt;Modular Design:&lt;/b&gt; Decouple components from the direct creation or lookup of their
 *       dependencies, making them more testable and reusable.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 *
 * &lt;pre&gt;{@code
 * // Define an environment interface or record
 * interface AppConfig {
 * String getGreeting();
 * int getDefaultRetries();
 * }
 *
 * // A simple implementation of the environment
 * record MyConfig(String greeting, int retries) implements AppConfig {
 * @Override public String getGreeting() { return greeting; }
 * @Override public int getDefaultRetries() { return retries; }
 * }
 *
 * // A computation that reads the greeting from the environment
 * Reader&lt;AppConfig, String&gt; getGreetingMessage = Reader.ask().map(AppConfig::getGreeting);
 *
 * // Another computation that reads the number of retries
 * Reader&lt;AppConfig, Integer&gt; getRetries = Reader.ask().map(AppConfig::getDefaultRetries);
 *
 * // Combine computations
 * Reader&lt;AppConfig, String&gt; personalizedGreeting = getGreetingMessage.flatMap(greeting -&gt;
 * getRetries.map(retries -&gt; greeting + &quot;! You have &quot; + retries + &quot; retries left.&quot;)
 * );
 *
 * // Provide the actual environment and run the computation
 * AppConfig productionConfig = new MyConfig(&quot;Hello from Reader&quot;, 3);
 * String message = personalizedGreeting.run(productionConfig);
 * System.out.println(message); // Output: Hello from Reader! You have 3 retries left.
 *
 * AppConfig testConfig = new MyConfig(&quot;Test Greeting&quot;, 0);
 * String testMessage = personalizedGreeting.run(testConfig);
 * System.out.println(testMessage); // Output: Test Greeting! You have 0 retries left.
 * }&lt;/pre&gt;
 *
 * @param &lt;R&gt; The type of the read-only environment (e.g., configuration, context, dependencies).
 *     This environment is provided when the {@code Reader} is eventually run.
 * @param &lt;A&gt; The type of the value produced by the computation within the {@code Reader}.
 */
@FunctionalInterface
public interface Reader&lt;R, A&gt; {

<span class="fc" id="L79">  Class&lt;Reader&gt; READER_CLASS = Reader.class;</span>

  /**
   * Executes the computation encapsulated by this {@code Reader} using the provided environment.
   * This is the method that &quot;runs&quot; the reader, supplying the necessary context or dependencies.
   *
   * @param r The environment of type {@code R}. While annotated as {@code @NonNull}, the specific
   *     nullability contract for {@code r} depends on the design of the environment type {@code R}
   *     and how it's intended to be used. It's generally good practice for {@code R} to be
   *     non-null.
   * @return The computed value of type {@code A}. The nullability of the result depends on the
   *     specific computation defined within this {@code Reader}. It's annotated as
   *     {@code @Nullable} to reflect that the function {@code Function&lt;R, A&gt;} might return null.
   */
  @Nullable A run(@NonNull R r);

  /**
   * Creates a {@code Reader} instance from a given function. This is the most fundamental way to
   * construct a {@code Reader}, by providing the function that defines the computation based on the
   * environment.
   *
   * @param runFunction The function {@code (R -&gt; A)} that represents the core logic of the {@code
   *     Reader}. It takes an environment {@code R} and produces a value {@code A}. Must not be
   *     null.
   * @param &lt;R&gt; The type of the environment.
   * @param &lt;A&gt; The type of the value produced.
   * @return A new {@code Reader&lt;R, A&gt;} instance.
   * @throws NullPointerException if {@code runFunction} is null.
   */
  static &lt;R, A&gt; Reader&lt;R, A&gt; of(Function&lt;R, A&gt; runFunction) {
<span class="fc" id="L109">    Validation.function().requireFunction(runFunction, &quot;runFunction&quot;, READER_CLASS, OF);</span>
<span class="fc" id="L110">    return runFunction::apply;</span>
  }

  /**
   * Transforms the result of this {@code Reader} using the provided mapping function. If this
   * {@code Reader} produces a value {@code A}, this method applies the function {@code f} to {@code
   * A} to produce a new value {@code B}, wrapped in a new {@code Reader}. The environment {@code R}
   * remains the same.
   *
   * &lt;p&gt;This is the Functor `map` operation for {@code Reader}.
   *
   * &lt;p&gt;Equivalent to: {@code r -&gt; f.apply(this.run(r))}
   *
   * @param f The non-null function to apply to the result of this {@code Reader}. It takes a value
   *     of type {@code A} and returns a value of type {@code B}.
   * @param &lt;B&gt; The type of the value produced by the mapping function and thus by the new {@code
   *     Reader}.
   * @return A new {@code Reader&lt;R, B&gt;} that, when run, will execute this {@code Reader} and then
   *     apply the mapping function {@code f} to its result.
   * @throws NullPointerException if {@code f} is null.
   */
  default &lt;B&gt; Reader&lt;R, B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L132">    Validation.function().requireMapper(f, &quot;f&quot;, READER_CLASS, MAP);</span>
<span class="fc" id="L133">    return (R r) -&gt; f.apply(this.run(r));</span>
  }

  /**
   * Composes this {@code Reader} with a function that takes the result of this {@code Reader} and
   * returns another {@code Reader}. The resulting {@code Reader} is then run with the same initial
   * environment.
   *
   * &lt;p&gt;This is the Monad `flatMap` (or `bind`) operation for {@code Reader}. It allows sequencing
   * computations where each step depends on the result of the previous one and also requires access
   * to the environment {@code R}.
   *
   * &lt;p&gt;Equivalent to: {@code r -&gt; f.apply(this.run(r)).run(r)}
   *
   * @param f The non-null function to apply to the result of this {@code Reader}. It takes a value
   *     of type {@code A} and returns a {@code Reader&lt;R, ? extends B&gt;}. The returned {@code Reader}
   *     must not be null.
   * @param &lt;B&gt; The type of the value produced by the {@code Reader} returned by function {@code f}.
   * @return A new {@code Reader&lt;R, B&gt;} that, when run, will execute this {@code Reader}, apply
   *     function {@code f} to its result to get a new {@code Reader}, and then run that new {@code
   *     Reader} with the original environment.
   * @throws NullPointerException if {@code f} is null, or if {@code f} returns a null {@code
   *     Reader}.
   */
  default &lt;B&gt; Reader&lt;R, B&gt; flatMap(Function&lt;? super A, ? extends Reader&lt;R, ? extends B&gt;&gt; f) {
<span class="fc" id="L158">    Validation.function().requireFlatMapper(f, &quot;f&quot;, READER_CLASS, FLAT_MAP);</span>
<span class="fc" id="L159">    return (R r) -&gt; {</span>
<span class="fc" id="L160">      A a = this.run(r);</span>
<span class="fc" id="L161">      Reader&lt;R, ? extends B&gt; readerB = f.apply(a);</span>
<span class="fc" id="L162">      Validation.function()</span>
<span class="fc" id="L163">          .requireNonNullResult(readerB, &quot;f&quot;, READER_CLASS, FLAT_MAP, READER_CLASS);</span>
<span class="fc" id="L164">      return readerB.run(r);</span>
    };
  }

  /**
   * Creates a Reader that ignores its environment and returns Unit.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Reader&lt;Config, Unit&gt; noop = Reader.unit();
   * }&lt;/pre&gt;
   *
   * @param &lt;R&gt; The environment type
   * @return A Reader that always returns Unit.INSTANCE
   */
  static &lt;R&gt; Reader&lt;R, Unit&gt; unit() {
<span class="fc" id="L181">    return env -&gt; Unit.INSTANCE;</span>
  }

  /**
   * Creates a Reader from a side-effecting Consumer of the environment.
   *
   * &lt;p&gt;This is useful for creating Readers that perform side effects based on configuration but
   * don't produce a meaningful return value.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Reader&lt;Config, Unit&gt; logConfig =
   *     Reader.fromConsumer(config -&gt; logger.info(&quot;Using: &quot; + config));
   * }&lt;/pre&gt;
   *
   * @param consumer The consumer that processes the environment, must not be null
   * @param &lt;R&gt; The environment type
   * @return A {@code Reader&lt;R, Unit&gt;} that applies the consumer
   * @throws NullPointerException if consumer is null
   */
  static &lt;R&gt; Reader&lt;R, Unit&gt; fromConsumer(Consumer&lt;R&gt; consumer) {
<span class="fc" id="L203">    requireNonNull(consumer, &quot;consumer cannot be null&quot;);</span>
<span class="fc" id="L204">    return env -&gt; {</span>
<span class="fc" id="L205">      consumer.accept(env);</span>
<span class="fc" id="L206">      return Unit.INSTANCE;</span>
    };
  }

  /**
   * Discards the result of this Reader, replacing it with Unit.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * Reader&lt;Config, String&gt; getHost = Reader.asks(Config::getHost);
   * Reader&lt;Config, Unit&gt; justReadConfig = getHost.asUnit();
   * }&lt;/pre&gt;
   *
   * @return A {@code Reader&lt;R, Unit&gt;} that reads the same environment but returns Unit
   */
  default Reader&lt;R, Unit&gt; asUnit() {
<span class="fc" id="L223">    return env -&gt; {</span>
<span class="fc" id="L224">      run(env);</span>
<span class="fc" id="L225">      return Unit.INSTANCE;</span>
    };
  }

  /**
   * Creates a {@code Reader} that ignores the environment and always yields the given constant
   * value. This is useful for injecting a fixed value into a sequence of {@code Reader}
   * computations or for lifting a simple value into the {@code Reader} context.
   *
   * @param value The constant value (of type {@code A}) to be returned by the {@code Reader}. Can
   *     be {@code null} if {@code A} is a nullable type.
   * @param &lt;R&gt; The type of the environment (which will be ignored).
   * @param &lt;A&gt; The type of the constant value.
   * @return A new {@code Reader&lt;R, A&gt;} that always produces the given {@code value} regardless of
   *     the environment it is run with.
   */
  static &lt;R, A&gt; Reader&lt;R, A&gt; constant(@Nullable A value) {
<span class="fc" id="L242">    return r -&gt; value;</span>
  }

  /**
   * Creates a {@code Reader} that, when run, simply returns the environment itself. This is a
   * fundamental operation for accessing the environment {@code R} from within a {@code Reader}
   * computation. It's often used as the starting point for computations that need to extract data
   * from the environment.
   *
   * &lt;p&gt;In Category Theory terms, this is often called {@code ask} (from the Reader Monad).
   *
   * @param &lt;R&gt; The type of the environment, which is also the type of the value produced.
   * @return A new {@code Reader&lt;R, R&gt;} that yields the environment it is run with.
   */
  static &lt;R&gt; Reader&lt;R, R&gt; ask() {
<span class="fc" id="L257">    return r -&gt; r;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>