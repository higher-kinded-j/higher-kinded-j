<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FocusPaths.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.focus</a> &gt; <span class="el_source">FocusPaths.java</span></div><h1>FocusPaths.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.focus;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.optics.Affine;
import org.higherkindedj.optics.Traversal;
import org.jspecify.annotations.NullMarked;

/**
 * Static utilities for creating optics used in Focus path navigation.
 *
 * &lt;p&gt;This class provides pre-built optics for common collection types that are used internally by
 * the Focus DSL for methods like {@code each()}, {@code at()}, {@code some()}, and {@code atKey()}.
 *
 * &lt;h2&gt;Supported Types&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link List} - via {@link #listElements()} and {@link #listAt(int)}
 *   &lt;li&gt;{@link Map} - via {@link #mapValues()} and {@link #mapAt(Object)}
 *   &lt;li&gt;{@link Optional} - via {@link #optionalSome()}
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Get a traversal over list elements
 * Traversal&lt;List&lt;String&gt;, String&gt; strings = FocusPaths.listElements();
 *
 * // Get an affine for a specific index
 * Affine&lt;List&lt;String&gt;, String&gt; second = FocusPaths.listAt(1);
 *
 * // Get an affine for Optional unwrapping
 * Affine&lt;Optional&lt;String&gt;, String&gt; some = FocusPaths.optionalSome();
 * }&lt;/pre&gt;
 */
@NullMarked
public final class FocusPaths {

  private FocusPaths() {
    // Utility class
  }

  // ===== List Optics =====

  /**
   * Creates a traversal over all elements in a list.
   *
   * @param &lt;E&gt; the element type
   * @return a traversal focusing on all list elements
   */
  public static &lt;E&gt; Traversal&lt;List&lt;E&gt;, E&gt; listElements() {
<span class="fc" id="L60">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, List&lt;E&gt;&gt; modifyF(
          Function&lt;E, Kind&lt;F, E&gt;&gt; f, List&lt;E&gt; source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (source.isEmpty()) {</span>
<span class="fc" id="L65">          return app.of(source);</span>
        }

        // Start with the first element
<span class="fc" id="L69">        Kind&lt;F, List&lt;E&gt;&gt; result = app.map(List::of, f.apply(source.get(0)));</span>

        // Combine with remaining elements
<span class="fc bfc" id="L72" title="All 2 branches covered.">        for (int i = 1; i &lt; source.size(); i++) {</span>
<span class="fc" id="L73">          Kind&lt;F, E&gt; modifiedElement = f.apply(source.get(i));</span>
<span class="fc" id="L74">          result = app.map2(result, modifiedElement, FocusPaths::appendToList);</span>
        }

<span class="fc" id="L77">        return result;</span>
      }
    };
  }

  /**
   * Creates an affine focusing on a specific index in a list.
   *
   * &lt;p&gt;The affine will return empty if the index is out of bounds. Setting a value at an index
   * requires the index to be within the current list size.
   *
   * @param index the index to focus on
   * @param &lt;E&gt; the element type
   * @return an affine focusing on the element at the given index
   */
  public static &lt;E&gt; Affine&lt;List&lt;E&gt;, E&gt; listAt(int index) {
<span class="fc" id="L93">    return Affine.of(</span>
        list -&gt;
<span class="fc bfc" id="L95" title="All 4 branches covered.">            (index &gt;= 0 &amp;&amp; index &lt; list.size()) ? Optional.of(list.get(index)) : Optional.empty(),</span>
        (list, element) -&gt; {
<span class="fc bfc" id="L97" title="All 4 branches covered.">          if (index &gt;= 0 &amp;&amp; index &lt; list.size()) {</span>
<span class="fc" id="L98">            List&lt;E&gt; result = new ArrayList&lt;&gt;(list);</span>
<span class="fc" id="L99">            result.set(index, element);</span>
<span class="fc" id="L100">            return result;</span>
          }
<span class="fc" id="L102">          return list;</span>
        });
  }

  /**
   * Creates an affine focusing on the first element of a list.
   *
   * @param &lt;E&gt; the element type
   * @return an affine focusing on the first element
   */
  public static &lt;E&gt; Affine&lt;List&lt;E&gt;, E&gt; listHead() {
<span class="fc" id="L113">    return listAt(0);</span>
  }

  /**
   * Creates an affine focusing on the last element of a list.
   *
   * @param &lt;E&gt; the element type
   * @return an affine focusing on the last element
   */
  public static &lt;E&gt; Affine&lt;List&lt;E&gt;, E&gt; listLast() {
<span class="fc" id="L123">    return Affine.of(</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        list -&gt; list.isEmpty() ? Optional.empty() : Optional.of(list.get(list.size() - 1)),</span>
        (list, element) -&gt; {
<span class="fc bfc" id="L126" title="All 2 branches covered.">          if (!list.isEmpty()) {</span>
<span class="fc" id="L127">            List&lt;E&gt; result = new ArrayList&lt;&gt;(list);</span>
<span class="fc" id="L128">            result.set(result.size() - 1, element);</span>
<span class="fc" id="L129">            return result;</span>
          }
<span class="fc" id="L131">          return list;</span>
        });
  }

  // ===== Map Optics =====

  /**
   * Creates a traversal over all values in a map.
   *
   * &lt;p&gt;Note: The traversal order depends on the map implementation. For predictable ordering, use a
   * {@code LinkedHashMap} or {@code TreeMap}.
   *
   * @param &lt;K&gt; the key type
   * @param &lt;V&gt; the value type
   * @return a traversal focusing on all map values
   */
  public static &lt;K, V&gt; Traversal&lt;Map&lt;K, V&gt;, V&gt; mapValues() {
<span class="fc" id="L148">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, Map&lt;K, V&gt;&gt; modifyF(
          Function&lt;V, Kind&lt;F, V&gt;&gt; f, Map&lt;K, V&gt; source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (source.isEmpty()) {</span>
<span class="fc" id="L153">          return app.of(source);</span>
        }

        // Convert to list for ordered processing
<span class="fc" id="L157">        List&lt;Map.Entry&lt;K, V&gt;&gt; entries = new ArrayList&lt;&gt;(source.entrySet());</span>

        // Start with the first entry
<span class="fc" id="L160">        Map.Entry&lt;K, V&gt; first = entries.get(0);</span>
<span class="fc" id="L161">        Kind&lt;F, Map&lt;K, V&gt;&gt; result =</span>
<span class="fc" id="L162">            app.map(v -&gt; Map.of(first.getKey(), v), f.apply(first.getValue()));</span>

        // Combine with remaining entries
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int i = 1; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L166">          Map.Entry&lt;K, V&gt; entry = entries.get(i);</span>
<span class="fc" id="L167">          Kind&lt;F, V&gt; modifiedValue = f.apply(entry.getValue());</span>
<span class="fc" id="L168">          K key = entry.getKey();</span>
<span class="fc" id="L169">          result = app.map2(result, modifiedValue, (map, v) -&gt; putInMap(map, key, v));</span>
        }

<span class="fc" id="L172">        return result;</span>
      }
    };
  }

  /**
   * Creates an affine focusing on a specific key in a map.
   *
   * &lt;p&gt;The affine will return empty if the key is not present. Setting a value will add or update
   * the key.
   *
   * @param key the key to focus on
   * @param &lt;K&gt; the key type
   * @param &lt;V&gt; the value type
   * @return an affine focusing on the value at the given key
   */
  public static &lt;K, V&gt; Affine&lt;Map&lt;K, V&gt;, V&gt; mapAt(K key) {
<span class="fc" id="L189">    return Affine.of(</span>
<span class="fc" id="L190">        map -&gt; Optional.ofNullable(map.get(key)),</span>
        (map, value) -&gt; {
<span class="fc" id="L192">          Map&lt;K, V&gt; result = new HashMap&lt;&gt;(map);</span>
<span class="fc" id="L193">          result.put(key, value);</span>
<span class="fc" id="L194">          return result;</span>
        },
        map -&gt; {
<span class="fc" id="L197">          Map&lt;K, V&gt; result = new HashMap&lt;&gt;(map);</span>
<span class="fc" id="L198">          result.remove(key);</span>
<span class="fc" id="L199">          return result;</span>
        });
  }

  // ===== Optional Optics =====

  /**
   * Creates an affine that unwraps an Optional.
   *
   * &lt;p&gt;The affine returns empty if the Optional is empty. Setting always creates a present
   * Optional.
   *
   * @param &lt;E&gt; the inner type
   * @return an affine for unwrapping Optional
   */
  public static &lt;E&gt; Affine&lt;Optional&lt;E&gt;, E&gt; optionalSome() {
<span class="fc" id="L215">    return Affine.of(</span>
<span class="fc" id="L216">        Function.identity(), (opt, value) -&gt; Optional.of(value), opt -&gt; Optional.empty());</span>
  }

  // ===== Nullable Optics =====

  /**
   * Creates an affine that treats null as absent.
   *
   * &lt;p&gt;This is useful for working with legacy APIs or records that use null to represent absent
   * values instead of {@link Optional}. The affine wraps null checks in Optional semantics,
   * allowing seamless integration with the Focus DSL.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * record LegacyUser(String name, @Nullable String nickname) {}
   *
   * // Create a path to the nullable nickname field
   * FocusPath&lt;LegacyUser, @Nullable String&gt; nicknamePath = LegacyUserFocus.nickname();
   *
   * // Chain with nullable() to get an AffinePath that handles null safely
   * AffinePath&lt;LegacyUser, String&gt; safeNickname = nicknamePath.nullable();
   *
   * // Now use it like any other AffinePath
   * Optional&lt;String&gt; result = safeNickname.getOptional(user);  // Empty if null
   * LegacyUser updated = safeNickname.set(&quot;Ally&quot;, user);       // Sets the nickname
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type (non-null)
   * @return an affine that treats null as absent
   */
  @SuppressWarnings(&quot;nullness&quot;) // Intentionally working with nullable values
  public static &lt;E&gt; Affine&lt;E, E&gt; nullable() {
<span class="fc" id="L249">    return Affine.of(Optional::ofNullable, (ignored, value) -&gt; value);</span>
  }

  // ===== Array Optics =====

  /**
   * Creates a traversal over all elements in an array.
   *
   * @param &lt;E&gt; the element type
   * @return a traversal focusing on all array elements
   */
  public static &lt;E&gt; Traversal&lt;E[], E&gt; arrayElements() {
<span class="fc" id="L261">    return new Traversal&lt;&gt;() {</span>
      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public &lt;F&gt; Kind&lt;F, E[]&gt; modifyF(Function&lt;E, Kind&lt;F, E&gt;&gt; f, E[] source, Applicative&lt;F&gt; app) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (source.length == 0) {</span>
<span class="fc" id="L266">          return app.of(source);</span>
        }

        // Start with the first element wrapped in a list
<span class="fc" id="L270">        Kind&lt;F, List&lt;E&gt;&gt; result = app.map(List::of, f.apply(source[0]));</span>

        // Combine with remaining elements
<span class="fc bfc" id="L273" title="All 2 branches covered.">        for (int i = 1; i &lt; source.length; i++) {</span>
<span class="fc" id="L274">          Kind&lt;F, E&gt; modifiedElement = f.apply(source[i]);</span>
<span class="fc" id="L275">          result = app.map2(result, modifiedElement, FocusPaths::appendToList);</span>
        }

        // Convert back to array
<span class="fc" id="L279">        return app.map(</span>
            list -&gt;
<span class="fc" id="L281">                list.toArray(</span>
                    (E[])
<span class="fc" id="L283">                        java.lang.reflect.Array.newInstance(</span>
<span class="fc" id="L284">                            source.getClass().getComponentType(), list.size())),</span>
            result);
      }
    };
  }

  /**
   * Creates an affine focusing on a specific index in an array.
   *
   * @param index the index to focus on
   * @param &lt;E&gt; the element type
   * @return an affine focusing on the element at the given index
   */
  public static &lt;E&gt; Affine&lt;E[], E&gt; arrayAt(int index) {
<span class="fc" id="L298">    return Affine.of(</span>
<span class="fc bfc" id="L299" title="All 4 branches covered.">        arr -&gt; (index &gt;= 0 &amp;&amp; index &lt; arr.length) ? Optional.of(arr[index]) : Optional.empty(),</span>
        (arr, element) -&gt; {
<span class="fc bfc" id="L301" title="All 4 branches covered.">          if (index &gt;= 0 &amp;&amp; index &lt; arr.length) {</span>
<span class="fc" id="L302">            E[] result = arr.clone();</span>
<span class="fc" id="L303">            result[index] = element;</span>
<span class="fc" id="L304">            return result;</span>
          }
<span class="fc" id="L306">          return arr;</span>
        });
  }

  // ===== Helper Methods =====

  private static &lt;E&gt; List&lt;E&gt; appendToList(List&lt;E&gt; list, E element) {
<span class="fc" id="L313">    List&lt;E&gt; result = new ArrayList&lt;&gt;(list);</span>
<span class="fc" id="L314">    result.add(element);</span>
<span class="fc" id="L315">    return result;</span>
  }

  private static &lt;K, V&gt; Map&lt;K, V&gt; putInMap(Map&lt;K, V&gt; map, K key, V value) {
<span class="fc" id="L319">    Map&lt;K, V&gt; result = new HashMap&lt;&gt;(map);</span>
<span class="fc" id="L320">    result.put(key, value);</span>
<span class="fc" id="L321">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>