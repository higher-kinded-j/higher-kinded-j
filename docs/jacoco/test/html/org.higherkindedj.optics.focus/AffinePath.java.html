<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AffinePath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.focus</a> &gt; <span class="el_source">AffinePath.java</span></div><h1>AffinePath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.focus;

import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Traverse;
import org.higherkindedj.optics.Affine;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Iso;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.util.TraverseTraversals;
import org.jspecify.annotations.NullMarked;

/**
 * A type-safe path through a data structure that focuses on zero or one element.
 *
 * &lt;p&gt;AffinePath wraps an {@link Affine} and provides fluent navigation and composition methods. Use
 * this when navigating to values that may or may not exist, such as Optional fields or the result
 * of navigating through a prism.
 *
 * &lt;p&gt;In the Focus DSL hierarchy, AffinePath sits between FocusPath and TraversalPath:
 *
 * &lt;pre&gt;
 *      FocusPath&lt;S, A&gt;     (exactly one element)
 *            │
 *      AffinePath&lt;S, A&gt;    (zero or one element)
 *            │
 *    TraversalPath&lt;S, A&gt;   (zero or more elements)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Navigate to an optional email field
 * AffinePath&lt;User, String&gt; emailPath = UserFocus.email();
 *
 * // Get the value (may be empty)
 * Optional&lt;String&gt; email = emailPath.getOptional(user);
 *
 * // Set a value (always succeeds)
 * User updated = emailPath.set(&quot;new@email.com&quot;, user);
 *
 * // Modify only if present
 * User modified = emailPath.modify(String::toLowerCase, user);
 *
 * // Check if present
 * if (emailPath.matches(user)) {
 *     // ...
 * }
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; the source type (the whole structure)
 * @param &lt;A&gt; the focused value type (the part)
 * @see FocusPath for paths focusing on exactly one element
 * @see TraversalPath for paths focusing on zero or more elements
 * @see FocusPaths for utility methods and optics factories
 */
@NullMarked
public sealed interface AffinePath&lt;S, A&gt; permits AffineFocusPath {

  /**
   * Extracts the focused value if present.
   *
   * @param source the source structure
   * @return Optional containing the value, or empty if not focused
   */
  Optional&lt;A&gt; getOptional(S source);

  /**
   * Creates a new source with the focused value replaced.
   *
   * &lt;p&gt;Unlike a Prism, this operation always succeeds. If the focused element was previously
   * absent, it becomes present with the new value (if the underlying structure supports this).
   *
   * @param value the new value
   * @param source the source structure
   * @return a new structure with the updated value
   */
  S set(A value, S source);

  /**
   * Creates a new source with the focused value transformed, if present.
   *
   * &lt;p&gt;If the focused element is absent, the original structure is returned unchanged.
   *
   * @param f the transformation function
   * @param source the source structure
   * @return a new structure with the modified value, or the original if not focused
   */
  default S modify(Function&lt;A, A&gt; f, S source) {
<span class="fc" id="L98">    return getOptional(source).map(a -&gt; set(f.apply(a), source)).orElse(source);</span>
  }

  /**
   * Checks if this path focuses on a value in the given source.
   *
   * @param source the source structure to test
   * @return true if a value is focused, false otherwise
   */
  default boolean matches(S source) {
<span class="fc" id="L108">    return getOptional(source).isPresent();</span>
  }

  /**
   * Returns the focused value or a default if absent.
   *
   * @param defaultValue the value to return if not focused
   * @param source the source structure
   * @return the focused value or the default
   */
  default A getOrElse(A defaultValue, S source) {
<span class="fc" id="L119">    return getOptional(source).orElse(defaultValue);</span>
  }

  /**
   * Applies a function to the focused value and returns the result in an Optional.
   *
   * @param f the function to apply
   * @param source the source structure
   * @param &lt;B&gt; the result type
   * @return Optional containing the result, or empty if not focused
   */
  default &lt;B&gt; Optional&lt;B&gt; mapOptional(Function&lt;? super A, ? extends B&gt; f, S source) {
<span class="fc" id="L131">    return getOptional(source).map(f);</span>
  }

  /**
   * Transforms the focused value with an effectful function.
   *
   * &lt;p&gt;This method enables effectful modifications such as validation, async operations, or
   * computations that may fail. If this path has no focus, the original source is returned wrapped
   * in the applicative's {@code of}.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Validation of optional field
   * AffinePath&lt;User, String&gt; emailPath = UserFocus.optionalEmail();
   *
   * Kind&lt;Validated.Witness, User&gt; result = emailPath.modifyF(
   *     email -&gt; EmailValidator.validate(email),
   *     user,
   *     ValidatedApplicative.INSTANCE
   * );
   *
   * // Async update of optional config value
   * Kind&lt;CompletableFutureKind.Witness, Config&gt; result = configPath.modifyF(
   *     value -&gt; fetchUpdatedValue(value),
   *     config,
   *     CompletableFutureApplicative.INSTANCE
   * );
   * }&lt;/pre&gt;
   *
   * @param f the effectful transformation function
   * @param source the source structure
   * @param applicative the applicative instance for the effect type F
   * @param &lt;F&gt; the effect type (e.g., Optional, Validated, IO)
   * @return the modified structure wrapped in the effect
   */
  default &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L168">    return toAffine().modifyF(f, source, applicative);</span>
  }

  // ===== Composition Methods =====

  /**
   * Composes this path with a lens, producing an AffinePath.
   *
   * &lt;p&gt;The result is an AffinePath because this path may have no focus.
   *
   * @param lens the lens to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the composed target
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Lens&lt;A, B&gt; lens);

  /**
   * Composes this path with a FocusPath.
   *
   * &lt;p&gt;This is a convenience method that extracts the lens from the other path. The result is an
   * AffinePath because this path may have no focus.
   *
   * @param other the FocusPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the composed target
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; via(FocusPath&lt;A, B&gt; other) {
<span class="fc" id="L195">    return via(other.toLens());</span>
  }

  /**
   * Composes this path with another AffinePath.
   *
   * &lt;p&gt;This is a convenience method that extracts the affine from the other path. The result is an
   * AffinePath because both paths may have no focus.
   *
   * @param other the AffinePath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; via(AffinePath&lt;A, B&gt; other) {
<span class="fc" id="L209">    return via(other.toAffine());</span>
  }

  /**
   * Composes this path with a TraversalPath.
   *
   * &lt;p&gt;This is a convenience method that extracts the traversal from the other path. The result is
   * a TraversalPath because the other path may focus on multiple elements.
   *
   * @param other the TraversalPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; via(TraversalPath&lt;A, B&gt; other) {
<span class="fc" id="L223">    return via(other.toTraversal());</span>
  }

  /**
   * Composes this path with a prism, producing an AffinePath.
   *
   * &lt;p&gt;The result is an AffinePath because both this path and the prism may have no focus.
   *
   * @param prism the prism to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Prism&lt;A, B&gt; prism);

  /**
   * Composes this path with an affine, producing an AffinePath.
   *
   * @param affine the affine to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Affine&lt;A, B&gt; affine);

  /**
   * Composes this path with an iso, producing an AffinePath.
   *
   * @param iso the iso to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the converted target
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Iso&lt;A, B&gt; iso);

  /**
   * Composes this path with a traversal, producing a TraversalPath.
   *
   * @param traversal the traversal to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  &lt;B&gt; TraversalPath&lt;S, B&gt; via(Traversal&lt;A, B&gt; traversal);

  // ===== then() Aliases =====

  /**
   * Alias for {@link #via(Lens)}. Composes this path with a lens.
   *
   * &lt;p&gt;This method provides an alternative naming convention familiar to users of other optics
   * libraries.
   *
   * @param lens the lens to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the composed target
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L277">    return via(lens);</span>
  }

  /**
   * Alias for {@link #via(FocusPath)}. Composes this path with a FocusPath.
   *
   * @param other the FocusPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the composed target
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(FocusPath&lt;A, B&gt; other) {
<span class="fc" id="L288">    return via(other);</span>
  }

  /**
   * Alias for {@link #via(Prism)}. Composes this path with a prism.
   *
   * @param prism the prism to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Prism&lt;A, B&gt; prism) {
<span class="fc" id="L299">    return via(prism);</span>
  }

  /**
   * Alias for {@link #via(Affine)}. Composes this path with an affine.
   *
   * @param affine the affine to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Affine&lt;A, B&gt; affine) {
<span class="fc" id="L310">    return via(affine);</span>
  }

  /**
   * Alias for {@link #via(AffinePath)}. Composes this path with another AffinePath.
   *
   * @param other the AffinePath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(AffinePath&lt;A, B&gt; other) {
<span class="fc" id="L321">    return via(other);</span>
  }

  /**
   * Alias for {@link #via(Iso)}. Composes this path with an iso.
   *
   * @param iso the iso to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath focusing on the composed target
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Iso&lt;A, B&gt; iso) {
<span class="fc" id="L332">    return via(iso);</span>
  }

  /**
   * Alias for {@link #via(Traversal)}. Composes this path with a traversal.
   *
   * @param traversal the traversal to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; then(Traversal&lt;A, B&gt; traversal) {
<span class="fc" id="L343">    return via(traversal);</span>
  }

  /**
   * Alias for {@link #via(TraversalPath)}. Composes this path with a TraversalPath.
   *
   * @param other the TraversalPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; then(TraversalPath&lt;A, B&gt; other) {
<span class="fc" id="L354">    return via(other);</span>
  }

  // ===== Collection Navigation =====

  /**
   * When the focused type is {@code List&lt;E&gt;}, traverses all elements.
   *
   * @param &lt;E&gt; the element type of the list
   * @return a TraversalPath over list elements
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; TraversalPath&lt;S, E&gt; each() {
<span class="fc" id="L367">    return via((Traversal&lt;A, E&gt;) FocusPaths.listElements());</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the element at the specified index.
   *
   * @param index the index to focus on
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath that may be empty if the index is out of bounds
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; at(int index) {
<span class="fc" id="L379">    return via((Affine&lt;A, E&gt;) FocusPaths.listAt(index));</span>
  }

  /**
   * When the focused type is {@code Map&lt;K, V&gt;}, focuses on the value for the specified key.
   *
   * @param key the key to focus on
   * @param &lt;K&gt; the key type of the map
   * @param &lt;V&gt; the value type of the map
   * @return an AffinePath that may be empty if the key is not present
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;K, V&gt; AffinePath&lt;S, V&gt; atKey(K key) {
<span class="fc" id="L392">    return via((Affine&lt;A, V&gt;) FocusPaths.mapAt(key));</span>
  }

  /**
   * When the focused type is {@code Optional&lt;E&gt;}, unwraps to the inner value.
   *
   * @param &lt;E&gt; the inner type of the Optional
   * @return an AffinePath that may be empty
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; some() {
<span class="fc" id="L403">    return via((Affine&lt;A, E&gt;) FocusPaths.optionalSome());</span>
  }

  /**
   * When the focused type may be null, creates an AffinePath that safely handles null values.
   *
   * &lt;p&gt;This is useful for working with legacy APIs or records that use null to represent absent
   * values instead of {@link java.util.Optional}. The resulting AffinePath treats null as absent
   * (empty Optional) and non-null as present.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Given an AffinePath to an optionally-present nullable field
   * AffinePath&lt;Config, @Nullable String&gt; apiKeyPath = ConfigFocus.apiKey();
   *
   * // Chain with nullable() to handle the null case
   * AffinePath&lt;Config, String&gt; safeApiKey = apiKeyPath.nullable();
   *
   * // getOptional returns empty for both &quot;path doesn't match&quot; and &quot;value is null&quot;
   * Optional&lt;String&gt; result = safeApiKey.getOptional(config);
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the non-null element type
   * @return an AffinePath that treats null as absent
   * @see FocusPaths#nullable()
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; nullable() {
<span class="fc" id="L432">    return via((Affine&lt;A, E&gt;) FocusPaths.nullable());</span>
  }

  /**
   * When the optionally-focused value is a traversable container {@code Kind&lt;F, E&gt;}, creates a
   * TraversalPath that focuses on all elements within it.
   *
   * &lt;p&gt;This enables generic traversal over any type with a {@link org.higherkindedj.hkt.Traverse}
   * instance, not just {@code List}. For example, {@code Set}, {@code Tree}, or custom collections.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Given: Config with optional Kind&lt;ListKind.Witness, Feature&gt; features field
   * AffinePath&lt;Config, Kind&lt;ListKind.Witness, Feature&gt;&gt; featuresPath = ConfigFocus.features();
   *
   * // Traverse into the List elements when present
   * TraversalPath&lt;Config, Feature&gt; allFeatures = featuresPath.traverseOver(
   *     ListTraverse.INSTANCE
   * );
   *
   * // Now can operate on all features (if present)
   * List&lt;Feature&gt; features = allFeatures.getAll(config);
   * Config updated = allFeatures.modifyAll(Feature::enable, config);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;For standard {@code List&lt;E&gt;} fields, prefer the {@link #each()} method which handles the
   * conversion automatically.
   *
   * @param &lt;F&gt; the witness type of the traversable container
   * @param &lt;E&gt; the element type within the container
   * @param traverse the Traverse instance for the container type
   * @return a TraversalPath focusing on all elements within the container
   * @see #each() for simpler List traversal
   * @see org.higherkindedj.optics.util.TraverseTraversals
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;F, E&gt; TraversalPath&lt;S, E&gt; traverseOver(Traverse&lt;F&gt; traverse) {
<span class="fc" id="L470">    Traversal&lt;Kind&lt;F, E&gt;, E&gt; traversal = TraverseTraversals.forTraverse(traverse);</span>
<span class="fc" id="L471">    return via((Traversal&lt;A, E&gt;) traversal);</span>
  }

  // ===== Conversion Methods =====

  /**
   * Extracts the underlying affine.
   *
   * @return the wrapped Affine
   */
  Affine&lt;S, A&gt; toAffine();

  /**
   * Views this path as a TraversalPath.
   *
   * &lt;p&gt;This is always valid because an AffinePath (zero or one) is a special case of TraversalPath
   * (zero or more).
   *
   * @return a TraversalPath view of this path
   */
  default TraversalPath&lt;S, A&gt; asTraversal() {
<span class="fc" id="L492">    return TraversalPath.of(toAffine().asTraversal());</span>
  }

  /**
   * Views this path as a Fold.
   *
   * @return a Fold view of the underlying affine
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L501">    return toAffine().asFold();</span>
  }

  // ===== Debugging =====

  /**
   * Creates a new AffinePath that invokes an observer during get operations.
   *
   * &lt;p&gt;This method is useful for debugging complex path navigations by logging or inspecting values
   * as they are accessed. The observer receives the source and the focused value (if present).
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * AffinePath&lt;Config, String&gt; debugPath = ConfigFocus.apiKey()
   *     .traced((config, key) -&gt; log.debug(&quot;Accessing API key: {} from {}&quot;, key, config));
   *
   * // Every getOptional() call will now log the accessed value
   * Optional&lt;String&gt; key = debugPath.getOptional(config);
   * }&lt;/pre&gt;
   *
   * @param observer a consumer that receives the source and focused value during get operations
   * @return a new AffinePath that invokes the observer
   */
  default AffinePath&lt;S, A&gt; traced(BiConsumer&lt;S, Optional&lt;A&gt;&gt; observer) {
<span class="fc" id="L526">    AffinePath&lt;S, A&gt; self = this;</span>
<span class="fc" id="L527">    return AffinePath.of(</span>
<span class="fc" id="L528">        Affine.of(</span>
            s -&gt; {
<span class="fc" id="L530">              Optional&lt;A&gt; result = self.getOptional(s);</span>
<span class="fc" id="L531">              observer.accept(s, result);</span>
<span class="fc" id="L532">              return result;</span>
            },
<span class="fc" id="L534">            (s, a) -&gt; self.set(a, s)));</span>
  }

  // ===== Factory Methods =====

  /**
   * Creates an AffinePath from an affine.
   *
   * @param affine the affine to wrap
   * @param &lt;S&gt; the source type
   * @param &lt;A&gt; the focused type
   * @return a new AffinePath
   */
  static &lt;S, A&gt; AffinePath&lt;S, A&gt; of(Affine&lt;S, A&gt; affine) {
<span class="fc" id="L548">    return new AffineFocusPath&lt;&gt;(affine);</span>
  }

  /**
   * Creates an AffinePath that focuses on instances of a specific subclass.
   *
   * &lt;p&gt;This is useful for working with sealed interfaces or class hierarchies, allowing you to
   * focus on a specific variant of a sum type.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * sealed interface Shape permits Circle, Rectangle {}
   * record Circle(double radius) implements Shape {}
   * record Rectangle(double width, double height) implements Shape {}
   *
   * // Focus on Circle instances only
   * AffinePath&lt;Shape, Circle&gt; circlePath = AffinePath.instanceOf(Circle.class);
   *
   * // Get the Circle if the shape is one
   * Optional&lt;Circle&gt; maybeCircle = circlePath.getOptional(someShape);
   *
   * // Compose with further navigation
   * AffinePath&lt;Shape, Double&gt; radiusPath = circlePath.via(CircleFocus.radius());
   * }&lt;/pre&gt;
   *
   * @param subclass the class of the subtype to focus on
   * @param &lt;S&gt; the source (supertype)
   * @param &lt;A&gt; the focused subtype
   * @return an AffinePath that focuses only on instances of the specified subclass
   */
  static &lt;S, A extends S&gt; AffinePath&lt;S, A&gt; instanceOf(Class&lt;A&gt; subclass) {
<span class="fc" id="L580">    Affine&lt;S, A&gt; affine =</span>
<span class="fc" id="L581">        Affine.of(</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            s -&gt; subclass.isInstance(s) ? Optional.of(subclass.cast(s)) : Optional.empty(),</span>
<span class="fc" id="L583">            (s, a) -&gt; a);</span>
<span class="fc" id="L584">    return of(affine);</span>
  }

  /**
   * Creates an AffinePath for a nullable field with implicit null-safety.
   *
   * &lt;p&gt;This is a convenience factory for creating paths to fields that may be null. The path treats
   * null values as absent (empty Optional), providing seamless integration with the Focus DSL for
   * legacy APIs that use null instead of {@link Optional}.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * record LegacyUser(String name, @Nullable String nickname) {}
   *
   * // Create an AffinePath directly for the nullable field
   * AffinePath&lt;LegacyUser, String&gt; nicknamePath = AffinePath.ofNullable(
   *     LegacyUser::nickname,
   *     (user, nickname) -&gt; new LegacyUser(user.name(), nickname)
   * );
   *
   * // Use like any AffinePath
   * LegacyUser user = new LegacyUser(&quot;Alice&quot;, null);
   * Optional&lt;String&gt; result = nicknamePath.getOptional(user);  // Optional.empty()
   *
   * LegacyUser updated = nicknamePath.set(&quot;Ally&quot;, user);
   * // LegacyUser[name=Alice, nickname=Ally]
   * }&lt;/pre&gt;
   *
   * @param getter extracts the potentially-null value from the source
   * @param setter creates a new source with the value set (receives non-null value)
   * @param &lt;S&gt; the source type
   * @param &lt;A&gt; the focused type (non-null)
   * @return an AffinePath that handles null safely
   */
  @SuppressWarnings(&quot;nullness&quot;) // Intentionally working with nullable values
  static &lt;S, A&gt; AffinePath&lt;S, A&gt; ofNullable(Function&lt;S, A&gt; getter, BiFunction&lt;S, A, S&gt; setter) {
<span class="fc" id="L621">    return of(Affine.of(s -&gt; Optional.ofNullable(getter.apply(s)), (s, a) -&gt; setter.apply(s, a)));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>