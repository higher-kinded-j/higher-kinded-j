<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FocusPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.focus</a> &gt; <span class="el_source">FocusPath.java</span></div><h1>FocusPath.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.focus;

import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Function;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Traverse;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.IdPath;
import org.higherkindedj.hkt.effect.MaybePath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.effect.TryPath;
import org.higherkindedj.optics.Affine;
import org.higherkindedj.optics.Each;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Iso;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.indexed.Pair;
import org.higherkindedj.optics.util.TraverseTraversals;
import org.jspecify.annotations.NullMarked;

/**
 * A type-safe path through a data structure that focuses on exactly one element.
 *
 * &lt;p&gt;FocusPath wraps a {@link Lens} and provides fluent navigation and composition methods. Use
 * this when navigating to fields that are guaranteed to exist.
 *
 * &lt;p&gt;In the Focus DSL hierarchy, FocusPath is the most specific type:
 *
 * &lt;pre&gt;
 *      FocusPath&lt;S, A&gt;     (exactly one element)
 *            │
 *      AffinePath&lt;S, A&gt;    (zero or one element)
 *            │
 *    TraversalPath&lt;S, A&gt;   (zero or more elements)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create from a lens
 * FocusPath&lt;User, String&gt; namePath = FocusPath.of(UserLenses.name());
 *
 * // Get a value
 * String name = namePath.get(user);
 *
 * // Set a value
 * User updated = namePath.set(&quot;Bob&quot;, user);
 *
 * // Modify a value
 * User modified = namePath.modify(String::toUpperCase, user);
 *
 * // Compose with another lens
 * FocusPath&lt;User, String&gt; cityPath = namePath.via(AddressLenses.city());
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; the source type (the whole structure)
 * @param &lt;A&gt; the focused value type (the part)
 * @see AffinePath for paths focusing on zero or one element
 * @see TraversalPath for paths focusing on zero or more elements
 * @see FocusPaths for utility methods and optics factories
 */
@NullMarked
public sealed interface FocusPath&lt;S, A&gt; permits LensFocusPath {

  /**
   * Extracts the focused value from the source.
   *
   * &lt;p&gt;This operation always succeeds because a FocusPath guarantees exactly one focused element.
   *
   * @param source the source structure
   * @return the focused value
   */
  A get(S source);

  /**
   * Creates a new source with the focused value replaced.
   *
   * &lt;p&gt;This operation is immutable; the original source is not modified.
   *
   * @param value the new value
   * @param source the source structure
   * @return a new structure with the updated value
   */
  S set(A value, S source);

  /**
   * Creates a new source with the focused value transformed.
   *
   * &lt;p&gt;This is equivalent to {@code set(f.apply(get(source)), source)}.
   *
   * @param f the transformation function
   * @param source the source structure
   * @return a new structure with the modified value
   */
  default S modify(Function&lt;A, A&gt; f, S source) {
<span class="fc" id="L105">    return set(f.apply(get(source)), source);</span>
  }

  /**
   * Transforms the focused value with an effectful function.
   *
   * &lt;p&gt;This method enables effectful modifications such as validation, async operations, or
   * computations that may fail. The effect is captured in the functor F.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Validation example
   * FocusPath&lt;User, String&gt; emailPath = UserFocus.email();
   *
   * Kind&lt;Validated.Witness, User&gt; result = emailPath.modifyF(
   *     email -&gt; EmailValidator.validate(email),
   *     user,
   *     ValidatedFunctor.INSTANCE
   * );
   *
   * // Optional example (transformation that may fail)
   * Kind&lt;OptionalKind.Witness, Config&gt; result = configPath.modifyF(
   *     value -&gt; parseConfig(value),  // Returns Optional
   *     config,
   *     OptionalFunctor.INSTANCE
   * );
   * }&lt;/pre&gt;
   *
   * @param f the effectful transformation function
   * @param source the source structure
   * @param functor the functor instance for the effect type F
   * @param &lt;F&gt; the effect type (e.g., Optional, Validated, IO)
   * @return the modified structure wrapped in the effect
   */
  default &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;&gt; Kind&lt;F, S&gt; modifyF(
      Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="fc" id="L142">    return toLens().modifyF(f, source, functor);</span>
  }

  // ===== Composition Methods =====

  /**
   * Composes this path with a lens to focus deeper into the structure.
   *
   * &lt;p&gt;The result is a FocusPath because both this path and the lens focus on exactly one element.
   *
   * @param lens the lens to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  &lt;B&gt; FocusPath&lt;S, B&gt; via(Lens&lt;A, B&gt; lens);

  /**
   * Composes this path with another FocusPath.
   *
   * &lt;p&gt;This is a convenience method that extracts the lens from the other path. The result is a
   * FocusPath because both paths focus on exactly one element.
   *
   * @param other the FocusPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  default &lt;B&gt; FocusPath&lt;S, B&gt; via(FocusPath&lt;A, B&gt; other) {
<span class="fc" id="L169">    return via(other.toLens());</span>
  }

  /**
   * Composes this path with an AffinePath.
   *
   * &lt;p&gt;This is a convenience method that extracts the affine from the other path. The result is an
   * AffinePath because the other path may have no focus.
   *
   * @param other the AffinePath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; via(AffinePath&lt;A, B&gt; other) {
<span class="fc" id="L183">    return via(other.toAffine());</span>
  }

  /**
   * Composes this path with a TraversalPath.
   *
   * &lt;p&gt;This is a convenience method that extracts the traversal from the other path. The result is
   * a TraversalPath because the other path may focus on multiple elements.
   *
   * @param other the TraversalPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; via(TraversalPath&lt;A, B&gt; other) {
<span class="fc" id="L197">    return via(other.toTraversal());</span>
  }

  /**
   * Composes this path with an iso to focus through a type conversion.
   *
   * &lt;p&gt;The result is a FocusPath because an iso is a lossless, reversible transformation.
   *
   * @param iso the iso to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  &lt;B&gt; FocusPath&lt;S, B&gt; via(Iso&lt;A, B&gt; iso);

  /**
   * Composes this path with a prism, producing an AffinePath.
   *
   * &lt;p&gt;The result is an AffinePath because the prism may not match (zero or one focus).
   *
   * @param prism the prism to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Prism&lt;A, B&gt; prism);

  /**
   * Composes this path with an affine, producing an AffinePath.
   *
   * &lt;p&gt;The result is an AffinePath because the affine may have no focus.
   *
   * @param affine the affine to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  &lt;B&gt; AffinePath&lt;S, B&gt; via(Affine&lt;A, B&gt; affine);

  /**
   * Composes this path with a traversal, producing a TraversalPath.
   *
   * &lt;p&gt;The result is a TraversalPath because the traversal may focus on multiple elements.
   *
   * @param traversal the traversal to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  &lt;B&gt; TraversalPath&lt;S, B&gt; via(Traversal&lt;A, B&gt; traversal);

  // ===== then() Aliases =====

  /**
   * Alias for {@link #via(Lens)}. Composes this path with a lens.
   *
   * &lt;p&gt;This method provides an alternative naming convention familiar to users of other optics
   * libraries.
   *
   * @param lens the lens to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  default &lt;B&gt; FocusPath&lt;S, B&gt; then(Lens&lt;A, B&gt; lens) {
<span class="fc" id="L257">    return via(lens);</span>
  }

  /**
   * Alias for {@link #via(FocusPath)}. Composes this path with another FocusPath.
   *
   * @param other the FocusPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  default &lt;B&gt; FocusPath&lt;S, B&gt; then(FocusPath&lt;A, B&gt; other) {
<span class="fc" id="L268">    return via(other);</span>
  }

  /**
   * Alias for {@link #via(Iso)}. Composes this path with an iso.
   *
   * @param iso the iso to compose with
   * @param &lt;B&gt; the new focused type
   * @return a new FocusPath focusing on the composed target
   */
  default &lt;B&gt; FocusPath&lt;S, B&gt; then(Iso&lt;A, B&gt; iso) {
<span class="fc" id="L279">    return via(iso);</span>
  }

  /**
   * Alias for {@link #via(Prism)}. Composes this path with a prism.
   *
   * @param prism the prism to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Prism&lt;A, B&gt; prism) {
<span class="fc" id="L290">    return via(prism);</span>
  }

  /**
   * Alias for {@link #via(Affine)}. Composes this path with an affine.
   *
   * @param affine the affine to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(Affine&lt;A, B&gt; affine) {
<span class="fc" id="L301">    return via(affine);</span>
  }

  /**
   * Alias for {@link #via(AffinePath)}. Composes this path with an AffinePath.
   *
   * @param other the AffinePath to compose with
   * @param &lt;B&gt; the new focused type
   * @return an AffinePath that may or may not focus on a value
   */
  default &lt;B&gt; AffinePath&lt;S, B&gt; then(AffinePath&lt;A, B&gt; other) {
<span class="fc" id="L312">    return via(other);</span>
  }

  /**
   * Alias for {@link #via(Traversal)}. Composes this path with a traversal.
   *
   * @param traversal the traversal to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; then(Traversal&lt;A, B&gt; traversal) {
<span class="fc" id="L323">    return via(traversal);</span>
  }

  /**
   * Alias for {@link #via(TraversalPath)}. Composes this path with a TraversalPath.
   *
   * @param other the TraversalPath to compose with
   * @param &lt;B&gt; the new focused type
   * @return a TraversalPath focusing on multiple elements
   */
  default &lt;B&gt; TraversalPath&lt;S, B&gt; then(TraversalPath&lt;A, B&gt; other) {
<span class="fc" id="L334">    return via(other);</span>
  }

  // ===== Collection Navigation =====

  /**
   * When the focused type is {@code List&lt;E&gt;}, traverses all elements.
   *
   * &lt;p&gt;This method requires that the focused type {@code A} is a {@code List&lt;E&gt;}. It returns a
   * TraversalPath that focuses on each element in the list.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // departments() returns FocusPath&lt;Company, List&lt;Department&gt;&gt;
   * TraversalPath&lt;Company, Department&gt; allDepts = CompanyFocus.departmentList().each();
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type of the list
   * @return a TraversalPath over list elements
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; TraversalPath&lt;S, E&gt; each() {
    // This cast is safe when A is List&lt;E&gt;
<span class="fc" id="L359">    return via((Traversal&lt;A, E&gt;) FocusPaths.listElements());</span>
  }

  /**
   * Traverses all elements using the provided {@link org.higherkindedj.optics.Each} instance.
   *
   * &lt;p&gt;This method provides type-safe traversal for any container type that has an Each instance.
   * Unlike the no-arg {@link #each()} method which only works with {@code List}, this method works
   * with any type that has an Each instance: Map, Set, Optional, Maybe, arrays, etc.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Using Each with a Map
   * Each&lt;Map&lt;String, Order&gt;, Order&gt; mapEach = EachInstances.mapValuesEach();
   * FocusPath&lt;User, Map&lt;String, Order&gt;&gt; ordersPath = UserFocus.orderMap();
   * TraversalPath&lt;User, Order&gt; allOrders = ordersPath.each(mapEach);
   *
   * // Using Each with Maybe (from EachExtensions)
   * Each&lt;Maybe&lt;Address&gt;, Address&gt; maybeEach = EachExtensions.maybeEach();
   * FocusPath&lt;User, Maybe&lt;Address&gt;&gt; addressPath = UserFocus.address();
   * TraversalPath&lt;User, Address&gt; address = addressPath.each(maybeEach);
   *
   * // Get all orders from all users
   * List&lt;Order&gt; orders = allOrders.getAll(user);
   * }&lt;/pre&gt;
   *
   * @param eachInstance the Each instance for the focused container type
   * @param &lt;E&gt; the element type within the container
   * @return a TraversalPath focusing on all elements
   * @see org.higherkindedj.optics.Each
   * @see org.higherkindedj.optics.each.EachInstances
   */
  default &lt;E&gt; TraversalPath&lt;S, E&gt; each(Each&lt;A, E&gt; eachInstance) {
<span class="fc" id="L393">    return via(eachInstance.each());</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the element at the specified index.
   *
   * &lt;p&gt;This method returns an AffinePath because the index may be out of bounds.
   *
   * @param index the index to focus on
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath that may be empty if the index is out of bounds
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; at(int index) {
<span class="fc" id="L408">    return via((Affine&lt;A, E&gt;) FocusPaths.listAt(index));</span>
  }

  /**
   * When the focused type is {@code Map&lt;K, V&gt;}, focuses on the value for the specified key.
   *
   * &lt;p&gt;This method returns an AffinePath because the key may not exist in the map.
   *
   * @param key the key to focus on
   * @param &lt;K&gt; the key type of the map
   * @param &lt;V&gt; the value type of the map
   * @return an AffinePath that may be empty if the key is not present
   * @throws ClassCastException if the focused type {@code A} is not a {@code Map}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;K, V&gt; AffinePath&lt;S, V&gt; atKey(K key) {
<span class="fc" id="L424">    return via((Affine&lt;A, V&gt;) FocusPaths.mapAt(key));</span>
  }

  /**
   * When the focused type is {@code Optional&lt;E&gt;}, unwraps to the inner value.
   *
   * &lt;p&gt;This method returns an AffinePath because the Optional may be empty.
   *
   * @param &lt;E&gt; the inner type of the Optional
   * @return an AffinePath that may be empty if the Optional is empty
   * @throws ClassCastException if the focused type {@code A} is not an {@code Optional}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; some() {
<span class="fc" id="L438">    return via((Affine&lt;A, E&gt;) FocusPaths.optionalSome());</span>
  }

  /**
   * When the focused type may be null, creates an AffinePath that safely handles null values.
   *
   * &lt;p&gt;This is useful for working with legacy APIs or records that use null to represent absent
   * values instead of {@link java.util.Optional}. The resulting AffinePath treats null as absent
   * (empty Optional) and non-null as present.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * record LegacyUser(String name, @Nullable String nickname) {}
   *
   * // Generate focus for the record (nickname is nullable)
   * FocusPath&lt;LegacyUser, @Nullable String&gt; nicknamePath = LegacyUserFocus.nickname();
   *
   * // Chain with nullable() to get null-safe access
   * AffinePath&lt;LegacyUser, String&gt; safeNickname = nicknamePath.nullable();
   *
   * // Now use it like any other AffinePath
   * LegacyUser user = new LegacyUser(&quot;Alice&quot;, null);
   * Optional&lt;String&gt; result = safeNickname.getOptional(user);  // Optional.empty()
   *
   * LegacyUser withNick = new LegacyUser(&quot;Bob&quot;, &quot;Bobby&quot;);
   * Optional&lt;String&gt; present = safeNickname.getOptional(withNick);  // Optional.of(&quot;Bobby&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the non-null element type
   * @return an AffinePath that treats null as absent
   * @see FocusPaths#nullable()
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; nullable() {
<span class="fc" id="L473">    return via((Affine&lt;A, E&gt;) FocusPaths.nullable());</span>
  }

  /**
   * When the focused value is a traversable container {@code Kind&lt;F, E&gt;}, creates a TraversalPath
   * that focuses on all elements within it.
   *
   * &lt;p&gt;This enables generic traversal over any type with a {@link org.higherkindedj.hkt.Traverse}
   * instance, not just {@code List}. For example, {@code Set}, {@code Tree}, or custom collections.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * // Given: User with Kind&lt;ListKind.Witness, Role&gt; roles field
   * FocusPath&lt;User, Kind&lt;ListKind.Witness, Role&gt;&gt; rolesPath = UserFocus.roles();
   *
   * // Traverse into the List elements using Traverse type class
   * TraversalPath&lt;User, Role&gt; allRoles = rolesPath.traverseOver(
   *     ListTraverse.INSTANCE
   * );
   *
   * // Now can operate on all roles
   * List&lt;Role&gt; roles = allRoles.getAll(user);
   * User updated = allRoles.modifyAll(Role::promote, user);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;For standard {@code List&lt;E&gt;} fields, prefer the {@link #each()} method which handles the
   * conversion automatically.
   *
   * @param &lt;F&gt; the witness type of the traversable container
   * @param &lt;E&gt; the element type within the container
   * @param traverse the Traverse instance for the container type
   * @return a TraversalPath focusing on all elements within the container
   * @see #each() for simpler List traversal
   * @see org.higherkindedj.optics.util.TraverseTraversals
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;F extends WitnessArity&lt;TypeArity.Unary&gt;, E&gt; TraversalPath&lt;S, E&gt; traverseOver(
      Traverse&lt;F&gt; traverse) {
<span class="fc" id="L512">    Traversal&lt;Kind&lt;F, E&gt;, E&gt; traversal = TraverseTraversals.forTraverse(traverse);</span>
<span class="fc" id="L513">    return via((Traversal&lt;A, E&gt;) traversal);</span>
  }

  // ===== List Decomposition Methods =====

  /**
   * When the focused type is {@code List&lt;E&gt;}, decomposes into head and tail.
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty. The decomposition follows
   * the classic functional programming &quot;cons&quot; pattern, viewing a non-empty list as a pair of its
   * first element (head) and remaining elements (tail).
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Given: FocusPath&lt;Order, List&lt;Item&gt;&gt; itemsPath
   * AffinePath&lt;Order, Pair&lt;Item, List&lt;Item&gt;&gt;&gt; headTail = itemsPath.cons();
   *
   * // Get head and tail
   * Optional&lt;Pair&lt;Item, List&lt;Item&gt;&gt;&gt; decomposed = headTail.getOptional(order);
   * decomposed.ifPresent(pair -&gt; {
   *     Item firstItem = pair.first();
   *     List&lt;Item&gt; remainingItems = pair.second();
   * });
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to a (head, tail) pair
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   * @see #headTail() for Java-familiar alias
   * @see #snoc() for init/last decomposition
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, Pair&lt;E, List&lt;E&gt;&gt;&gt; cons() {
<span class="fc" id="L547">    return via((Prism&lt;A, Pair&lt;E, List&lt;E&gt;&gt;&gt;) (Prism&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listCons());</span>
  }

  /**
   * Alias for {@link #cons()} using Java-familiar naming.
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to a (head, tail) pair
   * @see #cons()
   */
  default &lt;E&gt; AffinePath&lt;S, Pair&lt;E, List&lt;E&gt;&gt;&gt; headTail() {
<span class="fc" id="L558">    return cons();</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, decomposes into init and last.
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty. The decomposition follows
   * the &quot;snoc&quot; pattern (cons spelled backwards), viewing a non-empty list as a pair of all elements
   * except the last (init) and the last element.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Given: FocusPath&lt;Order, List&lt;Item&gt;&gt; itemsPath
   * AffinePath&lt;Order, Pair&lt;List&lt;Item&gt;, Item&gt;&gt; initLast = itemsPath.snoc();
   *
   * // Get init and last
   * Optional&lt;Pair&lt;List&lt;Item&gt;, Item&gt;&gt; decomposed = initLast.getOptional(order);
   * decomposed.ifPresent(pair -&gt; {
   *     List&lt;Item&gt; allButLast = pair.first();
   *     Item lastItem = pair.second();
   * });
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to an (init, last) pair
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   * @see #initLast() for Java-familiar alias
   * @see #cons() for head/tail decomposition
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, Pair&lt;List&lt;E&gt;, E&gt;&gt; snoc() {
<span class="fc" id="L590">    return via((Prism&lt;A, Pair&lt;List&lt;E&gt;, E&gt;&gt;) (Prism&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listSnoc());</span>
  }

  /**
   * Alias for {@link #snoc()} using Java-familiar naming.
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to an (init, last) pair
   * @see #snoc()
   */
  default &lt;E&gt; AffinePath&lt;S, Pair&lt;List&lt;E&gt;, E&gt;&gt; initLast() {
<span class="fc" id="L601">    return snoc();</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the head (first element).
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Given: FocusPath&lt;Order, List&lt;Item&gt;&gt; itemsPath
   * AffinePath&lt;Order, Item&gt; first = itemsPath.head();
   *
   * // Get the first item
   * Optional&lt;Item&gt; firstItem = first.getOptional(order);
   *
   * // Modify the first item
   * Order updated = first.modify(item -&gt; item.withDiscount(10), order);
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to the head element
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; head() {
<span class="fc" id="L628">    return via((Affine&lt;A, E&gt;) (Affine&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listHead());</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the last element.
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Given: FocusPath&lt;Order, List&lt;Item&gt;&gt; itemsPath
   * AffinePath&lt;Order, Item&gt; lastItem = itemsPath.last();
   *
   * // Get the last item
   * Optional&lt;Item&gt; last = lastItem.getOptional(order);
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to the last element
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, E&gt; last() {
<span class="fc" id="L652">    return via((Affine&lt;A, E&gt;) (Affine&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listLast());</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the tail (all elements except first).
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty.
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to the tail
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, List&lt;E&gt;&gt; tail() {
<span class="fc" id="L666">    return via((Affine&lt;A, List&lt;E&gt;&gt;) (Affine&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listTail());</span>
  }

  /**
   * When the focused type is {@code List&lt;E&gt;}, focuses on the init (all elements except last).
   *
   * &lt;p&gt;This method returns an AffinePath because the list may be empty.
   *
   * @param &lt;E&gt; the element type of the list
   * @return an AffinePath to the init
   * @throws ClassCastException if the focused type {@code A} is not a {@code List}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;E&gt; AffinePath&lt;S, List&lt;E&gt;&gt; init() {
<span class="fc" id="L680">    return via((Affine&lt;A, List&lt;E&gt;&gt;) (Affine&lt;?, ?&gt;) FocusPaths.&lt;E&gt;listInit());</span>
  }

  // ===== Conversion Methods =====

  /**
   * Extracts the underlying lens.
   *
   * @return the wrapped Lens
   */
  Lens&lt;S, A&gt; toLens();

  /**
   * Views this path as an AffinePath.
   *
   * &lt;p&gt;This is always valid because a FocusPath (exactly one) is a special case of AffinePath (zero
   * or one).
   *
   * @return an AffinePath view of this path
   */
  default AffinePath&lt;S, A&gt; asAffine() {
<span class="fc" id="L701">    Lens&lt;S, A&gt; lens = toLens();</span>
<span class="fc" id="L702">    return AffinePath.of(Affine.of(s -&gt; Optional.of(lens.get(s)), (s, a) -&gt; lens.set(a, s)));</span>
  }

  /**
   * Views this path as a TraversalPath.
   *
   * &lt;p&gt;This is always valid because a FocusPath (exactly one) is a special case of TraversalPath
   * (zero or more).
   *
   * @return a TraversalPath view of this path
   */
  default TraversalPath&lt;S, A&gt; asTraversal() {
<span class="fc" id="L714">    return TraversalPath.of(toLens().asTraversal());</span>
  }

  /**
   * Views this path as a Fold.
   *
   * @return a Fold view of the underlying lens
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L723">    return toLens().asFold();</span>
  }

  // ===== Debugging =====

  /**
   * Creates a new FocusPath that invokes an observer during get operations.
   *
   * &lt;p&gt;This method is useful for debugging complex path navigations by logging or inspecting values
   * as they are accessed.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;Company, String&gt; debugPath = CompanyFocus.ceo().name()
   *     .traced((company, name) -&gt; log.debug(&quot;Accessing CEO name: {} from {}&quot;, name, company));
   *
   * // Every get() call will now log the accessed value
   * String name = debugPath.get(company);
   * }&lt;/pre&gt;
   *
   * @param observer a consumer that receives the source and focused value during get operations
   * @return a new FocusPath that invokes the observer
   */
  default FocusPath&lt;S, A&gt; traced(BiConsumer&lt;S, A&gt; observer) {
<span class="fc" id="L748">    FocusPath&lt;S, A&gt; self = this;</span>
<span class="fc" id="L749">    return FocusPath.of(</span>
<span class="fc" id="L750">        Lens.of(</span>
            s -&gt; {
<span class="fc" id="L752">              A a = self.get(s);</span>
<span class="fc" id="L753">              observer.accept(s, a);</span>
<span class="fc" id="L754">              return a;</span>
            },
<span class="fc" id="L756">            (s, a) -&gt; self.set(a, s)));</span>
  }

  // ===== Effect Path Bridge Methods =====

  /**
   * Extracts the focused value and wraps it in a {@link MaybePath}.
   *
   * &lt;p&gt;This bridges from the optics domain to the effect domain, allowing the extracted value to be
   * used in effect-based computations. Since FocusPath always focuses on exactly one element, the
   * result is always a Just (non-empty) MaybePath.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;User, String&gt; namePath = UserFocus.name();
   * User user = new User(&quot;Alice&quot;, address);
   *
   * // Extract and process with effect operations
   * MaybePath&lt;String&gt; result = namePath.toMaybePath(user)
   *     .map(String::toUpperCase)
   *     .filter(name -&gt; !name.isEmpty());
   * }&lt;/pre&gt;
   *
   * @param source the source structure
   * @return a MaybePath containing the focused value
   */
  default MaybePath&lt;A&gt; toMaybePath(S source) {
<span class="fc" id="L784">    return Path.just(get(source));</span>
  }

  /**
   * Extracts the focused value and wraps it in an {@link EitherPath}.
   *
   * &lt;p&gt;This bridges from the optics domain to the effect domain for error-handling computations.
   * Since FocusPath always focuses on exactly one element, the result is always a Right (success)
   * EitherPath.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;User, String&gt; emailPath = UserFocus.email();
   * User user = new User(&quot;Alice&quot;, &quot;alice@example.com&quot;);
   *
   * // Extract and validate
   * EitherPath&lt;ValidationError, String&gt; result = emailPath.&lt;ValidationError&gt;toEitherPath(user)
   *     .via(email -&gt; validateEmail(email));
   * }&lt;/pre&gt;
   *
   * @param source the source structure
   * @param &lt;E&gt; the error type (phantom for success case)
   * @return an EitherPath containing the focused value as Right
   */
  default &lt;E&gt; EitherPath&lt;E, A&gt; toEitherPath(S source) {
<span class="fc" id="L810">    return Path.right(get(source));</span>
  }

  /**
   * Extracts the focused value and wraps it in a {@link TryPath}.
   *
   * &lt;p&gt;This bridges from the optics domain to the effect domain for exception-handling
   * computations. Since FocusPath always focuses on exactly one element, the result is always a
   * Success TryPath.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;Config, String&gt; urlPath = ConfigFocus.apiUrl();
   * Config config = new Config(&quot;https://api.example.com&quot;);
   *
   * // Extract and parse
   * TryPath&lt;URI&gt; result = urlPath.toTryPath(config)
   *     .via(url -&gt; Path.tryOf(() -&gt; new URI(url)));
   * }&lt;/pre&gt;
   *
   * @param source the source structure
   * @return a TryPath containing the focused value as Success
   */
  default TryPath&lt;A&gt; toTryPath(S source) {
<span class="fc" id="L835">    return Path.success(get(source));</span>
  }

  /**
   * Extracts the focused value and wraps it in an {@link IdPath}.
   *
   * &lt;p&gt;This bridges from the optics domain to the effect domain using the identity effect. IdPath
   * is useful when you need a consistent Path interface but don't require any effect semantics.
   *
   * &lt;h2&gt;Example Usage&lt;/h2&gt;
   *
   * &lt;pre&gt;{@code
   * FocusPath&lt;User, String&gt; namePath = UserFocus.name();
   * User user = new User(&quot;Alice&quot;, address);
   *
   * // Extract as IdPath for composition with other paths
   * IdPath&lt;String&gt; result = namePath.toIdPath(user)
   *     .map(String::toUpperCase);
   * }&lt;/pre&gt;
   *
   * @param source the source structure
   * @return an IdPath containing the focused value
   */
  default IdPath&lt;A&gt; toIdPath(S source) {
<span class="fc" id="L859">    return Path.id(get(source));</span>
  }

  // ===== Factory Methods =====

  /**
   * Creates a FocusPath from a lens.
   *
   * @param lens the lens to wrap
   * @param &lt;S&gt; the source type
   * @param &lt;A&gt; the focused type
   * @return a new FocusPath
   */
  static &lt;S, A&gt; FocusPath&lt;S, A&gt; of(Lens&lt;S, A&gt; lens) {
<span class="fc" id="L873">    return new LensFocusPath&lt;&gt;(lens);</span>
  }

  /**
   * Creates an identity FocusPath that focuses on the source itself.
   *
   * &lt;p&gt;This is useful as a starting point for path composition.
   *
   * @param &lt;S&gt; the source/target type
   * @return an identity FocusPath
   */
  static &lt;S&gt; FocusPath&lt;S, S&gt; identity() {
<span class="fc" id="L885">    return of(Lens.of(Function.identity(), (s, a) -&gt; a));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>