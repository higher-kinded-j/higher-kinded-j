// Generated by hkj-optics-processor. Do not edit.
package com.test.optics;

import com.test.Nested;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.Generated;
import org.higherkindedj.optics.util.Traversals;

/**
 * Generated optics for {@link Nested}. Do not edit.
 */
@Generated
public final class NestedLenses {
  private NestedLenses() {
  }

  /**
   * Creates a {@link Lens} for the {@code name} field of a {@link Nested}.
   *
   * @return A non-null {@code Lens<Nested, String>}.
   */
  public static Lens<Nested, String> name() {
    return Lens.of(Nested::name, (source, newValue) -> new Nested(newValue, source.description(), source.tags()));
  }

  /**
   * Creates a {@link Lens} for the {@code description} field of a {@link Nested}.
   *
   * @return A non-null {@code Lens<Nested, Optional<String>>}.
   */
  public static Lens<Nested, Optional<String>> description() {
    return Lens.of(Nested::description, (source, newValue) -> new Nested(source.name(), newValue, source.tags()));
  }

  /**
   * Creates a {@link Lens} for the {@code tags} field of a {@link Nested}.
   *
   * @return A non-null {@code Lens<Nested, List<String>>}.
   */
  public static Lens<Nested, List<String>> tags() {
    return Lens.of(Nested::tags, (source, newValue) -> new Nested(source.name(), source.description(), newValue));
  }

  /**
   * Creates a new {@link Nested} instance with an updated {@code name} field.
   * <p>This is a convenience method that uses the {@link #name()} lens.
   *
   * @param source The original {@code Nested} instance.
   * @param newName The new value for the {@code name} field.
   * @return A new, updated {@code Nested} instance.
   */
  public static Nested withName(Nested source, String newName) {
    return name().set(newName, source);
  }

  /**
   * Creates a new {@link Nested} instance with an updated {@code description} field.
   * <p>This is a convenience method that uses the {@link #description()} lens.
   *
   * @param source The original {@code Nested} instance.
   * @param newDescription The new value for the {@code description} field.
   * @return A new, updated {@code Nested} instance.
   */
  public static Nested withDescription(Nested source, Optional<String> newDescription) {
    return description().set(newDescription, source);
  }

  /**
   * Creates a new {@link Nested} instance with an updated {@code tags} field.
   * <p>This is a convenience method that uses the {@link #tags()} lens.
   *
   * @param source The original {@code Nested} instance.
   * @param newTags The new value for the {@code tags} field.
   * @return A new, updated {@code Nested} instance.
   */
  public static Nested withTags(Nested source, List<String> newTags) {
    return tags().set(newTags, source);
  }

  /**
   * Creates a {@link Traversal} for the {@code description} field of a {@link Nested}.
   * <p>This traversal focuses on all items within the {@code description} collection, allowing an effectful function
   * to be applied to each one.
   *
   * @return A non-null {@code Traversal<Nested, String>}.
   */
  public static Traversal<Nested, String> descriptionTraversal() {
    return new Traversal<Nested, String>() {
      @Override
      public <F extends WitnessArity<TypeArity.Unary>> Kind<F, Nested> modifyF(
          Function<String, Kind<F, String>> f, Nested source, Applicative<F> applicative) {
        final Optional<String> optional = source.description();
        if (optional.isPresent()) {
          final var g_of_b = f.apply(optional.get());
          @SuppressWarnings("unchecked") final var g_of_b_casted = (Kind<F, String>) g_of_b;
          return applicative.map(newValue -> new Nested(source.name(), Optional.of(newValue), source.tags()), g_of_b_casted);
        } else {
          return applicative.of(source);
        }
      }
    };
  }

  /**
   * Creates a {@link Traversal} for the {@code tags} field of a {@link Nested}.
   * <p>This traversal focuses on all items within the {@code tags} collection, allowing an effectful function
   * to be applied to each one.
   *
   * @return A non-null {@code Traversal<Nested, String>}.
   */
  public static Traversal<Nested, String> tagsTraversal() {
    return new Traversal<Nested, String>() {
      @Override
      public <F extends WitnessArity<TypeArity.Unary>> Kind<F, Nested> modifyF(
          Function<String, Kind<F, String>> f, Nested source, Applicative<F> applicative) {
        final var effectOfList = Traversals.traverseList(source.tags(), f, applicative);
        return applicative.map(newList -> new Nested(source.name(), source.description(), newList), effectOfList);
      }
    };
  }
}
