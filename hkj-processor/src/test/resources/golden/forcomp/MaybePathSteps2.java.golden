// Generated by hkj-processor. Do not edit.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.effect.MaybePath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeKindHelper;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.optics.annotations.Generated;

/** Step 2 in a MaybePath comprehension. */
@Generated
public final class MaybePathSteps2<A, B> {

  private static final MaybeMonad MONAD = MaybeMonad.INSTANCE;
  private final Kind<MaybeKind.Witness, Tuple2<A, B>> computation;

  MaybePathSteps2(Kind<MaybeKind.Witness, Tuple2<A, B>> computation) {
    this.computation = computation;
  }

  public <C> MaybePathSteps3<A, B, C> from(
      Function<Tuple2<A, B>, MaybePath<C>> next) {
    Kind<MaybeKind.Witness, Tuple3<A, B, C>> newComp =
        MONAD.flatMap(
            t -> MONAD.map(
                c -> Tuple.of(t._1(), t._2(), c),
                MaybeKindHelper.MAYBE.widen(next.apply(t).run())),
            computation);
    return new MaybePathSteps3<>(newComp);
  }

  public <C> MaybePathSteps3<A, B, C> let(
      Function<Tuple2<A, B>, C> f) {
    Kind<MaybeKind.Witness, Tuple3<A, B, C>> newComp =
        MONAD.map(
            t -> Tuple.of(t._1(), t._2(), f.apply(t)),
            computation);
    return new MaybePathSteps3<>(newComp);
  }

  public <C> MaybePathSteps3<A, B, C> focus(
      Function<Tuple2<A, B>, C> extractor) {
    Objects.requireNonNull(extractor, "extractor must not be null");
    return let(extractor);
  }

  public MaybePathSteps2<A, B> when(
      Predicate<Tuple2<A, B>> predicate) {
    Kind<MaybeKind.Witness, Tuple2<A, B>> newComp =
        MONAD.flatMap(
            t -> predicate.test(t) ? MONAD.of(t) : MONAD.zero(),
            computation);
    return new MaybePathSteps2<>(newComp);
  }

  public <C> MaybePathSteps3<A, B, C> match(
      Function<Tuple2<A, B>, Optional<C>> matcher) {
    Objects.requireNonNull(matcher, "matcher must not be null");
    Kind<MaybeKind.Witness, Tuple3<A, B, C>> newComp =
        MONAD.flatMap(
            t ->
                matcher
                    .apply(t)
                    .map(c -> MONAD.of(Tuple.of(t._1(), t._2(), c)))
                    .orElseGet(MONAD::zero),
            this.computation);
    return new MaybePathSteps3<>(newComp);
  }

  public <R> MaybePath<R> yield(BiFunction<A, B, R> f) {
    Kind<MaybeKind.Witness, R> result =
        MONAD.map(
            t -> Objects.requireNonNull(
                f.apply(t._1(), t._2()),
                "The yield function must not return null."),
            computation);
    return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));
  }

  public <R> MaybePath<R> yield(Function<Tuple2<A, B>, R> f) {
    Kind<MaybeKind.Witness, R> result =
        MONAD.map(
            t -> Objects.requireNonNull(f.apply(t), "The yield function must not return null."),
            computation);
    return Path.maybe(MaybeKindHelper.MAYBE.narrow(result));
  }
}
