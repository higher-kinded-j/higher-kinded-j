// Generated by hkj-processor. Do not edit.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.function.Function;
import java.util.function.BiFunction;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple3;
import org.higherkindedj.optics.annotations.Generated;

/** Step 2 in a non-filterable for-comprehension. */
@Generated
public final class MonadicSteps2<M extends WitnessArity<TypeArity.Unary>, A, B>
    implements For.Steps<M> {

  private final Monad<M> monad;
  private final Kind<M, Tuple2<A, B>> computation;

  MonadicSteps2(Monad<M> monad, Kind<M, Tuple2<A, B>> computation) {
    this.monad = monad;
    this.computation = computation;
  }

  public <C> MonadicSteps3<M, A, B, C> from(
      Function<Tuple2<A, B>, Kind<M, C>> next) {
    Kind<M, Tuple3<A, B, C>> newComputation =
        monad.flatMap(
            t -> monad.map(
                c -> Tuple.of(t._1(), t._2(), c),
                next.apply(t)),
            this.computation);
    return new MonadicSteps3<>(monad, newComputation);
  }

  public <C> MonadicSteps3<M, A, B, C> let(
      Function<Tuple2<A, B>, C> f) {
    Kind<M, Tuple3<A, B, C>> newComputation =
        monad.map(
            t -> Tuple.of(t._1(), t._2(), f.apply(t)),
            this.computation);
    return new MonadicSteps3<>(monad, newComputation);
  }

  public <C> MonadicSteps3<M, A, B, C> focus(
      Function<Tuple2<A, B>, C> extractor) {
    Objects.requireNonNull(extractor, "extractor must not be null");
    Kind<M, Tuple3<A, B, C>> newComputation =
        monad.map(
            t -> Tuple.of(t._1(), t._2(), extractor.apply(t)),
            this.computation);
    return new MonadicSteps3<>(monad, newComputation);
  }

  public <S> ForState.Steps<M, S> toState(BiFunction<A, B, S> constructor) {
    Objects.requireNonNull(constructor, "constructor must not be null");
    return ForState.withState(monad, monad.map(
        t -> constructor.apply(t._1(), t._2()),
        computation));
  }

  public <S> ForState.Steps<M, S> toState(Function<Tuple2<A, B>, S> constructor) {
    Objects.requireNonNull(constructor, "constructor must not be null");
    return ForState.withState(monad, monad.map(constructor, computation));
  }

  public <R> Kind<M, R> yield(BiFunction<A, B, R> f) {
    return monad.map(
        t -> Objects.requireNonNull(
            f.apply(t._1(), t._2()),
            "The yield function must not return null."),
        computation);
  }

  public <R> Kind<M, R> yield(Function<Tuple2<A, B>, R> f) {
    return monad.map(f, computation);
  }
}
