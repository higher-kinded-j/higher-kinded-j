// Generated by hkj-processor. Do not edit.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.effect.GenericPath;
import org.higherkindedj.hkt.function.Function6;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple6;
import org.higherkindedj.hkt.tuple.Tuple7;
import org.higherkindedj.optics.annotations.Generated;

/** Step 6 in a GenericPath comprehension. */
@Generated
public final class GenericPathSteps6<F extends WitnessArity<TypeArity.Unary>, A, B, C, D, E, G> {

  private final Monad<F> monad;
  private final Kind<F, Tuple6<A, B, C, D, E, G>> computation;

  GenericPathSteps6(Monad<F> monad, Kind<F, Tuple6<A, B, C, D, E, G>> computation) {
    this.monad = monad;
    this.computation = computation;
  }

  public <H> GenericPathSteps7<F, A, B, C, D, E, G, H> from(
      Function<Tuple6<A, B, C, D, E, G>, GenericPath<F, H>> next) {
    Kind<F, Tuple7<A, B, C, D, E, G, H>> newComp =
        monad.flatMap(
            t -> monad.map(
                h -> Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), h),
                next.apply(t).runKind()),
            computation);
    return new GenericPathSteps7<>(monad, newComp);
  }

  public <H> GenericPathSteps7<F, A, B, C, D, E, G, H> let(
      Function<Tuple6<A, B, C, D, E, G>, H> f) {
    Kind<F, Tuple7<A, B, C, D, E, G, H>> newComp =
        monad.map(
            t -> Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), f.apply(t)),
            computation);
    return new GenericPathSteps7<>(monad, newComp);
  }

  public <H> GenericPathSteps7<F, A, B, C, D, E, G, H> focus(
      Function<Tuple6<A, B, C, D, E, G>, H> extractor) {
    Objects.requireNonNull(extractor, "extractor must not be null");
    return let(extractor);
  }

  public <R> GenericPath<F, R> yield(Function6<A, B, C, D, E, G, R> f) {
    Kind<F, R> result =
        monad.map(
            t -> Objects.requireNonNull(
                f.apply(t._1(), t._2(), t._3(), t._4(), t._5(), t._6()),
                "The yield function must not return null."),
            computation);
    return GenericPath.of(result, monad);
  }

  public <R> GenericPath<F, R> yield(Function<Tuple6<A, B, C, D, E, G>, R> f) {
    Kind<F, R> result =
        monad.map(
            t -> Objects.requireNonNull(f.apply(t), "The yield function must not return null."),
            computation);
    return GenericPath.of(result, monad);
  }
}
