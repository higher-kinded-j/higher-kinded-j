// Generated by hkj-processor. Do not edit.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.function.Function9;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple9;
import org.higherkindedj.hkt.tuple.Tuple10;
import org.higherkindedj.optics.annotations.Generated;

/** Step 9 in a filterable for-comprehension. */
@Generated
public final class FilterableSteps9<M extends WitnessArity<TypeArity.Unary>, A, B, C, D, E, F, G, H, I>
    implements For.Steps<M> {

  private final MonadZero<M> monad;
  private final Kind<M, Tuple9<A, B, C, D, E, F, G, H, I>> computation;

  FilterableSteps9(MonadZero<M> monad, Kind<M, Tuple9<A, B, C, D, E, F, G, H, I>> computation) {
    this.monad = monad;
    this.computation = computation;
  }

  public <J> FilterableSteps10<M, A, B, C, D, E, F, G, H, I, J> from(
      Function<Tuple9<A, B, C, D, E, F, G, H, I>, Kind<M, J>> next) {
    Kind<M, Tuple10<A, B, C, D, E, F, G, H, I, J>> newComputation =
        monad.flatMap(
            t -> monad.map(
                j -> Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), t._7(), t._8(), t._9(), j),
                next.apply(t)),
            this.computation);
    return new FilterableSteps10<>(monad, newComputation);
  }

  public <J> FilterableSteps10<M, A, B, C, D, E, F, G, H, I, J> let(
      Function<Tuple9<A, B, C, D, E, F, G, H, I>, J> f) {
    Kind<M, Tuple10<A, B, C, D, E, F, G, H, I, J>> newComputation =
        monad.map(
            t -> Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), t._7(), t._8(), t._9(), f.apply(t)),
            this.computation);
    return new FilterableSteps10<>(monad, newComputation);
  }

  public <J> FilterableSteps10<M, A, B, C, D, E, F, G, H, I, J> focus(
      Function<Tuple9<A, B, C, D, E, F, G, H, I>, J> extractor) {
    Objects.requireNonNull(extractor, "extractor must not be null");
    Kind<M, Tuple10<A, B, C, D, E, F, G, H, I, J>> newComputation =
        monad.map(
            t -> Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), t._7(), t._8(), t._9(), extractor.apply(t)),
            this.computation);
    return new FilterableSteps10<>(monad, newComputation);
  }

  public <J> FilterableSteps10<M, A, B, C, D, E, F, G, H, I, J> match(
      Function<Tuple9<A, B, C, D, E, F, G, H, I>, Optional<J>> matcher) {
    Objects.requireNonNull(matcher, "matcher must not be null");
    Kind<M, Tuple10<A, B, C, D, E, F, G, H, I, J>> newComputation =
        monad.flatMap(
            t ->
                matcher
                    .apply(t)
                    .map(j -> monad.of(Tuple.of(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), t._7(), t._8(), t._9(), j)))
                    .orElseGet(monad::zero),
            this.computation);
    return new FilterableSteps10<>(monad, newComputation);
  }

  public FilterableSteps9<M, A, B, C, D, E, F, G, H, I> when(
      Predicate<Tuple9<A, B, C, D, E, F, G, H, I>> filter) {
    Kind<M, Tuple9<A, B, C, D, E, F, G, H, I>> newComputation =
        monad.flatMap(
            t -> filter.test(t) ? monad.of(t) : monad.zero(),
            this.computation);
    return new FilterableSteps9<>(monad, newComputation);
  }

  public <R> Kind<M, R> yield(Function9<A, B, C, D, E, F, G, H, I, R> f) {
    return monad.map(
        t -> Objects.requireNonNull(
            f.apply(t._1(), t._2(), t._3(), t._4(), t._5(), t._6(), t._7(), t._8(), t._9()),
            "The yield function must not return null."),
        computation);
  }

  public <R> Kind<M, R> yield(Function<Tuple9<A, B, C, D, E, F, G, H, I>, R> f) {
    return monad.map(f, computation);
  }
}
