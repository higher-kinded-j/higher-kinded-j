// Generated by hkj-processor. Do not edit.
package org.higherkindedj.hkt.tuple;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.util.validation.Validation;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.Generated;

/**
 * An immutable tuple containing 2 elements of potentially different types.
 *
 * <p>As a {@link java.lang.Record}, it automatically provides a canonical constructor,
 * accessors (e.g., {@code _1()}, {@code _2()}), and implementations for {@code equals()},
 * {@code hashCode()}, and {@code toString()}.
 *
 * @param <A> The type of the first element.
 * @param <B> The type of the second element.
 * @param _1 The first element of the tuple.
 * @param _2 The second element of the tuple.
 */
@Generated
@GenerateLenses
public record Tuple2<A, B>(A _1, B _2) implements Tuple {

  @SuppressWarnings("rawtypes")
  private static final Class<Tuple2> TUPLE2_CLASS = Tuple2.class;

  /**
   * Transforms both elements of this tuple using the provided mapping functions.
   *
   * <p>This is the fundamental bifunctor operation for {@code Tuple2}, allowing
   * simultaneous transformation of both elements.
   *
   * @param firstMapper The non-null function to apply to the first element.
   * @param secondMapper The non-null function to apply to the second element.
   * @param <C> The type of the first element in the resulting tuple.
   * @param <D> The type of the second element in the resulting tuple.
   * @return A new {@code Tuple2} with both elements transformed.
   * @throws NullPointerException if either mapper is null.
   */
  public <C, D> Tuple2<C, D> bimap(
      Function<? super A, ? extends C> firstMapper, Function<? super B, ? extends D> secondMapper) {
    Validation.function().requireMapper(firstMapper, "firstMapper", TUPLE2_CLASS, BIMAP);
    Validation.function().requireMapper(secondMapper, "secondMapper", TUPLE2_CLASS, BIMAP);

    return new Tuple2<>(firstMapper.apply(_1), secondMapper.apply(_2));
  }

  /**
   * Transforms all 2 elements of this tuple using the provided mapping functions.
   *
   * @param firstMapper The non-null function to apply to the first element.
   * @param secondMapper The non-null function to apply to the second element.
   * @param <A2> The type of the first element in the resulting tuple.
   * @param <B2> The type of the second element in the resulting tuple.
   * @return A new {@code Tuple2} with all elements transformed.
   * @throws NullPointerException if any mapper is null.
   */
  public <A2, B2> Tuple2<A2, B2> map(
      Function<? super A, ? extends A2> firstMapper,
      Function<? super B, ? extends B2> secondMapper) {
    Validation.function().requireMapper(firstMapper, "firstMapper", TUPLE2_CLASS, MAP);
    Validation.function().requireMapper(secondMapper, "secondMapper", TUPLE2_CLASS, MAP);

    return new Tuple2<>(
        firstMapper.apply(_1),
        secondMapper.apply(_2));
  }

  /**
   * Transforms only the first element of this tuple.
   *
   * @param firstMapper The non-null function to apply to the first element.
   * @param <A2> The type of the first element in the resulting tuple.
   * @return A new {@code Tuple2} with the first element transformed.
   * @throws NullPointerException if {@code firstMapper} is null.
   */
  public <A2> Tuple2<A2, B> mapFirst(Function<? super A, ? extends A2> firstMapper) {
    Validation.function().requireMapper(firstMapper, "firstMapper", TUPLE2_CLASS, MAP_FIRST);
    return new Tuple2<>(firstMapper.apply(_1), _2);
  }

  /**
   * Transforms only the second element of this tuple.
   *
   * @param secondMapper The non-null function to apply to the second element.
   * @param <B2> The type of the second element in the resulting tuple.
   * @return A new {@code Tuple2} with the second element transformed.
   * @throws NullPointerException if {@code secondMapper} is null.
   */
  public <B2> Tuple2<A, B2> mapSecond(Function<? super B, ? extends B2> secondMapper) {
    Validation.function().requireMapper(secondMapper, "secondMapper", TUPLE2_CLASS, MAP_SECOND);
    return new Tuple2<>(_1, secondMapper.apply(_2));
  }

}
