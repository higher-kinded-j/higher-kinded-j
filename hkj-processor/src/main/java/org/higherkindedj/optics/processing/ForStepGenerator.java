// Copyright (c) 2025 - 2026 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import java.io.IOException;
import java.io.Writer;
import javax.annotation.processing.ProcessingEnvironment;

/**
 * Generates {@code MonadicStepsN} and {@code FilterableStepsN} as top-level public classes in the
 * {@code org.higherkindedj.hkt.expression} package.
 *
 * <p>These classes extend the hand-written for-comprehension builder to higher arities.
 */
final class ForStepGenerator {

  private static final String PACKAGE = "org.higherkindedj.hkt.expression";
  private static final String[] TYPE_PARAMS = {
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"
  };

  private ForStepGenerator() {}

  static void generate(int minArity, int maxArity, ProcessingEnvironment processingEnv)
      throws IOException {
    for (int n = minArity; n <= maxArity; n++) {
      generateMonadicSteps(n, maxArity, processingEnv);
      generateFilterableSteps(n, maxArity, processingEnv);
    }
  }

  // ---------------------------------------------------------------------------
  // MonadicStepsN
  // ---------------------------------------------------------------------------

  private static void generateMonadicSteps(int n, int maxArity, ProcessingEnvironment processingEnv)
      throws IOException {
    boolean terminal = (n == maxArity);
    String className = "MonadicSteps" + n;
    String qualifiedName = PACKAGE + "." + className;

    StringBuilder sb = new StringBuilder();

    // Header
    sb.append("// Generated by hkj-processor. Do not edit.\n");
    sb.append("package ").append(PACKAGE).append(";\n\n");

    // Imports
    sb.append("import java.util.Objects;\n");
    sb.append("import java.util.function.Function;\n");
    if (n == 2) {
      sb.append("import java.util.function.BiFunction;\n");
    }
    sb.append("import org.higherkindedj.hkt.Kind;\n");
    sb.append("import org.higherkindedj.hkt.Monad;\n");
    sb.append("import org.higherkindedj.hkt.TypeArity;\n");
    sb.append("import org.higherkindedj.hkt.WitnessArity;\n");
    appendFunctionImport(sb, n);
    appendTupleImports(sb, n, terminal);
    sb.append("import org.higherkindedj.optics.annotations.Generated;\n");
    sb.append("\n");

    // Class declaration
    sb.append("/** Step ").append(n).append(" in a non-filterable for-comprehension. */\n");
    sb.append("@Generated\n");
    sb.append("public final class ")
        .append(className)
        .append("<M extends WitnessArity<TypeArity.Unary>");
    for (int i = 0; i < n; i++) {
      sb.append(", ").append(TYPE_PARAMS[i]);
    }
    sb.append(">\n    implements For.Steps<M> {\n\n");

    // Fields
    sb.append("  private final Monad<M> monad;\n");
    sb.append("  private final Kind<M, Tuple").append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">> computation;\n\n");

    // Constructor (package-private)
    sb.append("  ")
        .append(className)
        .append("(Monad<M> monad, Kind<M, Tuple")
        .append(n)
        .append("<");
    appendTypeParams(sb, n);
    sb.append(">> computation) {\n");
    sb.append("    this.monad = monad;\n");
    sb.append("    this.computation = computation;\n");
    sb.append("  }\n\n");

    // from(), let(), focus() - only if not terminal
    if (!terminal) {
      int next = n + 1;
      String nextType = TYPE_PARAMS[n]; // e.g. for n=6, nextType = "G"
      String nextClassName = "MonadicSteps" + next;

      // from()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> from(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, Kind<M, ").append(nextType).append(">> next) {\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.flatMap(\n");
      sb.append("            t -> monad.map(\n");
      sb.append("                ").append(nextType.toLowerCase()).append(" -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append(nextType.toLowerCase()).append("),\n");
      sb.append("                next.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");

      // let()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> let(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, ").append(nextType).append("> f) {\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.map(\n");
      sb.append("            t -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append("f.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");

      // focus()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> focus(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, ").append(nextType).append("> extractor) {\n");
      sb.append("    Objects.requireNonNull(extractor, \"extractor must not be null\");\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.map(\n");
      sb.append("            t -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append("extractor.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");
    }

    // toState with spread function
    generateToStateSpread(sb, n, "Monad", "ForState.Steps");

    // toState with Function<TupleN, S>
    generateToStateTuple(sb, n, "Monad", "ForState.Steps");

    // yield with spread function
    generateYieldSpread(sb, n);

    // yield with Function<TupleN, R>
    generateYieldTuple(sb, n);

    sb.append("}\n");

    Writer writer = processingEnv.getFiler().createSourceFile(qualifiedName).openWriter();
    writer.write(sb.toString());
    writer.close();
  }

  // ---------------------------------------------------------------------------
  // FilterableStepsN
  // ---------------------------------------------------------------------------

  private static void generateFilterableSteps(
      int n, int maxArity, ProcessingEnvironment processingEnv) throws IOException {
    boolean terminal = (n == maxArity);
    String className = "FilterableSteps" + n;
    String qualifiedName = PACKAGE + "." + className;

    StringBuilder sb = new StringBuilder();

    // Header
    sb.append("// Generated by hkj-processor. Do not edit.\n");
    sb.append("package ").append(PACKAGE).append(";\n\n");

    // Imports
    sb.append("import java.util.Objects;\n");
    sb.append("import java.util.Optional;\n");
    sb.append("import java.util.function.Function;\n");
    if (n == 2) {
      sb.append("import java.util.function.BiFunction;\n");
    }
    sb.append("import java.util.function.Predicate;\n");
    sb.append("import org.higherkindedj.hkt.Kind;\n");
    sb.append("import org.higherkindedj.hkt.MonadZero;\n");
    sb.append("import org.higherkindedj.hkt.TypeArity;\n");
    sb.append("import org.higherkindedj.hkt.WitnessArity;\n");
    appendFunctionImport(sb, n);
    appendTupleImports(sb, n, terminal);
    sb.append("import org.higherkindedj.optics.annotations.Generated;\n");
    sb.append("\n");

    // Class declaration
    sb.append("/** Step ").append(n).append(" in a filterable for-comprehension. */\n");
    sb.append("@Generated\n");
    sb.append("public final class ")
        .append(className)
        .append("<M extends WitnessArity<TypeArity.Unary>");
    for (int i = 0; i < n; i++) {
      sb.append(", ").append(TYPE_PARAMS[i]);
    }
    sb.append(">\n    implements For.Steps<M> {\n\n");

    // Fields
    sb.append("  private final MonadZero<M> monad;\n");
    sb.append("  private final Kind<M, Tuple").append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">> computation;\n\n");

    // Constructor (package-private)
    sb.append("  ")
        .append(className)
        .append("(MonadZero<M> monad, Kind<M, Tuple")
        .append(n)
        .append("<");
    appendTypeParams(sb, n);
    sb.append(">> computation) {\n");
    sb.append("    this.monad = monad;\n");
    sb.append("    this.computation = computation;\n");
    sb.append("  }\n\n");

    // from(), let(), focus(), match() - only if not terminal
    if (!terminal) {
      int next = n + 1;
      String nextType = TYPE_PARAMS[n];
      String nextClassName = "FilterableSteps" + next;

      // from()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> from(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, Kind<M, ").append(nextType).append(">> next) {\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.flatMap(\n");
      sb.append("            t -> monad.map(\n");
      sb.append("                ").append(nextType.toLowerCase()).append(" -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append(nextType.toLowerCase()).append("),\n");
      sb.append("                next.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");

      // let()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> let(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, ").append(nextType).append("> f) {\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.map(\n");
      sb.append("            t -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append("f.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");

      // focus()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> focus(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, ").append(nextType).append("> extractor) {\n");
      sb.append("    Objects.requireNonNull(extractor, \"extractor must not be null\");\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.map(\n");
      sb.append("            t -> Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append("extractor.apply(t)),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");

      // match()
      sb.append("  public <").append(nextType).append("> ").append(nextClassName).append("<M");
      for (int i = 0; i < next; i++) {
        sb.append(", ").append(TYPE_PARAMS[i]);
      }
      sb.append("> match(\n");
      sb.append("      Function<Tuple").append(n).append("<");
      appendTypeParams(sb, n);
      sb.append(">, Optional<").append(nextType).append(">> matcher) {\n");
      sb.append("    Objects.requireNonNull(matcher, \"matcher must not be null\");\n");
      sb.append("    Kind<M, Tuple").append(next).append("<");
      appendTypeParams(sb, next);
      sb.append(">> newComputation =\n");
      sb.append("        monad.flatMap(\n");
      sb.append("            t ->\n");
      sb.append("                matcher\n");
      sb.append("                    .apply(t)\n");
      sb.append("                    .map(")
          .append(nextType.toLowerCase())
          .append(" -> monad.of(Tuple.of(");
      for (int i = 0; i < n; i++) {
        sb.append("t._").append(i + 1).append("(), ");
      }
      sb.append(nextType.toLowerCase()).append(")))\n");
      sb.append("                    .orElseGet(monad::zero),\n");
      sb.append("            this.computation);\n");
      sb.append("    return new ").append(nextClassName).append("<>(monad, newComputation);\n");
      sb.append("  }\n\n");
    }

    // when()
    sb.append("  public ").append(className).append("<M");
    for (int i = 0; i < n; i++) {
      sb.append(", ").append(TYPE_PARAMS[i]);
    }
    sb.append("> when(\n");
    sb.append("      Predicate<Tuple").append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">> filter) {\n");
    sb.append("    Kind<M, Tuple").append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">> newComputation =\n");
    sb.append("        monad.flatMap(\n");
    sb.append("            t -> filter.test(t) ? monad.of(t) : monad.zero(),\n");
    sb.append("            this.computation);\n");
    sb.append("    return new ").append(className).append("<>(monad, newComputation);\n");
    sb.append("  }\n\n");

    // toState with spread function
    generateToStateSpread(sb, n, "MonadZero", "ForState.FilterableSteps");

    // toState with Function<TupleN, S>
    generateToStateTuple(sb, n, "MonadZero", "ForState.FilterableSteps");

    // yield with spread function
    generateYieldSpread(sb, n);

    // yield with Function<TupleN, R>
    generateYieldTuple(sb, n);

    sb.append("}\n");

    Writer writer = processingEnv.getFiler().createSourceFile(qualifiedName).openWriter();
    writer.write(sb.toString());
    writer.close();
  }

  // ---------------------------------------------------------------------------
  // Shared toState methods
  // ---------------------------------------------------------------------------

  private static void generateToStateSpread(
      StringBuilder sb, int n, String monadType, String returnType) {
    String funcType = spreadFunctionType(n);

    sb.append("  public <S> ").append(returnType).append("<M, S> toState(").append(funcType);
    sb.append("<");
    appendTypeParams(sb, n);
    sb.append(", S> constructor) {\n");
    sb.append("    Objects.requireNonNull(constructor, \"constructor must not be null\");\n");
    sb.append("    return ForState.withState(monad, monad.map(\n");
    sb.append("        t -> constructor.apply(");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append("t._").append(i + 1).append("()");
    }
    sb.append("),\n");
    sb.append("        computation));\n");
    sb.append("  }\n\n");
  }

  private static void generateToStateTuple(
      StringBuilder sb, int n, String monadType, String returnType) {
    sb.append("  public <S> ").append(returnType).append("<M, S> toState(Function<Tuple");
    sb.append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">, S> constructor) {\n");
    sb.append("    Objects.requireNonNull(constructor, \"constructor must not be null\");\n");
    sb.append("    return ForState.withState(monad, monad.map(constructor, computation));\n");
    sb.append("  }\n\n");
  }

  // ---------------------------------------------------------------------------
  // Shared yield methods
  // ---------------------------------------------------------------------------

  private static void generateYieldSpread(StringBuilder sb, int n) {
    String funcType = spreadFunctionType(n);

    sb.append("  public <R> Kind<M, R> yield(").append(funcType).append("<");
    appendTypeParams(sb, n);
    sb.append(", R> f) {\n");
    sb.append("    return monad.map(\n");
    sb.append("        t -> Objects.requireNonNull(\n");
    sb.append("            f.apply(");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append("t._").append(i + 1).append("()");
    }
    sb.append("),\n");
    sb.append("            \"The yield function must not return null.\"),\n");
    sb.append("        computation);\n");
    sb.append("  }\n\n");
  }

  private static void generateYieldTuple(StringBuilder sb, int n) {
    sb.append("  public <R> Kind<M, R> yield(Function<Tuple").append(n).append("<");
    appendTypeParams(sb, n);
    sb.append(">, R> f) {\n");
    sb.append("    return monad.map(f, computation);\n");
    sb.append("  }\n");
  }

  // ---------------------------------------------------------------------------
  // Utility
  // ---------------------------------------------------------------------------

  private static String spreadFunctionType(int n) {
    if (n == 2) return "BiFunction";
    return "Function" + n;
  }

  private static void appendTypeParams(StringBuilder sb, int n) {
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append(TYPE_PARAMS[i]);
    }
  }

  private static void appendFunctionImport(StringBuilder sb, int n) {
    if (n >= 3) {
      sb.append("import org.higherkindedj.hkt.function.Function").append(n).append(";\n");
    }
  }

  private static void appendTupleImports(StringBuilder sb, int n, boolean terminal) {
    sb.append("import org.higherkindedj.hkt.tuple.Tuple;\n");
    sb.append("import org.higherkindedj.hkt.tuple.Tuple").append(n).append(";\n");
    if (!terminal) {
      sb.append("import org.higherkindedj.hkt.tuple.Tuple").append(n + 1).append(";\n");
    }
  }
}
