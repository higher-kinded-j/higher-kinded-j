// Copyright (c) 2025 - 2026 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.*;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.annotations.GenerateFolds;

@AutoService(Processor.class)
@SupportedAnnotationTypes("org.higherkindedj.optics.annotations.GenerateFolds")
@SupportedSourceVersion(SourceVersion.RELEASE_25)
public class FoldProcessor extends AbstractProcessor {

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    for (TypeElement annotation : annotations) {
      Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);
      for (Element element : annotatedElements) {
        if (element.getKind() != ElementKind.RECORD) {
          error("The @GenerateFolds annotation can only be applied to records.", element);
          continue;
        }
        try {
          generateFoldsFile((TypeElement) element);
        } catch (IOException e) {
          error("Could not generate folds file: " + e.getMessage(), element);
        }
      }
    }
    return true;
  }

  private void generateFoldsFile(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String defaultPackage =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();

    // Check for custom target package in annotation
    GenerateFolds annotation = recordElement.getAnnotation(GenerateFolds.class);
    String targetPackage = annotation.targetPackage();
    String packageName = targetPackage.isEmpty() ? defaultPackage : targetPackage;

    String foldsClassName = recordName + "Folds";

    final ClassName generatedAnnotation =
        ClassName.get("org.higherkindedj.optics.annotations", "Generated");

    TypeSpec.Builder foldsClassBuilder =
        TypeSpec.classBuilder(foldsClassName)
            .addAnnotation(generatedAnnotation)
            .addJavadoc(
                "Generated optics for {@link $T}. Do not edit.", ClassName.get(recordElement))
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

    List<? extends RecordComponentElement> components = recordElement.getRecordComponents();
    TypeName recordTypeName = getParameterizedTypeName(recordElement);

    for (RecordComponentElement component : components) {
      foldsClassBuilder.addMethod(createFoldMethod(component, recordElement, recordTypeName));
    }

    JavaFile javaFile =
        JavaFile.builder(packageName, foldsClassBuilder.build())
            .addFileComment("Generated by hkj-optics-processor. Do not edit.")
            .build();

    javaFile.writeTo(processingEnv.getFiler());
  }

  private TypeName getParameterizedTypeName(TypeElement typeElement) {
    List<? extends TypeParameterElement> typeParameters = typeElement.getTypeParameters();
    if (typeParameters.isEmpty()) {
      return ClassName.get(typeElement);
    } else {
      List<TypeVariableName> typeVars = typeParameters.stream().map(TypeVariableName::get).toList();
      return ParameterizedTypeName.get(
          ClassName.get(typeElement), typeVars.toArray(new TypeName[0]));
    }
  }

  private MethodSpec createFoldMethod(
      RecordComponentElement component, TypeElement recordElement, TypeName recordTypeName) {

    String componentName = component.getSimpleName().toString();
    TypeName componentTypeName = TypeName.get(component.asType());

    // Check if this is an Iterable type (List, Set, etc.)
    boolean isIterable = isIterableType(component.asType());
    TypeName targetType = isIterable ? getElementType(component) : componentTypeName.box();

    ParameterizedTypeName foldTypeName =
        ParameterizedTypeName.get(ClassName.get(Fold.class), recordTypeName, targetType);

    MethodSpec.Builder methodBuilder =
        MethodSpec.methodBuilder(componentName)
            .addJavadoc(
                "Creates a {@link $T} for the {@code $L} field of a {@link $T}.\n\n"
                    + "@return A non-null {@code Fold<$T, $T>}.",
                Fold.class,
                component.getSimpleName(),
                recordTypeName,
                recordTypeName,
                targetType)
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(foldTypeName);

    for (TypeParameterElement typeParam : recordElement.getTypeParameters()) {
      methodBuilder.addTypeVariable(TypeVariableName.get(typeParam));
    }

    // Create the foldMap implementation
    if (isIterable) {
      // For Iterable types, fold over each element
      methodBuilder.addStatement(
          "return new $T<>() {\n"
              + "  @Override\n"
              + "  public <M> M foldMap($T<M> monoid, $T<? super $T, ? extends M> f, $T source) {\n"
              + "    M result = monoid.empty();\n"
              + "    for (var element : source.$L()) {\n"
              + "      result = monoid.combine(result, f.apply(element));\n"
              + "    }\n"
              + "    return result;\n"
              + "  }\n"
              + "}",
          Fold.class,
          ClassName.get("org.higherkindedj.hkt", "Monoid"),
          ClassName.get("java.util.function", "Function"),
          targetType,
          recordTypeName,
          componentName);
    } else {
      // For non-Iterable types, just apply function to the single value
      methodBuilder.addStatement(
          "return new $T<>() {\n"
              + "  @Override\n"
              + "  public <M> M foldMap($T<M> monoid, $T<? super $T, ? extends M> f, $T source) {\n"
              + "    return f.apply(source.$L());\n"
              + "  }\n"
              + "}",
          Fold.class,
          ClassName.get("org.higherkindedj.hkt", "Monoid"),
          ClassName.get("java.util.function", "Function"),
          targetType,
          recordTypeName,
          componentName);
    }

    return methodBuilder.build();
  }

  private boolean isIterableType(TypeMirror type) {
    if (!(type instanceof DeclaredType)) {
      return false;
    }
    Types typeUtils = processingEnv.getTypeUtils();
    Elements elementUtils = processingEnv.getElementUtils();

    // Get the Iterable type element
    TypeElement iterableElement = elementUtils.getTypeElement("java.lang.Iterable");
    if (iterableElement == null) {
      return false;
    }

    // Erase both types to compare raw types (handles generic parameters)
    TypeMirror erasedType = typeUtils.erasure(type);
    TypeMirror erasedIterable = typeUtils.erasure(iterableElement.asType());

    // Check if the type is a subtype of Iterable
    return typeUtils.isSubtype(erasedType, erasedIterable);
  }

  private TypeName getElementType(RecordComponentElement component) {
    if (component.asType() instanceof DeclaredType containerType) {
      if (!containerType.getTypeArguments().isEmpty()) {
        return TypeName.get(containerType.getTypeArguments().getFirst()).box();
      }
    }
    return ClassName.get(Object.class);
  }

  private void error(String msg, Element e) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, e);
  }
}
