// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.function.Function;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import org.higherkindedj.optics.processing.spi.TraversableGenerator;

@AutoService(Processor.class)
@SupportedAnnotationTypes("org.higherkindedj.optics.annotations.GenerateTraversals")
@SupportedSourceVersion(SourceVersion.RELEASE_25)
public class TraversalProcessor extends AbstractProcessor {

  private final List<TraversableGenerator> generators = new ArrayList<>();

  @Override
  public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    ServiceLoader.load(TraversableGenerator.class, getClass().getClassLoader())
        .forEach(generators::add);
  }

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    for (Element element : roundEnv.getElementsAnnotatedWith(GenerateTraversals.class)) {
      if (element.getKind() != ElementKind.RECORD) {
        error("The @GenerateTraversals annotation can only be applied to records.", element);
        continue;
      }
      try {
        generateTraversalsFile((TypeElement) element);
      } catch (IOException e) {
        error("Could not generate traversals file: " + e.getMessage(), element);
      }
    }
    return true;
  }

  private void generateTraversalsFile(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
    String traversalsClassName = recordName + "Traversals";

    // Define the ClassName for your custom @Generated annotation
    final ClassName generatedAnnotation =
        ClassName.get("org.higherkindedj.optics.annotations", "Generated");

    TypeSpec.Builder classBuilder =
        TypeSpec.classBuilder(traversalsClassName)
            // Add the @Generated annotation to the class
            .addAnnotation(generatedAnnotation)
            .addJavadoc(
                "Generated optics for {@link $T}. Do not edit.", ClassName.get(recordElement))
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

    for (RecordComponentElement component : recordElement.getRecordComponents()) {
      for (TraversableGenerator generator : generators) {
        if (generator.supports(component.asType())) {
          MethodSpec traversalMethod = createTraversalMethod(component, recordElement, generator);
          if (traversalMethod != null) {
            classBuilder.addMethod(traversalMethod);
          }
          break;
        }
      }
    }

    JavaFile.builder(packageName, classBuilder.build())
        .addFileComment("Generated by hkj-optics-processor. Do not edit.")
        .build()
        .writeTo(processingEnv.getFiler());
  }

  private MethodSpec createTraversalMethod(
      RecordComponentElement component, TypeElement recordElement, TraversableGenerator generator) {

    final String componentName = component.getSimpleName().toString();
    final ClassName recordClassName = ClassName.get(recordElement);

    final TypeName focusType;
    final TypeMirror componentType = component.asType();

    if (componentType instanceof ArrayType arrayType) {
      focusType = TypeName.get(arrayType.getComponentType()).box();
    } else if (componentType instanceof DeclaredType declaredType) {
      if (declaredType.getTypeArguments().isEmpty()) {
        return null; // Cannot traverse a raw type.
      }

      // Handle special cases like Either, Validated, and Map which have multiple type arguments.
      // A more advanced solution would be to add a `getFocusType` method to the SPI.
      String generatorName = generator.getClass().getSimpleName();
      int typeArgumentIndex = 0; // Default to the first type argument
      if (generatorName.equals("EitherGenerator")
          || generatorName.equals("ValidatedGenerator")
          || generatorName.equals("MapValueGenerator")) {
        typeArgumentIndex = 1; // These traverse the second type argument
      }

      if (declaredType.getTypeArguments().size() <= typeArgumentIndex) {
        return null; // Not enough type arguments for this generator.
      }
      focusType = TypeName.get(declaredType.getTypeArguments().get(typeArgumentIndex)).box();

    } else {
      return null; // Not a type we can handle.
    }

    final ParameterizedTypeName traversalTypeName =
        ParameterizedTypeName.get(ClassName.get(Traversal.class), recordClassName, focusType);

    final CodeBlock modifyFBody =
        generator.generateModifyF(component, recordClassName, recordElement.getRecordComponents());

    final TypeSpec traversalImpl =
        TypeSpec.anonymousClassBuilder("")
            .addSuperinterface(traversalTypeName)
            .addMethod(
                MethodSpec.methodBuilder("modifyF")
                    .addAnnotation(Override.class)
                    .addModifiers(Modifier.PUBLIC)
                    .addTypeVariable(TypeVariableName.get("F"))
                    .addParameter(
                        ParameterizedTypeName.get(
                            ClassName.get(Function.class),
                            focusType,
                            ParameterizedTypeName.get(
                                ClassName.get(Kind.class), TypeVariableName.get("F"), focusType)),
                        "f")
                    .addParameter(recordClassName, "source")
                    .addParameter(
                        ParameterizedTypeName.get(
                            ClassName.get(Applicative.class), TypeVariableName.get("F")),
                        "applicative")
                    .returns(
                        ParameterizedTypeName.get(
                            ClassName.get(Kind.class), TypeVariableName.get("F"), recordClassName))
                    .addCode(modifyFBody)
                    .build())
            .build();

    return MethodSpec.methodBuilder(componentName)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addJavadoc(
            "Creates a {@link $T} for the {@code $L} field of a {@link $T}.\n"
                + "<p>This traversal focuses on all items within the {@code $L} collection,"
                + " allowing an effectful function\n"
                + "to be applied to each one.\n\n"
                + "@return A non-null {@code Traversal<$T, $T>}.",
            ClassName.get(Traversal.class),
            component.getSimpleName(),
            recordClassName,
            component.getSimpleName(),
            recordClassName,
            focusType.box())
        .returns(traversalTypeName)
        .addStatement("return $L", traversalImpl)
        .build();
  }

  private void error(String msg, Element e) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, e);
  }
}
