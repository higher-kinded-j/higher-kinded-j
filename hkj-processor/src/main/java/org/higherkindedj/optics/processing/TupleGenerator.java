// Copyright (c) 2025 - 2026 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import java.io.IOException;
import java.io.Writer;
import javax.annotation.processing.ProcessingEnvironment;

/**
 * Generates {@code TupleN} record classes for extended arities.
 *
 * <p>Each generated record follows the same pattern as the hand-written {@code Tuple5}, including
 * {@code map}, {@code mapFirst}, {@code mapSecond}, etc.
 */
final class TupleGenerator {

  private static final String PACKAGE = "org.higherkindedj.hkt.tuple";

  private static final String[] TYPE_PARAMS = {"A", "B", "C", "D", "E", "F", "G", "H"};

  private static final String[] ORDINALS = {
    "First", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh", "Eighth"
  };

  private static final String[] ORDINAL_LOWER = {
    "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth"
  };

  private static final String[] MAP_OPS = {
    "MAP_FIRST",
    "MAP_SECOND",
    "MAP_THIRD",
    "MAP_FOURTH",
    "MAP_FIFTH",
    "MAP_SIXTH",
    "MAP_SEVENTH",
    "MAP_EIGHTH"
  };

  private TupleGenerator() {}

  static void generate(int minArity, int maxArity, ProcessingEnvironment processingEnv)
      throws IOException {
    for (int n = minArity; n <= maxArity; n++) {
      generateTuple(n, processingEnv);
    }
  }

  private static void generateTuple(int n, ProcessingEnvironment processingEnv) throws IOException {
    String className = "Tuple" + n;
    String qualifiedName = PACKAGE + "." + className;
    String constName = className.toUpperCase() + "_CLASS";

    StringBuilder sb = new StringBuilder();

    // Header
    sb.append("// Generated by hkj-processor. Do not edit.\n");
    sb.append("package ").append(PACKAGE).append(";\n\n");

    // Imports
    sb.append("import static org.higherkindedj.hkt.util.validation.Operation.*;\n\n");
    sb.append("import java.util.function.Function;\n");
    sb.append("import org.higherkindedj.hkt.util.validation.Validation;\n");
    sb.append("import org.higherkindedj.optics.annotations.GenerateLenses;\n");
    sb.append("import org.higherkindedj.optics.annotations.Generated;\n\n");

    // Javadoc
    sb.append("/**\n");
    sb.append(" * An immutable tuple containing ")
        .append(n)
        .append(" elements of potentially different types.\n");
    sb.append(" *\n");
    sb.append(
        " * <p>As a {@link java.lang.Record}, it automatically provides a canonical constructor,\n");
    sb.append(
        " * accessors (e.g., {@code _1()}, {@code _2()}), and implementations for {@code equals()},\n");
    sb.append(" * {@code hashCode()}, and {@code toString()}.\n");
    sb.append(" *\n");
    for (int i = 0; i < n; i++) {
      sb.append(" * @param <")
          .append(TYPE_PARAMS[i])
          .append("> The type of the ")
          .append(ORDINAL_LOWER[i])
          .append(" element.\n");
    }
    for (int i = 0; i < n; i++) {
      sb.append(" * @param _")
          .append(i + 1)
          .append(" The ")
          .append(ORDINAL_LOWER[i])
          .append(" element of the tuple.\n");
    }
    sb.append(" */\n");

    // Annotations and record declaration
    sb.append("@Generated\n");
    sb.append("@GenerateLenses\n");
    sb.append("public record ").append(className).append("<");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append(TYPE_PARAMS[i]);
    }
    sb.append(">(");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append(TYPE_PARAMS[i]).append(" _").append(i + 1);
    }
    sb.append(") implements Tuple {\n\n");

    // Class constant
    sb.append("  @SuppressWarnings(\"rawtypes\")\n");
    sb.append("  private static final Class<")
        .append(className)
        .append("> ")
        .append(constName)
        .append(" = ")
        .append(className)
        .append(".class;\n\n");

    // For arity 2, generate bimap() (the bifunctor operation) in addition to map()
    if (n == 2) {
      generateBimap(sb, constName);
    }

    // map() method - transforms all elements
    generateMapAll(sb, n, className, constName);

    // mapFirst(), mapSecond(), etc.
    for (int i = 0; i < n; i++) {
      generateMapNth(sb, n, i, className, constName);
    }

    sb.append("}\n");

    Writer writer = processingEnv.getFiler().createSourceFile(qualifiedName).openWriter();
    writer.write(sb.toString());
    writer.close();
  }

  private static void generateBimap(StringBuilder sb, String constName) {
    sb.append("  /**\n");
    sb.append(
        "   * Transforms both elements of this tuple using the provided mapping functions.\n");
    sb.append("   *\n");
    sb.append("   * <p>This is the fundamental bifunctor operation for {@code Tuple2}, allowing\n");
    sb.append("   * simultaneous transformation of both elements.\n");
    sb.append("   *\n");
    sb.append("   * @param firstMapper The non-null function to apply to the first element.\n");
    sb.append("   * @param secondMapper The non-null function to apply to the second element.\n");
    sb.append("   * @param <C> The type of the first element in the resulting tuple.\n");
    sb.append("   * @param <D> The type of the second element in the resulting tuple.\n");
    sb.append("   * @return A new {@code Tuple2} with both elements transformed.\n");
    sb.append("   * @throws NullPointerException if either mapper is null.\n");
    sb.append("   */\n");
    sb.append("  public <C, D> Tuple2<C, D> bimap(\n");
    sb.append(
        "      Function<? super A, ? extends C> firstMapper,"
            + " Function<? super B, ? extends D> secondMapper) {\n");
    sb.append("    Validation.function().requireMapper(firstMapper, \"firstMapper\", ")
        .append(constName)
        .append(", BIMAP);\n");
    sb.append("    Validation.function().requireMapper(secondMapper, \"secondMapper\", ")
        .append(constName)
        .append(", BIMAP);\n");
    sb.append("\n");
    sb.append("    return new Tuple2<>(firstMapper.apply(_1), secondMapper.apply(_2));\n");
    sb.append("  }\n\n");
  }

  private static void generateMapAll(StringBuilder sb, int n, String className, String constName) {
    // Javadoc
    sb.append("  /**\n");
    sb.append("   * Transforms all ")
        .append(n)
        .append(" elements of this tuple using the provided mapping functions.\n");
    sb.append("   *\n");
    for (int i = 0; i < n; i++) {
      sb.append("   * @param ")
          .append(ORDINAL_LOWER[i])
          .append("Mapper The non-null function to apply to the ")
          .append(ORDINAL_LOWER[i])
          .append(" element.\n");
    }
    for (int i = 0; i < n; i++) {
      sb.append("   * @param <")
          .append(TYPE_PARAMS[i])
          .append("2> The type of the ")
          .append(ORDINAL_LOWER[i])
          .append(" element in the resulting tuple.\n");
    }
    sb.append("   * @return A new {@code ")
        .append(className)
        .append("} with all elements transformed.\n");
    sb.append("   * @throws NullPointerException if any mapper is null.\n");
    sb.append("   */\n");

    // Signature
    sb.append("  public <");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append(TYPE_PARAMS[i]).append("2");
    }
    sb.append("> ").append(className).append("<");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      sb.append(TYPE_PARAMS[i]).append("2");
    }
    sb.append("> map(\n");
    for (int i = 0; i < n; i++) {
      sb.append("      Function<? super ")
          .append(TYPE_PARAMS[i])
          .append(", ? extends ")
          .append(TYPE_PARAMS[i])
          .append("2> ")
          .append(ORDINAL_LOWER[i])
          .append("Mapper");
      if (i < n - 1) sb.append(",\n");
    }
    sb.append(") {\n");

    // Validation
    for (int i = 0; i < n; i++) {
      sb.append("    Validation.function().requireMapper(")
          .append(ORDINAL_LOWER[i])
          .append("Mapper, \"")
          .append(ORDINAL_LOWER[i])
          .append("Mapper\", ")
          .append(constName)
          .append(", MAP);\n");
    }
    sb.append("\n");

    // Return
    sb.append("    return new ").append(className).append("<>(\n");
    for (int i = 0; i < n; i++) {
      sb.append("        ")
          .append(ORDINAL_LOWER[i])
          .append("Mapper.apply(_")
          .append(i + 1)
          .append(")");
      if (i < n - 1) sb.append(",\n");
    }
    sb.append(");\n");
    sb.append("  }\n\n");
  }

  private static void generateMapNth(
      StringBuilder sb, int n, int idx, String className, String constName) {
    String ordinal = ORDINALS[idx];
    String ordinalLower = ORDINAL_LOWER[idx];
    String typeParam = TYPE_PARAMS[idx];
    String mapOp = MAP_OPS[idx];

    // Javadoc
    sb.append("  /**\n");
    sb.append("   * Transforms only the ").append(ordinalLower).append(" element of this tuple.\n");
    sb.append("   *\n");
    sb.append("   * @param ")
        .append(ordinalLower)
        .append("Mapper The non-null function to apply to the ")
        .append(ordinalLower)
        .append(" element.\n");
    sb.append("   * @param <")
        .append(typeParam)
        .append("2> The type of the ")
        .append(ordinalLower)
        .append(" element in the resulting tuple.\n");
    sb.append("   * @return A new {@code ")
        .append(className)
        .append("} with the ")
        .append(ordinalLower)
        .append(" element transformed.\n");
    sb.append("   * @throws NullPointerException if {@code ")
        .append(ordinalLower)
        .append("Mapper} is null.\n");
    sb.append("   */\n");

    // Signature: public <A2> TupleN<A2, B, C, ...> mapFirst(Function<...> firstMapper)
    sb.append("  public <").append(typeParam).append("2> ").append(className).append("<");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      if (i == idx) {
        sb.append(typeParam).append("2");
      } else {
        sb.append(TYPE_PARAMS[i]);
      }
    }
    sb.append("> map")
        .append(ordinal)
        .append("(Function<? super ")
        .append(typeParam)
        .append(", ? extends ")
        .append(typeParam)
        .append("2> ")
        .append(ordinalLower)
        .append("Mapper) {\n");

    // Validation
    sb.append("    Validation.function().requireMapper(")
        .append(ordinalLower)
        .append("Mapper, \"")
        .append(ordinalLower)
        .append("Mapper\", ")
        .append(constName)
        .append(", ")
        .append(mapOp)
        .append(");\n");

    // Return
    sb.append("    return new ").append(className).append("<>(");
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(", ");
      if (i == idx) {
        sb.append(ordinalLower).append("Mapper.apply(_").append(i + 1).append(")");
      } else {
        sb.append("_").append(i + 1);
      }
    }
    sb.append(");\n");
    sb.append("  }\n\n");
  }
}
