// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.*;

import java.io.IOException;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.tools.Diagnostic;
import org.higherkindedj.optics.Lens;

@AutoService(Processor.class)
@SupportedAnnotationTypes("org.higherkindedj.optics.annotations.GenerateLenses")
@SupportedSourceVersion(SourceVersion.RELEASE_24)
public class LensProcessor extends AbstractProcessor {

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    for (TypeElement annotation : annotations) {
      Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);
      for (Element element : annotatedElements) {
        if (element.getKind() != ElementKind.RECORD) {
          error("The @GenerateLenses annotation can only be applied to records.", element);
          continue;
        }
        try {
          generateLensesFile((TypeElement) element);
        } catch (IOException e) {
          error("Could not generate lenses file: " + e.getMessage(), element);
        }
      }
    }
    return true;
  }

  private void generateLensesFile(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
    String lensesClassName = recordName + "Lenses";

    final ClassName generatedAnnotation =
        ClassName.get("org.higherkindedj.optics.annotations", "Generated");

    TypeSpec.Builder lensesClassBuilder =
        TypeSpec.classBuilder(lensesClassName)
            .addAnnotation(generatedAnnotation)
            .addJavadoc(
                "Generated optics for {@link $T}. Do not edit.", ClassName.get(recordElement))
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

    List<? extends RecordComponentElement> components = recordElement.getRecordComponents();
    TypeName recordTypeName = getParameterizedTypeName(recordElement);

    for (RecordComponentElement component : components) {
      lensesClassBuilder.addMethod(
          createLensMethod(component, recordElement, components, recordTypeName));
    }

    for (RecordComponentElement component : components) {
      lensesClassBuilder.addMethod(createWithMethod(component, recordElement, recordTypeName));
    }

    JavaFile javaFile =
        JavaFile.builder(packageName, lensesClassBuilder.build())
            .addFileComment("Generated by hkj-optics-processor. Do not edit.")
            .build();

    javaFile.writeTo(processingEnv.getFiler());
  }

  private TypeName getParameterizedTypeName(TypeElement typeElement) {
    List<? extends TypeParameterElement> typeParameters = typeElement.getTypeParameters();
    if (typeParameters.isEmpty()) {
      return ClassName.get(typeElement);
    } else {
      List<TypeVariableName> typeVars = typeParameters.stream().map(TypeVariableName::get).toList();
      return ParameterizedTypeName.get(
          ClassName.get(typeElement), typeVars.toArray(new TypeName[0]));
    }
  }

  private MethodSpec createLensMethod(
      RecordComponentElement component,
      TypeElement recordElement,
      List<? extends RecordComponentElement> allComponents,
      TypeName recordTypeName) {

    String componentName = component.getSimpleName().toString();
    TypeName componentTypeName = TypeName.get(component.asType());

    ParameterizedTypeName lensTypeName =
        ParameterizedTypeName.get(
            ClassName.get(Lens.class), recordTypeName, componentTypeName.box());

    MethodSpec.Builder methodBuilder =
        MethodSpec.methodBuilder(componentName)
            .addJavadoc(
                "Creates a {@link $T} for the {@code $L} field of a {@link $T}.\n\n"
                    + "@return A non-null {@code Lens<$T, $T>}.",
                Lens.class,
                component.getSimpleName(),
                recordTypeName,
                recordTypeName,
                componentTypeName.box())
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(lensTypeName);

    for (TypeParameterElement typeParam : recordElement.getTypeParameters()) {
      methodBuilder.addTypeVariable(TypeVariableName.get(typeParam));
    }

    String constructorArgs =
        allComponents.stream()
            .map(
                c ->
                    c.getSimpleName().toString().equals(componentName)
                        ? "newValue"
                        : "source." + c.getSimpleName() + "()")
            .collect(Collectors.joining(", "));

    methodBuilder.addStatement(
        "return $T.of($T::$L, (source, newValue) -> new $T($L))",
        Lens.class,
        recordTypeName,
        componentName,
        recordTypeName,
        constructorArgs);

    return methodBuilder.build();
  }

  private MethodSpec createWithMethod(
      RecordComponentElement component, TypeElement recordElement, TypeName recordTypeName) {

    String componentName = component.getSimpleName().toString();
    TypeName componentTypeName = TypeName.get(component.asType());
    String methodName = "with" + capitalise(componentName);
    String parameterName = "new" + capitalise(componentName);
    String lensesClassName = recordElement.getSimpleName().toString() + "Lenses";

    MethodSpec.Builder methodBuilder =
        MethodSpec.methodBuilder(methodName)
            .addJavadoc(
                "Creates a new {@link $T} instance with an updated {@code $L} field.\n"
                    + "<p>This is a convenience method that uses the {@link #$L()} lens.\n\n"
                    + "@param source The original {@code $T} instance.\n"
                    + "@param $L The new value for the {@code $L} field.\n"
                    + "@return A new, updated {@code $T} instance.",
                recordTypeName,
                componentName,
                componentName,
                recordTypeName,
                parameterName,
                componentName,
                recordTypeName)
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(recordTypeName)
            .addParameter(recordTypeName, "source")
            .addParameter(componentTypeName, parameterName);

    List<? extends TypeParameterElement> typeParameters = recordElement.getTypeParameters();
    for (TypeParameterElement typeParam : typeParameters) {
      methodBuilder.addTypeVariable(TypeVariableName.get(typeParam));
    }

    String typeArguments =
        typeParameters.stream()
            .map(p -> p.getSimpleName().toString())
            .collect(Collectors.joining(", "));

    if (typeArguments.isEmpty()) {
      methodBuilder.addStatement("return $L().set($L, source)", componentName, parameterName);
    } else {
      methodBuilder.addStatement(
          "return $L.<$L>$L().set($L, source)",
          lensesClassName,
          typeArguments,
          componentName,
          parameterName);
    }

    return methodBuilder.build();
  }

  private String capitalise(String s) {
    if (s == null || s.isEmpty()) {
      return s;
    }
    return s.substring(0, 1).toUpperCase() + s.substring(1);
  }

  private void error(String msg, Element e) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, e);
  }
}
