// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.processing;

import com.google.auto.service.AutoService;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import com.palantir.javapoet.TypeVariableName;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.tools.Diagnostic;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateLenses;

/**
 * An annotation processor that generates a companion 'Lenses' class for any Java record annotated
 * with {@link GenerateLenses}.
 *
 * <p>For a record {@code Person(String name, int age)}, this processor will generate a final class
 * {@code PersonLenses} containing static factory methods to create a {@link Lens} for each record
 * component (e.g., {@code PersonLenses.name()}, {@code PersonLenses.age()}).
 */
@AutoService(Processor.class)
@SupportedAnnotationTypes("org.higherkindedj.optics.annotations.GenerateLenses")
@SupportedSourceVersion(SourceVersion.RELEASE_24)
public class LensProcessor extends AbstractProcessor {

  /**
   * {@inheritDoc}
   *
   * <p>This implementation scans for records annotated with {@link GenerateLenses} and triggers the
   * generation of the corresponding lenses companion class.
   */
  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    for (TypeElement annotation : annotations) {
      Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);
      for (Element element : annotatedElements) {
        if (element.getKind() != ElementKind.RECORD) {
          error("The @GenerateLenses annotation can only be applied to records.", element);
          continue;
        }
        try {
          generateLensesFile((TypeElement) element);
        } catch (IOException e) {
          error("Could not generate lenses file: " + e.getMessage(), element);
        }
      }
    }
    return true;
  }

  /**
   * Generates the complete '...Lenses' companion class for a given annotated record.
   *
   * @param recordElement The {@link TypeElement} representing the record to process.
   * @throws IOException if the generated file cannot be written.
   */
  private void generateLensesFile(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
    String lensesClassName = recordName + "Lenses";

    // Define the ClassName for your custom @Generated annotation
    final ClassName generatedAnnotation =
        ClassName.get("org.higherkindedj.optics.annotations", "Generated");

    TypeSpec.Builder lensesClassBuilder =
        TypeSpec.classBuilder(lensesClassName)
            // Add the @Generated annotation to the class
            .addAnnotation(generatedAnnotation)
            .addJavadoc(
                "Generated optics for {@link $T}. Do not edit.", ClassName.get(recordElement))
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

    List<? extends RecordComponentElement> components = recordElement.getRecordComponents();
    TypeName recordTypeName = getParameterizedTypeName(recordElement);

    for (RecordComponentElement component : components) {
      lensesClassBuilder.addMethod(
          createLensMethod(component, recordElement, components, recordTypeName));
    }

    JavaFile javaFile =
        JavaFile.builder(packageName, lensesClassBuilder.build())
            .addFileComment("Generated by hkj-optics-processor. Do not edit.")
            .build();

    javaFile.writeTo(processingEnv.getFiler());
  }

  /**
   * Creates a {@link TypeName} for a given {@link TypeElement}, preserving its generic type
   * parameters if they exist.
   *
   * @param typeElement The element to create the type name for.
   * @return A {@link ParameterizedTypeName} if the element is generic, otherwise a simple {@link
   *     ClassName}.
   */
  private TypeName getParameterizedTypeName(TypeElement typeElement) {
    List<? extends TypeParameterElement> typeParameters = typeElement.getTypeParameters();
    if (typeParameters.isEmpty()) {
      return ClassName.get(typeElement);
    } else {
      List<TypeVariableName> typeVars =
          typeParameters.stream().map(TypeVariableName::get).collect(Collectors.toList());
      return ParameterizedTypeName.get(
          ClassName.get(typeElement), typeVars.toArray(new TypeName[0]));
    }
  }

  /**
   * Creates the {@link MethodSpec} for a static factory method that generates a {@link Lens} for a
   * single record component.
   *
   * @param component The specific {@link RecordComponentElement} to create the lens for.
   * @param recordElement The parent record {@link TypeElement}.
   * @param allComponents The list of all components in the record, used for reconstructing the
   *     record.
   * @param recordTypeName The {@link TypeName} of the record, including any generic parameters.
   * @return A complete {@code MethodSpec} for the lens factory method.
   */
  private MethodSpec createLensMethod(
      RecordComponentElement component,
      TypeElement recordElement,
      List<? extends RecordComponentElement> allComponents,
      TypeName recordTypeName) {

    String componentName = component.getSimpleName().toString();
    TypeName componentTypeName = TypeName.get(component.asType());

    ParameterizedTypeName lensTypeName =
        ParameterizedTypeName.get(
            ClassName.get(Lens.class), recordTypeName, componentTypeName.box());

    MethodSpec.Builder methodBuilder =
        MethodSpec.methodBuilder(componentName)
            .addJavadoc(
                "Creates a {@link $T} for the {@code $L} field of a {@link $T}.\n\n"
                    + "@return A non-null {@code Lens<$T, $T>}.",
                Lens.class,
                component.getSimpleName(),
                recordTypeName,
                recordTypeName,
                componentTypeName.box())
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(lensTypeName);

    // Add generic type variables from the record to the static method
    for (TypeParameterElement typeParam : recordElement.getTypeParameters()) {
      methodBuilder.addTypeVariable(TypeVariableName.get(typeParam));
    }

    // Generate the constructor arguments string
    String constructorArgs =
        allComponents.stream()
            .map(
                c ->
                    c.getSimpleName().toString().equals(componentName)
                        ? "newValue"
                        : "source." + c.getSimpleName() + "()")
            .collect(Collectors.joining(", "));

    // Use the Lens.of factory method with method references and lambdas
    methodBuilder.addStatement(
        "return $T.of($T::$L, (source, newValue) -> new $T($L))",
        Lens.class,
        recordTypeName,
        componentName,
        ClassName.get(recordElement), // Use raw class name for constructor
        constructorArgs);

    return methodBuilder.build();
  }

  /**
   * A utility method for reporting a processing error linked to a specific code element.
   *
   * @param msg The error message to report.
   * @param e The element to which the error should be attached.
   */
  private void error(String msg, Element e) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, e);
  }
}
