<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexedLens.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.indexed</a> &gt; <span class="el_source">IndexedLens.java</span></div><h1>IndexedLens.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.indexed;

import java.util.function.BiFunction;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Functor;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.optics.Lens;
import org.jspecify.annotations.NullMarked;

/**
 * An indexed lens that provides focused access to a single field along with its index/key.
 *
 * &lt;p&gt;An {@code IndexedLens} is the indexed equivalent of a {@link Lens}. While a regular lens
 * focuses on exactly one field that is guaranteed to exist, an indexed lens also provides index
 * information, which can represent:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A field name (for introspection/debugging)
 *   &lt;li&gt;A map key
 *   &lt;li&gt;A position in a fixed-size structure
 *   &lt;li&gt;A path component
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Common use cases include:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Tracking field names during transformations
 *   &lt;li&gt;Building audit trails with field provenance
 *   &lt;li&gt;Conditional logic based on which field is being accessed
 *   &lt;li&gt;Generic field processing with field identification
 * &lt;/ul&gt;
 *
 * @param &lt;I&gt; The index type (e.g., String for field names, K for Map keys)
 * @param &lt;S&gt; The source/target structure type
 * @param &lt;A&gt; The focused element type
 */
@NullMarked
public interface IndexedLens&lt;I, S, A&gt; extends IndexedOptic&lt;I, S, A&gt; {

  /**
   * Gets the index associated with this lens.
   *
   * &lt;p&gt;Unlike traversals where each element has its own index, a lens has a single fixed index
   * representing the field or key being focused on.
   *
   * @return The index value
   */
  I index();

  /**
   * Gets the focused part {@code A} from the whole structure {@code S}.
   *
   * @param source The whole structure
   * @return The focused part
   */
  A get(S source);

  /**
   * Sets a new value for the focused part {@code A}, returning a new, updated structure {@code S}.
   *
   * &lt;p&gt;This operation is immutable; the original {@code source} object is not changed.
   *
   * @param newValue The new value for the focused part
   * @param source The original structure
   * @return A new structure with the focused part updated
   */
  S set(A newValue, S source);

  /**
   * Gets the focused part along with its index as a pair.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IndexedLens&lt;String, User, Integer&gt; ageLens = IndexedLens.of(&quot;age&quot;, User::age, User::withAge);
   * Pair&lt;String, Integer&gt; indexed = ageLens.iget(user);
   * // Pair(&quot;age&quot;, 25)
   * }&lt;/pre&gt;
   *
   * @param source The whole structure
   * @return A pair of (index, value)
   */
  default Pair&lt;I, A&gt; iget(S source) {
<span class="fc" id="L88">    return new Pair&lt;&gt;(index(), get(source));</span>
  }

  /**
   * Modifies the focused part using a function that receives both index and value.
   *
   * @param modifier The function to apply, receiving both index and value
   * @param source The whole structure
   * @return A new structure with the modified part
   */
  default S imodify(BiFunction&lt;I, A, A&gt; modifier, S source) {
<span class="fc" id="L99">    return set(modifier.apply(index(), get(source)), source);</span>
  }

  /**
   * Modifies the focused part using a pure function (ignoring the index).
   *
   * @param modifier The function to apply to the focused part
   * @param source The whole structure
   * @return A new structure with the modified part
   */
  default S modify(Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L110">    return set(modifier.apply(get(source)), source);</span>
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;Modifies the focused part with an effectful function that receives both index and value.
   */
  @Override
  default &lt;F&gt; Kind&lt;F, S&gt; imodifyF(BiFunction&lt;I, A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; app) {
<span class="fc" id="L120">    Kind&lt;F, A&gt; fa = f.apply(index(), get(source));</span>
<span class="fc" id="L121">    return app.map(a -&gt; set(a, source), fa);</span>
  }

  /**
   * Modifies the focused part with an effectful function that receives only the value.
   *
   * @param f The effectful function to apply
   * @param source The whole structure
   * @param functor The Functor instance for the context F
   * @param &lt;F&gt; The witness type for the Functor context
   * @return The updated structure wrapped in the context F
   */
  default &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="nc" id="L134">    Kind&lt;F, A&gt; fa = f.apply(get(source));</span>
<span class="nc" id="L135">    return functor.map(a -&gt; set(a, source), fa);</span>
  }

  /**
   * Composes this {@code IndexedLens&lt;I, S, A&gt;} with another {@code IndexedLens&lt;J, A, B&gt;} to create
   * a new {@code IndexedLens&lt;Pair&lt;I, J&gt;, S, B&gt;} with paired indices.
   *
   * @param other The {@link IndexedLens} to compose with
   * @param &lt;J&gt; The index type of the other lens
   * @param &lt;B&gt; The focus type of the other lens
   * @return A new {@link IndexedLens} with paired indices
   */
  default &lt;J, B&gt; IndexedLens&lt;Pair&lt;I, J&gt;, S, B&gt; iandThen(IndexedLens&lt;J, A, B&gt; other) {
<span class="fc" id="L148">    IndexedLens&lt;I, S, A&gt; self = this;</span>
<span class="fc" id="L149">    return new IndexedLens&lt;&gt;() {</span>
      @Override
      public Pair&lt;I, J&gt; index() {
<span class="fc" id="L152">        return new Pair&lt;&gt;(self.index(), other.index());</span>
      }

      @Override
      public B get(S source) {
<span class="fc" id="L157">        return other.get(self.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L162">        return self.set(other.set(newValue, self.get(source)), source);</span>
      }
    };
  }

  /**
   * Composes this {@code IndexedLens&lt;I, S, A&gt;} with a regular {@code Lens&lt;A, B&gt;} to create a new
   * {@code IndexedLens&lt;I, S, B&gt;} that preserves the outer index.
   *
   * @param other The {@link Lens} to compose with
   * @param &lt;B&gt; The focus type of the other lens
   * @return A new {@link IndexedLens} preserving the outer index
   */
  default &lt;B&gt; IndexedLens&lt;I, S, B&gt; andThen(Lens&lt;A, B&gt; other) {
<span class="fc" id="L176">    IndexedLens&lt;I, S, A&gt; self = this;</span>
<span class="fc" id="L177">    return new IndexedLens&lt;&gt;() {</span>
      @Override
      public I index() {
<span class="fc" id="L180">        return self.index();</span>
      }

      @Override
      public B get(S source) {
<span class="fc" id="L185">        return other.get(self.get(source));</span>
      }

      @Override
      public S set(B newValue, S source) {
<span class="fc" id="L190">        return self.set(other.set(newValue, self.get(source)), source);</span>
      }
    };
  }

  /**
   * Views this {@code IndexedLens} as a regular (non-indexed) {@link Lens}.
   *
   * @return A {@link Lens} that ignores index information
   */
  default Lens&lt;S, A&gt; asLens() {
<span class="fc" id="L201">    IndexedLens&lt;I, S, A&gt; self = this;</span>
<span class="fc" id="L202">    return new Lens&lt;&gt;() {</span>
      @Override
      public A get(S source) {
<span class="fc" id="L205">        return self.get(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L210">        return self.set(newValue, source);</span>
      }

      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="nc" id="L215">        return self.modifyF(f, source, functor);</span>
      }
    };
  }

  /**
   * Views this {@code IndexedLens} as an {@link IndexedTraversal}.
   *
   * &lt;p&gt;This is always possible because a lens is a traversal that focuses on exactly one element.
   *
   * @return An {@link IndexedTraversal} that represents this lens
   */
  default IndexedTraversal&lt;I, S, A&gt; asIndexedTraversal() {
<span class="fc" id="L228">    IndexedLens&lt;I, S, A&gt; self = this;</span>
<span class="fc" id="L229">    return self::imodifyF;</span>
  }

  /**
   * Views this {@code IndexedLens} as an {@link IndexedFold}.
   *
   * @return An {@link IndexedFold} that represents this lens
   */
  default IndexedFold&lt;I, S, A&gt; asIndexedFold() {
<span class="fc" id="L238">    IndexedLens&lt;I, S, A&gt; self = this;</span>
<span class="fc" id="L239">    return new IndexedFold&lt;I, S, A&gt;() {</span>
      @Override
      public &lt;M&gt; M ifoldMap(
          Monoid&lt;M&gt; monoid, BiFunction&lt;? super I, ? super A, ? extends M&gt; f, S source) {
<span class="fc" id="L243">        return f.apply(self.index(), self.get(source));</span>
      }
    };
  }

  /**
   * Creates an {@code IndexedLens} from its components: an index, a getter, and a setter.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * IndexedLens&lt;String, User, String&gt; nameLens = IndexedLens.of(
   *     &quot;name&quot;,                           // Index (field name)
   *     User::name,                       // Getter
   *     (user, name) -&gt; user.withName(name)  // Setter
   * );
   *
   * // Use with index awareness
   * String fieldName = nameLens.index();        // &quot;name&quot;
   * Pair&lt;String, String&gt; indexed = nameLens.iget(user);  // Pair(&quot;name&quot;, &quot;Alice&quot;)
   * User updated = nameLens.imodify((field, value) -&gt; value.toUpperCase(), user);
   * }&lt;/pre&gt;
   *
   * @param index The index value for this lens
   * @param getter A function to extract the part from the structure
   * @param setter A function to immutably update the part within the structure
   * @param &lt;I&gt; The index type
   * @param &lt;S&gt; The structure type
   * @param &lt;A&gt; The focused part type
   * @return A new {@code IndexedLens} instance
   */
  static &lt;I, S, A&gt; IndexedLens&lt;I, S, A&gt; of(
      I index, Function&lt;S, A&gt; getter, BiFunction&lt;S, A, S&gt; setter) {
<span class="fc" id="L276">    return new IndexedLens&lt;&gt;() {</span>
      @Override
      public I index() {
<span class="fc" id="L279">        return index;</span>
      }

      @Override
      public A get(S source) {
<span class="fc" id="L284">        return getter.apply(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L289">        return setter.apply(source, newValue);</span>
      }
    };
  }

  /**
   * Creates an {@code IndexedLens} from an existing {@link Lens} plus an index.
   *
   * &lt;p&gt;This is useful when you have an existing lens and want to add index tracking to it.
   *
   * @param index The index value for this lens
   * @param lens The underlying lens
   * @param &lt;I&gt; The index type
   * @param &lt;S&gt; The structure type
   * @param &lt;A&gt; The focused part type
   * @return A new {@code IndexedLens} wrapping the provided lens
   */
  static &lt;I, S, A&gt; IndexedLens&lt;I, S, A&gt; from(I index, Lens&lt;S, A&gt; lens) {
<span class="fc" id="L307">    return new IndexedLens&lt;&gt;() {</span>
      @Override
      public I index() {
<span class="fc" id="L310">        return index;</span>
      }

      @Override
      public A get(S source) {
<span class="fc" id="L315">        return lens.get(source);</span>
      }

      @Override
      public S set(A newValue, S source) {
<span class="fc" id="L320">        return lens.set(newValue, source);</span>
      }

      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Functor&lt;F&gt; functor) {
<span class="fc" id="L325">        return lens.modifyF(f, source, functor);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>