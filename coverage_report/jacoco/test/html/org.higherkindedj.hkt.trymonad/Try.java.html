<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Try.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.trymonad</a> &gt; <span class="el_source">Try.java</span></div><h1>Try.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.trymonad;

import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Represents a computation that may either result in a value (a {@link Success}) or an exception (a
 * {@link Failure}). {@code Try} is a sum type designed to encapsulate operations that can throw
 * {@link Throwable}s, allowing for more functional error handling.
 *
 * &lt;p&gt;It is similar to Scala's {@code Try} or Haskell's {@code Either Exception a}. {@code Try} is
 * right-biased, meaning operations like {@link #map(Function)} and {@link #flatMap(Function)}
 * operate on the value of a {@link Success} and pass a {@link Failure} through unchanged.
 *
 * &lt;p&gt;This is a sealed interface, with {@link Success} and {@link Failure} as its only direct
 * implementations (provided as nested records). This facilitates exhaustive pattern matching using
 * `switch` expressions.
 *
 * &lt;p&gt;Primary use cases include:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Converting exception-throwing APIs into pure functional computations.
 *   &lt;li&gt;Sequencing operations where any step might fail, without deeply nested try-catch blocks.
 *   &lt;li&gt;Providing a clear path for recovery from failures.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Example:
 *
 * &lt;pre&gt;{@code
 * public Try&lt;Integer&gt; parseInt(String s) {
 * return Try.of(() -&gt; Integer.parseInt(s));
 * }
 *
 * Try&lt;Integer&gt; result = parseInt(&quot;123&quot;);
 * result.fold(
 * error -&gt; { System.err.println(&quot;Failed: &quot; + error.getMessage()); return -1; },
 * value -&gt; { System.out.println(&quot;Succeeded: &quot; + value); return value; }
 * );
 *
 * Try&lt;Integer&gt; doubled = result.map(v -&gt; v * 2); // Only maps if result was Success
 *
 * Try&lt;String&gt; recovered = parseInt(&quot;abc&quot;).recover(ex -&gt; &quot;Default Value&quot;); // Will be Success(&quot;Default Value&quot;)
 *
 * // Using toEither:
 * Either&lt;String, Integer&gt; eitherResult = parseInt(&quot;123&quot;).toEither(Throwable::getMessage);
 * // eitherResult will be Right(123)
 *
 * Either&lt;String, Integer&gt; eitherFailure = parseInt(&quot;xyz&quot;).toEither(t -&gt; &quot;Invalid input: &quot; + t.getMessage());
 * // eitherFailure will be Left(&quot;Invalid input: For input string: \&quot;xyz\&quot;&quot;)
 * }&lt;/pre&gt;
 *
 * @param &lt;T&gt; The type of the value if the computation is successful.
 * @see Success
 * @see Failure
 */
public sealed interface Try&lt;T&gt; permits Try.Success, Try.Failure {

<span class="fc" id="L66">  Class&lt;Try&gt; TRY_CLASS = Try.class;</span>

  /**
   * Executes a {@link Supplier} that produces a value of type {@code T} and wraps the outcome in a
   * {@code Try}. If the supplier executes successfully, its result (which can be {@code null}) is
   * wrapped in a {@link Success}. If the supplier throws any {@link Throwable} (including {@link
   * Error}s and checked/unchecked exceptions), it is caught and wrapped in a {@link Failure}.
   *
   * &lt;p&gt;This is the most common way to create a {@code Try} instance from potentially failable code.
   *
   * @param supplier The non-null computation (supplier) to execute. The supplier itself may return
   *     {@code null}.
   * @param &lt;T&gt; The type of the result produced by the supplier.
   * @return A non-null {@link Success} instance containing the supplier's result if execution is
   *     normal, or a non-null {@link Failure} instance containing the {@link Throwable} if an
   *     exception occurs.
   * @throws NullPointerException if {@code supplier} is null.
   */
  static &lt;T&gt; Try&lt;T&gt; of(Supplier&lt;? extends T&gt; supplier) {
<span class="fc" id="L85">    Validation.function().requireFunction(supplier, &quot;supplier&quot;, TRY_CLASS, OF);</span>
    try {
<span class="fc" id="L87">      return new Success&lt;&gt;(supplier.get());</span>
<span class="fc" id="L88">    } catch (Throwable t) {</span>
<span class="fc" id="L89">      return new Failure&lt;&gt;(t);</span>
    }
  }

  /**
   * Creates a {@code Try} representing a successful computation with the given value. The provided
   * value can be {@code null}, in which case it results in {@code Success(null)}.
   *
   * @param value The successful value. Can be {@code null}.
   * @param &lt;T&gt; The type of the value.
   * @return A non-null {@link Success} instance holding the provided value.
   */
  static &lt;T&gt; Try&lt;T&gt; success(@Nullable T value) {
<span class="fc" id="L102">    return new Success&lt;&gt;(value);</span>
  }

  /**
   * Creates a {@code Try} representing a failed computation due to the given {@link Throwable}.
   *
   * @param throwable The non-null {@link Throwable} that caused the failure.
   * @param &lt;T&gt; The phantom type of the value (since the computation failed to produce one).
   * @return A non-null {@link Failure} instance holding the {@link Throwable}.
   * @throws NullPointerException if {@code throwable} is null.
   */
  static &lt;T&gt; Try&lt;T&gt; failure(Throwable throwable) {
<span class="fc" id="L114">    Validation.coreType().requireError(throwable, TRY_CLASS, RAISE_ERROR);</span>
<span class="fc" id="L115">    return new Failure&lt;&gt;(throwable);</span>
  }

  /**
   * Checks if this {@code Try} instance represents a successful computation (i.e., is a {@link
   * Success}).
   *
   * @return {@code true} if this is a {@link Success}, {@code false} otherwise.
   */
  boolean isSuccess();

  /**
   * Checks if this {@code Try} instance represents a failed computation (i.e., is a {@link
   * Failure}).
   *
   * @return {@code true} if this is a {@link Failure}, {@code false} otherwise.
   */
  boolean isFailure();

  /**
   * Retrieves the successful value if this is a {@link Success}. If this is a {@link Failure}, it
   * re-throws the original {@link Throwable} that caused the failure.
   *
   * &lt;p&gt;&lt;b&gt;Caution:&lt;/b&gt; This method breaks functional purity by potentially throwing an exception.
   * It's generally preferred to use methods like {@link #fold(Function, Function)}, {@link
   * #orElse(Object)}, {@link #recover(Function)}, or pattern matching to handle both success and
   * failure cases without throwing exceptions.
   *
   * @return The successful value (can be {@code null} if it was a {@code Success(null)}).
   * @throws Throwable if this is a {@link Failure}, the original exception is thrown.
   */
  @Nullable T get() throws Throwable;

  /**
   * Retrieves the successful value if this is a {@link Success}. If this is a {@link Failure}, it
   * returns the provided {@code other} value.
   *
   * @param other The alternative value to return if this is a {@link Failure}. Can be {@code null}
   *     if {@code T} is a nullable type.
   * @return The successful value if this is a {@link Success}, otherwise {@code other}.
   */
  @Nullable T orElse(@Nullable T other);

  /**
   * Retrieves the successful value if this is a {@link Success}. If this is a {@link Failure}, it
   * returns the value provided by the {@code supplier}. The supplier is only evaluated if this is a
   * {@link Failure}.
   *
   * @param supplier The non-null {@link Supplier} that provides an alternative value if this is a
   *     {@link Failure}.
   * @return The successful value if this is a {@link Success}, otherwise the result of {@code
   *     supplier.get()}.
   * @throws NullPointerException if {@code supplier} is null (but only if this is a {@link Failure}
   *     and the supplier needs to be invoked by the concrete implementation).
   */
  @Nullable T orElseGet(Supplier&lt;? extends T&gt; supplier);

  /**
   * Applies one of two functions depending on whether this is a {@link Success} or a {@link
   * Failure}. This allows for a complete handling of both outcomes, transforming them into a single
   * result of type {@code U}.
   *
   * @param successMapper The non-null function to apply if this is a {@link Success}.
   * @param failureMapper The non-null function to apply if this is a {@link Failure}.
   * @param &lt;U&gt; The target type to which both outcomes are mapped.
   * @return The result of applying the appropriate mapping function.
   * @throws NullPointerException if either {@code successMapper} or {@code failureMapper} is null.
   */
  default &lt;U&gt; U fold(
      Function&lt;? super T, ? extends U&gt; successMapper,
      Function&lt;? super Throwable, ? extends U&gt; failureMapper) {

<span class="fc" id="L187">    Validation.function().requireFunction(successMapper, &quot;successMapper&quot;, TRY_CLASS, FOLD);</span>
<span class="fc" id="L188">    Validation.function().requireFunction(failureMapper, &quot;failureMapper&quot;, TRY_CLASS, FOLD);</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L191">      case Success&lt;T&gt;(var value) -&gt; successMapper.apply(value);</span>
<span class="fc" id="L192">      case Failure&lt;T&gt;(var cause) -&gt; failureMapper.apply(cause);</span>
    };
  }

  /**
   * Converts this {@code Try} to an {@link Either}. If this is a {@link Success}, returns an {@code
   * Either.Right} containing the success value. If this is a {@link Failure}, applies the {@code
   * failureToLeftMapper} function to the {@link Throwable} and returns an {@code Either.Left}
   * containing the result.
   *
   * @param failureToLeftMapper A non-null function that maps the {@link Throwable} of a {@link
   *     Failure} to a value of type {@code L}.
   * @param &lt;L&gt; The type for the left side of the resulting {@code Either} (representing the error).
   * @return An {@code Either&lt;L, T&gt;} representing the outcome of this {@code Try}.
   * @throws NullPointerException if {@code failureToLeftMapper} is null.
   */
  default &lt;L&gt; Either&lt;L, T&gt; toEither(Function&lt;? super Throwable, ? extends L&gt; failureToLeftMapper) {
<span class="fc" id="L209">    Validation.function()</span>
<span class="fc" id="L210">        .requireFunction(failureToLeftMapper, &quot;failureToLeftMapper&quot;, TRY_CLASS, TO_EITHER);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">    return switch (this) {</span>
<span class="fc" id="L212">      case Success&lt;T&gt;(var value) -&gt; Either.right(value);</span>
<span class="fc" id="L213">      case Failure&lt;T&gt;(var cause) -&gt; {</span>
<span class="fc" id="L214">        L leftValue = failureToLeftMapper.apply(cause);</span>
<span class="fc" id="L215">        Validation.function()</span>
<span class="fc" id="L216">            .requireNonNullResult(</span>
                leftValue, &quot;failureToLeftMapper&quot;, TRY_CLASS, TO_EITHER, Either.class);
<span class="fc" id="L218">        yield Either.left(leftValue);</span>
      }
    };
  }

  /**
   * If this is a {@link Success}, applies the given mapping function to its value. If the mapping
   * function itself throws a {@link Throwable}, the result is a new {@link Failure} containing that
   * {@link Throwable}. If this is a {@link Failure}, it returns the original {@link Failure}
   * instance unchanged.
   *
   * @param mapper The non-null function to apply to the successful value.
   * @param &lt;U&gt; The type of the value in the resulting {@link Try} if mapping is successful.
   * @return A new non-null {@code Try&lt;U&gt;} resulting from applying the mapper, or a {@link Failure}.
   * @throws NullPointerException if {@code mapper} is null (checked by implementations).
   */
  &lt;U&gt; Try&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper);

  /**
   * If this is a {@link Success}, applies the given {@code Try}-bearing function to its value and
   * returns the resulting {@code Try}. If the mapping function itself throws a {@link Throwable},
   * the result is a new {@link Failure} containing that {@link Throwable}. If this is a {@link
   * Failure}, it returns the original {@link Failure} instance unchanged.
   *
   * @param mapper The non-null function to apply to the successful value.
   * @param &lt;U&gt; The type parameter of the {@code Try} returned by the mapper.
   * @return The non-null {@code Try&lt;U&gt;} result from applying {@code mapper}, or a {@link Failure}.
   * @throws NullPointerException if {@code mapper} is null, or if {@code mapper} returns null
   *     (checked by implementations).
   */
  &lt;U&gt; Try&lt;U&gt; flatMap(Function&lt;? super T, ? extends Try&lt;? extends U&gt;&gt; mapper);

  /**
   * If this is a {@link Failure}, applies the given recovery function to the {@link Throwable}. If
   * the recovery function successfully produces a value of type {@code T}, a {@link Success}
   * containing this value is returned. If the recovery function itself throws a {@link Throwable},
   * a new {@link Failure} containing this new {@link Throwable} is returned. If this is a {@link
   * Success}, it returns the original {@link Success} instance unchanged.
   *
   * @param recoveryFunction The non-null function to apply to the {@link Throwable} in case of a
   *     {@link Failure}.
   * @return A non-null {@code Try&lt;T&gt;} which is either the original {@link Success}, a new {@link
   *     Success} from recovery, or a new {@link Failure} if recovery also failed.
   * @throws NullPointerException if {@code recoveryFunction} is null (checked by implementations).
   */
  Try&lt;T&gt; recover(Function&lt;? super Throwable, ? extends T&gt; recoveryFunction);

  /**
   * If this is a {@link Failure}, applies the given {@code Try}-bearing recovery function to the
   * {@link Throwable}. This allows for a recovery path that itself might result in a {@link
   * Success} or a {@link Failure}. If the recovery function throws a {@link Throwable}, or returns
   * a {@code null} {@code Try}, the result is a new {@link Failure}. If this is a {@link Success},
   * it returns the original {@link Success} instance unchanged.
   *
   * @param recoveryFunction The non-null function to apply to the {@link Throwable}.
   * @return A non-null {@code Try&lt;T&gt;} which is either the original {@link Success}, the {@code Try}
   *     returned by the {@code recoveryFunction}, or a new {@link Failure} if recovery also failed
   *     or returned null.
   * @throws NullPointerException if {@code recoveryFunction} is null, or if it returns null
   *     (checked by implementations).
   */
  Try&lt;T&gt; recoverWith(Function&lt;? super Throwable, ? extends Try&lt;? extends T&gt;&gt; recoveryFunction);

  /**
   * Performs one of two actions depending on whether this is a {@link Success} or a {@link
   * Failure}, using pattern matching. This is primarily for side effects.
   *
   * &lt;p&gt;Note: Any exceptions thrown by the consumer actions are caught and logged to avoid
   * propagating errors from side-effect operations.
   *
   * @param successAction The non-null action to perform if this is a {@link Success}.
   * @param failureAction The non-null action to perform if this is a {@link Failure}.
   * @throws NullPointerException if either {@code successAction} or {@code failureAction} is null.
   */
  default void match(Consumer&lt;? super T&gt; successAction, Consumer&lt;? super Throwable&gt; failureAction) {
<span class="fc" id="L293">    Validation.function().requireFunction(successAction, &quot;successAction&quot;, TRY_CLASS, MATCH);</span>
<span class="fc" id="L294">    Validation.function().requireFunction(failureAction, &quot;failureAction&quot;, TRY_CLASS, MATCH);</span>

    try {
<span class="fc bfc" id="L297" title="All 2 branches covered.">      switch (this) {</span>
<span class="fc" id="L298">        case Success&lt;T&gt;(var value) -&gt; successAction.accept(value);</span>
<span class="fc" id="L299">        case Failure&lt;T&gt;(var cause) -&gt; failureAction.accept(cause);</span>
      }
<span class="fc" id="L301">    } catch (Throwable t) {</span>
      // Catch any exceptions from consumer actions to prevent propagation from side effects
<span class="fc" id="L303">      System.err.println(&quot;Exception in Try.match() consumer: &quot; + t.getMessage());</span>
<span class="fc" id="L304">    }</span>
<span class="fc" id="L305">  }</span>

  /**
   * Represents a successful computation within a {@link Try}. It holds the resulting value of type
   * {@code T}, which can be {@code null}. This is a {@link Record} for conciseness and
   * immutability.
   *
   * @param &lt;T&gt; The type of the successful value.
   * @param value The successful value, which can be {@code null}.
   */
<span class="fc" id="L315">  record Success&lt;T&gt;(@Nullable T value) implements Try&lt;T&gt; {</span>
    @Override
    public boolean isSuccess() {
<span class="fc" id="L318">      return true;</span>
    }

    @Override
    public boolean isFailure() {
<span class="fc" id="L323">      return false;</span>
    }

    @Override
    public @Nullable T get() {
<span class="fc" id="L328">      return value;</span>
    }

    @Override
    public @Nullable T orElse(@Nullable T other) {
<span class="fc" id="L333">      return value;</span>
    }

    @Override
    public @Nullable T orElseGet(Supplier&lt;? extends T&gt; supplier) {
<span class="fc" id="L338">      Validation.function().requireFunction(supplier, &quot;supplier&quot;, Try.class, OR_ELSE_GET);</span>
<span class="fc" id="L339">      return value;</span>
    }

    @Override
    public &lt;U&gt; Try&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L344">      Validation.function().requireMapper(mapper, &quot;mapper&quot;, Try.class, MAP);</span>
      try {
<span class="fc" id="L346">        return new Success&lt;&gt;(mapper.apply(value));</span>
<span class="fc" id="L347">      } catch (Throwable t) {</span>
<span class="fc" id="L348">        return new Failure&lt;&gt;(t);</span>
      }
    }

    @Override
    public &lt;U&gt; Try&lt;U&gt; flatMap(Function&lt;? super T, ? extends Try&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L354">      Validation.function().requireFlatMapper(mapper, &quot;mapper&quot;, Try.class, FLAT_MAP);</span>
      Try&lt;? extends U&gt; result;
      try {
<span class="fc" id="L357">        result = mapper.apply(value);</span>
<span class="fc" id="L358">      } catch (Throwable t) {</span>
<span class="fc" id="L359">        return new Failure&lt;&gt;(t);</span>
<span class="fc" id="L360">      }</span>

<span class="fc" id="L362">      Validation.function().requireNonNullResult(result, &quot;mapper&quot;, Try.class, FLAT_MAP, TRY_CLASS);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L364">      Try&lt;U&gt; typedResult = (Try&lt;U&gt;) result;</span>
<span class="fc" id="L365">      return typedResult;</span>
    }

    @Override
    public Try&lt;T&gt; recover(Function&lt;? super Throwable, ? extends T&gt; recoveryFunction) {
<span class="fc" id="L370">      Validation.function()</span>
<span class="fc" id="L371">          .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, Try.class, RECOVER_FUNCTION);</span>
<span class="fc" id="L372">      return this;</span>
    }

    @Override
    public Try&lt;T&gt; recoverWith(
        Function&lt;? super Throwable, ? extends Try&lt;? extends T&gt;&gt; recoveryFunction) {
<span class="fc" id="L378">      Validation.function()</span>
<span class="fc" id="L379">          .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, Try.class, RECOVER_WITH);</span>
<span class="fc" id="L380">      return this;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L385">      return &quot;Success(&quot; + value + &quot;)&quot;;</span>
    }
  }

  /**
   * Represents a failed computation within a {@link Try}. It holds the non-null {@link Throwable}
   * that caused the failure. This is a {@link Record} for conciseness and immutability.
   *
   * @param &lt;T&gt; The phantom type of the value (as there is no successful value).
   * @param cause The non-null {@link Throwable} that caused the failure.
   */
<span class="fc" id="L396">  record Failure&lt;T&gt;(Throwable cause) implements Try&lt;T&gt; {</span>

    @Override
    public boolean isSuccess() {
<span class="fc" id="L400">      return false;</span>
    }

    @Override
    public boolean isFailure() {
<span class="fc" id="L405">      return true;</span>
    }

    @Override
    public @Nullable T get() throws Throwable {
<span class="fc" id="L410">      throw cause;</span>
    }

    @Override
    public @Nullable T orElse(@Nullable T other) {
<span class="fc" id="L415">      return other;</span>
    }

    @Override
    public @Nullable T orElseGet(Supplier&lt;? extends T&gt; supplier) {
<span class="fc" id="L420">      Validation.function().requireFunction(supplier, &quot;supplier&quot;, Try.class, OR_ELSE_GET);</span>
<span class="fc" id="L421">      return supplier.get();</span>
    }

    @Override
    public &lt;U&gt; Try&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L426">      Validation.function().requireMapper(mapper, &quot;mapper&quot;, Try.class, MAP);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L428">      Try&lt;U&gt; self = (Try&lt;U&gt;) this;</span>
<span class="fc" id="L429">      return self;</span>
    }

    @Override
    public &lt;U&gt; Try&lt;U&gt; flatMap(Function&lt;? super T, ? extends Try&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L434">      Validation.function().requireFlatMapper(mapper, &quot;mapper&quot;, Try.class, FLAT_MAP);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L436">      Try&lt;U&gt; self = (Try&lt;U&gt;) this;</span>
<span class="fc" id="L437">      return self;</span>
    }

    @Override
    public Try&lt;T&gt; recover(Function&lt;? super Throwable, ? extends T&gt; recoveryFunction) {
<span class="fc" id="L442">      Validation.function()</span>
<span class="fc" id="L443">          .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, Try.class, RECOVER);</span>
      try {
<span class="fc" id="L445">        return new Success&lt;&gt;(recoveryFunction.apply(cause));</span>
<span class="fc" id="L446">      } catch (Throwable t) {</span>
<span class="fc" id="L447">        return new Failure&lt;&gt;(t);</span>
      }
    }

    @Override
    public Try&lt;T&gt; recoverWith(
        Function&lt;? super Throwable, ? extends Try&lt;? extends T&gt;&gt; recoveryFunction) {
<span class="fc" id="L454">      Validation.function()</span>
<span class="fc" id="L455">          .requireFunction(recoveryFunction, &quot;recoveryFunction&quot;, Try.class, RECOVER_WITH);</span>
      Try&lt;? extends T&gt; result;
      try {
<span class="fc" id="L458">        result = recoveryFunction.apply(cause);</span>
<span class="fc" id="L459">      } catch (Throwable t) {</span>
<span class="fc" id="L460">        return new Failure&lt;&gt;(t);</span>
<span class="fc" id="L461">      }</span>
<span class="fc" id="L462">      Validation.function()</span>
<span class="fc" id="L463">          .requireNonNullResult(result, &quot;recoveryFunction&quot;, Try.class, RECOVER_WITH, Try.class);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L465">      Try&lt;T&gt; typedResult = (Try&lt;T&gt;) result;</span>
<span class="fc" id="L466">      return typedResult;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L471">      return &quot;Failure(&quot; + cause + &quot;)&quot;;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>