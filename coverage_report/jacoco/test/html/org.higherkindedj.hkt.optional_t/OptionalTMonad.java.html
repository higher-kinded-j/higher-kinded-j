<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OptionalTMonad.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.optional_t</a> &gt; <span class="el_source">OptionalTMonad.java</span></div><h1>OptionalTMonad.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.optional_t;

import static org.higherkindedj.hkt.optional_t.OptionalTKindHelper.OPTIONAL_T;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.Optional;
import java.util.function.Function;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadError;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;
import org.jspecify.annotations.Nullable;

/**
 * Implements the {@link MonadError} interface for {@link OptionalT}. The witness for {@code
 * OptionalT&lt;F, ?&gt;} is {@link OptionalTKind.Witness Witness&amp;lt;F&amp;gt;}. The error type {@code E} is
 * fixed to {@link Unit}, as {@code OptionalT} inherently represents failure as an absence of a
 * value (similar to {@code Optional.empty()}).
 *
 * &lt;p&gt;This class requires a {@link Monad} instance for the outer monad {@code F} to operate. It uses
 * {@link OptionalTKindHelper} to convert between the {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}
 * representation and the concrete {@link OptionalT} type.
 *
 * @param &lt;F&gt; The witness type of the outer monad (e.g., {@code IOKind.Witness}).
 */
public class OptionalTMonad&lt;F&gt; implements MonadError&lt;OptionalTKind.Witness&lt;F&gt;, Unit&gt; {

<span class="fc" id="L31">  private static final Class&lt;OptionalTMonad&gt; OPTIONAL_T_MONAD_CLASS = OptionalTMonad.class;</span>
  private final Monad&lt;F&gt; outerMonad;

  /**
   * Constructs an {@code OptionalTMonad} instance.
   *
   * @param outerMonad The {@link Monad} instance for the outer monad {@code F}. Must not be null.
   * @throws NullPointerException if {@code outerMonad} is null.
   */
<span class="fc" id="L40">  public OptionalTMonad(Monad&lt;F&gt; outerMonad) {</span>
<span class="fc" id="L41">    this.outerMonad =</span>
<span class="fc" id="L42">        Validation.transformer()</span>
<span class="fc" id="L43">            .requireOuterMonad(outerMonad, OPTIONAL_T_MONAD_CLASS, CONSTRUCTION);</span>
<span class="fc" id="L44">  }</span>

  /**
   * Lifts a value {@code a} into the {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} context. Uses {@link
   * Optional#ofNullable(Object)} to handle potential nulls, resulting in {@code
   * F&lt;Optional.of(value)&gt;} or {@code F&lt;Optional.empty()&gt;}.
   *
   * @param &lt;A&gt; The type of the value.
   * @param value The value to lift. Can be null.
   * @return A {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} representing the lifted value.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; of(@Nullable A value) {
<span class="fc" id="L57">    Kind&lt;F, Optional&lt;A&gt;&gt; lifted = outerMonad.of(Optional.ofNullable(value));</span>
<span class="fc" id="L58">    return OPTIONAL_T.widen(OptionalT.fromKind(lifted));</span>
  }

  /**
   * Maps a function {@code f} over the value within a {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}. If
   * the wrapped {@code Kind&lt;F, Optional&lt;A&gt;&gt;} contains {@code Optional.of(a)}, the function is
   * applied. If it contains {@code Optional.empty()}, or if {@code f} returns null, the result is
   * {@code F&lt;Optional.empty()&gt;}. The transformation is applied within the context of the outer
   * monad {@code F}.
   *
   * @param &lt;A&gt; The original type of the value.
   * @param &lt;B&gt; The new type of the value after applying the function.
   * @param f The function to apply. Must not be null.
   * @param fa The {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} to map over. Must not be null.
   * @return A new {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;} with the function applied.
   * @throws NullPointerException if {@code f} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fa} is not a valid {@code
   *     OptionalT} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt; map(
      Function&lt;? super A, ? extends @Nullable B&gt; f, Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; fa) {

<span class="fc" id="L81">    Validation.function().requireMapper(f, &quot;f&quot;, OPTIONAL_T_MONAD_CLASS, MAP);</span>
<span class="fc" id="L82">    Validation.kind().requireNonNull(fa, OPTIONAL_T_MONAD_CLASS, MAP);</span>

<span class="fc" id="L84">    OptionalT&lt;F, A&gt; optionalT = OPTIONAL_T.narrow(fa);</span>
<span class="fc" id="L85">    Kind&lt;F, Optional&lt;B&gt;&gt; newValue = outerMonad.map(opt -&gt; opt.map(f), optionalT.value());</span>
<span class="fc" id="L86">    return OPTIONAL_T.widen(OptionalT.fromKind(newValue));</span>
  }

  /**
   * Applies a function wrapped in {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, Function&lt;A, B&gt;&gt;} to a value
   * wrapped in {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}.
   *
   * &lt;p&gt;The behaviour is as follows:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If both the function and value are present (i.e., {@code F&lt;Optional.of(Function)&gt;} and
   *       {@code F&lt;Optional.of(Value)&gt;}), the function is applied. If the application results in a
   *       null, it becomes {@code F&lt;Optional.empty()&gt;}. Otherwise, {@code F&lt;Optional.of(Result)&gt;}.
   *   &lt;li&gt;If either the function or value is {@code empty} (i.e., {@code F&lt;Optional.empty()&gt;}), the
   *       result is {@code F&lt;Optional.empty()&gt;}.
   * &lt;/ul&gt;
   *
   * @param &lt;A&gt; The type of the input value.
   * @param &lt;B&gt; The type of the result value.
   * @param ff The wrapped function. Must not be null.
   * @param fa The wrapped value. Must not be null.
   * @return A new {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;} representing the application.
   * @throws NullPointerException if {@code ff} or {@code fa} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ff} or {@code fa} is not
   *     a valid {@code OptionalT} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt; ap(
      Kind&lt;OptionalTKind.Witness&lt;F&gt;, ? extends Function&lt;A, @Nullable B&gt;&gt; ff,
      Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; fa) {

<span class="fc" id="L117">    Validation.kind().requireNonNull(ff, OPTIONAL_T_MONAD_CLASS, AP, &quot;function&quot;);</span>
<span class="fc" id="L118">    Validation.kind().requireNonNull(fa, OPTIONAL_T_MONAD_CLASS, AP, &quot;argument&quot;);</span>

<span class="fc" id="L120">    OptionalT&lt;F, ? extends Function&lt;A, @Nullable B&gt;&gt; funcT = OPTIONAL_T.narrow(ff);</span>
<span class="fc" id="L121">    OptionalT&lt;F, A&gt; valT = OPTIONAL_T.narrow(fa);</span>

<span class="fc" id="L123">    Kind&lt;F, Optional&lt;B&gt;&gt; resultValue =</span>
<span class="fc" id="L124">        outerMonad.flatMap(</span>
<span class="fc" id="L125">            optF -&gt; outerMonad.map(optA -&gt; optF.flatMap(optA::map), valT.value()), funcT.value());</span>
<span class="fc" id="L126">    return OPTIONAL_T.widen(OptionalT.fromKind(resultValue));</span>
  }

  /**
   * Applies a function {@code f} that returns a {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;} to the
   * value within a {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}, and flattens the result.
   *
   * &lt;p&gt;If the input {@code ma} contains {@code F&lt;Optional.of(a)&gt;}, {@code f(a)} is invoked. The
   * resulting {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;} (which internally is {@code
   * F&lt;Optional&lt;B&gt;&gt;}) becomes the result. If {@code ma} contains {@code F&lt;Optional.empty()&gt;}, or if
   * the inner {@code Optional} is {@code empty}, the result is {@code F&lt;Optional.empty()&gt;}.
   *
   * @param &lt;A&gt; The original type of the value.
   * @param &lt;B&gt; The type of the value in the resulting {@code Kind}.
   * @param f The function to apply, returning a new {@code Kind}. Must not be null.
   * @param ma The {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} to transform. Must not be null.
   * @return A new {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;}.
   * @throws NullPointerException if {@code f} or {@code ma} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} is not a valid {@code
   *     OptionalT} representation.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt; flatMap(
      Function&lt;? super A, ? extends Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;&gt; f,
      Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; ma) {

<span class="fc" id="L152">    Validation.function().requireFlatMapper(f, &quot;f&quot;, OPTIONAL_T_MONAD_CLASS, FLAT_MAP);</span>
<span class="fc" id="L153">    Validation.kind().requireNonNull(ma, OPTIONAL_T_MONAD_CLASS, FLAT_MAP);</span>

<span class="fc" id="L155">    OptionalT&lt;F, A&gt; optionalT = OPTIONAL_T.narrow(ma);</span>

<span class="fc" id="L157">    Kind&lt;F, Optional&lt;B&gt;&gt; newValue =</span>
<span class="fc" id="L158">        outerMonad.flatMap(</span>
            optA -&gt;
<span class="fc" id="L160">                optA.map(</span>
                        a -&gt; {
<span class="fc" id="L162">                          Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt; resultKind = f.apply(a);</span>
<span class="fc" id="L163">                          Validation.function()</span>
<span class="fc" id="L164">                              .requireNonNullResult(</span>
                                  resultKind, &quot;f&quot;, OPTIONAL_T_MONAD_CLASS, FLAT_MAP);
<span class="fc" id="L166">                          OptionalT&lt;F, B&gt; resultT = OPTIONAL_T.narrow(resultKind);</span>
<span class="fc" id="L167">                          return resultT.value();</span>
                        })
<span class="fc" id="L169">                    .orElseGet(() -&gt; outerMonad.of(Optional.empty())),</span>
<span class="fc" id="L170">            optionalT.value());</span>
<span class="fc" id="L171">    return OPTIONAL_T.widen(OptionalT.fromKind(newValue));</span>
  }

  // --- MonadError Methods (Error Type E = Unit) ---

  /**
   * Raises an error in the {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} context. For {@code
   * OptionalT}, an error is represented by the {@code empty} state, so this method returns a {@code
   * Kind} wrapping {@code F&lt;Optional.empty()&gt;}. The provided {@code error} of type {@link Unit}
   * (typically {@link Unit#INSTANCE}) is ignored.
   *
   * @param &lt;A&gt; The type parameter for the resulting {@code Kind}, though it will be empty.
   * @param error The error value ({@link Unit#INSTANCE}). Must be non-null.
   * @return A {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} representing {@code F&lt;Optional.empty()&gt;}.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; raiseError(Unit error) {
    // Note: error parameter is ignored since Optional.empty() doesn't carry error information
<span class="fc" id="L189">    return OPTIONAL_T.widen(OptionalT.none(outerMonad));</span>
  }

  /**
   * Handles an error (represented by {@code empty}) in the {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;,
   * A&gt;}. If the input {@code ma} represents {@code F&lt;Optional.empty()&gt;}, the {@code handler}
   * function is applied. The {@link Unit} parameter to the handler will be {@link Unit#INSTANCE}.
   * If {@code ma} represents {@code F&lt;Optional.of(a)&gt;}, it is returned unchanged. This operation is
   * performed within the context of the outer monad {@code F}.
   *
   * @param &lt;A&gt; The type of the value.
   * @param ma The {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;} to handle. Must not be null.
   * @param handler The function to apply if {@code ma} represents {@code F&lt;Optional.empty()&gt;}. It
   *     takes a {@link Unit} (which will be {@link Unit#INSTANCE}) and returns a new {@code
   *     Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}. Must not be null.
   * @return A {@code Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;}, either the original or the result of the
   *     handler.
   * @throws NullPointerException if {@code ma} or {@code handler} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code ma} is not a valid {@code
   *     OptionalT} representation.
   */
  @Override
  public &lt;A&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; handleErrorWith(
      Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; ma,
      Function&lt;? super Unit, ? extends Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;&gt; handler) {

<span class="fc" id="L215">    Validation.kind().requireNonNull(ma, OPTIONAL_T_MONAD_CLASS, HANDLE_ERROR_WITH, &quot;source&quot;);</span>
<span class="fc" id="L216">    Validation.function()</span>
<span class="fc" id="L217">        .requireFunction(handler, &quot;handler&quot;, OPTIONAL_T_MONAD_CLASS, HANDLE_ERROR_WITH);</span>

<span class="fc" id="L219">    OptionalT&lt;F, A&gt; optionalT = OPTIONAL_T.narrow(ma);</span>

<span class="fc" id="L221">    Kind&lt;F, Optional&lt;A&gt;&gt; handledValue =</span>
<span class="fc" id="L222">        outerMonad.flatMap(</span>
            optA -&gt; {
<span class="fc bfc" id="L224" title="All 2 branches covered.">              if (optA.isPresent()) {</span>
<span class="fc" id="L225">                return outerMonad.of(optA);</span>
              } else {
<span class="fc" id="L227">                Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; resultKind = handler.apply(Unit.INSTANCE);</span>
<span class="fc" id="L228">                Validation.function()</span>
<span class="fc" id="L229">                    .requireNonNullResult(</span>
                        resultKind,
                        &quot;handler&quot;,
                        OPTIONAL_T_MONAD_CLASS,
                        HANDLE_ERROR_WITH,
                        Kind.class);
<span class="fc" id="L235">                OptionalT&lt;F, A&gt; resultT = OPTIONAL_T.narrow(resultKind);</span>
<span class="fc" id="L236">                return resultT.value();</span>
              }
            },
<span class="fc" id="L239">            optionalT.value());</span>
<span class="fc" id="L240">    return OPTIONAL_T.widen(OptionalT.fromKind(handledValue));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>