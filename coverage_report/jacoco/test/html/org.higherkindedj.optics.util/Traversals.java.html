<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Traversals.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.util</a> &gt; <span class="el_source">Traversals.java</span></div><h1>Traversals.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.id.Id;
import org.higherkindedj.hkt.id.IdKind;
import org.higherkindedj.hkt.id.IdKindHelper;
import org.higherkindedj.hkt.id.IdMonad;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListKindHelper;
import org.higherkindedj.hkt.list.ListTraverse;
import org.higherkindedj.hkt.optional.OptionalKind;
import org.higherkindedj.hkt.optional.OptionalKindHelper;
import org.higherkindedj.hkt.optional.OptionalTraverse;
import org.higherkindedj.hkt.state.State;
import org.higherkindedj.hkt.state.StateTuple;
import org.higherkindedj.hkt.trampoline.Trampoline;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

/** A final utility class providing static helper methods for working with {@link Traversal}s. */
@NullMarked
public final class Traversals {
  /** Private constructor to prevent instantiation. */
  private Traversals() {}

  /**
   * Modifies all targets of a {@link Traversal} using a pure, non-effectful function.
   *
   * &lt;p&gt;This is a convenience method that wraps the function in the {@link Id} monad, which
   * represents a direct, synchronous computation, and then immediately unwraps the result.
   *
   * @param traversal The {@code Traversal} to use.
   * @param f A pure function to apply to each focused part.
   * @param source The source structure.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused parts.
   * @return A new, updated source structure.
   */
  public static &lt;S, A&gt; @Nullable S modify(
      final Traversal&lt;S, A&gt; traversal, final Function&lt;A, A&gt; f, S source) {
<span class="fc" id="L60">    Function&lt;A, Kind&lt;IdKind.Witness, A&gt;&gt; fId = a -&gt; Id.of(f.apply(a));</span>
<span class="fc" id="L61">    Kind&lt;IdKind.Witness, S&gt; resultInId = traversal.modifyF(fId, source, IdMonad.instance());</span>
<span class="fc" id="L62">    return IdKindHelper.ID.narrow(resultInId).value();</span>
  }

  /**
   * Extracts all targets of a {@link Traversal} from a source structure into a {@link List}.
   *
   * &lt;p&gt;This method traverses the structure, collecting each focused part into a list. It uses the
   * {@link Id} monad internally as a trivial context for the traversal.
   *
   * @param traversal The {@code Traversal} to use.
   * @param source The source structure.
   * @param &lt;S&gt; The type of the source structure.
   * @param &lt;A&gt; The type of the focused parts.
   * @return A {@code List} containing all the focused parts, in the order they were traversed.
   */
  public static &lt;S, A&gt; List&lt;A&gt; getAll(final Traversal&lt;S, A&gt; traversal, final S source) {
<span class="fc" id="L78">    final List&lt;A&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L79">    traversal.modifyF(</span>
        a -&gt; {
<span class="fc" id="L81">          results.add(a);</span>
<span class="fc" id="L82">          return Id.of(a); // Return original value in an Id context</span>
        },
        source,
<span class="fc" id="L85">        IdMonad.instance());</span>
<span class="fc" id="L86">    return results;</span>
  }

  /**
   * Creates an affine {@code Traversal} that focuses on the value only if it matches the given
   * predicate.
   *
   * &lt;p&gt;This is a static combinator that creates a {@code Traversal&lt;A, A&gt;} which focuses on zero or
   * one element (the input itself). It acts as an identity for matching values and a no-op for
   * non-matching values.
   *
   * &lt;p&gt;This combinator is particularly useful when composed with other traversals to add filtering
   * at any point in the composition chain.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Create an affine traversal that only focuses on active users
   * Traversal&lt;User, User&gt; activeUserFilter = Traversals.filtered(User::isActive);
   *
   * // Compose with a list traversal
   * Traversal&lt;List&lt;User&gt;, User&gt; activeUsersInList =
   *     Traversals.&lt;User&gt;forList().andThen(activeUserFilter);
   *
   * // Alternative: use directly with andThen
   * Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
   *     Traversals.&lt;User&gt;forList()
   *         .andThen(Traversals.filtered(User::isActive))
   *         .andThen(userNameLens.asTraversal());
   *
   * // Can also be used standalone
   * User user = ...;
   * User result = Traversals.modify(activeUserFilter, User::grantBonus, user);
   * // If user is active, returns user with bonus; otherwise returns user unchanged
   * }&lt;/pre&gt;
   *
   * @param predicate The predicate to filter by
   * @param &lt;A&gt; The type of the value to filter
   * @return An affine {@code Traversal} that focuses on the value only if it matches
   */
  public static &lt;A&gt; Traversal&lt;A, A&gt; filtered(final Predicate&lt;? super A&gt; predicate) {
<span class="fc" id="L127">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, A&gt; modifyF(
          final Function&lt;A, Kind&lt;F, A&gt;&gt; f, final A source, final Applicative&lt;F&gt; applicative) {
<span class="fc bfc" id="L131" title="All 2 branches covered.">        return predicate.test(source) ? f.apply(source) : applicative.of(source);</span>
      }
    };
  }

  /**
   * Creates a {@code Traversal} that focuses on every element within a {@link List}.
   *
   * &lt;p&gt;This is a canonical traversal for the {@code List} data type, allowing an effectful function
   * to be applied to each of its elements.
   *
   * @param &lt;A&gt; The element type of the list.
   * @return A {@code Traversal} for the elements of a list.
   */
  public static &lt;A&gt; Traversal&lt;List&lt;A&gt;, A&gt; forList() {
<span class="fc" id="L146">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, List&lt;A&gt;&gt; modifyF(
          final Function&lt;A, Kind&lt;F, A&gt;&gt; f, final List&lt;A&gt; source, final Applicative&lt;F&gt; applicative) {
<span class="fc" id="L150">        Kind&lt;F, Kind&lt;ListKind.Witness, A&gt;&gt; traversed =</span>
<span class="fc" id="L151">            ListTraverse.INSTANCE.traverse(applicative, f, ListKindHelper.LIST.widen(source));</span>
<span class="fc" id="L152">        return applicative.map(ListKindHelper.LIST::narrow, traversed);</span>
      }
    };
  }

  /**
   * Creates a {@code Traversal} that focuses on a specific value within a {@code Map} by its key.
   *
   * &lt;p&gt;If the key exists in the map, the traversal focuses on its corresponding value. If the key
   * does not exist, the traversal focuses on zero elements, and any modification will have no
   * effect.
   *
   * @param key The key to focus on in the map.
   * @param &lt;K&gt; The type of the map's keys.
   * @param &lt;V&gt; The type of the map's values.
   * @return A {@code Traversal} for a map value.
   */
  public static &lt;K, V&gt; Traversal&lt;Map&lt;K, V&gt;, V&gt; forMap(final K key) {
<span class="fc" id="L170">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, Map&lt;K, V&gt;&gt; modifyF(
          Function&lt;V, Kind&lt;F, V&gt;&gt; f, Map&lt;K, V&gt; source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L174">        V currentValue = source.get(key);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (currentValue == null) {</span>
          // If the key doesn't exist, do nothing.
<span class="fc" id="L177">          return applicative.of(source);</span>
        }

        // Apply the function to the existing value to get the new value in context.
<span class="fc" id="L181">        Kind&lt;F, V&gt; newValueF = f.apply(currentValue);</span>

        // Map the result back into the map structure.
<span class="fc" id="L184">        return applicative.map(</span>
            newValue -&gt; {
              // Create a new map to preserve immutability.
<span class="fc" id="L187">              Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(source);</span>
<span class="fc" id="L188">              newMap.put(key, newValue);</span>
<span class="fc" id="L189">              return newMap;</span>
            },
            newValueF);
      }
    };
  }

  /**
   * Creates a {@code Traversal} that focuses on the value within an {@link Optional}.
   *
   * &lt;p&gt;This is an affine traversal with 0-1 cardinality. If the optional is empty, the traversal
   * focuses on zero elements and modifications have no effect. If the optional contains a value,
   * the traversal focuses on that single value.
   *
   * &lt;p&gt;This traversal is particularly useful for composing with other traversals to handle optional
   * nested structures.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Modify the value inside an optional
   * Traversal&lt;Optional&lt;String&gt;, String&gt; optTraversal = Traversals.forOptional();
   * Optional&lt;String&gt; result = Traversals.modify(
   *     optTraversal,
   *     String::toUpperCase,
   *     Optional.of(&quot;hello&quot;)
   * );
   * // result = Optional.of(&quot;HELLO&quot;)
   *
   * // Compose with other traversals
   * Traversal&lt;List&lt;Optional&lt;User&gt;&gt;, User&gt; userTraversal =
   *     Traversals.&lt;Optional&lt;User&gt;&gt;forList()
   *         .andThen(Traversals.forOptional());
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value potentially contained in the optional.
   * @return A {@code Traversal} for optional values.
   */
  public static &lt;A&gt; Traversal&lt;Optional&lt;A&gt;, A&gt; forOptional() {
<span class="fc" id="L228">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, Optional&lt;A&gt;&gt; modifyF(
          final Function&lt;A, Kind&lt;F, A&gt;&gt; f,
          final Optional&lt;A&gt; source,
          final Applicative&lt;F&gt; applicative) {
<span class="fc" id="L234">        return traverseOptional(source, f, applicative);</span>
      }
    };
  }

  /**
   * Creates a {@code Traversal} that focuses on all values within a {@link Map}, preserving the
   * keys.
   *
   * &lt;p&gt;This traversal applies an effectful function to each value in the map while keeping all keys
   * unchanged. The order of traversal follows the map's iteration order.
   *
   * &lt;p&gt;This is distinct from {@link #forMap(Object)} which focuses on a single key-value pair. This
   * traversal focuses on all values simultaneously.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Modify all values in a map
   * Map&lt;String, Integer&gt; ages = Map.of(&quot;Alice&quot;, 25, &quot;Bob&quot;, 30);
   * Traversal&lt;Map&lt;String, Integer&gt;, Integer&gt; allValues = Traversals.forMapValues();
   *
   * Map&lt;String, Integer&gt; incremented = Traversals.modify(
   *     allValues,
   *     age -&gt; age + 1,
   *     ages
   * );
   * // incremented = Map.of(&quot;Alice&quot;, 26, &quot;Bob&quot;, 31)
   *
   * // Get all values
   * List&lt;Integer&gt; values = Traversals.getAll(allValues, ages);
   * // values = [25, 30] (order depends on map iteration order)
   * }&lt;/pre&gt;
   *
   * @param &lt;K&gt; The type of the map's keys.
   * @param &lt;V&gt; The type of the map's values.
   * @return A {@code Traversal} for all map values.
   */
  public static &lt;K, V&gt; Traversal&lt;Map&lt;K, V&gt;, V&gt; forMapValues() {
<span class="fc" id="L273">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, Map&lt;K, V&gt;&gt; modifyF(
          final Function&lt;V, Kind&lt;F, V&gt;&gt; f,
          final Map&lt;K, V&gt; source,
          final Applicative&lt;F&gt; applicative) {
<span class="fc" id="L279">        return traverseMapValues(source, f, applicative);</span>
      }
    };
  }

  /**
   * Applies an effectful function to each element of a {@link List} and collects the results in a
   * single effect.
   *
   * &lt;p&gt;This is a direct application of the {@code traverse} operation for {@code List}, provided
   * here as a static helper for convenience. It &quot;flips&quot; a {@code List&lt;A&gt;} and a function {@code A
   * -&gt; F&lt;B&gt;} into a single {@code F&lt;List&lt;B&gt;&gt;}.
   *
   * @param list The source list to traverse.
   * @param f The effectful function to apply to each element.
   * @param applicative The {@code Applicative} instance for the effect {@code F}.
   * @param &lt;F&gt; The higher-kinded type witness of the applicative effect.
   * @param &lt;A&gt; The element type of the source list.
   * @param &lt;B&gt; The element type of the resulting list.
   * @return A {@code Kind&lt;F, List&lt;B&gt;&gt;}, representing the collected results within the applicative
   *     context.
   */
  public static &lt;F, A, B&gt; Kind&lt;F, List&lt;B&gt;&gt; traverseList(
      final List&lt;A&gt; list, final Function&lt;A, Kind&lt;F, B&gt;&gt; f, final Applicative&lt;F&gt; applicative) {

<span class="fc" id="L304">    final List&lt;Kind&lt;F, B&gt;&gt; listOfEffects = list.stream().map(f).collect(Collectors.toList());</span>
<span class="fc" id="L305">    final Kind&lt;ListKind.Witness, Kind&lt;F, B&gt;&gt; effectsAsKind =</span>
<span class="fc" id="L306">        ListKindHelper.LIST.widen(listOfEffects);</span>
<span class="fc" id="L307">    final var effectOfKindList = ListTraverse.INSTANCE.sequenceA(applicative, effectsAsKind);</span>

<span class="fc" id="L309">    return applicative.map(ListKindHelper.LIST::narrow, effectOfKindList);</span>
  }

  /**
   * Applies an effectful function to the value in an {@link Optional} if present, collecting the
   * result in a single effect.
   *
   * &lt;p&gt;This is a direct application of the {@code traverse} operation for {@code Optional},
   * provided here as a static helper for convenience. It &quot;flips&quot; an {@code Optional&lt;A&gt;} and a
   * function {@code A -&gt; F&lt;B&gt;} into a single {@code F&lt;Optional&lt;B&gt;&gt;}.
   *
   * &lt;p&gt;If the optional is empty, the result is {@code applicative.of(Optional.empty())}. If the
   * optional contains a value, the function is applied to produce {@code F&lt;B&gt;}, which is then
   * mapped to {@code F&lt;Optional&lt;B&gt;&gt;}.
   *
   * @param optional The source optional to traverse.
   * @param f The effectful function to apply to the value if present.
   * @param applicative The {@code Applicative} instance for the effect {@code F}.
   * @param &lt;F&gt; The higher-kinded type witness of the applicative effect.
   * @param &lt;A&gt; The element type of the source optional.
   * @param &lt;B&gt; The element type of the resulting optional.
   * @return A {@code Kind&lt;F, Optional&lt;B&gt;&gt;}, representing the result within the applicative context.
   */
  public static &lt;F, A, B&gt; Kind&lt;F, Optional&lt;B&gt;&gt; traverseOptional(
      final Optional&lt;A&gt; optional,
      final Function&lt;? super A, ? extends Kind&lt;F, ? extends B&gt;&gt; f,
      final Applicative&lt;F&gt; applicative) {

<span class="fc" id="L337">    final Kind&lt;OptionalKind.Witness, A&gt; optionalKind = OptionalKindHelper.OPTIONAL.widen(optional);</span>
<span class="fc" id="L338">    final Kind&lt;F, Kind&lt;OptionalKind.Witness, B&gt;&gt; traversed =</span>
<span class="fc" id="L339">        OptionalTraverse.INSTANCE.traverse(applicative, f, optionalKind);</span>

<span class="fc" id="L341">    return applicative.map(OptionalKindHelper.OPTIONAL::narrow, traversed);</span>
  }

  /**
   * Applies an effectful function to each value in a {@link Map}, preserving the keys and
   * collecting the results in a single effect.
   *
   * &lt;p&gt;This helper traverses all values in the map, applying the effectful function {@code f} to
   * each value while keeping the keys unchanged. The result is a {@code F&lt;Map&lt;K, W&gt;&gt;} where all
   * effects have been sequenced.
   *
   * &lt;p&gt;If the map is empty, returns {@code applicative.of(emptyMap)}.
   *
   * @param map The source map to traverse.
   * @param f The effectful function to apply to each value.
   * @param applicative The {@code Applicative} instance for the effect {@code F}.
   * @param &lt;F&gt; The higher-kinded type witness of the applicative effect.
   * @param &lt;K&gt; The type of the map keys.
   * @param &lt;V&gt; The type of the source map values.
   * @param &lt;W&gt; The type of the resulting map values.
   * @return A {@code Kind&lt;F, Map&lt;K, W&gt;&gt;}, representing the transformed map within the applicative
   *     context.
   */
  public static &lt;F, K, V, W&gt; Kind&lt;F, Map&lt;K, W&gt;&gt; traverseMapValues(
      final Map&lt;K, V&gt; map,
      final Function&lt;? super V, ? extends Kind&lt;F, ? extends W&gt;&gt; f,
      final Applicative&lt;F&gt; applicative) {

<span class="fc bfc" id="L369" title="All 2 branches covered.">    if (map.isEmpty()) {</span>
<span class="fc" id="L370">      return applicative.of(new HashMap&lt;&gt;());</span>
    }

<span class="fc" id="L373">    Kind&lt;F, Map&lt;K, W&gt;&gt; result = applicative.of(new HashMap&lt;&gt;(map.size()));</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L376">      final Kind&lt;F, W&gt; newFValue = (Kind&lt;F, W&gt;) f.apply(entry.getValue());</span>
<span class="fc" id="L377">      final K key = entry.getKey();</span>
<span class="fc" id="L378">      result =</span>
<span class="fc" id="L379">          applicative.map2(</span>
              result,
              newFValue,
              (m, w) -&gt; {
<span class="fc" id="L383">                final Map&lt;K, W&gt; updated = new HashMap&lt;&gt;(m);</span>
<span class="fc" id="L384">                updated.put(key, w);</span>
<span class="fc" id="L385">                return updated;</span>
              });
<span class="fc" id="L387">    }</span>
<span class="fc" id="L388">    return result;</span>
  }

  /**
   * Applies an effectful function to both elements of a {@link Tuple2} where both elements are of
   * the same type, collecting the results in a single effect.
   *
   * &lt;p&gt;This helper traverses both positions in the tuple, applying the effectful function {@code f}
   * to each element. The result is {@code F&lt;Tuple2&lt;B, B&gt;&gt;} where both effects have been sequenced.
   *
   * @param tuple The source tuple to traverse.
   * @param f The effectful function to apply to each element.
   * @param applicative The {@code Applicative} instance for the effect {@code F}.
   * @param &lt;F&gt; The higher-kinded type witness of the applicative effect.
   * @param &lt;A&gt; The element type of the source tuple.
   * @param &lt;B&gt; The element type of the resulting tuple.
   * @return A {@code Kind&lt;F, Tuple2&lt;B, B&gt;&gt;}, representing the transformed tuple within the
   *     applicative context.
   */
  public static &lt;F, A, B&gt; Kind&lt;F, Tuple2&lt;B, B&gt;&gt; traverseTuple2Both(
      final Tuple2&lt;A, A&gt; tuple,
      final Function&lt;? super A, ? extends Kind&lt;F, ? extends B&gt;&gt; f,
      final Applicative&lt;F&gt; applicative) {

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L413">    final Kind&lt;F, B&gt; first = (Kind&lt;F, B&gt;) f.apply(tuple._1());</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L415">    final Kind&lt;F, B&gt; second = (Kind&lt;F, B&gt;) f.apply(tuple._2());</span>

<span class="fc" id="L417">    return applicative.map2(first, second, Tuple2::new);</span>
  }

  /**
   * Traverse a list with speculative execution for each element. Both branches are visible upfront,
   * allowing selective implementations to potentially execute them in parallel.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Try cache first, API as fallback - both can start immediately
   * List&lt;UserId&gt; ids = List.of(id1, id2, id3);
   * Kind&lt;F, List&lt;User&gt;&gt; users = Traversals.speculativeTraverseList(
   *   ids,
   *   id -&gt; cacheHas(id),           // Predicate
   *   id -&gt; fetchFromCache(id),     // Fast path
   *   id -&gt; fetchFromAPI(id),       // Slow path
   *   selective
   * );
   * }&lt;/pre&gt;
   *
   * @param list The list to traverse
   * @param predicate Determines which branch to take for each element
   * @param thenBranch Function to apply when predicate is true
   * @param elseBranch Function to apply when predicate is false
   * @param selective The Selective instance
   * @param &lt;F&gt; The effect type
   * @param &lt;A&gt; The element type of the input list
   * @param &lt;B&gt; The element type of the output list
   * @return The transformed list wrapped in the effect
   */
  public static &lt;F, A, B&gt; Kind&lt;F, List&lt;B&gt;&gt; speculativeTraverseList(
      final List&lt;A&gt; list,
      final Predicate&lt;? super A&gt; predicate,
      final Function&lt;? super A, ? extends Kind&lt;F, B&gt;&gt; thenBranch,
      final Function&lt;? super A, ? extends Kind&lt;F, B&gt;&gt; elseBranch,
      final Selective&lt;F&gt; selective) {
    // Wrap each element in a selective conditional
<span class="fc" id="L455">    final Function&lt;A, Kind&lt;F, B&gt;&gt; selectiveF =</span>
        a -&gt;
<span class="fc" id="L457">            selective.ifS(</span>
<span class="fc" id="L458">                selective.of(predicate.test(a)), thenBranch.apply(a), elseBranch.apply(a));</span>

    // Use the standard traverse implementation
<span class="fc" id="L461">    return traverseList(list, selectiveF, selective);</span>
  }

  /**
   * Traverse a list, applying a function only to elements that match a predicate. Elements that
   * don't match are left unchanged.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Only validate emails that look valid
   * List&lt;String&gt; emails = List.of(&quot;valid@example.com&quot;, &quot;invalid&quot;, &quot;another@example.com&quot;);
   * Kind&lt;F, List&lt;String&gt;&gt; result = Traversals.traverseListIf(
   *   emails,
   *   email -&gt; email.contains(&quot;@&quot;),
   *   email -&gt; validateEmailInDatabase(email),
   *   selective
   * );
   * }&lt;/pre&gt;
   *
   * @param list The list to traverse
   * @param predicate Determines which elements to process
   * @param f Function to apply to matching elements
   * @param selective The Selective instance
   * @param &lt;F&gt; The effect type
   * @param &lt;A&gt; The element type
   * @return The transformed list wrapped in the effect
   */
  public static &lt;F, A&gt; Kind&lt;F, List&lt;A&gt;&gt; traverseListIf(
      final List&lt;A&gt; list,
      final Predicate&lt;? super A&gt; predicate,
      final Function&lt;? super A, ? extends Kind&lt;F, A&gt;&gt; f,
      final Selective&lt;F&gt; selective) {
<span class="fc" id="L494">    final Function&lt;A, Kind&lt;F, A&gt;&gt; conditionalF =</span>
        a -&gt; {
<span class="fc bfc" id="L496" title="All 2 branches covered.">          if (predicate.test(a)) {</span>
<span class="fc" id="L497">            return f.apply(a);</span>
          } else {
<span class="fc" id="L499">            return selective.of(a);</span>
          }
        };

<span class="fc" id="L503">    return traverseList(list, conditionalF, selective);</span>
  }

  /**
   * Traverse a list, stopping when a predicate is met. Elements after the stopping point are left
   * unchanged.
   *
   * &lt;p&gt;This implementation uses the State monad to track whether we've stopped, making it purely
   * functional, referentially transparent, and thread-safe.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Process items until we hit an error
   * List&lt;Task&gt; tasks = List.of(task1, task2, task3);
   * Kind&lt;F, List&lt;Task&gt;&gt; result = Traversals.traverseListUntil(
   *   tasks,
   *   task -&gt; task.hasError(),
   *   task -&gt; processTask(task),
   *   selective
   * );
   * }&lt;/pre&gt;
   *
   * @param list The list to traverse
   * @param stopCondition Predicate that triggers stopping
   * @param f Function to apply to elements before stopping
   * @param selective The Selective instance
   * @param &lt;F&gt; The effect type
   * @param &lt;A&gt; The element type
   * @return The transformed list wrapped in the effect
   */
  public static &lt;F, A&gt; Kind&lt;F, List&lt;A&gt;&gt; traverseListUntil(
      final List&lt;A&gt; list,
      final Predicate&lt;? super A&gt; stopCondition,
      final Function&lt;? super A, ? extends Kind&lt;F, A&gt;&gt; f,
      final Selective&lt;F&gt; selective) {

    // Create a stateful function that tracks whether we've stopped
<span class="fc" id="L541">    final Function&lt;A, State&lt;Boolean, Kind&lt;F, A&gt;&gt;&gt; statefulF =</span>
        a -&gt;
<span class="fc bfc" id="L543" title="All 4 branches covered.">            State.&lt;Boolean, Boolean&gt;inspect(stopped -&gt; stopped || stopCondition.test(a))</span>
<span class="fc" id="L544">                .flatMap(</span>
                    shouldStop -&gt; {
<span class="fc bfc" id="L546" title="All 2 branches covered.">                      if (shouldStop) {</span>
<span class="fc" id="L547">                        return State.set(true).map(_ -&gt; selective.of(a));</span>
                      } else {
<span class="fc" id="L549">                        return State.pure(f.apply(a));</span>
                      }
                    });

    // Map each element through the stateful function
<span class="fc" id="L554">    final List&lt;State&lt;Boolean, Kind&lt;F, A&gt;&gt;&gt; statefulComputations =</span>
<span class="fc" id="L555">        list.stream().map(statefulF).collect(Collectors.toList());</span>

    // Sequence the stateful computations
<span class="fc" id="L558">    final State&lt;Boolean, List&lt;Kind&lt;F, A&gt;&gt;&gt; sequencedState = sequenceStateList(statefulComputations);</span>

    // Run the state computation (initial state: false = not stopped)
<span class="fc" id="L561">    final StateTuple&lt;Boolean, List&lt;Kind&lt;F, A&gt;&gt;&gt; result = sequencedState.run(false);</span>

    // Now sequence the effects within F
<span class="fc" id="L564">    final List&lt;Kind&lt;F, A&gt;&gt; effectsList = result.value();</span>
<span class="fc" id="L565">    return traverseList(effectsList, Function.identity(), selective);</span>
  }

  /**
   * Sequences a list of State computations into a State of a list.
   *
   * &lt;p&gt;This implementation uses {@link Trampoline} for stack safety whilst maintaining functional
   * purity. The previous imperative loop implementation has been replaced with a tail-recursive
   * algorithm executed via Trampoline, preventing {@code StackOverflowError} with arbitrarily large
   * lists whilst preserving referential transparency.
   *
   * &lt;p&gt;The naive functional approach using {@code Stream.reduce} with {@code flatMap} creates
   * deeply nested closures that cause {@code StackOverflowError} with large lists (&gt;1000 elements).
   * Trampoline eliminates this issue by converting recursion into iteration.
   *
   * @param states List of State computations to sequence
   * @param &lt;S&gt; The state type
   * @param &lt;A&gt; The value type
   * @return A State computation that produces a list of all values
   */
  static &lt;S, A&gt; State&lt;S, List&lt;A&gt;&gt; sequenceStateList(final List&lt;State&lt;S, A&gt;&gt; states) {
<span class="fc" id="L586">    return State.of(</span>
        initialState -&gt; {
<span class="fc" id="L588">          final List&lt;A&gt; resultList = new ArrayList&lt;&gt;(states.size());</span>
<span class="fc" id="L589">          final Trampoline&lt;StateTuple&lt;S, List&lt;A&gt;&gt;&gt; trampoline =</span>
<span class="fc" id="L590">              sequenceStateListTrampoline(states, 0, initialState, resultList);</span>
<span class="fc" id="L591">          return trampoline.run();</span>
        });
  }

  /**
   * Tail-recursive helper for sequencing State computations using Trampoline.
   *
   * &lt;p&gt;This method processes the list of State computations recursively, building up the result
   * list and threading state through. Each recursive call is wrapped in {@link Trampoline#defer} to
   * ensure stack safety.
   *
   * @param states The list of State computations to sequence
   * @param index The current index in the list
   * @param currentState The current state value
   * @param resultList The accumulated list of results (mutated for efficiency)
   * @param &lt;S&gt; The state type
   * @param &lt;A&gt; The value type
   * @return A Trampoline that will produce the final StateTuple when run
   */
  private static &lt;S, A&gt; Trampoline&lt;StateTuple&lt;S, List&lt;A&gt;&gt;&gt; sequenceStateListTrampoline(
      final List&lt;State&lt;S, A&gt;&gt; states,
      final int index,
      final S currentState,
      final List&lt;A&gt; resultList) {
    // Base case: processed all states
<span class="fc bfc" id="L616" title="All 2 branches covered.">    if (index &gt;= states.size()) {</span>
<span class="fc" id="L617">      return Trampoline.done(new StateTuple&lt;&gt;(resultList, currentState));</span>
    }

    // Recursive case: process next state
<span class="fc" id="L621">    final StateTuple&lt;S, A&gt; result = states.get(index).run(currentState);</span>
<span class="fc" id="L622">    resultList.add(result.value());</span>

<span class="fc" id="L624">    return Trampoline.defer(</span>
<span class="fc" id="L625">        () -&gt; sequenceStateListTrampoline(states, index + 1, result.state(), resultList));</span>
  }

  /**
   * Converts a {@link Traversal} into a {@link Lens} focusing on a list of all traversed elements.
   *
   * &lt;p&gt;This powerful combinator allows you to extract all focused elements as a list, manipulate
   * that list using standard list operations (sorting, reversing, filtering, etc.), and write the
   * results back to the structure.
   *
   * &lt;p&gt;The getter extracts all focused elements into a mutable {@link List}. The setter distributes
   * the list elements back to the original positions. If the new list has fewer elements than the
   * original, the remaining positions retain their original values. If the new list has more
   * elements, the extra elements are ignored.
   *
   * &lt;p&gt;Example use cases:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Sorting focused elements
   *   &lt;li&gt;Reversing focused elements
   *   &lt;li&gt;Removing duplicates
   *   &lt;li&gt;Applying list algorithms to traversal focuses
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Sort all names in a list of users
   * Traversal&lt;List&lt;User&gt;, String&gt; userNames = Traversals.&lt;User&gt;forList()
   *     .andThen(userNameLens.asTraversal());
   * Lens&lt;List&lt;User&gt;, List&lt;String&gt;&gt; namesLens = Traversals.partsOf(userNames);
   *
   * List&lt;User&gt; users = List.of(
   *     new User(&quot;Charlie&quot;, 30),
   *     new User(&quot;Alice&quot;, 25),
   *     new User(&quot;Bob&quot;, 35)
   * );
   *
   * // Get all names as a list
   * List&lt;String&gt; names = namesLens.get(users);  // [&quot;Charlie&quot;, &quot;Alice&quot;, &quot;Bob&quot;]
   *
   * // Sort the names
   * List&lt;String&gt; sorted = new ArrayList&lt;&gt;(names);
   * Collections.sort(sorted);
   *
   * // Set them back
   * List&lt;User&gt; result = namesLens.set(sorted, users);
   * // Result: [User(&quot;Alice&quot;, 30), User(&quot;Bob&quot;, 25), User(&quot;Charlie&quot;, 35)]
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal to convert into a lens
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused elements
   * @return A lens focusing on a list of all traversed elements
   */
  public static &lt;S, A&gt; Lens&lt;S, List&lt;A&gt;&gt; partsOf(final Traversal&lt;S, A&gt; traversal) {
<span class="fc" id="L681">    return Lens.of(</span>
        // Getter: collect all elements into a mutable list
<span class="fc" id="L683">        source -&gt; getAll(traversal, source),</span>
        // Setter: distribute list elements back to original positions
        (source, newList) -&gt; {
<span class="fc" id="L686">          final AtomicInteger index = new AtomicInteger(0);</span>
<span class="fc" id="L687">          return modify(</span>
              traversal,
              oldValue -&gt; {
<span class="fc" id="L690">                int i = index.getAndIncrement();</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                return i &lt; newList.size() ? newList.get(i) : oldValue;</span>
              },
              source);
        });
  }

  /**
   * Sorts the elements focused by a traversal using their natural ordering.
   *
   * &lt;p&gt;This is a convenience method that uses {@link #partsOf} to extract all focused elements,
   * sort them, and write them back.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Traversal&lt;List&lt;User&gt;, Integer&gt; userAges = Traversals.&lt;User&gt;forList()
   *     .andThen(userAgeLens.asTraversal());
   *
   * List&lt;User&gt; users = List.of(
   *     new User(&quot;Alice&quot;, 30),
   *     new User(&quot;Bob&quot;, 25),
   *     new User(&quot;Charlie&quot;, 35)
   * );
   *
   * List&lt;User&gt; sorted = Traversals.sorted(userAges, users);
   * // Result: [User(&quot;Alice&quot;, 25), User(&quot;Bob&quot;, 30), User(&quot;Charlie&quot;, 35)]
   * // Note: ages are sorted, not users themselves
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal focusing on elements to sort
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused elements (must be Comparable)
   * @return A new structure with focused elements sorted
   */
  public static &lt;S, A extends Comparable&lt;? super A&gt;&gt; @Nullable S sorted(
      final Traversal&lt;S, A&gt; traversal, final S source) {
<span class="fc" id="L728">    final Lens&lt;S, List&lt;A&gt;&gt; partsLens = partsOf(traversal);</span>
<span class="fc" id="L729">    final List&lt;A&gt; parts = new ArrayList&lt;&gt;(partsLens.get(source));</span>
<span class="fc" id="L730">    Collections.sort(parts);</span>
<span class="fc" id="L731">    return partsLens.set(parts, source);</span>
  }

  /**
   * Sorts the elements focused by a traversal using a custom comparator.
   *
   * &lt;p&gt;This is a convenience method that uses {@link #partsOf} to extract all focused elements,
   * sort them with the provided comparator, and write them back.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Traversal&lt;List&lt;User&gt;, String&gt; userNames = Traversals.&lt;User&gt;forList()
   *     .andThen(userNameLens.asTraversal());
   *
   * List&lt;User&gt; users = List.of(
   *     new User(&quot;charlie&quot;, 30),
   *     new User(&quot;Alice&quot;, 25),
   *     new User(&quot;bob&quot;, 35)
   * );
   *
   * // Sort names case-insensitively
   * List&lt;User&gt; sorted = Traversals.sorted(userNames, String.CASE_INSENSITIVE_ORDER, users);
   * // Result: [User(&quot;Alice&quot;, 30), User(&quot;bob&quot;, 25), User(&quot;charlie&quot;, 35)]
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal focusing on elements to sort
   * @param comparator The comparator to use for sorting
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused elements
   * @return A new structure with focused elements sorted
   */
  public static &lt;S, A&gt; @Nullable S sorted(
      final Traversal&lt;S, A&gt; traversal, final Comparator&lt;? super A&gt; comparator, final S source) {
<span class="fc" id="L766">    final Lens&lt;S, List&lt;A&gt;&gt; partsLens = partsOf(traversal);</span>
<span class="fc" id="L767">    final List&lt;A&gt; parts = new ArrayList&lt;&gt;(partsLens.get(source));</span>
<span class="fc" id="L768">    parts.sort(comparator);</span>
<span class="fc" id="L769">    return partsLens.set(parts, source);</span>
  }

  /**
   * Reverses the order of elements focused by a traversal.
   *
   * &lt;p&gt;This is a convenience method that uses {@link #partsOf} to extract all focused elements,
   * reverse them, and write them back.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Traversal&lt;List&lt;User&gt;, String&gt; userNames = Traversals.&lt;User&gt;forList()
   *     .andThen(userNameLens.asTraversal());
   *
   * List&lt;User&gt; users = List.of(
   *     new User(&quot;Alice&quot;, 25),
   *     new User(&quot;Bob&quot;, 30),
   *     new User(&quot;Charlie&quot;, 35)
   * );
   *
   * List&lt;User&gt; reversed = Traversals.reversed(userNames, users);
   * // Result: [User(&quot;Charlie&quot;, 25), User(&quot;Bob&quot;, 30), User(&quot;Alice&quot;, 35)]
   * // Note: names are reversed, not users themselves
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal focusing on elements to reverse
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused elements
   * @return A new structure with focused elements reversed
   */
  public static &lt;S, A&gt; @Nullable S reversed(final Traversal&lt;S, A&gt; traversal, final S source) {
<span class="fc" id="L802">    final Lens&lt;S, List&lt;A&gt;&gt; partsLens = partsOf(traversal);</span>
<span class="fc" id="L803">    final List&lt;A&gt; parts = new ArrayList&lt;&gt;(partsLens.get(source));</span>
<span class="fc" id="L804">    Collections.reverse(parts);</span>
<span class="fc" id="L805">    return partsLens.set(parts, source);</span>
  }

  /**
   * Removes duplicate elements from the focus of a traversal, preserving first occurrences.
   *
   * &lt;p&gt;This is a convenience method that uses {@link #partsOf} to extract all focused elements,
   * remove duplicates while preserving order, and write them back. Since the resulting list may
   * have fewer elements than the original, any positions beyond the deduplicated list retain their
   * original values.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Traversal&lt;List&lt;User&gt;, String&gt; userNames = Traversals.&lt;User&gt;forList()
   *     .andThen(userNameLens.asTraversal());
   *
   * List&lt;User&gt; users = List.of(
   *     new User(&quot;Alice&quot;, 25),
   *     new User(&quot;Bob&quot;, 30),
   *     new User(&quot;Alice&quot;, 35),
   *     new User(&quot;Charlie&quot;, 40)
   * );
   *
   * List&lt;User&gt; distinct = Traversals.distinct(userNames, users);
   * // Result: [User(&quot;Alice&quot;, 25), User(&quot;Bob&quot;, 30), User(&quot;Charlie&quot;, 35), User(&quot;Charlie&quot;, 40)]
   * // &quot;Alice&quot; appears only once, &quot;Charlie&quot; fills third position, fourth keeps original
   * }&lt;/pre&gt;
   *
   * @param traversal The traversal focusing on elements to deduplicate
   * @param source The source structure
   * @param &lt;S&gt; The type of the source structure
   * @param &lt;A&gt; The type of the focused elements
   * @return A new structure with duplicate focused elements removed
   */
  public static &lt;S, A&gt; @Nullable S distinct(final Traversal&lt;S, A&gt; traversal, final S source) {
<span class="fc" id="L841">    final Lens&lt;S, List&lt;A&gt;&gt; partsLens = partsOf(traversal);</span>
<span class="fc" id="L842">    final List&lt;A&gt; parts = partsLens.get(source);</span>
    // Use LinkedHashSet to preserve order while removing duplicates
<span class="fc" id="L844">    final List&lt;A&gt; distinctParts = new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;(parts));</span>
<span class="fc" id="L845">    return partsLens.set(distinctParts, source);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>