<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Prisms.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.util</a> &gt; <span class="el_source">Prisms.java</span></div><h1>Prisms.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.util;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.maybe.Maybe;
import org.higherkindedj.hkt.trymonad.Try;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.optics.Prism;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

/**
 * A final utility class providing common {@link Prism} instances for standard types.
 *
 * &lt;p&gt;This class contains factory methods for creating prisms that work with common Java types like
 * {@link Optional}, {@link Either}, collections, and type hierarchies.
 */
@NullMarked
public final class Prisms {
  /** Private constructor to prevent instantiation. */
  private Prisms() {}

  /**
   * Creates a prism for {@link Optional} that focuses on the value when present.
   *
   * &lt;p&gt;This prism matches when the {@code Optional} contains a value and extracts it. Building from
   * a value wraps it in {@code Optional.of()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Optional&lt;String&gt;, String&gt; somePrism = Prisms.some();
   *
   * Optional&lt;String&gt; present = Optional.of(&quot;hello&quot;);
   * Optional&lt;String&gt; result = somePrism.getOptional(present);  // Optional.of(&quot;hello&quot;)
   *
   * Optional&lt;String&gt; empty = Optional.empty();
   * Optional&lt;String&gt; noMatch = somePrism.getOptional(empty);  // Optional.empty()
   *
   * Optional&lt;String&gt; built = somePrism.build(&quot;world&quot;);  // Optional.of(&quot;world&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value inside the {@code Optional}.
   * @return A prism focusing on present values in an {@code Optional}.
   */
  public static &lt;A&gt; Prism&lt;Optional&lt;A&gt;, A&gt; some() {
<span class="fc" id="L53">    return Prism.of(Function.identity(), Optional::of);</span>
  }

  /**
   * Creates a prism for {@link Either} that focuses on the {@link Either.Left} case.
   *
   * &lt;p&gt;This prism matches when the {@code Either} is a {@code Left} and extracts its value.
   * Building from a value wraps it in {@code Either.left()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Either&lt;String, Integer&gt;, String&gt; leftPrism = Prisms.left();
   *
   * Either&lt;String, Integer&gt; leftValue = Either.left(&quot;error&quot;);
   * Optional&lt;String&gt; result = leftPrism.getOptional(leftValue);  // Optional.of(&quot;error&quot;)
   *
   * Either&lt;String, Integer&gt; rightValue = Either.right(42);
   * Optional&lt;String&gt; noMatch = leftPrism.getOptional(rightValue);  // Optional.empty()
   *
   * Either&lt;String, Integer&gt; built = leftPrism.build(&quot;failure&quot;);  // Either.left(&quot;failure&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;L&gt; The type of the {@code Left} value.
   * @param &lt;R&gt; The type of the {@code Right} value.
   * @return A prism focusing on the {@code Left} case of an {@code Either}.
   */
  public static &lt;L, R&gt; Prism&lt;Either&lt;L, R&gt;, L&gt; left() {
<span class="fc" id="L81">    return Prism.of(</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        either -&gt; either.isLeft() ? Optional.of(either.getLeft()) : Optional.empty(), Either::left);</span>
  }

  /**
   * Creates a prism for {@link Either} that focuses on the {@link Either.Right} case.
   *
   * &lt;p&gt;This prism matches when the {@code Either} is a {@code Right} and extracts its value.
   * Building from a value wraps it in {@code Either.right()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Either&lt;String, Integer&gt;, Integer&gt; rightPrism = Prisms.right();
   *
   * Either&lt;String, Integer&gt; rightValue = Either.right(42);
   * Optional&lt;Integer&gt; result = rightPrism.getOptional(rightValue);  // Optional.of(42)
   *
   * Either&lt;String, Integer&gt; leftValue = Either.left(&quot;error&quot;);
   * Optional&lt;Integer&gt; noMatch = rightPrism.getOptional(leftValue);  // Optional.empty()
   *
   * Either&lt;String, Integer&gt; built = rightPrism.build(100);  // Either.right(100)
   * }&lt;/pre&gt;
   *
   * @param &lt;L&gt; The type of the {@code Left} value.
   * @param &lt;R&gt; The type of the {@code Right} value.
   * @return A prism focusing on the {@code Right} case of an {@code Either}.
   */
  public static &lt;L, R&gt; Prism&lt;Either&lt;L, R&gt;, R&gt; right() {
<span class="fc" id="L110">    return Prism.of(</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        either -&gt; either.isRight() ? Optional.of(either.getRight()) : Optional.empty(),</span>
        Either::right);
  }

  /**
   * Creates a prism for {@link Maybe} that focuses on the {@link org.higherkindedj.hkt.maybe.Just}
   * case.
   *
   * &lt;p&gt;This prism matches when the {@code Maybe} is a {@code Just} (contains a value) and extracts
   * it. Building from a value wraps it in {@code Maybe.just()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Maybe&lt;String&gt;, String&gt; justPrism = Prisms.just();
   *
   * Maybe&lt;String&gt; justValue = Maybe.just(&quot;hello&quot;);
   * Optional&lt;String&gt; result = justPrism.getOptional(justValue);  // Optional.of(&quot;hello&quot;)
   *
   * Maybe&lt;String&gt; nothing = Maybe.nothing();
   * Optional&lt;String&gt; noMatch = justPrism.getOptional(nothing);  // Optional.empty()
   *
   * Maybe&lt;String&gt; built = justPrism.build(&quot;world&quot;);  // Maybe.just(&quot;world&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value inside the {@code Maybe}.
   * @return A prism focusing on the {@code Just} case of a {@code Maybe}.
   */
  public static &lt;A&gt; Prism&lt;Maybe&lt;A&gt;, A&gt; just() {
<span class="fc" id="L140">    return Prism.of(</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        maybe -&gt; maybe.isJust() ? Optional.of(maybe.get()) : Optional.empty(), Maybe::just);</span>
  }

  /**
   * Creates a prism for {@link Validated} that focuses on the {@link
   * org.higherkindedj.hkt.validated.Valid} case.
   *
   * &lt;p&gt;This prism matches when the {@code Validated} is {@code Valid} (successful) and extracts its
   * value. Building from a value wraps it in {@code Validated.valid()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Validated&lt;String, Integer&gt;, Integer&gt; validPrism = Prisms.valid();
   *
   * Validated&lt;String, Integer&gt; validValue = Validated.valid(42);
   * Optional&lt;Integer&gt; result = validPrism.getOptional(validValue);  // Optional.of(42)
   *
   * Validated&lt;String, Integer&gt; invalidValue = Validated.invalid(&quot;error&quot;);
   * Optional&lt;Integer&gt; noMatch = validPrism.getOptional(invalidValue);  // Optional.empty()
   *
   * Validated&lt;String, Integer&gt; built = validPrism.build(100);  // Validated.valid(100)
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; The type of the error value.
   * @param &lt;A&gt; The type of the valid value.
   * @return A prism focusing on the {@code Valid} case of a {@code Validated}.
   */
  public static &lt;E, A&gt; Prism&lt;Validated&lt;E, A&gt;, A&gt; valid() {
<span class="fc" id="L170">    return Prism.of(</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        validated -&gt; validated.isValid() ? Optional.of(validated.get()) : Optional.empty(),</span>
        Validated::valid);
  }

  /**
   * Creates a prism for {@link Validated} that focuses on the {@link
   * org.higherkindedj.hkt.validated.Invalid} case.
   *
   * &lt;p&gt;This prism matches when the {@code Validated} is {@code Invalid} (contains errors) and
   * extracts the error value. Building from an error value wraps it in {@code Validated.invalid()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Validated&lt;String, Integer&gt;, String&gt; invalidPrism = Prisms.invalid();
   *
   * Validated&lt;String, Integer&gt; invalidValue = Validated.invalid(&quot;error&quot;);
   * Optional&lt;String&gt; result = invalidPrism.getOptional(invalidValue);  // Optional.of(&quot;error&quot;)
   *
   * Validated&lt;String, Integer&gt; validValue = Validated.valid(42);
   * Optional&lt;String&gt; noMatch = invalidPrism.getOptional(validValue);  // Optional.empty()
   *
   * Validated&lt;String, Integer&gt; built = invalidPrism.build(&quot;failure&quot;);
   * // Validated.invalid(&quot;failure&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;E&gt; The type of the error value.
   * @param &lt;A&gt; The type of the valid value.
   * @return A prism focusing on the {@code Invalid} case of a {@code Validated}.
   */
  public static &lt;E, A&gt; Prism&lt;Validated&lt;E, A&gt;, E&gt; invalid() {
<span class="fc" id="L202">    return Prism.of(</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        validated -&gt; validated.isInvalid() ? Optional.of(validated.getError()) : Optional.empty(),</span>
        Validated::invalid);
  }

  /**
   * Creates a prism for {@link Try} that focuses on the {@link Try.Success} case.
   *
   * &lt;p&gt;This prism matches when the {@code Try} is a {@code Success} and extracts its value.
   * Building from a value wraps it in {@code Try.success()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Try&lt;Integer&gt;, Integer&gt; successPrism = Prisms.success();
   *
   * Try&lt;Integer&gt; successValue = Try.success(42);
   * Optional&lt;Integer&gt; result = successPrism.getOptional(successValue);  // Optional.of(42)
   *
   * Try&lt;Integer&gt; failure = Try.failure(new Exception(&quot;error&quot;));
   * Optional&lt;Integer&gt; noMatch = successPrism.getOptional(failure);  // Optional.empty()
   *
   * Try&lt;Integer&gt; built = successPrism.build(100);  // Try.success(100)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the success value.
   * @return A prism focusing on the {@code Success} case of a {@code Try}.
   */
  public static &lt;A&gt; Prism&lt;Try&lt;A&gt;, A&gt; success() {
<span class="fc" id="L231">    return Prism.of(</span>
        tryValue -&gt;
<span class="fc bfc" id="L233" title="All 2 branches covered.">            switch (tryValue) {</span>
<span class="fc" id="L234">              case Try.Success&lt;A&gt;(var value) -&gt; Optional.of(value);</span>
<span class="fc" id="L235">              case Try.Failure&lt;A&gt; failure -&gt; Optional.empty();</span>
            },
        Try::success);
  }

  /**
   * Creates a prism for {@link Try} that focuses on the {@link Try.Failure} case.
   *
   * &lt;p&gt;This prism matches when the {@code Try} is a {@code Failure} and extracts the {@link
   * Throwable}. Building from a {@code Throwable} wraps it in {@code Try.failure()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;Try&lt;Integer&gt;, Throwable&gt; failurePrism = Prisms.failure();
   *
   * Exception error = new Exception(&quot;error&quot;);
   * Try&lt;Integer&gt; failureValue = Try.failure(error);
   * Optional&lt;Throwable&gt; result = failurePrism.getOptional(failureValue);
   * // Optional.of(error)
   *
   * Try&lt;Integer&gt; success = Try.success(42);
   * Optional&lt;Throwable&gt; noMatch = failurePrism.getOptional(success);  // Optional.empty()
   *
   * Try&lt;Integer&gt; built = failurePrism.build(new RuntimeException(&quot;fail&quot;));
   * // Try.failure(RuntimeException)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the success value (phantom type in failure case).
   * @return A prism focusing on the {@code Failure} case of a {@code Try}.
   */
  public static &lt;A&gt; Prism&lt;Try&lt;A&gt;, Throwable&gt; failure() {
<span class="fc" id="L267">    return Prism.of(</span>
        tryValue -&gt;
<span class="fc bfc" id="L269" title="All 2 branches covered.">            switch (tryValue) {</span>
<span class="fc" id="L270">              case Try.Failure&lt;A&gt;(var cause) -&gt; Optional.of(cause);</span>
<span class="fc" id="L271">              case Try.Success&lt;A&gt; success -&gt; Optional.empty();</span>
            },
        Try::failure);
  }

  /**
   * Creates a prism that only matches a specific value.
   *
   * &lt;p&gt;This prism is useful for pattern matching on constant values. It matches when the source is
   * equal to the expected value (using {@link Objects#equals}), and focuses on {@link Unit} since
   * there's no additional information to extract. Building always returns the expected value.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;String, Unit&gt; helloPrism = Prisms.only(&quot;hello&quot;);
   *
   * String matching = &quot;hello&quot;;
   * Optional&lt;Unit&gt; result = helloPrism.getOptional(matching);  // Optional.of(Unit.INSTANCE)
   *
   * String notMatching = &quot;world&quot;;
   * Optional&lt;Unit&gt; noMatch = helloPrism.getOptional(notMatching);  // Optional.empty()
   *
   * String built = helloPrism.build(Unit.INSTANCE);  // &quot;hello&quot;
   *
   * // Can be used for conditional logic
   * if (helloPrism.matches(&quot;hello&quot;)) {
   *   // Handle the specific case
   * }
   * }&lt;/pre&gt;
   *
   * @param expected The expected value to match against.
   * @param &lt;A&gt; The type of the value.
   * @return A prism that matches only the specified value.
   */
  public static &lt;A&gt; Prism&lt;A, Unit&gt; only(A expected) {
<span class="fc" id="L307">    return Prism.of(</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        actual -&gt; Objects.equals(actual, expected) ? Optional.of(Unit.INSTANCE) : Optional.empty(),</span>
<span class="fc" id="L309">        unit -&gt; expected);</span>
  }

  /**
   * Creates a prism that matches non-null values.
   *
   * &lt;p&gt;This prism filters out {@code null} values, focusing on non-null instances. It's useful for
   * safely working with potentially nullable data structures.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;String, String&gt; notNullPrism = Prisms.notNull();
   *
   * String value = &quot;hello&quot;;
   * Optional&lt;String&gt; result = notNullPrism.getOptional(value);  // Optional.of(&quot;hello&quot;)
   *
   * String nullValue = null;
   * Optional&lt;String&gt; noMatch = notNullPrism.getOptional(nullValue);  // Optional.empty()
   *
   * String built = notNullPrism.build(&quot;world&quot;);  // &quot;world&quot;
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The type of the value.
   * @return A prism that matches non-null values.
   */
  public static &lt;A&gt; Prism&lt;@Nullable A, A&gt; notNull() {
<span class="fc" id="L336">    return Prism.of(Optional::ofNullable, a -&gt; a);</span>
  }

  /**
   * Creates a prism for safe type casting using {@code instanceof} checks.
   *
   * &lt;p&gt;This prism is useful for working with type hierarchies and polymorphic structures. It
   * matches when the source is an instance of the target class and performs a safe cast. Building
   * is an identity operation (the value is already of the target type).
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; The build operation for this prism is limited—it can only build instances
   * that are already of type {@code A}. This is inherent to type-based prisms.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Working with Number hierarchy
   * Prism&lt;Number, Integer&gt; integerPrism = Prisms.instanceOf(Integer.class);
   *
   * Number intValue = Integer.valueOf(42);
   * Optional&lt;Integer&gt; result = integerPrism.getOptional(intValue);  // Optional.of(42)
   *
   * Number doubleValue = Double.valueOf(3.14);
   * Optional&lt;Integer&gt; noMatch = integerPrism.getOptional(doubleValue);  // Optional.empty()
   *
   * // Composing with other optics for type-safe navigation
   * sealed interface JsonValue permits JsonString, JsonNumber {}
   * record JsonString(String value) implements JsonValue {}
   * record JsonNumber(int value) implements JsonValue {}
   *
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = Prisms.instanceOf(JsonString.class);
   * Lens&lt;JsonString, String&gt; valueLens = JsonStringLenses.value();
   *
   * Traversal&lt;JsonValue, String&gt; jsonStringValue =
   *     stringPrism.asTraversal().andThen(valueLens.asTraversal());
   * }&lt;/pre&gt;
   *
   * @param targetClass The class to match against.
   * @param &lt;S&gt; The source type (supertype).
   * @param &lt;A&gt; The target type (subtype).
   * @return A prism for safe instanceof-based casting.
   */
  public static &lt;S, A extends S&gt; Prism&lt;S, A&gt; instanceOf(Class&lt;A&gt; targetClass) {
<span class="fc" id="L379">    return Prism.of(</span>
        source -&gt;
<span class="fc bfc" id="L381" title="All 2 branches covered.">            targetClass.isInstance(source)</span>
<span class="fc" id="L382">                ? Optional.of(targetClass.cast(source))</span>
<span class="fc" id="L383">                : Optional.empty(),</span>
<span class="fc" id="L384">        a -&gt; a);</span>
  }

  /**
   * Creates a prism for the first element of a {@link List}.
   *
   * &lt;p&gt;This prism matches non-empty lists and focuses on the first element. It does not modify the
   * list when building—it simply creates a singleton list with the given value.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The build operation creates a new list containing only the single element,
   * discarding any other elements that might have been in the original list.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;List&lt;String&gt;, String&gt; headPrism = Prisms.listHead();
   *
   * List&lt;String&gt; list = List.of(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;);
   * Optional&lt;String&gt; result = headPrism.getOptional(list);  // Optional.of(&quot;first&quot;)
   *
   * List&lt;String&gt; empty = List.of();
   * Optional&lt;String&gt; noMatch = headPrism.getOptional(empty);  // Optional.empty()
   *
   * List&lt;String&gt; built = headPrism.build(&quot;new&quot;);  // List.of(&quot;new&quot;)
   *
   * // Useful for modifying the first element
   * List&lt;String&gt; modified = headPrism.modify(String::toUpperCase, list);
   * // Returns List.of(&quot;FIRST&quot;) - note: other elements are lost due to build
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The element type of the list.
   * @return A prism focusing on the first element of a list.
   */
  public static &lt;A&gt; Prism&lt;List&lt;A&gt;, A&gt; listHead() {
<span class="fc bfc" id="L418" title="All 2 branches covered.">    return Prism.of(list -&gt; list.isEmpty() ? Optional.empty() : Optional.of(list.get(0)), List::of);</span>
  }

  /**
   * Creates a prism for accessing an element at a specific index in a {@link List}.
   *
   * &lt;p&gt;This prism matches when the list has an element at the specified index and focuses on that
   * element. The build operation is not supported for indexed prisms (it throws {@code
   * UnsupportedOperationException}) since there's no meaningful way to construct a complete list
   * from a single indexed element.
   *
   * &lt;p&gt;&lt;b&gt;Usage:&lt;/b&gt; This prism is primarily useful for reading and conditionally modifying
   * elements at specific positions. Avoid using the {@code build} method directly.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;List&lt;String&gt;, String&gt; secondPrism = Prisms.listAt(1);
   *
   * List&lt;String&gt; list = List.of(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;);
   * Optional&lt;String&gt; result = secondPrism.getOptional(list);  // Optional.of(&quot;second&quot;)
   *
   * List&lt;String&gt; short = List.of(&quot;only&quot;);
   * Optional&lt;String&gt; noMatch = secondPrism.getOptional(short);  // Optional.empty()
   *
   * // Checking if index exists
   * boolean hasSecond = secondPrism.matches(list);  // true
   * }&lt;/pre&gt;
   *
   * @param index The zero-based index to focus on.
   * @param &lt;A&gt; The element type of the list.
   * @return A prism focusing on the element at the specified index.
   * @throws UnsupportedOperationException if {@code build} is called.
   */
  public static &lt;A&gt; Prism&lt;List&lt;A&gt;, A&gt; listAt(int index) {
<span class="fc" id="L453">    return Prism.of(</span>
        list -&gt;
<span class="fc bfc" id="L455" title="All 4 branches covered.">            (index &gt;= 0 &amp;&amp; index &lt; list.size()) ? Optional.of(list.get(index)) : Optional.empty(),</span>
        a -&gt; {
<span class="fc" id="L457">          throw new UnsupportedOperationException(</span>
              &quot;Cannot build a list from an indexed element. Use Lens or Traversal for list&quot;
                  + &quot; modification.&quot;);
        });
  }

  /**
   * Creates a prism for the last element of a {@link List}.
   *
   * &lt;p&gt;This prism matches non-empty lists and focuses on the last element. It does not modify the
   * list when building—it simply creates a singleton list with the given value.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The build operation creates a new list containing only the single element,
   * discarding any other elements that might have been in the original list.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;List&lt;String&gt;, String&gt; lastPrism = Prisms.listLast();
   *
   * List&lt;String&gt; list = List.of(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;);
   * Optional&lt;String&gt; result = lastPrism.getOptional(list);  // Optional.of(&quot;third&quot;)
   *
   * List&lt;String&gt; empty = List.of();
   * Optional&lt;String&gt; noMatch = lastPrism.getOptional(empty);  // Optional.empty()
   *
   * List&lt;String&gt; built = lastPrism.build(&quot;new&quot;);  // List.of(&quot;new&quot;)
   * }&lt;/pre&gt;
   *
   * @param &lt;A&gt; The element type of the list.
   * @return A prism focusing on the last element of a list.
   */
  public static &lt;A&gt; Prism&lt;List&lt;A&gt;, A&gt; listLast() {
<span class="fc" id="L490">    return Prism.of(</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        list -&gt; list.isEmpty() ? Optional.empty() : Optional.of(list.get(list.size() - 1)),</span>
        List::of);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>