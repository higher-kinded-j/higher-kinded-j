<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IxedInstances.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics.ixed</a> &gt; <span class="el_source">IxedInstances.java</span></div><h1>IxedInstances.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics.ixed;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.optics.At;
import org.higherkindedj.optics.Ixed;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.at.AtInstances;
import org.higherkindedj.optics.prism.Prisms;
import org.higherkindedj.optics.util.Traversals;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

/**
 * Provides standard {@link Ixed} instances for common Java collection types.
 *
 * &lt;p&gt;This class contains factory methods that create {@code Ixed} instances for:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Map} - indexed by key type {@code K}
 *   &lt;li&gt;{@link List} - indexed by {@link Integer} position
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All instances are built on top of {@link At} instances, composing with a prism that unwraps
 * the optional layer. This ensures consistency between {@code At} and {@code Ixed} semantics.
 *
 * &lt;h3&gt;Usage Examples:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Map operations - only updates existing keys
 * Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
 * Map&lt;String, Integer&gt; scores = Map.of(&quot;alice&quot;, 100, &quot;bob&quot;, 85);
 *
 * // Get value at key using convenience method
 * Optional&lt;Integer&gt; aliceScore = IxedInstances.get(mapIx, &quot;alice&quot;, scores);
 * // aliceScore = Optional[100]
 *
 * // Update existing key
 * Map&lt;String, Integer&gt; updated = IxedInstances.update(mapIx, &quot;alice&quot;, 110, scores);
 * // updated = {alice=110, bob=85}
 *
 * // Non-existent key - no change
 * Map&lt;String, Integer&gt; unchanged = IxedInstances.update(mapIx, &quot;charlie&quot;, 90, scores);
 * // unchanged = {alice=100, bob=85}
 *
 * // Modify with function
 * Optional&lt;Integer&gt; bobScore = IxedInstances.get(mapIx, &quot;bob&quot;, scores);
 * // bobScore = Optional[85]
 *
 * Map&lt;String, Integer&gt; updatedBob = IxedInstances.modify(mapIx, &quot;bob&quot;, x -&gt; x + 10, scores);
 * // updatedBob = {alice=100, bob=95}
 *
 * // List operations - only updates existing indices
 * Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();
 * List&lt;String&gt; names = List.of(&quot;alice&quot;, &quot;bob&quot;, &quot;charlie&quot;);
 *
 * // Update existing index
 * List&lt;String&gt; updatedNames = IxedInstances.modify(listIx, 1, String::toUpperCase, names);
 * // updatedNames = [&quot;alice&quot;, &quot;BOB&quot;, &quot;charlie&quot;]
 *
 * // Out of bounds index - no change
 * List&lt;String&gt; unchangedNames = IxedInstances.modify(listIx, 10, String::toUpperCase, names);
 * // unchangedNames = [&quot;alice&quot;, &quot;bob&quot;, &quot;charlie&quot;]
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Design Note:&lt;/h3&gt;
 *
 * &lt;p&gt;These instances are intentionally built on {@link At} to maintain consistency. The composition
 * pattern is:
 *
 * &lt;pre&gt;{@code
 * at.at(index).asTraversal().andThen(somePrism.asTraversal())
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;This ensures that the boundary behaviour of {@code Ixed} aligns with {@code At}, and both can
 * be used interchangeably based on whether insert/delete semantics are needed.
 */
@NullMarked
public final class IxedInstances {

  /** Private constructor to prevent instantiation. */
  private IxedInstances() {}

  /**
   * Creates an {@link Ixed} instance for {@link Map} types.
   *
   * &lt;p&gt;The returned {@code Ixed} provides a traversal to an existing value at a given key:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code ix(key)} focuses on the value if key exists, or zero elements if absent
   *   &lt;li&gt;Modifications are no-ops for absent keys (no insertion)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Null Value Limitation:&lt;/strong&gt; Due to Java's {@link Optional} semantics, null map
   * values cannot be distinguished from absent keys. A key with null value appears the same as an
   * absent key.
   *
   * &lt;p&gt;&lt;strong&gt;Immutability:&lt;/strong&gt; All operations return new {@link Map} instances, leaving the
   * original unchanged.
   *
   * @param &lt;K&gt; The key type of the map
   * @param &lt;V&gt; The value type of the map
   * @return An {@code Ixed} instance for maps
   */
  public static &lt;K, V&gt; Ixed&lt;Map&lt;K, V&gt;, K, @Nullable V&gt; mapIx() {
<span class="fc" id="L113">    return fromAt(AtInstances.mapAt());</span>
  }

  /**
   * Creates an {@link Ixed} instance for {@link List} types.
   *
   * &lt;p&gt;The returned {@code Ixed} provides a traversal to an existing element at a given index:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code ix(index)} focuses on the element if index is valid, or zero elements if out of
   *       bounds
   *   &lt;li&gt;Modifications are no-ops for invalid indices (no insertion, no exception)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;strong&gt;Bounds Checking:&lt;/strong&gt; Unlike {@link At#insertOrUpdate}, updating at an
   * out-of-bounds index has no effect and returns the original list unchanged. This is consistent
   * with the &quot;zero or one element&quot; semantics of {@code Ixed}.
   *
   * &lt;p&gt;&lt;strong&gt;Immutability:&lt;/strong&gt; All operations return new {@link List} instances, leaving the
   * original unchanged.
   *
   * @param &lt;A&gt; The element type of the list
   * @return An {@code Ixed} instance for lists
   */
  public static &lt;A&gt; Ixed&lt;List&lt;A&gt;, Integer, A&gt; listIx() {
<span class="fc" id="L138">    return fromAt(AtInstances.listAt());</span>
  }

  /**
   * Creates an {@link Ixed} instance for {@link List} types using a custom {@link At} instance.
   *
   * &lt;p&gt;This factory method allows using alternative {@code At} implementations, such as {@link
   * AtInstances#listAtWithPadding(Object)}.
   *
   * &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;
   *
   * &lt;pre&gt;{@code
   * // Create Ixed that uses padding semantics from underlying At
   * At&lt;List&lt;String&gt;, Integer, String&gt; paddingAt = AtInstances.listAtWithPadding(null);
   * Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIxFrom(paddingAt);
   * }&lt;/pre&gt;
   *
   * @param at The {@link At} instance to build upon
   * @param &lt;A&gt; The element type of the list
   * @return An {@code Ixed} instance for lists using the provided {@code At}
   */
  public static &lt;A&gt; Ixed&lt;List&lt;A&gt;, Integer, A&gt; listIxFrom(At&lt;List&lt;A&gt;, Integer, A&gt; at) {
<span class="fc" id="L160">    return fromAt(at);</span>
  }

  /**
   * Creates a generic {@link Ixed} instance from any {@link At} instance.
   *
   * &lt;p&gt;This factory method allows creating {@code Ixed} for any type that has an {@code At}
   * instance. The resulting {@code Ixed} composes the {@code At} with a prism that unwraps the
   * optional layer.
   *
   * &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;
   *
   * &lt;pre&gt;{@code
   * // Custom At for a tree structure
   * At&lt;Tree&lt;A&gt;, Path, A&gt; treeAt = ...;
   * Ixed&lt;Tree&lt;A&gt;, Path, A&gt; treeIx = IxedInstances.fromAt(treeAt);
   *
   * // Now can safely access tree nodes
   * List&lt;A&gt; nodes = Traversals.getAll(treeIx.ix(somePath), tree);
   * }&lt;/pre&gt;
   *
   * @param at The {@link At} instance to convert
   * @param &lt;S&gt; The structure type
   * @param &lt;I&gt; The index type
   * @param &lt;A&gt; The value type
   * @return An {@code Ixed} instance derived from the provided {@code At}
   */
  public static &lt;S, I, A&gt; Ixed&lt;S, I, A&gt; fromAt(At&lt;S, I, A&gt; at) {
<span class="fc" id="L188">    Prism&lt;Optional&lt;A&gt;, A&gt; somePrism = Prisms.some();</span>
<span class="fc" id="L189">    return index -&gt;</span>
<span class="fc" id="L190">        new Traversal&lt;&gt;() {</span>
          @Override
          public &lt;F&gt; Kind&lt;F, S&gt; modifyF(
              Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L194">            Optional&lt;A&gt; optValue = at.at(index).get(source);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (optValue.isEmpty()) {</span>
              // Do not modify if absent - this prevents deletion semantics from leaking
<span class="fc" id="L197">              return applicative.of(source);</span>
            }
            // Value is present, so we can proceed with modification
<span class="fc" id="L200">            Kind&lt;F, Optional&lt;A&gt;&gt; newOptValueF = somePrism.modifyF(f, optValue, applicative);</span>
<span class="fc" id="L201">            return applicative.map(</span>
<span class="fc" id="L202">                newOptValue -&gt; at.at(index).set(newOptValue, source), newOptValueF);</span>
          }
        };
  }

  // =========================================================================
  // Convenience Methods for Common Operations
  // =========================================================================

  /**
   * Retrieves the value at the given index, if present.
   *
   * &lt;p&gt;This is a convenience method equivalent to:
   *
   * &lt;pre&gt;{@code
   * List&lt;A&gt; results = Traversals.getAll(ixed.ix(index), source);
   * return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));
   * }&lt;/pre&gt;
   *
   * @param ixed The Ixed instance
   * @param index The index to look up
   * @param source The structure to query
   * @param &lt;S&gt; The structure type
   * @param &lt;I&gt; The index type
   * @param &lt;A&gt; The value type
   * @return An {@link Optional} containing the value if present, or empty if absent
   */
  public static &lt;S, I, A&gt; Optional&lt;A&gt; get(Ixed&lt;S, I, A&gt; ixed, I index, S source) {
<span class="fc" id="L230">    List&lt;A&gt; results = Traversals.getAll(ixed.ix(index), source);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));</span>
  }

  /**
   * Updates the value at the given index if it exists.
   *
   * &lt;p&gt;If the index does not exist in the structure, the original structure is returned unchanged.
   * This differs from {@link At#insertOrUpdate}, which would insert the value at a missing index.
   *
   * @param ixed The Ixed instance
   * @param index The index to update
   * @param value The new value
   * @param source The original structure
   * @param &lt;S&gt; The structure type
   * @param &lt;I&gt; The index type
   * @param &lt;A&gt; The value type
   * @return A new structure with the value updated, or unchanged if the index is absent
   */
  public static &lt;S, I, A&gt; S update(Ixed&lt;S, I, A&gt; ixed, I index, A value, S source) {
<span class="fc" id="L250">    return Traversals.modify(ixed.ix(index), _ -&gt; value, source);</span>
  }

  /**
   * Modifies the value at the given index using the provided function, if the index exists.
   *
   * &lt;p&gt;If the index does not exist, the structure is returned unchanged.
   *
   * @param ixed The Ixed instance
   * @param index The index to modify
   * @param modifier The function to apply to the existing value
   * @param source The original structure
   * @param &lt;S&gt; The structure type
   * @param &lt;I&gt; The index type
   * @param &lt;A&gt; The value type
   * @return A new structure with the modified value, or unchanged if absent
   */
  public static &lt;S, I, A&gt; S modify(Ixed&lt;S, I, A&gt; ixed, I index, Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L268">    return Traversals.modify(ixed.ix(index), modifier, source);</span>
  }

  /**
   * Checks if a value is present at the given index.
   *
   * @param ixed The Ixed instance
   * @param index The index to check
   * @param source The structure to query
   * @param &lt;S&gt; The structure type
   * @param &lt;I&gt; The index type
   * @param &lt;A&gt; The value type
   * @return {@code true} if a value is present at the index, {@code false} otherwise
   */
  public static &lt;S, I, A&gt; boolean contains(Ixed&lt;S, I, A&gt; ixed, I index, S source) {
<span class="fc" id="L283">    return get(ixed, index, source).isPresent();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>