<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Traverse.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt</a> &gt; <span class="el_source">Traverse.java</span></div><h1>Traverse.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt;

import java.util.function.Function;
import org.jspecify.annotations.NullMarked;

/**
 * The Traverse type class represents data structures that can be traversed from left to right,
 * performing an Applicative (or Monadic) effect for each element and collecting the results.
 *
 * &lt;p&gt;Traverse combines the capabilities of {@link Functor} and {@link Foldable}, allowing you to
 * both map over a structure with an effectful function and collect the results into the same
 * structure shape. Unlike {@code map}, which applies a pure function, {@code traverse} applies a
 * function that produces effects and ensures those effects are properly sequenced according to the
 * {@link Applicative} being used.
 *
 * &lt;h2&gt;Key Operations&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #traverse(Applicative, Function, Kind)}: The fundamental operation that maps an
 *       effectful function over a structure and sequences the effects.
 *   &lt;li&gt;{@link #sequenceA(Applicative, Kind)}: A specialized version of traverse that &quot;flips&quot; a
 *       structure of effects into an effect of a structure.
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Common Use Cases&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Example 1: Validating a list of inputs
 * // Given: List&lt;String&gt; userInputs and a function String -&gt; Validation&lt;Error, Integer&gt;
 * Traverse&lt;ListKind.Witness&gt; listTraverse = ...;
 * Kind&lt;ValidationKind.Witness, Kind&lt;ListKind.Witness, Integer&gt;&gt; result =
 *     listTraverse.traverse(validationApplicative, validateAndParse, userInputs);
 * // Result: Either all inputs are valid (Right(List&lt;Integer&gt;)) or
 * //         accumulates all validation errors (Left(List&lt;Error&gt;))
 *
 * // Example 2: Fetching data for a collection of IDs
 * // Given: List&lt;UserId&gt; ids and a function UserId -&gt; IO&lt;User&gt;
 * Kind&lt;IO.Witness, Kind&lt;ListKind.Witness, User&gt;&gt; users =
 *     listTraverse.traverse(ioApplicative, id -&gt; fetchUser(id), ids);
 * // Result: A single IO action that, when executed, fetches all users
 *
 * // Example 3: Sequencing a list of effects
 * // Given: List&lt;IO&lt;String&gt;&gt; effects
 * Kind&lt;IO.Witness, Kind&lt;ListKind.Witness, String&gt;&gt; sequenced =
 *     listTraverse.sequenceA(ioApplicative, effects);
 * // Result: A single IO action that executes all effects in sequence
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Relationship to Other Type Classes&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Extends {@link Functor}: Every Traverse can map pure functions over its structure.
 *   &lt;li&gt;Extends {@link Foldable}: Every Traverse can fold its elements into a summary value.
 *   &lt;li&gt;More powerful than Functor: Can sequence effects, not just apply pure functions.
 *   &lt;li&gt;More structured than Foldable: Preserves the structure's shape during traversal.
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Laws&lt;/h2&gt;
 *
 * &lt;p&gt;A Traverse instance must satisfy the following laws to ensure predictable and composable
 * behaviour:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;&lt;b&gt;Naturality:&lt;/b&gt; For any applicative transformation {@code t} (natural transformation
 *       between applicatives {@code F} and {@code G}):
 *       &lt;pre&gt;{@code
 * t.compose(traverse(appF, f, ta)) == traverse(appG, t.compose(f), ta)
 * }&lt;/pre&gt;
 *       This law states that transforming between applicative contexts can happen either before or
 *       after traversal with the same result.
 *   &lt;li&gt;&lt;b&gt;Identity:&lt;/b&gt; Traversing with the Identity applicative and the identity function is
 *       itself the identity:
 *       &lt;pre&gt;{@code
 * traverse(Identity.applicative(), a -&gt; Identity.of(a), ta) == Identity.of(ta)
 * }&lt;/pre&gt;
 *       This ensures that traverse doesn't add unnecessary structure or effects.
 *   &lt;li&gt;&lt;b&gt;Composition:&lt;/b&gt; Traversing with a composed applicative is the same as traversing twice:
 *       &lt;pre&gt;{@code
 * traverse(Compose(F, G), f, ta) == F.map(traverse(G, _, ta), traverse(F, f, ta))
 * }&lt;/pre&gt;
 *       Where {@code Compose(F, G)} represents the composition of two applicatives. This law
 *       ensures that nested traversals can be fused into a single traversal.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;These laws ensure that:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Traversals behave predictably regardless of the applicative effect being used
 *   &lt;li&gt;Traversals compose properly with other traversals
 *   &lt;li&gt;Traversals can be optimised through fusion
 *   &lt;li&gt;The order of effects is deterministic (left-to-right)
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Design Notes&lt;/h2&gt;
 *
 * &lt;p&gt;The traverse operation's power comes from its interaction with different {@link Applicative}
 * instances:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;With {@code Option}/{@code Maybe}:&lt;/b&gt; Returns {@code Some(structure)} if all
 *       applications succeed, {@code None} if any fails (fail-fast).
 *   &lt;li&gt;&lt;b&gt;With {@code Validation}:&lt;/b&gt; Accumulates all errors, allowing you to see all validation
 *       failures at once.
 *   &lt;li&gt;&lt;b&gt;With {@code IO}/{@code Future}:&lt;/b&gt; Sequences side effects, creating a single action
 *       that performs all effects.
 *   &lt;li&gt;&lt;b&gt;With {@code List}:&lt;/b&gt; Generates all possible combinations (cartesian product).
 *   &lt;li&gt;&lt;b&gt;With {@code Const} (constant applicative):&lt;/b&gt; Allows for pure folds without rebuilding
 *       the structure.
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Implementation Guidelines&lt;/h2&gt;
 *
 * &lt;p&gt;When implementing Traverse for a custom data structure:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;Ensure elements are traversed left-to-right consistently
 *   &lt;li&gt;Use the applicative's {@code ap} and {@code of} operations to sequence effects
 *   &lt;li&gt;Preserve the structure's shape in the result
 *   &lt;li&gt;Consider implementing efficient versions of {@code sequenceA} and {@code foldMap} when
 *       possible
 * &lt;/ol&gt;
 *
 * &lt;h2&gt;Performance Considerations&lt;/h2&gt;
 *
 * &lt;p&gt;The default implementation of {@link #sequenceA(Applicative, Kind)} delegates to {@code
 * traverse} with an identity function. For some data structures, a specialized implementation may
 * be more efficient. Similarly, {@code foldMap} can often be implemented more efficiently than a
 * general traverse followed by extraction.
 *
 * @param &lt;T&gt; The type constructor of the traversable data structure (e.g., {@code
 *     ListKind.Witness}, {@code TreeKind.Witness}, {@code OptionKind.Witness}).
 * @see Applicative
 * @see Functor
 * @see Foldable
 */
@NullMarked
public interface Traverse&lt;T&gt; extends Functor&lt;T&gt;, Foldable&lt;T&gt; {

  /**
   * Traverses this structure from left to right, applying an effectful function {@code f} to each
   * element {@code A}, and collecting the results into the same structure shape, all within an
   * {@link Applicative} context {@code G}.
   *
   * &lt;p&gt;This is the fundamental operation of the Traverse type class. It combines mapping and
   * sequencing: applying a function that produces effects to each element, and then &quot;sequencing&quot;
   * those effects according to the rules of the applicative being used.
   *
   * &lt;p&gt;&lt;b&gt;Behaviour varies by Applicative:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;&lt;b&gt;Optional/Maybe:&lt;/b&gt; Short-circuits on the first {@code None} encountered, otherwise
   *       returns {@code Some} of the mapped structure.
   *   &lt;li&gt;&lt;b&gt;Validation:&lt;/b&gt; Accumulates all errors using the validation's semigroup, or returns a
   *       valid result if all applications succeed.
   *   &lt;li&gt;&lt;b&gt;IO/Future:&lt;/b&gt; Creates a single composite effect that, when executed, runs all effects
   *       in sequence and collects results.
   *   &lt;li&gt;&lt;b&gt;List:&lt;/b&gt; Generates all possible combinations (cartesian product) of results.
   *   &lt;li&gt;&lt;b&gt;Either:&lt;/b&gt; Returns the first error encountered (left), or the successfully mapped
   *       structure (right).
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Usage:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Validate a list of strings, converting each to an integer
   * Traverse&lt;ListKind.Witness&gt; listTraverse = ...;
   * Applicative&lt;ValidationKind.Witness&gt; validationApp = ...;
   *
   * Function&lt;String, Kind&lt;ValidationKind.Witness, Integer&gt;&gt; parseAndValidate = s -&gt; {
   *   try {
   *     int value = Integer.parseInt(s);
   *     return value &gt; 0 ? valid(value) : invalid(&quot;Must be positive&quot;);
   *   } catch (NumberFormatException e) {
   *     return invalid(&quot;Not a number: &quot; + s);
   *   }
   * };
   *
   * Kind&lt;ListKind.Witness, String&gt; inputs = ListKind.of(&quot;1&quot;, &quot;2&quot;, &quot;abc&quot;, &quot;-5&quot;);
   * Kind&lt;ValidationKind.Witness, Kind&lt;ListKind.Witness, Integer&gt;&gt; result =
   *     listTraverse.traverse(validationApp, parseAndValidate, inputs);
   * // Result: Invalid with errors [&quot;Not a number: abc&quot;, &quot;Must be positive&quot;]
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Key Properties:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Preserves the structure's shape (same number and arrangement of elements)
   *   &lt;li&gt;Processes elements left-to-right
   *   &lt;li&gt;Effects are sequenced according to the applicative's rules
   *   &lt;li&gt;Type-safe: The compiler ensures all effects are handled
   * &lt;/ul&gt;
   *
   * @param &lt;G&gt; The type constructor of the applicative effect (e.g., {@code IO.Witness}, {@code
   *     ValidationKind.Witness}, {@code OptionKind.Witness}).
   * @param &lt;A&gt; The type of elements in the input structure {@code ta}.
   * @param &lt;B&gt; The type of elements in the output structure, after applying the effectful function
   *     {@code f}.
   * @param applicative The {@link Applicative} instance for the effect type {@code G}, which
   *     determines how effects are sequenced and combined. Must not be null.
   * @param f A function from {@code A} to {@code Kind&lt;G, B&gt;}, producing an effectful computation
   *     for each element. The function must not be null. The wildcard bounds allow for flexible
   *     variance: the function can accept any supertype of {@code A} and return any subtype of
   *     {@code B} wrapped in the effect {@code G}.
   * @param ta The traversable structure {@code Kind&lt;T, A&gt;} to traverse (e.g., a {@code List&lt;A&gt;}, a
   *     {@code Tree&lt;A&gt;}). Must not be null.
   * @return A {@code Kind&lt;G, Kind&lt;T, B&gt;&gt;}, which represents the structure {@code T} containing
   *     elements of type {@code B}, all wrapped in the applicative effect {@code G}. For example:
   *     {@code IO&lt;List&lt;User&gt;&gt;}, {@code Validation&lt;Error, Tree&lt;Int&gt;&gt;}, or {@code
   *     Optional&lt;Set&lt;String&gt;&gt;}. Guaranteed to be non-null.
   * @throws NullPointerException if {@code applicative}, {@code f}, or {@code ta} is null
   *     (implementation-dependent).
   */
  &lt;G, A, B&gt; Kind&lt;G, Kind&lt;T, B&gt;&gt; traverse(
      Applicative&lt;G&gt; applicative,
      Function&lt;? super A, ? extends Kind&lt;G, ? extends B&gt;&gt; f,
      Kind&lt;T, A&gt; ta);

  /**
   * Sequences a structure of applicative effects {@code Kind&lt;T, Kind&lt;G, A&gt;&gt;} into an applicative
   * effect of a structure {@code Kind&lt;G, Kind&lt;T, A&gt;&gt;}.
   *
   * &lt;p&gt;This operation &quot;flips&quot; the nesting of type constructors, taking a structure (like a List)
   * where each element is an effect (like an IO action), and turning it into a single effect that
   * produces the structure of results.
   *
   * &lt;p&gt;This is a specialized version of {@link #traverse(Applicative, Function, Kind)} where the
   * function {@code f} is the identity function (i.e., the effects are already present in the
   * structure, we just need to sequence them).
   *
   * &lt;p&gt;&lt;b&gt;Common Use Cases:&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Executing a collection of IO actions and collecting their results
   *   &lt;li&gt;Validating a collection of validations and accumulating errors
   *   &lt;li&gt;Converting {@code List&lt;Optional&lt;T&gt;&gt;} to {@code Optional&lt;List&lt;T&gt;&gt;}
   *   &lt;li&gt;Converting {@code Tree&lt;Future&lt;T&gt;&gt;} to {@code Future&lt;Tree&lt;T&gt;&gt;}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Example Usage:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Execute multiple database queries and collect results
   * Traverse&lt;ListKind.Witness&gt; listTraverse = ...;
   * Applicative&lt;IO.Witness&gt; ioApp = ...;
   *
   * // A list of IO actions
   * Kind&lt;ListKind.Witness, Kind&lt;IO.Witness, User&gt;&gt; queries = ListKind.of(
   *     fetchUser(1),
   *     fetchUser(2),
   *     fetchUser(3)
   * );
   *
   * // Sequence into a single IO action
   * Kind&lt;IO.Witness, Kind&lt;ListKind.Witness, User&gt;&gt; allUsers =
   *     listTraverse.sequenceA(ioApp, queries);
   * // When executed, performs all queries in sequence and returns List&lt;User&gt;
   *
   * // Example with Optional: fail-fast semantics
   * Kind&lt;ListKind.Witness, Kind&lt;OptionKind.Witness, Integer&gt;&gt; maybeInts = ListKind.of(
   *     Optional.of(1),
   *     Optional.empty(),  // This causes the whole thing to be None
   *     Optional.of(3)
   * );
   * Kind&lt;OptionKind.Witness, Kind&lt;ListKind.Witness, Integer&gt;&gt; result =
   *     listTraverse.sequenceA(optionApp, maybeInts);
   * // Result: Optional.empty() because one element was empty
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Relationship to traverse:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * sequenceA(app, tga) == traverse(app, identity, tga)
   * }&lt;/pre&gt;
   *
   * where {@code identity} is the function {@code ga -&gt; ga}.
   *
   * &lt;p&gt;&lt;b&gt;Type Transformation:&lt;/b&gt;
   *
   * &lt;pre&gt;
   * Structure&amp;lt;Effect&amp;lt;A&amp;gt;&amp;gt; ──sequenceA──&amp;gt; Effect&amp;lt;Structure&amp;lt;A&amp;gt;&amp;gt;
   *
   * Examples:
   * List&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;  ──&amp;gt;  Optional&amp;lt;List&amp;lt;Int&amp;gt;&amp;gt;
   * Tree&amp;lt;IO&amp;lt;String&amp;gt;&amp;gt;     ──&amp;gt;  IO&amp;lt;Tree&amp;lt;String&amp;gt;&amp;gt;
   * Set&amp;lt;Validation&amp;lt;E,A&amp;gt;&amp;gt; ──&amp;gt;  Validation&amp;lt;E, Set&amp;lt;A&amp;gt;&amp;gt;
   * &lt;/pre&gt;
   *
   * @param &lt;G&gt; The type constructor of the applicative effect that is currently nested inside the
   *     structure.
   * @param &lt;A&gt; The type of elements wrapped in the effect {@code G} within the structure {@code T}.
   * @param applicative The {@link Applicative} instance for the effect type {@code G}, which
   *     determines how the effects are sequenced. Must not be null.
   * @param tga The traversable structure where each element is already an applicative effect:
   *     {@code Kind&lt;T, Kind&lt;G, A&gt;&gt;}. For example, a {@code List&lt;IO&lt;String&gt;&gt;} or {@code
   *     Tree&lt;Optional&lt;Int&gt;&gt;}. Must not be null.
   * @return An applicative effect {@code Kind&lt;G, Kind&lt;T, A&gt;&gt;} that, when &quot;run&quot; or &quot;extracted&quot;,
   *     produces the structure of results. For example, an {@code IO&lt;List&lt;String&gt;&gt;} or {@code
   *     Optional&lt;Tree&lt;Int&gt;&gt;}. Guaranteed to be non-null.
   * @throws NullPointerException if {@code applicative} or {@code tga} is null
   *     (implementation-dependent).
   */
  default &lt;G, A&gt; Kind&lt;G, Kind&lt;T, A&gt;&gt; sequenceA(
      Applicative&lt;G&gt; applicative, Kind&lt;T, Kind&lt;G, A&gt;&gt; tga) {
    // Implementation using traverse with identity function
    // The cast for '? extends A' to 'A' is generally safe here due to how sequence is used.
    // The function f is A -&gt; Kind&lt;G, A&gt;, where A is Kind&lt;G,A&gt; from tga.
    // So it becomes Kind&lt;G,A&gt; -&gt; Kind&lt;G, Kind&lt;G,A&gt;&gt; which is not what we want.
    // The A in traverse's f: A -&gt; Kind&lt;G,B&gt; is the inner A of Kind&lt;T,A&gt;
    // Here, A is Kind&lt;G,A_val&gt; for tga :: Kind&lt;T, Kind&lt;G,A_val&gt;&gt;.
    // So f is (Kind&lt;G, A_val&gt; element) -&gt; (Kind&lt;G, A_val&gt; element)
    // B becomes A_val.
    // The result of traverse is Kind&lt;G, Kind&lt;T, A_val&gt;&gt;
<span class="fc" id="L315">    return traverse(applicative, (Kind&lt;G, A&gt; ga) -&gt; ga, tga);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>