<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>At.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">At.java</span></div><h1>At.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import java.util.function.Function;

/**
 * A type class for structures that support indexed access with insertion and deletion semantics.
 *
 * &lt;p&gt;{@code At} provides a {@link Lens} focusing on the optional presence of a value at a given
 * index. This enables CRUD (Create, Read, Update, Delete) operations on indexed structures like
 * {@link java.util.Map} or {@link java.util.List}.
 *
 * &lt;p&gt;The key insight is that setting to {@link Optional#empty()} deletes the entry, while setting
 * to {@link Optional#of(Object)} inserts or updates the entry. This makes {@code At} more powerful
 * than a simple indexed accessor.
 *
 * &lt;h3&gt;Example Usage:&lt;/h3&gt;
 *
 * &lt;pre&gt;{@code
 * // Create an At instance for Map&lt;String, Integer&gt;
 * At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();
 *
 * Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
 * scores.put(&quot;alice&quot;, 100);
 *
 * // Insert a new entry
 * Map&lt;String, Integer&gt; updated = mapAt.insertOrUpdate(&quot;bob&quot;, 85, scores);
 * // scores is unchanged, updated = {alice=100, bob=85}
 *
 * // Remove an entry
 * Map&lt;String, Integer&gt; afterRemove = mapAt.remove(&quot;alice&quot;, updated);
 * // afterRemove = {bob=85}
 *
 * // Check for presence
 * Optional&lt;Integer&gt; bobScore = mapAt.at(&quot;bob&quot;).get(afterRemove);
 * // bobScore = Optional[85]
 *
 * // Compose with other optics
 * Lens&lt;Map&lt;String, Integer&gt;, Optional&lt;Integer&gt;&gt; aliceLens = mapAt.at(&quot;alice&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Composition with Prisms:&lt;/h3&gt;
 *
 * &lt;p&gt;To compose through the {@code Optional} layer, use a {@code Prism} that unwraps {@code
 * Optional}:
 *
 * &lt;pre&gt;{@code
 * Lens&lt;User, Map&lt;String, Address&gt;&gt; addressMapLens = ...;
 * At&lt;Map&lt;String, Address&gt;, String, Address&gt; mapAt = AtInstances.mapAt();
 * Prism&lt;Optional&lt;Address&gt;, Address&gt; somePrism = Prisms.some();
 *
 * // Compose to get a Traversal (0-or-1 focus)
 * Traversal&lt;User, Address&gt; homeAddressTraversal =
 *     addressMapLens
 *         .andThen(mapAt.at(&quot;home&quot;))  // Lens&lt;User, Optional&lt;Address&gt;&gt;
 *         .asTraversal()
 *         .andThen(somePrism.asTraversal());
 * }&lt;/pre&gt;
 *
 * @param &lt;S&gt; The structure type (e.g., {@code Map&lt;K, V&gt;} or {@code List&lt;A&gt;})
 * @param &lt;I&gt; The index type (e.g., {@code K} for maps, {@code Integer} for lists)
 * @param &lt;A&gt; The value type stored at each index
 */
@FunctionalInterface
public interface At&lt;S, I, A&gt; {

  /**
   * Returns a {@link Lens} that focuses on the optional presence of a value at the given index.
   *
   * &lt;p&gt;The returned lens has the following semantics:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code get(source)} returns {@link Optional#empty()} if the index is absent, or {@link
   *       Optional#of(Object)} if present
   *   &lt;li&gt;{@code set(Optional.empty(), source)} removes the entry at the index
   *   &lt;li&gt;{@code set(Optional.of(value), source)} inserts or updates the entry at the index
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Note on null values: Due to Java's {@link Optional} semantics, an index present with a
   * {@code null} value is indistinguishable from an absent index. Both will result in {@link
   * Optional#empty()} from a {@code get} operation.
   *
   * @param index The index to focus on
   * @return A {@link Lens} focusing on {@code Optional&lt;A&gt;} at the given index
   */
  Lens&lt;S, Optional&lt;A&gt;&gt; at(I index);

  /**
   * Retrieves the value at the given index, if present.
   *
   * &lt;p&gt;This is a convenience method equivalent to {@code at(index).get(source)}.
   *
   * @param index The index to look up
   * @param source The structure to query
   * @return An {@link Optional} containing the value if present, or empty if absent
   */
  default Optional&lt;A&gt; get(I index, S source) {
<span class="fc" id="L100">    return at(index).get(source);</span>
  }

  /**
   * Sets the optional value at the given index.
   *
   * &lt;p&gt;This is a convenience method equivalent to {@code at(index).set(value, source)}.
   *
   * @param index The index to modify
   * @param value The optional value to set (empty to remove, present to insert/update)
   * @param source The original structure
   * @return A new structure with the modification applied
   */
  default S set(I index, Optional&lt;A&gt; value, S source) {
<span class="fc" id="L114">    return at(index).set(value, source);</span>
  }

  /**
   * Removes the entry at the given index.
   *
   * &lt;p&gt;This is equivalent to {@code at(index).set(Optional.empty(), source)}.
   *
   * @param index The index to remove
   * @param source The original structure
   * @return A new structure with the entry removed (or unchanged if not present)
   */
  default S remove(I index, S source) {
<span class="fc" id="L127">    return at(index).set(Optional.empty(), source);</span>
  }

  /**
   * Inserts or updates the value at the given index.
   *
   * &lt;p&gt;This is equivalent to {@code at(index).set(Optional.of(value), source)}.
   *
   * @param index The index to insert or update
   * @param value The value to set
   * @param source The original structure
   * @return A new structure with the entry inserted or updated
   */
  default S insertOrUpdate(I index, A value, S source) {
<span class="fc" id="L141">    return at(index).set(Optional.of(value), source);</span>
  }

  /**
   * Modifies the value at the given index if present, using the provided function.
   *
   * &lt;p&gt;If the index is absent, the structure is returned unchanged.
   *
   * @param index The index to modify
   * @param modifier The function to apply to the existing value
   * @param source The original structure
   * @return A new structure with the modified value, or unchanged if absent
   */
  default S modify(I index, Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L155">    return at(index).modify(opt -&gt; opt.map(modifier), source);</span>
  }

  /**
   * Checks if a value is present at the given index.
   *
   * @param index The index to check
   * @param source The structure to query
   * @return {@code true} if a value is present at the index, {@code false} otherwise
   */
  default boolean contains(I index, S source) {
<span class="fc" id="L166">    return get(index, source).isPresent();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>