<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Traversal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Traversal.java</span></div><h1>Traversal.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;

/**
 * A **Traversal** is a versatile optic that can focus on zero or more parts 'A' within a larger
 * structure 'S'. Think of it as a functional &quot;search-and-replace&quot; or a bulk update tool üó∫Ô∏è.
 *
 * &lt;p&gt;A Traversal is the right tool for &quot;has-many&quot; relationships, such as operating on every element
 * in a {@code List} or {@code Set}. It is the most general of the core optics, capable of modifying
 * all focused parts simultaneously within an {@link Applicative} context.
 *
 * &lt;p&gt;Both {@link Lens} and {@link Prism} can be viewed as specialized {@code Traversal}s:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A {@code Lens} is a {@code Traversal} that focuses on exactly one item.
 *   &lt;li&gt;A {@code Prism} is a {@code Traversal} that focuses on zero or one item.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;It extends the generic {@link Optic}, specializing it for {@code S = T} and {@code A = B}.
 *
 * @param &lt;S&gt; The type of the whole structure (e.g., a {@code List&lt;User&gt;}).
 * @param &lt;A&gt; The type of the focused parts (e.g., the {@code User} elements).
 */
public interface Traversal&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This is the core operation of a {@code Traversal}. It modifies all focused parts {@code A}
   * within a structure {@code S} by applying a function that returns a value in an {@link
   * Applicative} context {@code F}.
   *
   * &lt;p&gt;The {@link Applicative} instance is crucial as it defines how to combine the results of
   * modifying multiple parts (e.g., fail-fast for {@code Optional}, accumulate for {@code
   * Validated}, or run in parallel for a concurrent data type).
   *
   * @param &lt;F&gt; The witness type for the {@link Applicative} context.
   * @param f The effectful function to apply to each focused part.
   * @param source The whole structure to operate on.
   * @param applicative The {@link Applicative} instance for the context {@code F}.
   * @return The updated structure {@code S}, itself wrapped in the context {@code F}.
   */
  @Override
  &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative);

  /**
   * Composes this {@code Traversal&lt;S, A&gt;} with another {@code Traversal&lt;A, B&gt;} to create a new
   * {@code Traversal&lt;S, B&gt;}.
   *
   * &lt;p&gt;This specialized overload is kept for convenience to ensure the result is correctly and
   * conveniently typed as a {@code Traversal}. For example, composing a traversal for a {@code
   * List&lt;Team&gt;} with one for a {@code List&lt;Player&gt;} results in a traversal for every {@code Player}
   * in the nested structure.
   *
   * @param other The {@link Traversal} to compose with.
   * @param &lt;B&gt; The type of the final focused parts.
   * @return A new, composed {@link Traversal}.
   */
  default &lt;B&gt; Traversal&lt;S, B&gt; andThen(final Traversal&lt;A, B&gt; other) {
    // Use the generic 'andThen' from the parent Optic interface
    // and wrap the result back into the Traversal interface.
<span class="fc" id="L69">    final Optic&lt;S, S, B, B&gt; composedOptic = Optic.super.andThen(other);</span>
<span class="fc" id="L70">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;B, Kind&lt;F, B&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
        // The actual composition logic is handled by the parent.
<span class="fc" id="L74">        return composedOptic.modifyF(f, s, app);</span>
      }
    };
  }

  /**
   * Branch between two modification strategies based on a predicate. Both branches are visible
   * upfront, allowing selective implementations to potentially execute them in parallel.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Different validation for different user types
   * Kind&lt;F, Users&gt; result = traversal.branch(
   *   User::isAdmin,
   *   user -&gt; strictAdminValidation(user),
   *   user -&gt; basicUserValidation(user),
   *   users,
   *   selective
   * );
   * }&lt;/pre&gt;
   *
   * @param predicate Predicate to determine which branch to take
   * @param thenBranch Function to apply when predicate is true
   * @param elseBranch Function to apply when predicate is false
   * @param source The source structure
   * @param selective The Selective instance
   * @param &lt;F&gt; The effect type
   * @return The modified structure wrapped in the effect
   */
  default &lt;F&gt; Kind&lt;F, S&gt; branch(
      Predicate&lt;? super A&gt; predicate,
      Function&lt;A, Kind&lt;F, A&gt;&gt; thenBranch,
      Function&lt;A, Kind&lt;F, A&gt;&gt; elseBranch,
      S source,
      Selective&lt;F&gt; selective) {
<span class="fc" id="L110">    return this.modifyF(</span>
        a -&gt;
<span class="fc" id="L112">            selective.ifS(</span>
<span class="fc" id="L113">                selective.of(predicate.test(a)), thenBranch.apply(a), elseBranch.apply(a)),</span>
        source,
        selective);
  }

  /**
   * Apply a function only when a condition is met, otherwise leave unchanged. This is useful for
   * performing effects only on elements that need processing.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Only update stale cache entries
   * Kind&lt;F, Cache&gt; result = traversal.modifyWhen(
   *   CacheEntry::isStale,
   *   entry -&gt; refreshFromSource(entry),
   *   cache,
   *   selective
   * );
   * }&lt;/pre&gt;
   *
   * @param shouldModify Predicate to test if modification is needed
   * @param f Function to apply when modification is needed
   * @param source The source structure
   * @param selective The Selective instance
   * @param &lt;F&gt; The effect type
   * @return The modified structure wrapped in the effect
   */
  default &lt;F&gt; Kind&lt;F, S&gt; modifyWhen(
      Predicate&lt;? super A&gt; shouldModify,
      Function&lt;A, Kind&lt;F, A&gt;&gt; f,
      S source,
      Selective&lt;F&gt; selective) {
<span class="fc" id="L146">    return this.modifyF(</span>
<span class="fc" id="L147">        a -&gt; selective.ifS(selective.of(shouldModify.test(a)), f.apply(a), selective.of(a)),</span>
        source,
        selective);
  }

  /**
   * Creates a new {@code Traversal} that only focuses on elements matching the given predicate.
   *
   * &lt;p&gt;This is a composable filtering combinator that enables declarative filtering as part of
   * optic composition. Elements that don't match the predicate are preserved unchanged in the
   * structure during modifications, but are excluded from queries like {@code getAll}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Create a traversal for all users
   * Traversal&lt;List&lt;User&gt;, User&gt; allUsers = Traversals.forList();
   *
   * // Filter to only active users
   * Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = allUsers.filtered(User::isActive);
   *
   * // Compose further to get their names
   * Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
   *     activeUsers.andThen(userNameLens.asTraversal());
   *
   * // Usage:
   * List&lt;String&gt; names = Traversals.getAll(activeUserNames, users);
   * // Returns only names of active users
   *
   * List&lt;User&gt; modified = Traversals.modify(activeUsers, User::grantBonus, users);
   * // Grants bonus only to active users, inactive users preserved unchanged
   * }&lt;/pre&gt;
   *
   * @param predicate The predicate to filter elements by
   * @return A new {@code Traversal} that only focuses on matching elements
   */
  default Traversal&lt;S, A&gt; filtered(Predicate&lt;? super A&gt; predicate) {
<span class="fc" id="L184">    Traversal&lt;S, A&gt; self = this;</span>
<span class="fc" id="L185">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
        // Apply f only to matching elements, leave others unchanged
<span class="fc" id="L190">        Function&lt;A, Kind&lt;F, A&gt;&gt; conditionalF =</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            a -&gt; predicate.test(a) ? f.apply(a) : applicative.of(a);</span>
<span class="fc" id="L192">        return self.modifyF(conditionalF, source, applicative);</span>
      }
    };
  }

  /**
   * Creates a new {@code Traversal} that only focuses on elements where a nested query satisfies
   * the given predicate.
   *
   * &lt;p&gt;This advanced filtering combinator allows filtering based on properties accessed through
   * another optic (Fold), enabling queries like &quot;all users who have at least one expensive order&quot;.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * // Traversal for all users
   * Traversal&lt;List&lt;User&gt;, User&gt; allUsers = Traversals.forList();
   *
   * // Fold from User to their order totals
   * Fold&lt;User, Integer&gt; orderTotals = userOrdersFold.andThen(orderTotalFold);
   *
   * // Filter to users who have any order over $100
   * Traversal&lt;List&lt;User&gt;, User&gt; bigSpenders =
   *     allUsers.filterBy(orderTotals, total -&gt; total &gt; 100);
   *
   * // Get all big spenders
   * List&lt;User&gt; spenders = Traversals.getAll(bigSpenders, users);
   * }&lt;/pre&gt;
   *
   * @param query The {@link Fold} to query each focused element
   * @param predicate The predicate to test the queried values
   * @param &lt;B&gt; The type of values queried by the Fold
   * @return A new {@code Traversal} that only focuses on elements where the query matches
   */
  default &lt;B&gt; Traversal&lt;S, A&gt; filterBy(Fold&lt;A, B&gt; query, Predicate&lt;? super B&gt; predicate) {
<span class="fc" id="L227">    Traversal&lt;S, A&gt; self = this;</span>
<span class="fc" id="L228">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L232">        Function&lt;A, Kind&lt;F, A&gt;&gt; conditionalF =</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            a -&gt; query.exists(predicate, a) ? f.apply(a) : applicative.of(a);</span>
<span class="fc" id="L234">        return self.modifyF(conditionalF, source, applicative);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>