<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Prism.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.optics</a> &gt; <span class="el_source">Prism.java</span></div><h1>Prism.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.optics;

import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monoid;

/**
 * A **Prism** is an optic that provides a focused view into a part of a sum type (e.g., a {@code
 * sealed interface} or {@code enum}). Think of it as a safe-cracker's tool ðŸ”¬; it attempts to focus
 * on a single, specific case 'A' within a larger structure 'S' and only succeeds if the structure
 * is of that case.
 *
 * &lt;p&gt;A Prism is the right tool for &quot;is-a&quot; relationships. It provides a functional, type-safe
 * alternative to {@code instanceof} checks and casting. It is defined by two core operations: a
 * failable getter (`getOptional`) and a constructor (`build`).
 *
 * &lt;p&gt;It extends the generic {@link Optic}, specializing it for {@code S = T} and {@code A = B}.
 *
 * @param &lt;S&gt; The source type of the whole structure (e.g., a sealed interface like {@code
 *     JsonValue}).
 * @param &lt;A&gt; The target type of the focused case (e.g., a specific implementation like {@code
 *     JsonString}).
 */
public interface Prism&lt;S, A&gt; extends Optic&lt;S, S, A, A&gt; {

  /**
   * Attempts to get the focused part {@code A} from the whole structure {@code S}.
   *
   * &lt;p&gt;This is the primary &quot;getter&quot; for a Prism, providing a safe way to access the value of a
   * specific case of a sum type.
   *
   * @param source The whole structure.
   * @return An {@link Optional} containing the focused part if the prism matches, otherwise an
   *     empty {@code Optional}.
   */
  Optional&lt;A&gt; getOptional(S source);

  /**
   * Builds the whole structure {@code S} from a part {@code A}.
   *
   * &lt;p&gt;This is the &quot;constructor&quot; or reverse operation for a Prism.
   *
   * @param value The part to build the structure from.
   * @return A new instance of the whole structure {@code S}.
   */
  S build(A value);

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;The implementation for a {@code Prism} will only apply the function {@code f} if the prism
   * successfully matches the source {@code s}. If it does not match, it returns the original
   * structure {@code s} wrapped in the {@link Applicative} context, effectively performing a no-op.
   */
  @Override
  default &lt;F&gt; Kind&lt;F, S&gt; modifyF(Function&lt;A, Kind&lt;F, A&gt;&gt; f, S s, Applicative&lt;F&gt; app) {
<span class="fc" id="L62">    return getOptional(s).map(a -&gt; app.map(this::build, f.apply(a))).orElse(app.of(s));</span>
  }

  /**
   * Views this {@code Prism} as a {@link Traversal}.
   *
   * &lt;p&gt;This is always possible because a {@code Prism} is fundamentally a {@code Traversal} that
   * focuses on zero or one element.
   *
   * @return A {@link Traversal} that represents this {@code Prism}.
   */
  default Traversal&lt;S, A&gt; asTraversal() {
<span class="fc" id="L74">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L75">    return new Traversal&lt;&gt;() {</span>
      @Override
      public &lt;F&gt; Kind&lt;F, S&gt; modifyF(
          Function&lt;A, Kind&lt;F, A&gt;&gt; f, S source, Applicative&lt;F&gt; applicative) {
<span class="fc" id="L79">        return self.modifyF(f, source, applicative);</span>
      }
    };
  }

  /**
   * Views this {@code Prism} as a {@link Fold}.
   *
   * &lt;p&gt;This is always possible because a {@code Prism} can be used as a read-only query that
   * focuses on zero or one element.
   *
   * @return A {@link Fold} that represents this {@code Prism}.
   */
  default Fold&lt;S, A&gt; asFold() {
<span class="fc" id="L93">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L94">    return new Fold&lt;&gt;() {</span>
      @Override
      public &lt;M&gt; M foldMap(Monoid&lt;M&gt; monoid, Function&lt;? super A, ? extends M&gt; f, S source) {
<span class="fc" id="L97">        Optional&lt;A&gt; opt = self.getOptional(source);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (opt.isPresent()) {</span>
<span class="fc" id="L99">          return f.apply(opt.get());</span>
        } else {
<span class="fc" id="L101">          return monoid.empty();</span>
        }
      }
    };
  }

  /**
   * Composes this {@code Prism&lt;S, A&gt;} with another {@code Prism&lt;A, B&gt;} to create a new {@code
   * Prism&lt;S, B&gt;}.
   *
   * &lt;p&gt;This specialized version is kept for efficiency and to ensure the result is correctly and
   * conveniently typed as a {@code Prism}.
   *
   * @param other The {@link Prism} to compose with.
   * @param &lt;B&gt; The type of the final focused part.
   * @return A new {@link Prism} that focuses from {@code S} to {@code B}.
   */
  default &lt;B&gt; Prism&lt;S, B&gt; andThen(final Prism&lt;A, B&gt; other) {
<span class="fc" id="L119">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L120">    return new Prism&lt;&gt;() {</span>
      @Override
      public Optional&lt;B&gt; getOptional(S source) {
<span class="fc" id="L123">        return self.getOptional(source).flatMap(other::getOptional);</span>
      }

      @Override
      public S build(B value) {
<span class="fc" id="L128">        return self.build(other.build(value));</span>
      }
    };
  }

  /**
   * Checks if this prism matches the given structure.
   *
   * &lt;p&gt;This is useful for type checking without extraction, providing a cleaner alternative to
   * {@code getOptional(source).isPresent()}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * if (stringPrism.matches(value)) {
   *   // Process as a string
   * }
   * }&lt;/pre&gt;
   *
   * @param source The source structure to test.
   * @return {@code true} if the prism matches, {@code false} otherwise.
   */
  default boolean matches(S source) {
<span class="fc" id="L154">    return getOptional(source).isPresent();</span>
  }

  /**
   * Provides a default value if the prism doesn't match.
   *
   * &lt;p&gt;This is a convenient shortcut for {@code getOptional(source).orElse(defaultValue)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonNumber(42);
   *
   * String result = stringPrism.getOrElse(new JsonString(&quot;default&quot;), value);
   * // Returns &quot;default&quot; since the value is a number, not a string
   * }&lt;/pre&gt;
   *
   * @param defaultValue The default value to use if the prism doesn't match.
   * @param source The source structure.
   * @return The matched value or the default value.
   */
  default A getOrElse(A defaultValue, S source) {
<span class="fc" id="L177">    return getOptional(source).orElse(defaultValue);</span>
  }

  /**
   * Applies a function to the matched value and returns the result wrapped in an {@link Optional}.
   *
   * &lt;p&gt;This is useful for transforming matched values without building them back into the source
   * structure. It's equivalent to {@code getOptional(source).map(f)}.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * Optional&lt;Integer&gt; length = stringPrism.mapOptional(String::length, value);
   * // Returns Optional.of(5)
   * }&lt;/pre&gt;
   *
   * @param f The function to apply to the matched value.
   * @param source The source structure.
   * @param &lt;B&gt; The result type of the function.
   * @return An {@link Optional} containing the result if the prism matches, or empty otherwise.
   */
  default &lt;B&gt; Optional&lt;B&gt; mapOptional(Function&lt;? super A, ? extends B&gt; f, S source) {
<span class="fc" id="L202">    return getOptional(source).map(f);</span>
  }

  /**
   * Modifies the focused part {@code A} using a pure function, if the prism matches.
   *
   * &lt;p&gt;This is a convenient shortcut similar to {@link Lens#modify}, but for prisms. If the prism
   * matches, the focused value is extracted, modified, and built back into the structure. If the
   * prism doesn't match, the original structure is returned unchanged.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * JsonValue result = stringPrism.modify(
   *     s -&gt; new JsonString(s.value().toUpperCase()),
   *     value
   * );
   * // Returns new JsonString(&quot;HELLO&quot;)
   *
   * JsonValue number = new JsonNumber(42);
   * JsonValue unchanged = stringPrism.modify(
   *     s -&gt; new JsonString(s.value().toUpperCase()),
   *     number
   * );
   * // Returns the original JsonNumber(42) unchanged
   * }&lt;/pre&gt;
   *
   * @param modifier The function to apply to the focused part.
   * @param source The source structure.
   * @return A new structure with the modified part, or the original structure if the prism doesn't
   *     match.
   */
  default S modify(Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L238">    return getOptional(source).map(a -&gt; build(modifier.apply(a))).orElse(source);</span>
  }

  /**
   * Modifies the focused part only when it meets a specified condition.
   *
   * &lt;p&gt;This combines matching and conditional modification: the prism must match, and the extracted
   * value must satisfy the predicate for modification to occur.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;hello&quot;);
   *
   * // Only uppercase strings longer than 3 characters
   * JsonValue result = stringPrism.modifyWhen(
   *   s -&gt; s.length() &gt; 3,
   *   String::toUpperCase,
   *   value
   * );
   * // Returns new JsonString(&quot;HELLO&quot;)
   *
   * JsonValue shortValue = new JsonString(&quot;hi&quot;);
   * JsonValue unchanged = stringPrism.modifyWhen(
   *   s -&gt; s.length() &gt; 3,
   *   String::toUpperCase,
   *   shortValue
   * );
   * // Returns original JsonString(&quot;hi&quot;) since condition not met
   * }&lt;/pre&gt;
   *
   * @param condition The predicate that the focused value must satisfy.
   * @param modifier The function to apply if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally modified part, or the original structure if the
   *     prism doesn't match or the condition is not met.
   */
  default S modifyWhen(Predicate&lt;? super A&gt; condition, Function&lt;A, A&gt; modifier, S source) {
<span class="fc" id="L277">    return getOptional(source).filter(condition).map(a -&gt; build(modifier.apply(a))).orElse(source);</span>
  }

  /**
   * Sets a new value only when the current value meets a specified condition.
   *
   * &lt;p&gt;This is useful for conditional updates based on the current state. The prism must match, and
   * the extracted value must satisfy the predicate for the set operation to occur.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();
   * JsonValue value = new JsonString(&quot;old&quot;);
   *
   * // Only replace non-empty strings
   * JsonValue result = stringPrism.setWhen(
   *   s -&gt; !s.isEmpty(),
   *   &quot;new&quot;,
   *   value
   * );
   * // Returns new JsonString(&quot;new&quot;)
   *
   * JsonValue emptyValue = new JsonString(&quot;&quot;);
   * JsonValue unchanged = stringPrism.setWhen(
   *   s -&gt; !s.isEmpty(),
   *   &quot;new&quot;,
   *   emptyValue
   * );
   * // Returns original JsonString(&quot;&quot;) since condition not met
   * }&lt;/pre&gt;
   *
   * @param condition The predicate that the current value must satisfy.
   * @param newValue The new value to set if the condition is met.
   * @param source The source structure.
   * @return A new structure with the conditionally set value, or the original structure if the
   *     prism doesn't match or the condition is not met.
   */
  default S setWhen(Predicate&lt;? super A&gt; condition, A newValue, S source) {
<span class="fc" id="L316">    return getOptional(source).filter(condition).map(a -&gt; build(newValue)).orElse(source);</span>
  }

  /**
   * Chains multiple prisms, returning the first match.
   *
   * &lt;p&gt;This creates a new prism that tries this prism first, and if it doesn't match, tries the
   * other prism. The resulting prism uses the first prism's {@code build} function for
   * construction.
   *
   * &lt;p&gt;This is useful for providing fallback matching strategies or handling multiple alternative
   * cases.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * Prism&lt;JsonValue, Number&gt; intPrism = JsonValuePrisms.jsonInt();
   * Prism&lt;JsonValue, Number&gt; doublePrism = JsonValuePrisms.jsonDouble();
   *
   * Prism&lt;JsonValue, Number&gt; numberPrism = intPrism.orElse(doublePrism);
   *
   * // Matches either int or double
   * JsonValue intValue = new JsonInt(42);
   * Optional&lt;Number&gt; result1 = numberPrism.getOptional(intValue);  // Optional.of(42)
   *
   * JsonValue doubleValue = new JsonDouble(3.14);
   * Optional&lt;Number&gt; result2 = numberPrism.getOptional(doubleValue);  // Optional.of(3.14)
   *
   * // Building uses the first prism's builder
   * JsonValue built = numberPrism.build(100);  // Uses intPrism.build
   * }&lt;/pre&gt;
   *
   * @param other Another prism to try if this one doesn't match.
   * @return A prism that tries this one first, then the other.
   */
  default Prism&lt;S, A&gt; orElse(Prism&lt;S, A&gt; other) {
<span class="fc" id="L352">    Prism&lt;S, A&gt; self = this;</span>
<span class="fc" id="L353">    return Prism.of(</span>
<span class="fc" id="L354">        source -&gt; self.getOptional(source).or(() -&gt; other.getOptional(source)),</span>
<span class="fc" id="L355">        self::build // Always use the first prism's builder</span>
        );
  }

  /**
   * Creates a {@code Prism} from its two fundamental operations: a failable getter and a builder
   * function.
   *
   * @param getter A function that attempts to extract part {@code A} from structure {@code S}.
   * @param builder A function that constructs the structure {@code S} from a part {@code A}.
   * @param &lt;S&gt; The type of the whole structure.
   * @param &lt;A&gt; The type of the focused part.
   * @return A new {@code Prism} instance.
   */
  static &lt;S, A&gt; Prism&lt;S, A&gt; of(Function&lt;S, Optional&lt;A&gt;&gt; getter, Function&lt;A, S&gt; builder) {
<span class="fc" id="L370">    return new Prism&lt;&gt;() {</span>
      @Override
      public Optional&lt;A&gt; getOptional(S source) {
<span class="fc" id="L373">        return getter.apply(source);</span>
      }

      @Override
      public S build(A value) {
<span class="fc" id="L378">        return builder.apply(value);</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>