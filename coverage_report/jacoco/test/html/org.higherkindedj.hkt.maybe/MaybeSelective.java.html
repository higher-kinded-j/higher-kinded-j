<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MaybeSelective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hkj-core</a> &gt; <a href="index.source.html" class="el_package">org.higherkindedj.hkt.maybe</a> &gt; <span class="el_source">MaybeSelective.java</span></div><h1>MaybeSelective.java</h1><pre class="source lang-java linenums">// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import static org.higherkindedj.hkt.util.validation.Operation.*;

import java.util.function.Function;
import org.higherkindedj.hkt.Choice;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.util.validation.Validation;

/**
 * Implements the {@link Selective} type class for {@link Maybe}. This provides selective
 * applicative operations that allow conditional execution based on the result of previous
 * computations.
 *
 * &lt;p&gt;The Selective interface sits between {@link org.higherkindedj.hkt.Applicative} and {@link
 * org.higherkindedj.hkt.Monad} in terms of power. For Maybe, selective operations handle the {@link
 * Just} and {@link Nothing} cases appropriately:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Just} values: Operations are applied
 *   &lt;li&gt;{@link Nothing} values: Propagated unchanged (short-circuit)
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Unit Usage:&lt;/b&gt; The {@link #whenS(Kind, Kind)} method uses {@link Unit} to distinguish
 * between two different &quot;empty-like&quot; states:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Nothing}: No condition to evaluate (input was Nothing)
 *   &lt;li&gt;{@code Just(Unit.INSTANCE)}: Condition evaluated to false, operation skipped
 * &lt;/ul&gt;
 *
 * This distinction is semantically important and improves code clarity. Previously, both cases
 * returned {@code Nothing}, making them indistinguishable. This mirrors the same semantic
 * improvement made in {@link org.higherkindedj.hkt.optional.OptionalSelective}.
 *
 * &lt;p&gt;Key operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #select(Kind, Kind)}: Conditionally applies an effectful function based on a Choice.
 *   &lt;li&gt;{@link #branch(Kind, Kind, Kind)}: Provides two-way conditional choice with different
 *       handlers.
 *   &lt;li&gt;{@link #whenS(Kind, Kind)}: Conditionally executes a Unit-returning effect based on a
 *       boolean.
 *   &lt;li&gt;{@link #ifS(Kind, Kind, Kind)}: Ternary conditional for selective functors.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This class is a singleton, accessible via {@link #INSTANCE}.
 *
 * @see Maybe
 * @see MaybeMonad
 * @see Selective
 * @see Choice
 * @see Unit
 */
public final class MaybeSelective extends MaybeMonad implements Selective&lt;MaybeKind.Witness&gt; {

  /** Singleton instance of {@code MaybeSelective}. */
<span class="fc" id="L63">  public static final MaybeSelective INSTANCE = new MaybeSelective();</span>

<span class="fc" id="L65">  private static final Class&lt;MaybeSelective&gt; MAYBE_SELECTIVE_CLASS = MaybeSelective.class;</span>

  /** Private constructor to enforce the singleton pattern. */
  private MaybeSelective() {
    super();
  }

  /**
   * The core selective operation for Maybe. Given an effectful choice {@code fab} and an effectful
   * function {@code ff}, applies the function only if the choice is a {@code Left}.
   *
   * &lt;p&gt;Behavior:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;If {@code fab} is {@code Nothing}: Returns {@code Nothing}, {@code ff} is not evaluated.
   *   &lt;li&gt;If {@code fab} is {@code Just(Choice.Right(b))}: Returns {@code Just(b)}, {@code ff} is
   *       not evaluated.
   *   &lt;li&gt;If {@code fab} is {@code Just(Choice.Left(a))} and {@code ff} is {@code Just(function)}:
   *       Returns {@code Just(function.apply(a))}.
   *   &lt;li&gt;If {@code fab} is {@code Just(Choice.Left(a))} and {@code ff} is {@code Nothing}: Returns
   *       {@code Nothing}.
   * &lt;/ul&gt;
   *
   * @param fab A {@link Kind} representing {@code Maybe&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param ff A {@link Kind} representing {@code Maybe&lt;Function&lt;A, B&gt;&gt;}. Must not be null.
   * @param &lt;A&gt; The input type of the function (the type inside {@code Left} of the Choice).
   * @param &lt;B&gt; The output type and the type inside {@code Right} of the Choice.
   * @return A {@link Kind} representing {@code Maybe&lt;B&gt;}. Never null.
   * @throws NullPointerException if {@code fab} or {@code ff} is null.
   * @throws org.higherkindedj.hkt.exception.KindUnwrapException if {@code fab} or {@code ff} cannot
   *     be unwrapped.
   */
  @Override
  public &lt;A, B&gt; Kind&lt;MaybeKind.Witness, B&gt; select(
      Kind&lt;MaybeKind.Witness, Choice&lt;A, B&gt;&gt; fab, Kind&lt;MaybeKind.Witness, Function&lt;A, B&gt;&gt; ff) {

<span class="fc" id="L101">    Validation.kind().requireNonNull(fab, MAYBE_SELECTIVE_CLASS, SELECT, &quot;choice&quot;);</span>
<span class="fc" id="L102">    Validation.kind().requireNonNull(ff, MAYBE_SELECTIVE_CLASS, SELECT, &quot;function&quot;);</span>

<span class="fc" id="L104">    Maybe&lt;Choice&lt;A, B&gt;&gt; maybeChoice = MAYBE.narrow(fab);</span>

    // Short-circuit if no choice
<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (maybeChoice.isNothing()) {</span>
<span class="fc" id="L108">      return MAYBE.nothing();</span>
    }

<span class="fc" id="L111">    Choice&lt;A, B&gt; choice = maybeChoice.get();</span>

    // If choice is Right(b), we already have our value
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (choice.isRight()) {</span>
<span class="fc" id="L115">      B rightValue = choice.getRight();</span>
<span class="fc" id="L116">      return MAYBE.widen(Maybe.fromNullable(rightValue));</span>
    }

    // Choice is Left(a), so we need to apply the function
<span class="fc" id="L120">    Maybe&lt;Function&lt;A, B&gt;&gt; maybeFunction = MAYBE.narrow(ff);</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (maybeFunction.isNothing()) {</span>
<span class="fc" id="L123">      return MAYBE.nothing();</span>
    }

    // Apply the function to the value
<span class="fc" id="L127">    A value = choice.getLeft();</span>
<span class="fc" id="L128">    Function&lt;A, B&gt; function = maybeFunction.get();</span>
<span class="fc" id="L129">    B result = function.apply(value);</span>
<span class="fc" id="L130">    return MAYBE.widen(Maybe.fromNullable(result));</span>
  }

  /**
   * Optimised implementation of {@code branch} for Maybe. Provides a two-way conditional choice,
   * applying the appropriate handler based on whether the Choice is Left or Right.
   *
   * @param fab A {@link Kind} representing {@code Maybe&lt;Choice&lt;A, B&gt;&gt;}. Must not be null.
   * @param fl A {@link Kind} representing {@code Maybe&lt;Function&lt;A, C&gt;&gt;} for the Left case. Must not
   *     be null.
   * @param fr A {@link Kind} representing {@code Maybe&lt;Function&lt;B, C&gt;&gt;} for the Right case. Must
   *     not be null.
   * @param &lt;A&gt; The type inside {@code Left} of the Choice.
   * @param &lt;B&gt; The type inside {@code Right} of the Choice.
   * @param &lt;C&gt; The result type.
   * @return A {@link Kind} representing {@code Maybe&lt;C&gt;}. Never null.
   */
  @Override
  public &lt;A, B, C&gt; Kind&lt;MaybeKind.Witness, C&gt; branch(
      Kind&lt;MaybeKind.Witness, Choice&lt;A, B&gt;&gt; fab,
      Kind&lt;MaybeKind.Witness, Function&lt;A, C&gt;&gt; fl,
      Kind&lt;MaybeKind.Witness, Function&lt;B, C&gt;&gt; fr) {

<span class="fc" id="L153">    Validation.kind().requireNonNull(fab, MAYBE_SELECTIVE_CLASS, BRANCH, &quot;choice&quot;);</span>
<span class="fc" id="L154">    Validation.kind().requireNonNull(fl, MAYBE_SELECTIVE_CLASS, BRANCH, &quot;leftHandler&quot;);</span>
<span class="fc" id="L155">    Validation.kind().requireNonNull(fr, MAYBE_SELECTIVE_CLASS, BRANCH, &quot;rightHandler&quot;);</span>

<span class="fc" id="L157">    Maybe&lt;Choice&lt;A, B&gt;&gt; maybeChoice = MAYBE.narrow(fab);</span>

    // Short-circuit on Nothing
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (maybeChoice.isNothing()) {</span>
<span class="fc" id="L161">      return MAYBE.nothing();</span>
    }

<span class="fc" id="L164">    Choice&lt;A, B&gt; choice = maybeChoice.get();</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (choice.isLeft()) {</span>
      // Use left handler
<span class="fc" id="L168">      Maybe&lt;Function&lt;A, C&gt;&gt; leftFunction = MAYBE.narrow(fl);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (leftFunction.isNothing()) {</span>
<span class="fc" id="L170">        return MAYBE.nothing();</span>
      }
<span class="fc" id="L172">      C result = leftFunction.get().apply(choice.getLeft());</span>
<span class="fc" id="L173">      return MAYBE.widen(Maybe.fromNullable(result));</span>
    } else {
      // Use right handler
<span class="fc" id="L176">      Maybe&lt;Function&lt;B, C&gt;&gt; rightFunction = MAYBE.narrow(fr);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (rightFunction.isNothing()) {</span>
<span class="fc" id="L178">        return MAYBE.nothing();</span>
      }
<span class="fc" id="L180">      C result = rightFunction.get().apply(choice.getRight());</span>
<span class="fc" id="L181">      return MAYBE.widen(Maybe.just(result));</span>
    }
  }

  /**
   * Optimised implementation of {@code whenS} for Maybe. Conditionally executes a Unit-returning
   * effect based on a boolean condition.
   *
   * &lt;p&gt;This method now uses {@link Unit} to clearly distinguish between different states:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code Nothing} in condition: Returns {@code Nothing} (no condition to evaluate)
   *   &lt;li&gt;{@code Just(true)}: Executes effect and returns its result
   *   &lt;li&gt;{@code Just(false)}: Returns {@code Just(Unit.INSTANCE)} (condition evaluated, operation
   *       skipped)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This distinction is semantically important:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code Nothing}: &quot;No information available&quot; (condition itself is absent)
   *   &lt;li&gt;{@code Just(Unit.INSTANCE)}: &quot;Operation completed with no interesting result&quot; (condition
   *       was false)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This mirrors the semantics of {@link org.higherkindedj.hkt.optional.OptionalSelective},
   * where {@code Optional.empty()} means &quot;no value&quot; and {@code Optional.of(Unit.INSTANCE)} means
   * &quot;operation completed with no interesting result&quot;.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
   *
   * &lt;pre&gt;{@code
   * // Condition is present and true - effect executes
   * Maybe&lt;Boolean&gt; shouldLog = Maybe.just(true);
   * Maybe&lt;Unit&gt; logEffect = Maybe.just(Unit.INSTANCE);
   * Maybe&lt;Unit&gt; result1 = MAYBE.narrow(maybeSelective.whenS(
   *     MAYBE.widen(shouldLog),
   *     MAYBE.widen(logEffect)
   * ));
   * // result1 = Just(Unit.INSTANCE) - effect executed
   *
   * // Condition is present and false - effect skipped
   * Maybe&lt;Boolean&gt; shouldNotLog = Maybe.just(false);
   * Maybe&lt;Unit&gt; result2 = MAYBE.narrow(maybeSelective.whenS(
   *     MAYBE.widen(shouldNotLog),
   *     MAYBE.widen(logEffect)
   * ));
   * // result2 = Just(Unit.INSTANCE) - condition evaluated, effect skipped
   *
   * // Condition is absent - no evaluation possible
   * Maybe&lt;Boolean&gt; noCondition = Maybe.nothing();
   * Maybe&lt;Unit&gt; result3 = MAYBE.narrow(maybeSelective.whenS(
   *     MAYBE.widen(noCondition),
   *     MAYBE.widen(logEffect)
   * ));
   * // result3 = Nothing - no condition to evaluate
   * }&lt;/pre&gt;
   *
   * @param fcond A {@link Kind} representing {@code Maybe&lt;Boolean&gt;}. Must not be null.
   * @param fa A {@link Kind} representing {@code Maybe&lt;Unit&gt;} to execute if condition is true. Must
   *     not be null.
   * @return A {@link Kind} representing {@code Maybe&lt;Unit&gt;}. Never null.
   */
  @Override
  public Kind&lt;MaybeKind.Witness, Unit&gt; whenS(
      Kind&lt;MaybeKind.Witness, Boolean&gt; fcond, Kind&lt;MaybeKind.Witness, Unit&gt; fa) {

<span class="fc" id="L248">    Validation.kind().requireNonNull(fcond, MAYBE_SELECTIVE_CLASS, WHEN_S, &quot;condition&quot;);</span>
<span class="fc" id="L249">    Validation.kind().requireNonNull(fa, MAYBE_SELECTIVE_CLASS, WHEN_S, &quot;effect&quot;);</span>

<span class="fc" id="L251">    Maybe&lt;Boolean&gt; condMaybe = MAYBE.narrow(fcond);</span>

    // Short-circuit on Nothing - no condition to evaluate
<span class="fc bfc" id="L254" title="All 2 branches covered.">    if (condMaybe.isNothing()) {</span>
<span class="fc" id="L255">      return MAYBE.nothing();</span>
    }

<span class="fc" id="L258">    boolean condition = condMaybe.get();</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">    if (condition) {</span>
      // Execute and return the effect
<span class="fc" id="L262">      return fa;</span>
    } else {
      // Condition is false, return Just(Unit.INSTANCE)
      // This is NOT Nothing - it represents &quot;operation completed, effect skipped&quot;
<span class="fc" id="L266">      return MAYBE.widen(Maybe.just(Unit.INSTANCE));</span>
    }
  }

  /**
   * Optimised implementation of {@code ifS} for Maybe. A ternary conditional operator for selective
   * functors.
   *
   * @param fcond A {@link Kind} representing {@code Maybe&lt;Boolean&gt;}. Must not be null.
   * @param fthen A {@link Kind} representing {@code Maybe&lt;A&gt;} for the true branch. Must not be
   *     null.
   * @param felse A {@link Kind} representing {@code Maybe&lt;A&gt;} for the false branch. Must not be
   *     null.
   * @param &lt;A&gt; The type of the result.
   * @return A {@link Kind} representing {@code Maybe&lt;A&gt;}. Never null.
   */
  @Override
  public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; ifS(
      Kind&lt;MaybeKind.Witness, Boolean&gt; fcond,
      Kind&lt;MaybeKind.Witness, A&gt; fthen,
      Kind&lt;MaybeKind.Witness, A&gt; felse) {

<span class="fc" id="L288">    Validation.kind().requireNonNull(fcond, MAYBE_SELECTIVE_CLASS, IF_S, &quot;condition&quot;);</span>
<span class="fc" id="L289">    Validation.kind().requireNonNull(fthen, MAYBE_SELECTIVE_CLASS, IF_S, &quot;thenBranch&quot;);</span>
<span class="fc" id="L290">    Validation.kind().requireNonNull(felse, MAYBE_SELECTIVE_CLASS, IF_S, &quot;elseBranch&quot;);</span>

<span class="fc" id="L292">    Maybe&lt;Boolean&gt; condMaybe = MAYBE.narrow(fcond);</span>

    // Short-circuit on Nothing
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (condMaybe.isNothing()) {</span>
<span class="fc" id="L296">      return MAYBE.nothing();</span>
    }

<span class="fc" id="L299">    boolean condition = condMaybe.get();</span>

    // Return the appropriate branch
<span class="fc bfc" id="L302" title="All 2 branches covered.">    return condition ? fthen : felse;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>