// Copyright (c) 2025 - 2026 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.hkt.expression;

import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.MonadZero;
import org.higherkindedj.hkt.TypeArity;
import org.higherkindedj.hkt.WitnessArity;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;

/**
 * Provides a statically-typed, fluent for-comprehension builder for monadic types, simulating a
 * feature common in languages like Scala.
 *
 * <p>For-comprehensions offer a convenient and readable syntax for composing sequences of monadic
 * operations (like {@code flatMap} and {@code map}). This builder de-sugars the comprehension into
 * a series of monadic calls, guiding the user through the composition process while ensuring type
 * safety at each step. Comprehensions support up to 12 chained bindings. Step 1 is hand-written;
 * steps 2-12 are generated by the {@code hkj-processor} annotation processor.
 *
 * <h3>Usage</h3>
 *
 * <p>A comprehension is a chain of operations that includes generators, bindings, filters, and a
 * final projection:
 *
 * <ul>
 *   <li><b>Generators ({@code .from(...)}):</b> These are the core of the comprehension, equivalent
 *       to a {@code flatMap}. Each generator takes a value from a previous step and produces a new
 *       monadic value, which is then flattened into the ongoing computation. The results of all
 *       generators are accumulated in a tuple.
 *   <li><b>Bindings ({@code .let(...)}):</b> Binds the result of a pure computation to a new
 *       variable in the comprehension's scope. This is equivalent to a {@code map} operation that
 *       adds the computed value to the accumulated tuple.
 *   <li><b>Filters ({@code .when(...)}):</b> Filters the results based on a predicate. If the
 *       predicate returns {@code false}, the computation for that path is short-circuited. This
 *       operation is only available for monads that implement {@link MonadZero}, which provides an
 *       "empty" or "zero" element (e.g., an empty list, {@code Optional.empty()}).
 *   <li><b>Projection ({@code .yield(...)}):</b> Concludes the comprehension by applying a function
 *       to the accumulated results from all previous steps, producing the final monadic value.
 * </ul>
 *
 * <h3>Example with List (a {@code MonadZero})</h3>
 *
 * <pre>{@code
 * // Imports for context
 * import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
 * import java.util.Arrays;
 *
 * ListMonad listMonad = ListMonad.INSTANCE;
 * Kind<ListKind.Witness, Integer> list1 = LIST.widen(Arrays.asList(1, 2, 3));
 * Kind<ListKind.Witness, Integer> list2 = LIST.widen(Arrays.asList(10, 20));
 *
 * // Equivalent to Scala: for { a <- list1; b <- list2 if (a+b) % 2 != 0; c = "Sum: " + (a+b) } yield s"$a + $b = $c"
 * Kind<ListKind.Witness, String> result =
 * For.from(listMonad, list1)                       // Generator: a <- list1
 * .from(a -> list2)                             // Generator: b <- list2
 * .when(t -> (t._1() + t._2()) % 2 != 0)        // Filter: if (a+b) is odd
 * .let(t -> "Sum: " + (t._1() + t._2()))        // Binding: c = "Sum: " + (a+b)
 * .yield((a, b, c) -> a + "+" + b + " = " + c); // Projection
 *
 * List<String> finalResult = LIST.narrow(result);
 * // finalResult: ["1+10 = Sum: 11", "1+20 = Sum: 21", "3+10 = Sum: 13", "3+20 = Sum: 23"]
 * }</pre>
 *
 * @see Monad
 * @see MonadZero
 * @see Kind
 */
public final class For {

  private For() {} // Static access only

  /**
   * Initiates a for-comprehension for any {@link Monad}. The resulting builder chain will not
   * support filtering with {@code .when(...)}.
   *
   * @param monad The Monad instance that defines the behaviour of {@code flatMap} and {@code map}.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param <M> The witness type of the Monad.
   * @param <A> The value type of the source.
   * @return The first step of the builder, ready for the next operation.
   */
  public static <M extends WitnessArity<TypeArity.Unary>, A> MonadicSteps1<M, A> from(
      Monad<M> monad, Kind<M, A> source) {
    return new MonadicSteps1<>(monad, source);
  }

  /**
   * Initiates a for-comprehension for a {@link MonadZero}. The resulting builder chain supports
   * filtering with {@code .when(...)}.
   *
   * @param monad The MonadZero instance, providing {@code zero()} for filtering.
   * @param source The initial monadic source, the first generator in the comprehension.
   * @param <M> The witness type of the Monad.
   * @param <A> The value type of the source.
   * @return The first step of the filterable builder, ready for the next operation.
   */
  public static <M extends WitnessArity<TypeArity.Unary>, A> FilterableSteps1<M, A> from(
      MonadZero<M> monad, Kind<M, A> source) {
    return new FilterableSteps1<>(monad, source);
  }

  /**
   * A marker interface for all builder steps, ensuring they can be permitted by a sealed interface.
   * This is an internal detail to organise the different step types.
   *
   * @param <M> The witness type of the Monad.
   */
  public sealed interface Steps<M extends WitnessArity<TypeArity.Unary>>
      permits MonadicSteps1,
          MonadicSteps2,
          MonadicSteps3,
          MonadicSteps4,
          MonadicSteps5,
          MonadicSteps6,
          MonadicSteps7,
          MonadicSteps8,
          MonadicSteps9,
          MonadicSteps10,
          MonadicSteps11,
          MonadicSteps12,
          FilterableSteps1,
          FilterableSteps2,
          FilterableSteps3,
          FilterableSteps4,
          FilterableSteps5,
          FilterableSteps6,
          FilterableSteps7,
          FilterableSteps8,
          FilterableSteps9,
          FilterableSteps10,
          FilterableSteps11,
          FilterableSteps12 {}

  // --- Monadic (Non-Filterable) Steps ---

  /**
   * Represents the first step in a non-filterable for-comprehension, holding a single monadic
   * value.
   *
   * @param <M> The witness type of the Monad.
   * @param <A> The value type of the initial computation.
   */
  public static final class MonadicSteps1<M extends WitnessArity<TypeArity.Unary>, A>
      implements Steps<M> {
    private final Monad<M> monad;
    private final Kind<M, A> computation;

    private MonadicSteps1(Monad<M> monad, Kind<M, A> computation) {
      this.monad = monad;
      this.computation = computation;
    }

    /**
     * Binds the result of another monadic computation (a generator).
     *
     * <p>This corresponds to a {@code flatMap} operation. The function {@code next} is applied to
     * the result of the first step, and the resulting monadic value is flattened into the
     * comprehension.
     *
     * @param next A function that takes the result of the first step (type {@code A}) and returns a
     *     new monadic computation {@code Kind<M, B>}.
     * @param <B> The value type of the new monadic computation.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2<A, B>}.
     */
    public <B> MonadicSteps2<M, A, B> from(Function<A, Kind<M, B>> next) {
      Kind<M, Tuple2<A, B>> newComputation =
          monad.flatMap(a -> monad.map(b -> Tuple.of(a, b), next.apply(a)), this.computation);
      return new MonadicSteps2<>(monad, newComputation);
    }

    /**
     * Binds the result of a pure computation.
     *
     * <p>This corresponds to a {@code map} operation. The function {@code f} is applied to the
     * result of the first step to produce a new value, which is then carried along in the
     * comprehension.
     *
     * @param f A function that takes the result of the first step (type {@code A}) and returns a
     *     pure value of type {@code B}.
     * @param <B> The type of the computed value.
     * @return The next step in the builder, now tracking types {@code A} and {@code B} as a {@code
     *     Tuple2<A, B>}.
     */
    public <B> MonadicSteps2<M, A, B> let(Function<A, B> f) {
      Kind<M, Tuple2<A, B>> newComputation =
          monad.map(a -> Tuple.of(a, f.apply(a)), this.computation);
      return new MonadicSteps2<>(monad, newComputation);
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * <p>This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value. The extracted value is accumulated
     * alongside the original value.
     *
     * <h3>Example</h3>
     *
     * <pre>{@code
     * record User(String name, Address address) {}
     * record Address(String city) {}
     *
     * Lens<User, Address> addressLens = Lens.of(User::address, User::withAddress);
     *
     * Kind<IdKind.Witness, String> result =
     *     For.from(idMonad, Id.of(new User("Alice", new Address("NYC"))))
     *         .focus(addressLens)
     *         .yield((user, address) -> user.name() + " lives in " + address.city());
     * // Result: "Alice lives in NYC"
     * }</pre>
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param <B> The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public <B> MonadicSteps2<M, A, B> focus(Lens<A, B> lens) {
      Objects.requireNonNull(lens, "lens must not be null");
      Kind<M, Tuple2<A, B>> newComputation =
          monad.map(a -> Tuple.of(a, lens.get(a)), this.computation);
      return new MonadicSteps2<>(monad, newComputation);
    }

    /**
     * Transitions from this for-comprehension step into a {@link ForState} builder by constructing
     * a state object from the current computation result.
     *
     * <p>This bridges the value-accumulation style of {@link For} comprehensions with the
     * lens-based state threading of {@link ForState}. After calling this method, you can use lens
     * operations ({@code update}, {@code modify}, {@code fromThen}, etc.) to further transform the
     * state.
     *
     * <h3>Example</h3>
     *
     * <pre>{@code
     * Kind<IdKind.Witness, Dashboard> result =
     *     For.from(idMonad, fetchUser())
     *         .toState(user -> new Dashboard(user, false))
     *         .update(readyLens, true)
     *         .yield();
     * }</pre>
     *
     * @param constructor A function that constructs the state object from the current value.
     * @param <S> The type of the state object.
     * @return A {@link ForState.Steps} builder for chaining lens-based state operations.
     * @throws NullPointerException if {@code constructor} is null.
     */
    public <S> ForState.Steps<M, S> toState(Function<A, S> constructor) {
      Objects.requireNonNull(constructor, "constructor must not be null");
      return ForState.withState(monad, monad.map(constructor, computation));
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value of type {@code A} into the result type
     *     {@code R}.
     * @param <R> The final result type.
     * @return A monadic value of type {@code R}.
     */
    public <R> Kind<M, R> yield(Function<A, R> f) {
      return monad.map(f, computation);
    }
  }

  // --- Filterable Steps (for MonadZero) ---

  /**
   * Represents the first step in a filterable for-comprehension, holding a single monadic value.
   *
   * @param <M> The witness type of the Monad.
   * @param <A> The value type of the initial computation.
   */
  public static final class FilterableSteps1<M extends WitnessArity<TypeArity.Unary>, A>
      implements Steps<M> {
    private final MonadZero<M> monad;
    private final Kind<M, A> computation;

    private FilterableSteps1(MonadZero<M> monad, Kind<M, A> computation) {
      this.monad = monad;
      this.computation = computation;
    }

    /**
     * Adds a new monadic generator to the comprehension.
     *
     * @param next A function producing the next monadic computation.
     * @param <B> The value type of the new computation.
     * @return The next step in the builder, now tracking two results.
     */
    public <B> FilterableSteps2<M, A, B> from(Function<A, Kind<M, B>> next) {
      Kind<M, Tuple2<A, B>> newComputation =
          monad.flatMap(a -> monad.map(b -> Tuple.of(a, b), next.apply(a)), this.computation);
      return new FilterableSteps2<>(monad, newComputation);
    }

    /**
     * Adds a pure computation to the comprehension.
     *
     * @param f A function producing a new pure value.
     * @param <B> The type of the new computed value.
     * @return The next step in the builder, now tracking two results.
     */
    public <B> FilterableSteps2<M, A, B> let(Function<A, B> f) {
      Kind<M, Tuple2<A, B>> newComputation =
          monad.map(a -> Tuple.of(a, f.apply(a)), this.computation);
      return new FilterableSteps2<>(monad, newComputation);
    }

    /**
     * Filters the results of the comprehension based on a predicate. If the predicate returns
     * {@code false}, the comprehension short-circuits for that path by using the monad's {@link
     * MonadZero#zero()} element (e.g., an empty list).
     *
     * @param filter The predicate to apply to the current value {@code A}.
     * @return The current builder step, with the filter applied.
     */
    public FilterableSteps1<M, A> when(Predicate<A> filter) {
      Kind<M, A> newComputation =
          monad.flatMap(a -> filter.test(a) ? monad.of(a) : monad.zero(), this.computation);
      return new FilterableSteps1<>(monad, newComputation);
    }

    /**
     * Extracts a value from the current computation result using the provided {@link Lens} and adds
     * it to the accumulated tuple.
     *
     * <p>This operation is equivalent to a pure computation that doesn't introduce new effects—it
     * simply extracts a focused part of the current value.
     *
     * @param lens The {@link Lens} to use for extracting the focused value.
     * @param <B> The type of the extracted value.
     * @return The next step in the builder, now tracking the original value and the extracted
     *     value.
     * @throws NullPointerException if {@code lens} is null.
     * @see Lens
     */
    public <B> FilterableSteps2<M, A, B> focus(Lens<A, B> lens) {
      Objects.requireNonNull(lens, "lens must not be null");
      Kind<M, Tuple2<A, B>> newComputation =
          monad.map(a -> Tuple.of(a, lens.get(a)), this.computation);
      return new FilterableSteps2<>(monad, newComputation);
    }

    /**
     * Attempts to extract a value using the provided {@link Prism}. If the prism matches, the
     * extracted value is added to the accumulated tuple. If it doesn't match, the computation
     * short-circuits using the monad's {@link MonadZero#zero()} element.
     *
     * <p>This provides type-safe pattern matching within for-comprehensions, eliminating the need
     * for {@code instanceof} checks and casts.
     *
     * <h3>Example</h3>
     *
     * <pre>{@code
     * sealed interface Result permits Success, Failure {}
     * record Success(String value) implements Result {}
     * record Failure(String error) implements Result {}
     *
     * Prism<Result, Success> successPrism = Prism.of(
     *     r -> r instanceof Success s ? Optional.of(s) : Optional.empty(),
     *     s -> s
     * );
     *
     * Kind<MaybeKind.Witness, String> result =
     *     For.from(maybeMonad, MAYBE.just(someResult))
     *         .match(successPrism)
     *         .yield((original, success) -> success.value());
     * // Returns Just(value) if someResult is Success, Nothing otherwise
     * }</pre>
     *
     * @param prism The {@link Prism} to use for pattern matching.
     * @param <B> The type of the extracted value when the prism matches.
     * @return The next step in the builder if the prism matches, or short-circuits to zero.
     * @throws NullPointerException if {@code prism} is null.
     * @see Prism
     */
    public <B> FilterableSteps2<M, A, B> match(Prism<A, B> prism) {
      Objects.requireNonNull(prism, "prism must not be null");
      Kind<M, Tuple2<A, B>> newComputation =
          monad.flatMap(
              a -> prism.getOptional(a).map(b -> monad.of(Tuple.of(a, b))).orElseGet(monad::zero),
              this.computation);
      return new FilterableSteps2<>(monad, newComputation);
    }

    /**
     * Transitions from this for-comprehension step into a {@link ForState} builder by constructing
     * a state object from the current computation result.
     *
     * <p>This bridges the value-accumulation style of {@link For} comprehensions with the
     * lens-based state threading of {@link ForState}. Since this step uses a {@link MonadZero}, the
     * returned builder preserves filtering capabilities ({@code when}, {@code matchThen}).
     *
     * @param constructor A function that constructs the state object from the current value.
     * @param <S> The type of the state object.
     * @return A {@link ForState.FilterableSteps} builder for chaining lens-based state operations
     *     with filtering support.
     * @throws NullPointerException if {@code constructor} is null.
     */
    public <S> ForState.FilterableSteps<M, S> toState(Function<A, S> constructor) {
      Objects.requireNonNull(constructor, "constructor must not be null");
      return ForState.withState(monad, monad.map(constructor, computation));
    }

    /**
     * Completes the for-comprehension by applying a function to the final result.
     *
     * @param f A function to transform the final value.
     * @param <R> The final result type.
     * @return A monadic value of type {@code R}.
     */
    public <R> Kind<M, R> yield(Function<A, R> f) {
      return monad.map(f, computation);
    }
  }
}
